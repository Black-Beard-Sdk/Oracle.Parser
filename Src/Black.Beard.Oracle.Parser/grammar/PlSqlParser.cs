//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.7
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from PlSqlParser.g4 by ANTLR 4.7

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Bb.Oracle.Parser {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7")]
[System.CLSCompliant(false)]
public partial class PlSqlParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		ACCESS=1, ACCOUNT=2, ADD=3, ADMIN=4, ADMINISTER=5, ADVANCED=6, ADVISOR=7, 
		AFTER=8, AGENT=9, AGGREGATE=10, A_LETTER=11, ALL=12, ALLOW=13, ALTER=14, 
		ALWAYS=15, ANALYZE=16, AND=17, ANY=18, ANYSCHEMA=19, ARCHIVAL=20, ARCHIVE=21, 
		ARRAY=22, AS=23, ASC=24, ASSOCIATE=25, AT=26, ATTRIBUTE=27, AUDIT=28, 
		AUTHENTICATED=29, AUTHENTICATION=30, AUTHID=31, AUTOALLOCATE=32, AUTO=33, 
		AUTOEXTEND=34, AUTOMATIC=35, AUTONOMOUS_TRANSACTION=36, BACKUP=37, BASIC=38, 
		BASICFILE=39, BATCH=40, BECOME=41, BEFORE=42, BEGIN=43, BETWEEN=44, BFILE=45, 
		BIGFILE=46, BINARY=47, BINARY_DOUBLE=48, BINARY_FLOAT=49, BINARY_INTEGER=50, 
		BLOB=51, BLOCK=52, BLOCKSIZE=53, BODY=54, BOOLEAN=55, BOTH=56, BREADTH=57, 
		BUFFER_POOL=58, BUILD=59, BULK=60, BY=61, BYTE=62, CACHE=63, CALL=64, 
		CANONICAL=65, CAPACITY=66, CASCADE=67, CASE=68, CAST=69, CERTIFICATE=70, 
		CHANGE=71, CHARACTER=72, CHAR=73, CHAR_CS=74, CHECK=75, CHR=76, CHUNK=77, 
		CLASS=78, C_LETTER=79, CLOB=80, CLOSE=81, CLUSTER=82, CLUSTERING=83, COALESCE=84, 
		COLLECT=85, COLUMN=86, COLUMNS=87, COMMENT=88, COMMIT=89, COMMITTED=90, 
		COMPATIBILITY=91, COMPILE=92, COMPOUND=93, COMPRESS=94, COMPUTE=95, CONNECT_BY_ROOT=96, 
		CONNECT=97, CONSTANT=98, CONSTRAINT=99, CONSTRAINTS=100, CONSTRUCTOR=101, 
		CONTAINER=102, CONTAINER_DATA=103, CONTENT=104, CONTEXT=105, CONTINUE=106, 
		CONVERT=107, CORRUPT_XID_ALL=108, CORRUPT_XID=109, COST=110, COUNT=111, 
		CREATE=112, CREATION=113, CRITICAL=114, CROSS=115, CUBE=116, CURRENT=117, 
		CURRENT_USER=118, CURRVAL=119, CURSOR=120, CUSTOMDATUM=121, CYCLE=122, 
		DATABASE=123, DATA=124, DATAFILE=125, DATE=126, DAY=127, DAYS=128, DBA_RECYCLEBIN=129, 
		DB_ROLE_CHANGE=130, DBTIMEZONE=131, DDL=132, DEBUG=133, DEC=134, DECIMAL=135, 
		DECLARE=136, DECOMPOSE=137, DECREMENT=138, DECRYPT=139, DEDUPLICATE=140, 
		DEFAULT=141, DEFAULTS=142, DEFERRABLE=143, DEFERRED=144, DEFINER=145, 
		DELEGATE=146, DELETE=147, DEPTH=148, DESC=149, DETERMINISTIC=150, DICTIONARY=151, 
		DIMENSION=152, DIRECTORY=153, DISABLE=154, DISALLOW=155, DISASSOCIATE=156, 
		DISTINCT=157, DISTINGUISHED=158, DISTRIBUTE=159, DML=160, DOCUMENT=161, 
		DOUBLE=162, DROP=163, DSINTERVAL_UNCONSTRAINED=164, DUPLICATE=165, EACH=166, 
		EDITIONABLE=167, EDITION=168, EDITIONING=169, EDITIONS=170, ELEMENT=171, 
		ELSE=172, ELSIF=173, EMPTY=174, ENABLE=175, ENCODING=176, ENCRYPT=177, 
		ENCRYPTION=178, END=179, ENTERPRISE=180, ENTITYESCAPING=181, ERR=182, 
		ERRORS=183, ESCAPE=184, EVALNAME=185, EVALUATION=186, EXCEPT=187, EXCEPTION=188, 
		EXCEPTION_INIT=189, EXCEPTIONS=190, EXCLUDE=191, EXCLUSIVE=192, EXECUTE=193, 
		EXEMPT=194, EXISTS=195, EXIT=196, EXPIRE=197, EXPLAIN=198, EXTENT=199, 
		EXTERNAL=200, EXTERNALLY=201, EXTRACT=202, FAILURE=203, FALSE=204, FETCH=205, 
		FILESYSTEM_LIKE_LOGGING=206, FINAL=207, FIRST=208, FIRST_VALUE=209, FLASHBACK=210, 
		FLASH_CACHE=211, FLOAT=212, FOLDER=213, FOLLOWING=214, FOLLOWS=215, FORALL=216, 
		FORCE=217, FOREIGN=218, FOR=219, FREELIST=220, FREELISTS=221, FREEPOOLS=222, 
		FROM=223, FULL=224, FUNCTION=225, GENERATED=226, GLOBAL=227, GLOBALLY=228, 
		GOTO=229, GRANT=230, GROUP=231, GROUPING=232, GROUPS=233, GUARANTEE=234, 
		HASH=235, HAVING=236, HEAP=237, HIDE=238, HIERARCHY=239, HIGH=240, HOUR=241, 
		IDENTIFIED=242, IDENTIFIER=243, IDENTITY=244, ID=245, IF=246, IGNORE=247, 
		ILM=248, IMMEDIATE=249, INCLUDE=250, INCLUDING=251, INCREMENT=252, INDENT=253, 
		INDEXED=254, INDEX=255, INDEXING=256, INDEXTYPE=257, INDICATOR=258, INDICES=259, 
		INFINITE=260, INHERIT=261, IN=262, INITIAL=263, INITIALLY=264, INITRANS=265, 
		INLINE=266, INMEMORY=267, INNER=268, INOUT=269, INSERT=270, INSTANTIABLE=271, 
		INSTEAD=272, INTEGER=273, INTERSECT=274, INTERVAL=275, INTERVLEAVED=276, 
		INT=277, INTO=278, INVALIDATE=279, INVISIBLE=280, IS=281, ISOLATION=282, 
		ITERATE=283, JAVA=284, JOB=285, JOIN=286, KEEP_DUPLICATES=287, KEEP=288, 
		KEY=289, LANGUAGE=290, LAST=291, LAST_VALUE=292, LEADING=293, LEFT=294, 
		LESS=295, LEVEL=296, LEVELS=297, LIBRARY=298, LIKE2=299, LIKE4=300, LIKEC=301, 
		LIKE=302, LIMIT=303, LINEAR=304, LINK=305, LIST=306, LOAD=307, LOB=308, 
		LOBS=309, LOCAL=310, LOCATION=311, LOCATOR=312, LOCKED=313, LOCKING=314, 
		LOCK=315, LOGGING=316, LOG=317, LOGMINING=318, LOGOFF=319, LOGON=320, 
		LONG=321, LOOP=322, LOW=323, MAIN=324, MANAGE=325, MANAGEMENT=326, MANUAL=327, 
		MAP=328, MAPPING=329, MATCHED=330, MATERIALIZED=331, MAXSIZE=332, MAXTRANS=333, 
		MAXVALUE=334, MEASURE=335, MEASURES=336, MEDIUM=337, MEMBER=338, MEMCOMPRESS=339, 
		MERGE=340, MINEXTENTS=341, NEXTVAL=342, MINIMUM=343, MINING=344, MINUS=345, 
		MINUTE=346, MINVALUE=347, MLSLABEL=348, MODEL=349, MODE=350, MODIFICATION=351, 
		MODIFY=352, MONTH=353, MONTHS=354, MOVEMENT=355, MULTISET=356, NAME=357, 
		NAN=358, NATURAL=359, NATURALN=360, NAV=361, NCHAR_CS=362, NCHAR=363, 
		NCLOB=364, NESTED=365, NEW=366, NEXT=367, NOAUDIT=368, NOCACHE=369, NOCOMPRESS=370, 
		NOCOPY=371, NOCYCLE=372, NOEDITIONABLE=373, NOENTITYESCAPING=374, NOGUARANTEE=375, 
		NOKEEP=376, NOLOGGING=377, NOMAPPING=378, NOMAXVALUE=379, NOMINVALUE=380, 
		NONEDITIONABLE=381, NONE=382, NO=383, NONSCHEMA=384, NOORDER=385, NOPARALLEL=386, 
		NORELY=387, NOROWDEPENDENCIES=388, NOSCHEMACHECK=389, NOSORT=390, NOTIFICATION=391, 
		NOT=392, NOVALIDATE=393, NOWAIT=394, NULL=395, NULLS=396, NUMBER=397, 
		NUMERIC=398, NVARCHAR2=399, OBJECT=400, OFFLINE=401, OFF=402, OF=403, 
		OID=404, OLD=405, OLTP=406, ONLINE=407, ONLY=408, ON=409, OPEN=410, OPERATOR=411, 
		OPTIMAL=412, OPTION=413, ORADATA=414, ORDER=415, ORDINALITY=416, ORGANIZATION=417, 
		OR=418, OSERROR=419, OUTER=420, OUTLINE=421, OUT=422, OVERFLOW=423, OVER=424, 
		OVERRIDING=425, PACKAGE=426, PARALLEL_ENABLE=427, PARALLEL=428, PARAMETERS=429, 
		PARENT=430, PARTIAL=431, PARTITION=432, PARTITIONS=433, PASSING=434, PASSWORD=435, 
		PATH=436, PCTFREE=437, PCTINCREASE=438, PCTTHRESHOLD=439, PCTUSED=440, 
		PCTVERSION=441, PERCENT_FOUND=442, PERCENT_ISOPEN=443, PERCENT_NOTFOUND=444, 
		PERCENT_ROWCOUNT=445, PERCENT_ROWTYPE=446, PERCENT_TYPE=447, PIPELINED=448, 
		PIPE=449, PIVOT=450, PLAN=451, PLS_INTEGER=452, PLUGGABLE=453, POLICY=454, 
		POSITIVEN=455, POSITIVE=456, PRAGMA=457, PRECEDING=458, PRECISION=459, 
		PRESENT=460, PRESERVE=461, PRIMARY=462, PRIORITY=463, PRIOR=464, PRIVILEGE=465, 
		PRIVILEGES=466, PROCEDURE=467, PROCESS=468, PROFILE=469, PROGRAM=470, 
		PUBLIC=471, PURGE=472, QUERY=473, QUOTA=474, RAISE=475, RANGE=476, RAW=477, 
		READ=478, READS=479, REAL=480, RECORD=481, RECYCLE=482, REDACTION=483, 
		REFERENCE=484, REFERENCES=485, REFERENCING=486, REF=487, REFRESH=488, 
		REJECT=489, RELATIONAL=490, RELIES_ON=491, RELY=492, REMOVE=493, RENAME=494, 
		REPLACE=495, REQUIRED=496, RESOURCE=497, RESPECT=498, RESTRICTED=499, 
		RESTRICT_REFERENCES=500, RESULT_CACHE=501, RESULT=502, RESUMABLE=503, 
		RETENTION=504, RETURNING=505, RETURN=506, REUSE=507, REVERSE=508, REVOKE=509, 
		REWRITE=510, RIGHT=511, ROLE=512, ROLES=513, ROLLBACK=514, ROLLUP=515, 
		ROWDEPENDENCIES=516, ROWID=517, ROWNUM=518, ROW=519, ROWS=520, RULES=521, 
		SALT=522, SAMPLE=523, SAVEPOINT=524, SAVE=525, SCHEDULER=526, SCHEMACHECK=527, 
		SCHEMA=528, SCN=529, SCOPE=530, SEARCH=531, SECOND=532, SECUREFILE=533, 
		SEED=534, SEGMENT=535, SELECT=536, SELF=537, SEQUENCE=538, SEQUENTIAL=539, 
		SERIALIZABLE=540, SERIALLY_REUSABLE=541, SERVERERROR=542, SESSION=543, 
		SESSIONTIMEZONE=544, SET=545, SETS=546, SETTINGS=547, SHARE=548, SHARP=549, 
		SHOW=550, SHUTDOWN=551, SIBLINGS=552, SIGNTYPE=553, SIMPLE_INTEGER=554, 
		SINGLE=555, SIZE=556, SKIP_=557, SMALLFILE=558, SMALLINT=559, SNAPSHOT=560, 
		SOME=561, SORT=562, SOURCE=563, SPACE_KEYWORD=564, SPECIFICATION=565, 
		SQLDATA=566, SQLERROR=567, SQL=568, STANDALONE=569, START=570, STARTUP=571, 
		STATEMENT_ID=572, STATEMENT=573, STATIC=574, STATISTICS=575, STORAGE=576, 
		STORE=577, STRING=578, SUBMULTISET=579, SUBPARTITIONS=580, SUBPARTITION=581, 
		SUBSTITUTABLE=582, SUBTYPE=583, SUCCESS=584, SUPPLEMENTAL=585, SUSPEND=586, 
		SYNONYM=587, SYSBACKUP=588, SYSDATE=589, SYSDBA=590, SYSDG=591, SYSGUID=592, 
		SYSKM=593, SYSOPER=594, SYSTEM=595, TABLESPACE=596, TABLES=597, TABLE=598, 
		TEMPFILE=599, TEMPLATE=600, TEMPORARY=601, THAN=602, THEN=603, THE=604, 
		THROUGH=605, TIER=606, TIMESTAMP_LTZ_UNCONSTRAINED=607, TIMESTAMP=608, 
		TIMESTAMP_TZ_UNCONSTRAINED=609, TIMESTAMP_UNCONSTRAINED=610, TIME=611, 
		TIMEZONE_ABBR=612, TIMEZONE_HOUR=613, TIMEZONE_MINUTE=614, TIMEZONE_REGION=615, 
		TO_NCLOB=616, TO_NUMBER=617, TO_SINGLE_BYTE=618, TO_TIMESTAMP_TZ=619, 
		TO=620, TO_YMINTERVAL=621, TRAILING=622, TRANSACTION=623, TRANSLATE=624, 
		TRANSLATION=625, TREAT=626, TRIGGER=627, TRUE=628, TRUNCATE=629, TRUNC=630, 
		TUNING=631, TYPE=632, UNBOUNDED=633, UNDER=634, UNDO=635, UNIFORM=636, 
		UNION=637, UNIQUE=638, UNLIMITED=639, UNLOCK=640, UNPIVOT=641, UNTIL=642, 
		UNUSABLE=643, UPDATED=644, UPDATE=645, UPSERT=646, UROWID=647, USABLE=648, 
		USERS=649, USER=650, USE=651, USING=652, VALIDATE=653, VALUES=654, VALUE=655, 
		VARCHAR2=656, VARCHAR=657, VARIABLE=658, VARRAYS=659, VARRAY=660, VARYING=661, 
		VERSIONS=662, VERSION=663, VIEW=664, VIRTUAL=665, VISIBLE=666, WAIT=667, 
		WARNING=668, WELLFORMED=669, WHENEVER=670, WHEN=671, WHERE=672, WHILE=673, 
		WITHIN=674, WITHOUT=675, WITH=676, WORK=677, WRITE=678, XMLAGG=679, XMLATTRIBUTES=680, 
		XMLCAST=681, XMLCOLATTVAL=682, XMLELEMENT=683, XMLEXISTS=684, XMLFOREST=685, 
		XMLNAMESPACES=686, XMLPARSE=687, XMLPI=688, XMLQUERY=689, XMLROOT=690, 
		XMLSCHEMA=691, XMLSERIALIZE=692, XMLTABLE=693, XMLTYPE=694, XML=695, YEARS=696, 
		YEAR=697, YES=698, YMINTERVAL_UNCONSTRAINED=699, ZONEMAP=700, ZONE=701, 
		PREDICTION=702, PREDICTION_BOUNDS=703, PREDICTION_COST=704, PREDICTION_DETAILS=705, 
		PREDICTION_PROBABILITY=706, PREDICTION_SET=707, CUME_DIST=708, DENSE_RANK=709, 
		LISTAGG=710, PERCENT_RANK=711, PERCENTILE_CONT=712, PERCENTILE_DISC=713, 
		RANK=714, AVG=715, CORR=716, COVAR_=717, DECODE=718, LAG=719, LEAD=720, 
		MAX=721, MEDIAN=722, MIN=723, NTILE=724, NVL=725, RATIO_TO_REPORT=726, 
		REGR_=727, ROUND=728, ROW_NUMBER=729, SUBSTR=730, TO_CHAR=731, TRIM=732, 
		SUM=733, STDDEV=734, VAR_=735, VARIANCE=736, LEAST=737, GREATEST=738, 
		TO_DATE=739, VARIABLE_SESSION=740, NATIONAL_CHAR_STRING_LIT=741, BIT_STRING_LIT=742, 
		HEX_STRING_LIT=743, DOUBLE_PERIOD=744, PERIOD=745, UNSIGNED_INTEGER=746, 
		APPROXIMATE_NUM_LIT=747, CHAR_STRING=748, DELIMITED_ID=749, PERCENT=750, 
		AMPERSAND=751, LEFT_PAREN=752, RIGHT_PAREN=753, DOUBLE_ASTERISK=754, ASTERISK=755, 
		PLUS_SIGN=756, MINUS_SIGN=757, COMMA=758, SOLIDUS=759, AT_SIGN=760, ASSIGN_OP=761, 
		BINDVAR=762, NOT_EQUAL_OP=763, CARRET_OPERATOR_PART=764, TILDE_OPERATOR_PART=765, 
		EXCLAMATION_OPERATOR_PART=766, GREATER_THAN_OP=767, LESS_THAN_OP=768, 
		COLON=769, SEMICOLON=770, BAR=771, EQUALS_OP=772, LEFT_BRACKET=773, RIGHT_BRACKET=774, 
		BIND_VAR=775, INTRODUCER=776, SPACES=777, SINGLE_LINE_COMMENT=778, MULTI_LINE_COMMENT=779, 
		PROMPT=780, START_CMD=781, REGULAR_ID=782, ZV=783;
	public const int
		RULE_sql_script = 0, RULE_unit_statement = 1, RULE_drop_function = 2, 
		RULE_alter_function = 3, RULE_create_function_body = 4, RULE_parallel_enable_clause = 5, 
		RULE_partition_by_clause = 6, RULE_result_cache_clause = 7, RULE_relies_on_part = 8, 
		RULE_streaming_clause = 9, RULE_drop_package = 10, RULE_alter_package = 11, 
		RULE_create_package = 12, RULE_create_package_body = 13, RULE_package_obj_spec = 14, 
		RULE_procedure_spec = 15, RULE_function_spec = 16, RULE_package_obj_body = 17, 
		RULE_drop_procedure = 18, RULE_alter_procedure = 19, RULE_function_body = 20, 
		RULE_procedure_body = 21, RULE_create_procedure_body = 22, RULE_drop_trigger = 23, 
		RULE_alter_trigger = 24, RULE_create_trigger = 25, RULE_trigger_follows_clause = 26, 
		RULE_trigger_when_clause = 27, RULE_simple_dml_trigger = 28, RULE_for_each_row = 29, 
		RULE_compound_dml_trigger = 30, RULE_non_dml_trigger = 31, RULE_trigger_body = 32, 
		RULE_routine_clause = 33, RULE_compound_trigger_block = 34, RULE_timing_point_section = 35, 
		RULE_non_dml_event = 36, RULE_dml_event_clause = 37, RULE_dml_event_element = 38, 
		RULE_dml_event_nested_clause = 39, RULE_referencing_clause = 40, RULE_referencing_element = 41, 
		RULE_drop_type = 42, RULE_alter_type = 43, RULE_compile_type_clause = 44, 
		RULE_replace_type_clause = 45, RULE_alter_method_spec = 46, RULE_alter_method_element = 47, 
		RULE_alter_attribute_definition = 48, RULE_attribute_definition = 49, 
		RULE_alter_collection_clauses = 50, RULE_dependent_handling_clause = 51, 
		RULE_dependent_exceptions_part = 52, RULE_create_type = 53, RULE_type_definition = 54, 
		RULE_object_type_def = 55, RULE_object_as_part = 56, RULE_object_under_part = 57, 
		RULE_nested_table_type_def = 58, RULE_sqlj_object_type = 59, RULE_type_body = 60, 
		RULE_type_body_elements = 61, RULE_map_order_func_declaration = 62, RULE_subprog_decl_in_type = 63, 
		RULE_proc_decl_in_type = 64, RULE_func_decl_in_type = 65, RULE_constructor_declaration = 66, 
		RULE_modifier_clause = 67, RULE_object_member_spec = 68, RULE_sqlj_object_type_attr = 69, 
		RULE_element_spec = 70, RULE_element_spec_options = 71, RULE_subprogram_spec = 72, 
		RULE_type_procedure_spec = 73, RULE_type_function_spec = 74, RULE_constructor_spec = 75, 
		RULE_map_order_function_spec = 76, RULE_pragma_clause = 77, RULE_pragma_elements = 78, 
		RULE_type_elements_parameter = 79, RULE_drop_sequence = 80, RULE_alter_sequence = 81, 
		RULE_create_sequence = 82, RULE_sequence_spec = 83, RULE_create_index = 84, 
		RULE_alter_index = 85, RULE_create_user = 86, RULE_alter_user = 87, RULE_alter_identified_by = 88, 
		RULE_identified_by = 89, RULE_identified_other_clause = 90, RULE_user_tablespace_clause = 91, 
		RULE_quota_clause = 92, RULE_profile_clause = 93, RULE_role_clause = 94, 
		RULE_user_default_role_clause = 95, RULE_password_expire_clause = 96, 
		RULE_user_lock_clause = 97, RULE_user_editions_clause = 98, RULE_alter_user_editions_clause = 99, 
		RULE_proxy_clause = 100, RULE_container_names = 101, RULE_set_container_data = 102, 
		RULE_add_rem_container_data = 103, RULE_container_data_clause = 104, RULE_drop_index = 105, 
		RULE_revoke_statment = 106, RULE_revoke_system_privileges = 107, RULE_revoke_object_privileges = 108, 
		RULE_grant_statement = 109, RULE_container_clause = 110, RULE_create_view = 111, 
		RULE_view_options = 112, RULE_view_alias_constraint = 113, RULE_object_view_clause = 114, 
		RULE_constraint = 115, RULE_inline_constraint = 116, RULE_out_of_line_constraint = 117, 
		RULE_out_of_line_constraints = 118, RULE_constraint_state = 119, RULE_using_index_clause = 120, 
		RULE_index_properties = 121, RULE_global_partitioned_index = 122, RULE_individual_hash_partitions = 123, 
		RULE_index_partitioning_clause = 124, RULE_segment_attributes_clause = 125, 
		RULE_index_attributes = 126, RULE_physical_attributes_clauses = 127, RULE_physical_attributes_clause = 128, 
		RULE_hash_partitions_by_quantity = 129, RULE_local_partitioned_index = 130, 
		RULE_on_range_partitioned_table = 131, RULE_on_list_partitioned_table = 132, 
		RULE_on_hash_partitioned_table = 133, RULE_on_comp_partitioned_table = 134, 
		RULE_xmltable_index_clause = 135, RULE_xmlindex_clause = 136, RULE_partition_clause = 137, 
		RULE_partition_clause_optional = 138, RULE_indexing_clause = 139, RULE_partitioning_storage_clause = 140, 
		RULE_inmemory_table_clause = 141, RULE_inmemory_column_clause = 142, RULE_inmemory_clause = 143, 
		RULE_inmemory_parameters = 144, RULE_inmemory_memcompress = 145, RULE_inmemory_priority = 146, 
		RULE_inmemory_distribute = 147, RULE_inmemory_duplicate = 148, RULE_table_compression = 149, 
		RULE_index_compression = 150, RULE_prefix_compression = 151, RULE_advanced_index_compression = 152, 
		RULE_lob_partitioning_storage = 153, RULE_index_subpartition_clause = 154, 
		RULE_usable_clause = 155, RULE_hash_partition_quantity = 156, RULE_varray_item = 157, 
		RULE_partial_index_clause = 158, RULE_parallel_clause = 159, RULE_domain_index_clause = 160, 
		RULE_local_domain_index_clause = 161, RULE_local_domain_index_parameters_clause = 162, 
		RULE_odci_parameters = 163, RULE_exceptions_clause = 164, RULE_create_tablespace = 165, 
		RULE_permanent_tablespace_clause = 166, RULE_tablespace_encryption_spec = 167, 
		RULE_logging_clause = 168, RULE_extent_management_clause = 169, RULE_segment_management_clause = 170, 
		RULE_flashback_mode_clause = 171, RULE_temporary_tablespace_clause = 172, 
		RULE_tablespace_group_clause = 173, RULE_undo_tablespace_clause = 174, 
		RULE_tablespace_retention_clause = 175, RULE_datafile_specification = 176, 
		RULE_tempfile_specification = 177, RULE_datafile_tempfile_spec = 178, 
		RULE_redo_log_file_spec = 179, RULE_autoextend_clause = 180, RULE_maxsize_clause = 181, 
		RULE_subquery = 182, RULE_create_table = 183, RULE_relational_table = 184, 
		RULE_relational_properties = 185, RULE_relational_property = 186, RULE_table_properties = 187, 
		RULE_flashback_archive_clause = 188, RULE_row_movement_clause = 189, RULE_attribute_clustering_clause = 190, 
		RULE_clustering_join = 191, RULE_cluster_clause = 192, RULE_clustering_columns = 193, 
		RULE_clustering_columns_group = 194, RULE_clustering_when = 195, RULE_zonemap_clause = 196, 
		RULE_enable_disable_clause = 197, RULE_table_partitioning_clauses = 198, 
		RULE_range_partitions = 199, RULE_hash_partitions = 200, RULE_column_properties = 201, 
		RULE_xmltype_column_properties = 202, RULE_xmltype_storage = 203, RULE_xmlschema_spec = 204, 
		RULE_list_partitions = 205, RULE_composite_range_partitions = 206, RULE_composite_hash_partitions = 207, 
		RULE_composite_list_partitions = 208, RULE_range_partition_desc = 209, 
		RULE_list_partition_desc = 210, RULE_range_subpartition_desc = 211, RULE_list_subpartition_desc = 212, 
		RULE_individual_hash_subparts = 213, RULE_hash_subparts_by_quantity = 214, 
		RULE_table_partition_description = 215, RULE_range_values_clause = 216, 
		RULE_list_values_clause = 217, RULE_subpartition_by_range = 218, RULE_subpartition_by_list = 219, 
		RULE_subpartition_by_hash = 220, RULE_subpartition_template = 221, RULE_reference_partitioning = 222, 
		RULE_reference_partition_desc = 223, RULE_object_type_col_properties = 224, 
		RULE_substituable_column_clause = 225, RULE_nested_table_col_properties = 226, 
		RULE_object_properties = 227, RULE_varray_col_properties = 228, RULE_varray_storage_clause = 229, 
		RULE_lob_storage_clause = 230, RULE_lob_storage_parameters = 231, RULE_paren_lob_parameters = 232, 
		RULE_lob_parameters = 233, RULE_lob_retention_clause = 234, RULE_lob_deduplicate_clause = 235, 
		RULE_lob_compresssion_clause = 236, RULE_physical_properties = 237, RULE_external_table_clause = 238, 
		RULE_external_data_properties = 239, RULE_external_data_properties_location = 240, 
		RULE_index_org_table_clause = 241, RULE_mapping_table_clause = 242, RULE_index_org_overflow_clause = 243, 
		RULE_deferred_segment_creation = 244, RULE_tablespace_clause = 245, RULE_store_in = 246, 
		RULE_ilm_clause = 247, RULE_ilm_policy_clause = 248, RULE_ilm_compression_policy = 249, 
		RULE_ilm_tiering_policy = 250, RULE_ilm_time_period = 251, RULE_storage_clauses = 252, 
		RULE_storage_clause = 253, RULE_column_definition = 254, RULE_virtual_column_definition = 255, 
		RULE_column_expresssion = 256, RULE_period_definition = 257, RULE_supplemental_logging_props = 258, 
		RULE_supplemental_log_grp_clause = 259, RULE_supplemental_id_key_clause = 260, 
		RULE_column_logged = 261, RULE_evaluation_edition_clause = 262, RULE_edition_name = 263, 
		RULE_unusable_editions_clause = 264, RULE_identity_options = 265, RULE_encryption_spec = 266, 
		RULE_inline_ref_constraint = 267, RULE_out_of_line_ref_constraint = 268, 
		RULE_size_clause = 269, RULE_drop_table = 270, RULE_comment_on_column = 271, 
		RULE_create_synonym = 272, RULE_comment_on_table = 273, RULE_alter_table = 274, 
		RULE_add_constraint = 275, RULE_check_constraint = 276, RULE_drop_constraint = 277, 
		RULE_enable_constraint = 278, RULE_disable_constraint = 279, RULE_foreign_key_clause = 280, 
		RULE_references_clause = 281, RULE_unique_key_clause = 282, RULE_primary_key_clause = 283, 
		RULE_anonymous_block = 284, RULE_invoker_rights_clause = 285, RULE_compiler_parameters_clause = 286, 
		RULE_call_spec = 287, RULE_java_spec = 288, RULE_c_spec = 289, RULE_c_agent_in_clause = 290, 
		RULE_c_parameters_clause = 291, RULE_parameter = 292, RULE_default_value_part = 293, 
		RULE_seq_of_declare_specs = 294, RULE_declare_spec = 295, RULE_variable_declaration = 296, 
		RULE_subtype_declaration = 297, RULE_cursor_declaration = 298, RULE_parameter_spec = 299, 
		RULE_exception_declaration = 300, RULE_pragma_declaration = 301, RULE_type_declaration = 302, 
		RULE_ref_cursor_type_def = 303, RULE_table_type_def = 304, RULE_table_indexed_by_part = 305, 
		RULE_varray_type_def = 306, RULE_record_type_def = 307, RULE_field_spec = 308, 
		RULE_seq_of_statements = 309, RULE_label_declaration = 310, RULE_statement = 311, 
		RULE_swallow_to_semi = 312, RULE_assignment_statement = 313, RULE_continue_statement = 314, 
		RULE_exit_statement = 315, RULE_goto_statement = 316, RULE_if_statement = 317, 
		RULE_elsif_part = 318, RULE_else_part = 319, RULE_loop_statement = 320, 
		RULE_cursor_loop_param = 321, RULE_forall_statement = 322, RULE_bounds_clause = 323, 
		RULE_between_bound = 324, RULE_lower_bound = 325, RULE_upper_bound = 326, 
		RULE_null_statement = 327, RULE_raise_statement = 328, RULE_return_statement = 329, 
		RULE_function_call = 330, RULE_pipe_row_statement = 331, RULE_body = 332, 
		RULE_exception_handler = 333, RULE_trigger_block = 334, RULE_block = 335, 
		RULE_sql_statement = 336, RULE_execute_immediate = 337, RULE_dynamic_returning_clause = 338, 
		RULE_data_manipulation_language_statements = 339, RULE_cursor_manipulation_statements = 340, 
		RULE_close_statement = 341, RULE_open_statement = 342, RULE_fetch_statement = 343, 
		RULE_open_for_statement = 344, RULE_transaction_control_statements = 345, 
		RULE_set_transaction_command = 346, RULE_set_constraint_command = 347, 
		RULE_commit_statement = 348, RULE_write_clause = 349, RULE_rollback_statement = 350, 
		RULE_savepoint_statement = 351, RULE_explain_statement = 352, RULE_select_statement = 353, 
		RULE_subquery_factoring_clause = 354, RULE_factoring_element = 355, RULE_search_clause = 356, 
		RULE_cycle_clause = 357, RULE_subquery_basic_elements = 358, RULE_subquery_operation_part = 359, 
		RULE_query_block = 360, RULE_selected_element = 361, RULE_from_clause = 362, 
		RULE_select_list_elements = 363, RULE_table_ref_list = 364, RULE_table_ref = 365, 
		RULE_table_ref_aux = 366, RULE_table_ref_aux_internal = 367, RULE_join_clause = 368, 
		RULE_join_on_part = 369, RULE_join_using_part = 370, RULE_outer_join_type = 371, 
		RULE_query_partition_clause = 372, RULE_flashback_query_clause = 373, 
		RULE_pivot_clause = 374, RULE_pivot_element = 375, RULE_pivot_for_clause = 376, 
		RULE_pivot_in_clause = 377, RULE_pivot_in_clause_element = 378, RULE_pivot_in_clause_elements = 379, 
		RULE_unpivot_clause = 380, RULE_unpivot_in_clause = 381, RULE_unpivot_in_elements = 382, 
		RULE_hierarchical_query_clause = 383, RULE_start_part = 384, RULE_group_by_clause = 385, 
		RULE_group_by_elements = 386, RULE_rollup_cube_clause = 387, RULE_grouping_sets_clause = 388, 
		RULE_grouping_sets_elements = 389, RULE_having_clause = 390, RULE_model_clause = 391, 
		RULE_cell_reference_options = 392, RULE_return_rows_clause = 393, RULE_reference_model = 394, 
		RULE_main_model = 395, RULE_model_column_clauses = 396, RULE_model_column_partition_part = 397, 
		RULE_model_column_list = 398, RULE_model_column = 399, RULE_model_rules_clause = 400, 
		RULE_model_rules_part = 401, RULE_model_rules_element = 402, RULE_cell_assignment = 403, 
		RULE_model_iterate_clause = 404, RULE_until_part = 405, RULE_order_by_clause = 406, 
		RULE_order_by_elements = 407, RULE_for_update_clause = 408, RULE_for_update_of_part = 409, 
		RULE_for_update_options = 410, RULE_update_statement = 411, RULE_update_set_clause = 412, 
		RULE_column_based_update_set_clause = 413, RULE_delete_statement = 414, 
		RULE_insert_statement = 415, RULE_single_table_insert = 416, RULE_multi_table_insert = 417, 
		RULE_multi_table_element = 418, RULE_conditional_insert_clause = 419, 
		RULE_conditional_insert_when_part = 420, RULE_conditional_insert_else_part = 421, 
		RULE_insert_into_clause = 422, RULE_values_clause = 423, RULE_merge_statement = 424, 
		RULE_merge_update_clause = 425, RULE_merge_element = 426, RULE_merge_update_delete_part = 427, 
		RULE_merge_insert_clause = 428, RULE_selected_tableview = 429, RULE_lock_table_statement = 430, 
		RULE_wait_nowait_part = 431, RULE_lock_table_element = 432, RULE_lock_mode = 433, 
		RULE_general_table_ref = 434, RULE_static_returning_clause = 435, RULE_error_logging_clause = 436, 
		RULE_error_logging_into_part = 437, RULE_error_logging_reject_part = 438, 
		RULE_dml_table_expression_clause = 439, RULE_table_collection_expression = 440, 
		RULE_subquery_restriction_clause = 441, RULE_sample_clause = 442, RULE_seed_part = 443, 
		RULE_condition = 444, RULE_expressions = 445, RULE_expression = 446, RULE_cursor_expression = 447, 
		RULE_logical_expression = 448, RULE_multiset_expression = 449, RULE_relational_expression = 450, 
		RULE_simple_expression = 451, RULE_compound_expression = 452, RULE_concatenation = 453, 
		RULE_relational_operator = 454, RULE_model_expression = 455, RULE_in_elements = 456, 
		RULE_between_elements = 457, RULE_interval_expression = 458, RULE_model_expression_element = 459, 
		RULE_single_column_for_loop = 460, RULE_multi_column_for_loop = 461, RULE_unary_expression = 462, 
		RULE_case_statement = 463, RULE_simple_case_statement = 464, RULE_simple_case_when_part = 465, 
		RULE_searched_case_statement = 466, RULE_searched_case_when_part = 467, 
		RULE_case_else_part = 468, RULE_atom = 469, RULE_quantified_expression = 470, 
		RULE_standard_function = 471, RULE_string_function = 472, RULE_numeric_function_wrapper = 473, 
		RULE_numeric_function = 474, RULE_to_date = 475, RULE_other_function = 476, 
		RULE_over_clause_keyword = 477, RULE_within_or_over_clause_keyword = 478, 
		RULE_standard_prediction_function_keyword = 479, RULE_over_clause = 480, 
		RULE_windowing_clause = 481, RULE_windowing_type = 482, RULE_windowing_elements = 483, 
		RULE_using_clause = 484, RULE_using_element = 485, RULE_collect_order_by_part = 486, 
		RULE_within_or_over_part = 487, RULE_cost_matrix_clause = 488, RULE_xml_passing_clause = 489, 
		RULE_xml_attributes_clause = 490, RULE_xml_namespaces_clause = 491, RULE_xml_table_column = 492, 
		RULE_xml_general_default_part = 493, RULE_xml_multiuse_expression_element = 494, 
		RULE_xmlroot_param_version_part = 495, RULE_xmlroot_param_standalone_part = 496, 
		RULE_xmlserialize_param_enconding_part = 497, RULE_xmlserialize_param_version_part = 498, 
		RULE_xmlserialize_param_ident_part = 499, RULE_sql_plus_command = 500, 
		RULE_sqlplus_execute_command = 501, RULE_sqlplus_whenever_command = 502, 
		RULE_function_arguments = 503, RULE_arguments = 504, RULE_argument = 505, 
		RULE_sqlplus_set_command = 506, RULE_partition_extension_clause = 507, 
		RULE_column_alias = 508, RULE_table_alias = 509, RULE_where_clause = 510, 
		RULE_into_clause = 511, RULE_xml_column_name = 512, RULE_routine_name = 513, 
		RULE_indextype = 514, RULE_grantee_name = 515, RULE_role_name = 516, RULE_constraint_name = 517, 
		RULE_variable_name = 518, RULE_cursor_name = 519, RULE_record_name = 520, 
		RULE_link_name = 521, RULE_tableview_name = 522, RULE_element_name = 523, 
		RULE_flashback_archive_name = 524, RULE_zonemap_name = 525, RULE_subpartition_name = 526, 
		RULE_lob_item_name = 527, RULE_dir_object_name = 528, RULE_user_object_name = 529, 
		RULE_tablespace_name = 530, RULE_label_name = 531, RULE_partition_name = 532, 
		RULE_schema_object_name = 533, RULE_lob_segname = 534, RULE_ilm_policy_name = 535, 
		RULE_directory_name = 536, RULE_full_identifier = 537, RULE_implementation_type_name = 538, 
		RULE_container_tableview_name = 539, RULE_function_name = 540, RULE_procedure_name = 541, 
		RULE_trigger_name = 542, RULE_collection_name = 543, RULE_index_name = 544, 
		RULE_table_fullname = 545, RULE_grant_object_name = 546, RULE_column_list = 547, 
		RULE_paren_column_list = 548, RULE_keep_clause = 549, RULE_function_argument_analytic = 550, 
		RULE_function_argument_modeling = 551, RULE_respect_or_ignore_nulls = 552, 
		RULE_type_spec = 553, RULE_datatype = 554, RULE_precision_part = 555, 
		RULE_native_datatype_element = 556, RULE_bind_variable = 557, RULE_general_element = 558, 
		RULE_general_element_part = 559, RULE_table_element = 560, RULE_object_privilege = 561, 
		RULE_system_privilege = 562, RULE_literal = 563, RULE_literal_datetime = 564, 
		RULE_constant = 565, RULE_identifier = 566, RULE_synonym_name = 567, RULE_package_name = 568, 
		RULE_parameter_name = 569, RULE_reference_model_name = 570, RULE_cost_class_name = 571, 
		RULE_attribute_name = 572, RULE_savepoint_name = 573, RULE_rollback_segment_name = 574, 
		RULE_table_var_name = 575, RULE_schema_name = 576, RULE_main_model_name = 577, 
		RULE_query_name = 578, RULE_log_group_name = 579, RULE_identifiers = 580, 
		RULE_aggregate_function_name = 581, RULE_exception_name = 582, RULE_column_name = 583, 
		RULE_id_expression = 584, RULE_id_expressions = 585, RULE_type_name = 586, 
		RULE_sequence_name = 587, RULE_char_set_name = 588, RULE_outer_join_sign = 589, 
		RULE_regular_id = 590, RULE_string_function_name = 591, RULE_numeric_function_name = 592, 
		RULE_integer = 593, RULE_numeric = 594, RULE_numeric_negative = 595, RULE_string = 596;
	public static readonly string[] ruleNames = {
		"sql_script", "unit_statement", "drop_function", "alter_function", "create_function_body", 
		"parallel_enable_clause", "partition_by_clause", "result_cache_clause", 
		"relies_on_part", "streaming_clause", "drop_package", "alter_package", 
		"create_package", "create_package_body", "package_obj_spec", "procedure_spec", 
		"function_spec", "package_obj_body", "drop_procedure", "alter_procedure", 
		"function_body", "procedure_body", "create_procedure_body", "drop_trigger", 
		"alter_trigger", "create_trigger", "trigger_follows_clause", "trigger_when_clause", 
		"simple_dml_trigger", "for_each_row", "compound_dml_trigger", "non_dml_trigger", 
		"trigger_body", "routine_clause", "compound_trigger_block", "timing_point_section", 
		"non_dml_event", "dml_event_clause", "dml_event_element", "dml_event_nested_clause", 
		"referencing_clause", "referencing_element", "drop_type", "alter_type", 
		"compile_type_clause", "replace_type_clause", "alter_method_spec", "alter_method_element", 
		"alter_attribute_definition", "attribute_definition", "alter_collection_clauses", 
		"dependent_handling_clause", "dependent_exceptions_part", "create_type", 
		"type_definition", "object_type_def", "object_as_part", "object_under_part", 
		"nested_table_type_def", "sqlj_object_type", "type_body", "type_body_elements", 
		"map_order_func_declaration", "subprog_decl_in_type", "proc_decl_in_type", 
		"func_decl_in_type", "constructor_declaration", "modifier_clause", "object_member_spec", 
		"sqlj_object_type_attr", "element_spec", "element_spec_options", "subprogram_spec", 
		"type_procedure_spec", "type_function_spec", "constructor_spec", "map_order_function_spec", 
		"pragma_clause", "pragma_elements", "type_elements_parameter", "drop_sequence", 
		"alter_sequence", "create_sequence", "sequence_spec", "create_index", 
		"alter_index", "create_user", "alter_user", "alter_identified_by", "identified_by", 
		"identified_other_clause", "user_tablespace_clause", "quota_clause", "profile_clause", 
		"role_clause", "user_default_role_clause", "password_expire_clause", "user_lock_clause", 
		"user_editions_clause", "alter_user_editions_clause", "proxy_clause", 
		"container_names", "set_container_data", "add_rem_container_data", "container_data_clause", 
		"drop_index", "revoke_statment", "revoke_system_privileges", "revoke_object_privileges", 
		"grant_statement", "container_clause", "create_view", "view_options", 
		"view_alias_constraint", "object_view_clause", "constraint", "inline_constraint", 
		"out_of_line_constraint", "out_of_line_constraints", "constraint_state", 
		"using_index_clause", "index_properties", "global_partitioned_index", 
		"individual_hash_partitions", "index_partitioning_clause", "segment_attributes_clause", 
		"index_attributes", "physical_attributes_clauses", "physical_attributes_clause", 
		"hash_partitions_by_quantity", "local_partitioned_index", "on_range_partitioned_table", 
		"on_list_partitioned_table", "on_hash_partitioned_table", "on_comp_partitioned_table", 
		"xmltable_index_clause", "xmlindex_clause", "partition_clause", "partition_clause_optional", 
		"indexing_clause", "partitioning_storage_clause", "inmemory_table_clause", 
		"inmemory_column_clause", "inmemory_clause", "inmemory_parameters", "inmemory_memcompress", 
		"inmemory_priority", "inmemory_distribute", "inmemory_duplicate", "table_compression", 
		"index_compression", "prefix_compression", "advanced_index_compression", 
		"lob_partitioning_storage", "index_subpartition_clause", "usable_clause", 
		"hash_partition_quantity", "varray_item", "partial_index_clause", "parallel_clause", 
		"domain_index_clause", "local_domain_index_clause", "local_domain_index_parameters_clause", 
		"odci_parameters", "exceptions_clause", "create_tablespace", "permanent_tablespace_clause", 
		"tablespace_encryption_spec", "logging_clause", "extent_management_clause", 
		"segment_management_clause", "flashback_mode_clause", "temporary_tablespace_clause", 
		"tablespace_group_clause", "undo_tablespace_clause", "tablespace_retention_clause", 
		"datafile_specification", "tempfile_specification", "datafile_tempfile_spec", 
		"redo_log_file_spec", "autoextend_clause", "maxsize_clause", "subquery", 
		"create_table", "relational_table", "relational_properties", "relational_property", 
		"table_properties", "flashback_archive_clause", "row_movement_clause", 
		"attribute_clustering_clause", "clustering_join", "cluster_clause", "clustering_columns", 
		"clustering_columns_group", "clustering_when", "zonemap_clause", "enable_disable_clause", 
		"table_partitioning_clauses", "range_partitions", "hash_partitions", "column_properties", 
		"xmltype_column_properties", "xmltype_storage", "xmlschema_spec", "list_partitions", 
		"composite_range_partitions", "composite_hash_partitions", "composite_list_partitions", 
		"range_partition_desc", "list_partition_desc", "range_subpartition_desc", 
		"list_subpartition_desc", "individual_hash_subparts", "hash_subparts_by_quantity", 
		"table_partition_description", "range_values_clause", "list_values_clause", 
		"subpartition_by_range", "subpartition_by_list", "subpartition_by_hash", 
		"subpartition_template", "reference_partitioning", "reference_partition_desc", 
		"object_type_col_properties", "substituable_column_clause", "nested_table_col_properties", 
		"object_properties", "varray_col_properties", "varray_storage_clause", 
		"lob_storage_clause", "lob_storage_parameters", "paren_lob_parameters", 
		"lob_parameters", "lob_retention_clause", "lob_deduplicate_clause", "lob_compresssion_clause", 
		"physical_properties", "external_table_clause", "external_data_properties", 
		"external_data_properties_location", "index_org_table_clause", "mapping_table_clause", 
		"index_org_overflow_clause", "deferred_segment_creation", "tablespace_clause", 
		"store_in", "ilm_clause", "ilm_policy_clause", "ilm_compression_policy", 
		"ilm_tiering_policy", "ilm_time_period", "storage_clauses", "storage_clause", 
		"column_definition", "virtual_column_definition", "column_expresssion", 
		"period_definition", "supplemental_logging_props", "supplemental_log_grp_clause", 
		"supplemental_id_key_clause", "column_logged", "evaluation_edition_clause", 
		"edition_name", "unusable_editions_clause", "identity_options", "encryption_spec", 
		"inline_ref_constraint", "out_of_line_ref_constraint", "size_clause", 
		"drop_table", "comment_on_column", "create_synonym", "comment_on_table", 
		"alter_table", "add_constraint", "check_constraint", "drop_constraint", 
		"enable_constraint", "disable_constraint", "foreign_key_clause", "references_clause", 
		"unique_key_clause", "primary_key_clause", "anonymous_block", "invoker_rights_clause", 
		"compiler_parameters_clause", "call_spec", "java_spec", "c_spec", "c_agent_in_clause", 
		"c_parameters_clause", "parameter", "default_value_part", "seq_of_declare_specs", 
		"declare_spec", "variable_declaration", "subtype_declaration", "cursor_declaration", 
		"parameter_spec", "exception_declaration", "pragma_declaration", "type_declaration", 
		"ref_cursor_type_def", "table_type_def", "table_indexed_by_part", "varray_type_def", 
		"record_type_def", "field_spec", "seq_of_statements", "label_declaration", 
		"statement", "swallow_to_semi", "assignment_statement", "continue_statement", 
		"exit_statement", "goto_statement", "if_statement", "elsif_part", "else_part", 
		"loop_statement", "cursor_loop_param", "forall_statement", "bounds_clause", 
		"between_bound", "lower_bound", "upper_bound", "null_statement", "raise_statement", 
		"return_statement", "function_call", "pipe_row_statement", "body", "exception_handler", 
		"trigger_block", "block", "sql_statement", "execute_immediate", "dynamic_returning_clause", 
		"data_manipulation_language_statements", "cursor_manipulation_statements", 
		"close_statement", "open_statement", "fetch_statement", "open_for_statement", 
		"transaction_control_statements", "set_transaction_command", "set_constraint_command", 
		"commit_statement", "write_clause", "rollback_statement", "savepoint_statement", 
		"explain_statement", "select_statement", "subquery_factoring_clause", 
		"factoring_element", "search_clause", "cycle_clause", "subquery_basic_elements", 
		"subquery_operation_part", "query_block", "selected_element", "from_clause", 
		"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux", 
		"table_ref_aux_internal", "join_clause", "join_on_part", "join_using_part", 
		"outer_join_type", "query_partition_clause", "flashback_query_clause", 
		"pivot_clause", "pivot_element", "pivot_for_clause", "pivot_in_clause", 
		"pivot_in_clause_element", "pivot_in_clause_elements", "unpivot_clause", 
		"unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause", 
		"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause", 
		"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause", 
		"cell_reference_options", "return_rows_clause", "reference_model", "main_model", 
		"model_column_clauses", "model_column_partition_part", "model_column_list", 
		"model_column", "model_rules_clause", "model_rules_part", "model_rules_element", 
		"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause", 
		"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options", 
		"update_statement", "update_set_clause", "column_based_update_set_clause", 
		"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert", 
		"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part", 
		"conditional_insert_else_part", "insert_into_clause", "values_clause", 
		"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part", 
		"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part", 
		"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause", 
		"error_logging_clause", "error_logging_into_part", "error_logging_reject_part", 
		"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause", 
		"sample_clause", "seed_part", "condition", "expressions", "expression", 
		"cursor_expression", "logical_expression", "multiset_expression", "relational_expression", 
		"simple_expression", "compound_expression", "concatenation", "relational_operator", 
		"model_expression", "in_elements", "between_elements", "interval_expression", 
		"model_expression_element", "single_column_for_loop", "multi_column_for_loop", 
		"unary_expression", "case_statement", "simple_case_statement", "simple_case_when_part", 
		"searched_case_statement", "searched_case_when_part", "case_else_part", 
		"atom", "quantified_expression", "standard_function", "string_function", 
		"numeric_function_wrapper", "numeric_function", "to_date", "other_function", 
		"over_clause_keyword", "within_or_over_clause_keyword", "standard_prediction_function_keyword", 
		"over_clause", "windowing_clause", "windowing_type", "windowing_elements", 
		"using_clause", "using_element", "collect_order_by_part", "within_or_over_part", 
		"cost_matrix_clause", "xml_passing_clause", "xml_attributes_clause", "xml_namespaces_clause", 
		"xml_table_column", "xml_general_default_part", "xml_multiuse_expression_element", 
		"xmlroot_param_version_part", "xmlroot_param_standalone_part", "xmlserialize_param_enconding_part", 
		"xmlserialize_param_version_part", "xmlserialize_param_ident_part", "sql_plus_command", 
		"sqlplus_execute_command", "sqlplus_whenever_command", "function_arguments", 
		"arguments", "argument", "sqlplus_set_command", "partition_extension_clause", 
		"column_alias", "table_alias", "where_clause", "into_clause", "xml_column_name", 
		"routine_name", "indextype", "grantee_name", "role_name", "constraint_name", 
		"variable_name", "cursor_name", "record_name", "link_name", "tableview_name", 
		"element_name", "flashback_archive_name", "zonemap_name", "subpartition_name", 
		"lob_item_name", "dir_object_name", "user_object_name", "tablespace_name", 
		"label_name", "partition_name", "schema_object_name", "lob_segname", "ilm_policy_name", 
		"directory_name", "full_identifier", "implementation_type_name", "container_tableview_name", 
		"function_name", "procedure_name", "trigger_name", "collection_name", 
		"index_name", "table_fullname", "grant_object_name", "column_list", "paren_column_list", 
		"keep_clause", "function_argument_analytic", "function_argument_modeling", 
		"respect_or_ignore_nulls", "type_spec", "datatype", "precision_part", 
		"native_datatype_element", "bind_variable", "general_element", "general_element_part", 
		"table_element", "object_privilege", "system_privilege", "literal", "literal_datetime", 
		"constant", "identifier", "synonym_name", "package_name", "parameter_name", 
		"reference_model_name", "cost_class_name", "attribute_name", "savepoint_name", 
		"rollback_segment_name", "table_var_name", "schema_name", "main_model_name", 
		"query_name", "log_group_name", "identifiers", "aggregate_function_name", 
		"exception_name", "column_name", "id_expression", "id_expressions", "type_name", 
		"sequence_name", "char_set_name", "outer_join_sign", "regular_id", "string_function_name", 
		"numeric_function_name", "integer", "numeric", "numeric_negative", "string"
	};

	private static readonly string[] _LiteralNames = {
		null, "'ACCESS'", "'ACCOUNT'", "'ADD'", "'ADMIN'", "'ADMINISTER'", "'ADVANCED'", 
		"'ADVISOR'", "'AFTER'", "'AGENT'", "'AGGREGATE'", "'A'", "'ALL'", "'ALLOW'", 
		"'ALTER'", "'ALWAYS'", "'ANALYZE'", "'AND'", "'ANY'", "'ANYSCHEMA'", "'ARCHIVAL'", 
		"'ARCHIVE'", "'ARRAY'", "'AS'", "'ASC'", "'ASSOCIATE'", "'AT'", "'ATTRIBUTE'", 
		"'AUDIT'", "'AUTHENTICATED'", "'AUTHENTICATION'", "'AUTHID'", "'AUTOALLOCATE'", 
		"'AUTO'", "'AUTOEXTEND'", "'AUTOMATIC'", "'AUTONOMOUS_TRANSACTION'", "'BACKUP'", 
		"'BASIC'", "'BASICFILE'", "'BATCH'", "'BECOME'", "'BEFORE'", "'BEGIN'", 
		"'BETWEEN'", "'BFILE'", "'BIGFILE'", "'BINARY'", "'BINARY_DOUBLE'", "'BINARY_FLOAT'", 
		"'BINARY_INTEGER'", "'BLOB'", "'BLOCK'", "'BLOCKSIZE'", "'BODY'", "'BOOLEAN'", 
		"'BOTH'", "'BREADTH'", "'BUFFER_POOL'", "'BUILD'", "'BULK'", "'BY'", "'BYTE'", 
		"'CACHE'", "'CALL'", "'CANONICAL'", "'CAPACITY'", "'CASCADE'", "'CASE'", 
		"'CAST'", "'CERTIFICATE'", "'CHANGE'", "'CHARACTER'", "'CHAR'", "'CHAR_CS'", 
		"'CHECK'", "'CHR'", "'CHUNK'", "'CLASS'", "'C'", "'CLOB'", "'CLOSE'", 
		"'CLUSTER'", "'CLUSTERING'", "'COALESCE'", "'COLLECT'", "'COLUMN'", "'COLUMNS'", 
		"'COMMENT'", "'COMMIT'", "'COMMITTED'", "'COMPATIBILITY'", "'COMPILE'", 
		"'COMPOUND'", "'COMPRESS'", "'COMPUTE'", "'CONNECT_BY_ROOT'", "'CONNECT'", 
		"'CONSTANT'", "'CONSTRAINT'", "'CONSTRAINTS'", "'CONSTRUCTOR'", "'CONTAINER'", 
		"'CONTAINER_DATA'", "'CONTENT'", "'CONTEXT'", "'CONTINUE'", "'CONVERT'", 
		"'CORRUPT_XID_ALL'", "'CORRUPT_XID'", "'COST'", "'COUNT'", "'CREATE'", 
		"'CREATION'", "'CRITICAL'", "'CROSS'", "'CUBE'", "'CURRENT'", "'CURRENT_USER'", 
		"'CURRVAL'", "'CURSOR'", "'CUSTOMDATUM'", "'CYCLE'", "'DATABASE'", "'DATA'", 
		"'DATAFILE'", "'DATE'", "'DAY'", "'DAYS'", "'DBA_RECYCLEBIN'", "'DB_ROLE_CHANGE'", 
		"'DBTIMEZONE'", "'DDL'", "'DEBUG'", "'DEC'", "'DECIMAL'", "'DECLARE'", 
		"'DECOMPOSE'", "'DECREMENT'", "'DECRYPT'", "'DEDUPLICATE'", "'DEFAULT'", 
		"'DEFAULTS'", "'DEFERRABLE'", "'DEFERRED'", "'DEFINER'", "'DELEGATE'", 
		"'DELETE'", "'DEPTH'", "'DESC'", "'DETERMINISTIC'", "'DICTIONARY'", "'DIMENSION'", 
		"'DIRECTORY'", "'DISABLE'", "'DISALLOW'", "'DISASSOCIATE'", "'DISTINCT'", 
		"'DISTINGUISHED'", "'DISTRIBUTE'", "'DML'", "'DOCUMENT'", "'DOUBLE'", 
		"'DROP'", "'DSINTERVAL_UNCONSTRAINED'", "'DUPLICATE'", "'EACH'", "'EDITIONABLE'", 
		"'EDITION'", "'EDITIONING'", "'EDITIONS'", "'ELEMENT'", "'ELSE'", "'ELSIF'", 
		"'EMPTY'", "'ENABLE'", "'ENCODING'", "'ENCRYPT'", "'ENCRYPTION'", "'END'", 
		"'ENTERPRISE'", "'ENTITYESCAPING'", "'ERR'", "'ERRORS'", "'ESCAPE'", "'EVALNAME'", 
		"'EVALUATION'", "'EXCEPT'", "'EXCEPTION'", "'EXCEPTION_INIT'", "'EXCEPTIONS'", 
		"'EXCLUDE'", "'EXCLUSIVE'", "'EXECUTE'", "'EXEMPT'", "'EXISTS'", "'EXIT'", 
		"'EXPIRE'", "'EXPLAIN'", "'EXTENT'", "'EXTERNAL'", "'EXTERNALLY'", "'EXTRACT'", 
		"'FAILURE'", "'FALSE'", "'FETCH'", "'FILESYSTEM_LIKE_LOGGING'", "'FINAL'", 
		"'FIRST'", "'FIRST_VALUE'", "'FLASHBACK'", "'FLASH_CACHE'", "'FLOAT'", 
		"'FOLDER'", "'FOLLOWING'", "'FOLLOWS'", "'FORALL'", "'FORCE'", "'FOREIGN'", 
		"'FOR'", "'FREELIST'", "'FREELISTS'", "'FREEPOOLS'", "'FROM'", "'FULL'", 
		"'FUNCTION'", "'GENERATED'", "'GLOBAL'", "'GLOBALLY'", "'GOTO'", "'GRANT'", 
		"'GROUP'", "'GROUPING'", "'GROUPS'", "'GUARANTEE'", "'HASH'", "'HAVING'", 
		"'HEAP'", "'HIDE'", "'HIERARCHY'", "'HIGH'", "'HOUR'", "'IDENTIFIED'", 
		"'IDENTIFIER'", "'IDENTITY'", "'ID'", "'IF'", "'IGNORE'", "'ILM'", "'IMMEDIATE'", 
		"'INCLUDE'", "'INCLUDING'", "'INCREMENT'", "'INDENT'", "'INDEXED'", "'INDEX'", 
		"'INDEXING'", "'INDEXTYPE'", "'INDICATOR'", "'INDICES'", "'INFINITE'", 
		"'INHERIT'", "'IN'", "'INITIAL'", "'INITIALLY'", "'INITRANS'", "'INLINE'", 
		"'INMEMORY'", "'INNER'", "'INOUT'", "'INSERT'", "'INSTANTIABLE'", "'INSTEAD'", 
		"'INTEGER'", "'INTERSECT'", "'INTERVAL'", "'INTERVLEAVED'", "'INT'", "'INTO'", 
		"'INVALIDATE'", "'INVISIBLE'", "'IS'", "'ISOLATION'", "'ITERATE'", "'JAVA'", 
		"'JOB'", "'JOIN'", "'KEEP_DUPLICATES'", "'KEEP'", "'KEY'", "'LANGUAGE'", 
		"'LAST'", "'LAST_VALUE'", "'LEADING'", "'LEFT'", "'LESS'", "'LEVEL'", 
		"'LEVELS'", "'LIBRARY'", "'LIKE2'", "'LIKE4'", "'LIKEC'", "'LIKE'", "'LIMIT'", 
		"'LINEAR'", "'LINK'", "'LIST'", "'LOAD'", "'LOB'", "'LOBS'", "'LOCAL'", 
		"'LOCATION'", "'LOCATOR'", "'LOCKED'", "'LOCKING'", "'LOCK'", "'LOGGING'", 
		"'LOG'", "'LOGMINING'", "'LOGOFF'", "'LOGON'", "'LONG'", "'LOOP'", "'LOW'", 
		"'MAIN'", "'MANAGE'", "'MANAGEMENT'", "'MANUAL'", "'MAP'", "'MAPPING'", 
		"'MATCHED'", "'MATERIALIZED'", "'MAXSIZE'", "'MAXTRANS'", "'MAXVALUE'", 
		"'MEASURE'", "'MEASURES'", "'MEDIUM'", "'MEMBER'", "'MEMCOMPRESS'", "'MERGE'", 
		"'MINEXTENTS'", "'NEXTVAL'", "'MINIMUM'", "'MINING'", "'MINUS'", "'MINUTE'", 
		"'MINVALUE'", "'MLSLABEL'", "'MODEL'", "'MODE'", "'MODIFICATION'", "'MODIFY'", 
		"'MONTH'", "'MONTHS'", "'MOVEMENT'", "'MULTISET'", "'NAME'", "'NAN'", 
		"'NATURAL'", "'NATURALN'", "'NAV'", "'NCHAR_CS'", "'NCHAR'", "'NCLOB'", 
		"'NESTED'", "'NEW'", "'NEXT'", "'NOAUDIT'", "'NOCACHE'", "'NOCOMPRESS'", 
		"'NOCOPY'", "'NOCYCLE'", "'NOEDITIONABLE'", "'NOENTITYESCAPING'", "'NOGUARANTEE'", 
		"'NOKEEP'", "'NOLOGGING'", "'NOMAPPING'", "'NOMAXVALUE'", "'NOMINVALUE'", 
		"'NONEDITIONABLE'", "'NONE'", "'NO'", "'NONSCHEMA'", "'NOORDER'", "'NOPARALLEL'", 
		"'NORELY'", "'NOROWDEPENDENCIES'", "'NOSCHEMACHECK'", "'NOSORT'", "'NOTIFICATION'", 
		"'NOT'", "'NOVALIDATE'", "'NOWAIT'", "'NULL'", "'NULLS'", "'NUMBER'", 
		"'NUMERIC'", "'NVARCHAR2'", "'OBJECT'", "'OFFLINE'", "'OFF'", "'OF'", 
		"'OID'", "'OLD'", "'OLTP'", "'ONLINE'", "'ONLY'", "'ON'", "'OPEN'", "'OPERATOR'", 
		"'OPTIMAL'", "'OPTION'", "'ORADATA'", "'ORDER'", "'ORDINALITY'", "'ORGANIZATION'", 
		"'OR'", "'OSERROR'", "'OUTER'", "'OUTLINE'", "'OUT'", "'OVERFLOW'", "'OVER'", 
		"'OVERRIDING'", "'PACKAGE'", "'PARALLEL_ENABLE'", "'PARALLEL'", "'PARAMETERS'", 
		"'PARENT'", "'PARTIAL'", "'PARTITION'", "'PARTITIONS'", "'PASSING'", "'PASSWORD'", 
		"'PATH'", "'PCTFREE'", "'PCTINCREASE'", "'PCTTHRESHOLD'", "'PCTUSED'", 
		"'PCTVERSION'", "'%FOUND'", "'%ISOPEN'", "'%NOTFOUND'", "'%ROWCOUNT'", 
		"'%ROWTYPE'", "'%TYPE'", "'PIPELINED'", "'PIPE'", "'PIVOT'", "'PLAN'", 
		"'PLS_INTEGER'", "'PLUGGABLE'", "'POLICY'", "'POSITIVEN'", "'POSITIVE'", 
		"'PRAGMA'", "'PRECEDING'", "'PRECISION'", "'PRESENT'", "'PRESERVE'", "'PRIMARY'", 
		"'PRIORITY'", "'PRIOR'", "'PRIVILEGE'", "'PRIVILEGES'", "'PROCEDURE'", 
		"'PROCESS'", "'PROFILE'", "'PROGRAM'", "'PUBLIC'", "'PURGE'", "'QUERY'", 
		"'QUOTA'", "'RAISE'", "'RANGE'", "'RAW'", "'READ'", "'READS'", "'REAL'", 
		"'RECORD'", "'RECYCLE'", "'REDACTION'", "'REFERENCE'", "'REFERENCES'", 
		"'REFERENCING'", "'REF'", "'REFRESH'", "'REJECT'", "'RELATIONAL'", "'RELIES_ON'", 
		"'RELY'", "'REMOVE'", "'RENAME'", "'REPLACE'", "'REQUIRED'", "'RESOURCE'", 
		"'RESPECT'", "'RESTRICTED'", "'RESTRICT_REFERENCES'", "'RESULT_CACHE'", 
		"'RESULT'", "'RESUMABLE'", "'RETENTION'", "'RETURNING'", "'RETURN'", "'REUSE'", 
		"'REVERSE'", "'REVOKE'", "'REWRITE'", "'RIGHT'", "'ROLE'", "'ROLES'", 
		"'ROLLBACK'", "'ROLLUP'", "'ROWDEPENDENCIES'", "'ROWID'", "'ROWNUM'", 
		"'ROW'", "'ROWS'", "'RULES'", "'SALT'", "'SAMPLE'", "'SAVEPOINT'", "'SAVE'", 
		"'SCHEDULER'", "'SCHEMACHECK'", "'SCHEMA'", "'SCN'", "'SCOPE'", "'SEARCH'", 
		"'SECOND'", "'SECUREFILE'", "'SEED'", "'SEGMENT'", "'SELECT'", "'SELF'", 
		"'SEQUENCE'", "'SEQUENTIAL'", "'SERIALIZABLE'", "'SERIALLY_REUSABLE'", 
		"'SERVERERROR'", "'SESSION'", "'SESSIONTIMEZONE'", "'SET'", "'SETS'", 
		"'SETTINGS'", "'SHARE'", "'#'", "'SHOW'", "'SHUTDOWN'", "'SIBLINGS'", 
		"'SIGNTYPE'", "'SIMPLE_INTEGER'", "'SINGLE'", "'SIZE'", "'SKIP'", "'SMALLFILE'", 
		"'SMALLINT'", "'SNAPSHOT'", "'SOME'", "'SORT'", "'SOURCE'", "'SPACE'", 
		"'SPECIFICATION'", "'SQLDATA'", "'SQLERROR'", "'SQL'", "'STANDALONE'", 
		"'START'", "'STARTUP'", "'STATEMENT_ID'", "'STATEMENT'", "'STATIC'", "'STATISTICS'", 
		"'STORAGE'", "'STORE'", "'STRING'", "'SUBMULTISET'", "'SUBPARTITIONS'", 
		"'SUBPARTITION'", "'SUBSTITUTABLE'", "'SUBTYPE'", "'SUCCESS'", "'SUPPLEMENTAL'", 
		"'SUSPEND'", "'SYNONYM'", "'SYSBACKUP'", "'SYSDATE'", "'SYSDBA'", "'SYSDG'", 
		"'SYSGUID'", "'SYSKM'", "'SYSOPER'", "'SYSTEM'", "'TABLESPACE'", "'TABLES'", 
		"'TABLE'", "'TEMPFILE'", "'TEMPLATE'", "'TEMPORARY'", "'THAN'", "'THEN'", 
		"'THE'", "'THROUGH'", "'TIER'", "'TIMESTAMP_LTZ_UNCONSTRAINED'", "'TIMESTAMP'", 
		"'TIMESTAMP_TZ_UNCONSTRAINED'", "'TIMESTAMP_UNCONSTRAINED'", "'TIME'", 
		"'TIMEZONE_ABBR'", "'TIMEZONE_HOUR'", "'TIMEZONE_MINUTE'", "'TIMEZONE_REGION'", 
		"'TO_NCLOB'", "'TO_NUMBER'", "'TO_SINGLE_BYTE'", "'TO_TIMESTAMP_TZ'", 
		"'TO'", "'TO_YMINTERVAL'", "'TRAILING'", "'TRANSACTION'", "'TRANSLATE'", 
		"'TRANSLATION'", "'TREAT'", "'TRIGGER'", "'TRUE'", "'TRUNCATE'", "'TRUNC'", 
		"'TUNING'", "'TYPE'", "'UNBOUNDED'", "'UNDER'", "'UNDO'", "'UNIFORM'", 
		"'UNION'", "'UNIQUE'", "'UNLIMITED'", "'UNLOCK'", "'UNPIVOT'", "'UNTIL'", 
		"'UNUSABLE'", "'UPDATED'", "'UPDATE'", "'UPSERT'", "'UROWID'", "'USABLE'", 
		"'USERS'", "'USER'", "'USE'", "'USING'", "'VALIDATE'", "'VALUES'", "'VALUE'", 
		"'VARCHAR2'", "'VARCHAR'", "'VARIABLE'", "'VARRAYS'", "'VARRAY'", "'VARYING'", 
		"'VERSIONS'", "'VERSION'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'", 
		"'WARNING'", "'WELLFORMED'", "'WHENEVER'", "'WHEN'", "'WHERE'", "'WHILE'", 
		"'WITHIN'", "'WITHOUT'", "'WITH'", "'WORK'", "'WRITE'", "'XMLAGG'", "'XMLATTRIBUTES'", 
		"'XMLCAST'", "'XMLCOLATTVAL'", "'XMLELEMENT'", "'XMLEXISTS'", "'XMLFOREST'", 
		"'XMLNAMESPACES'", "'XMLPARSE'", "'XMLPI'", "'XMLQUERY'", "'XMLROOT'", 
		"'XMLSCHEMA'", "'XMLSERIALIZE'", "'XMLTABLE'", "'XMLTYPE'", "'XML'", "'YEARS'", 
		"'YEAR'", "'YES'", "'YMINTERVAL_UNCONSTRAINED'", "'ZONEMAP'", "'ZONE'", 
		"'PREDICTION'", "'PREDICTION_BOUNDS'", "'PREDICTION_COST'", "'PREDICTION_DETAILS'", 
		"'PREDICTION_PROBABILITY'", "'PREDICTION_SET'", "'CUME_DIST'", "'DENSE_RANK'", 
		"'LISTAGG'", "'PERCENT_RANK'", "'PERCENTILE_CONT'", "'PERCENTILE_DISC'", 
		"'RANK'", "'AVG'", "'CORR'", "'COVAR_'", "'DECODE'", "'LAG'", "'LEAD'", 
		"'MAX'", "'MEDIAN'", "'MIN'", "'NTILE'", "'NVL'", "'RATIO_TO_REPORT'", 
		"'REGR_'", "'ROUND'", "'ROW_NUMBER'", "'SUBSTR'", "'TO_CHAR'", "'TRIM'", 
		"'SUM'", "'STDDEV'", "'VAR_'", "'VARIANCE'", "'LEAST'", "'GREATEST'", 
		"'TO_DATE'", null, null, null, null, "'..'", "'.'", null, null, null, 
		null, "'%'", "'&'", "'('", "')'", "'**'", "'*'", "'+'", "'-'", "','", 
		"'/'", "'@'", "':='", null, null, "'^'", "'~'", "'!'", "'>'", "'<'", "':'", 
		"';'", "'|'", "'='", "'['", "']'", "'=>'", "'_'", null, null, null, null, 
		null, null, "'@!'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "ACCESS", "ACCOUNT", "ADD", "ADMIN", "ADMINISTER", "ADVANCED", "ADVISOR", 
		"AFTER", "AGENT", "AGGREGATE", "A_LETTER", "ALL", "ALLOW", "ALTER", "ALWAYS", 
		"ANALYZE", "AND", "ANY", "ANYSCHEMA", "ARCHIVAL", "ARCHIVE", "ARRAY", 
		"AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE", "AUDIT", "AUTHENTICATED", 
		"AUTHENTICATION", "AUTHID", "AUTOALLOCATE", "AUTO", "AUTOEXTEND", "AUTOMATIC", 
		"AUTONOMOUS_TRANSACTION", "BACKUP", "BASIC", "BASICFILE", "BATCH", "BECOME", 
		"BEFORE", "BEGIN", "BETWEEN", "BFILE", "BIGFILE", "BINARY", "BINARY_DOUBLE", 
		"BINARY_FLOAT", "BINARY_INTEGER", "BLOB", "BLOCK", "BLOCKSIZE", "BODY", 
		"BOOLEAN", "BOTH", "BREADTH", "BUFFER_POOL", "BUILD", "BULK", "BY", "BYTE", 
		"CACHE", "CALL", "CANONICAL", "CAPACITY", "CASCADE", "CASE", "CAST", "CERTIFICATE", 
		"CHANGE", "CHARACTER", "CHAR", "CHAR_CS", "CHECK", "CHR", "CHUNK", "CLASS", 
		"C_LETTER", "CLOB", "CLOSE", "CLUSTER", "CLUSTERING", "COALESCE", "COLLECT", 
		"COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPATIBILITY", 
		"COMPILE", "COMPOUND", "COMPRESS", "COMPUTE", "CONNECT_BY_ROOT", "CONNECT", 
		"CONSTANT", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTAINER", "CONTAINER_DATA", 
		"CONTENT", "CONTEXT", "CONTINUE", "CONVERT", "CORRUPT_XID_ALL", "CORRUPT_XID", 
		"COST", "COUNT", "CREATE", "CREATION", "CRITICAL", "CROSS", "CUBE", "CURRENT", 
		"CURRENT_USER", "CURRVAL", "CURSOR", "CUSTOMDATUM", "CYCLE", "DATABASE", 
		"DATA", "DATAFILE", "DATE", "DAY", "DAYS", "DBA_RECYCLEBIN", "DB_ROLE_CHANGE", 
		"DBTIMEZONE", "DDL", "DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", 
		"DECREMENT", "DECRYPT", "DEDUPLICATE", "DEFAULT", "DEFAULTS", "DEFERRABLE", 
		"DEFERRED", "DEFINER", "DELEGATE", "DELETE", "DEPTH", "DESC", "DETERMINISTIC", 
		"DICTIONARY", "DIMENSION", "DIRECTORY", "DISABLE", "DISALLOW", "DISASSOCIATE", 
		"DISTINCT", "DISTINGUISHED", "DISTRIBUTE", "DML", "DOCUMENT", "DOUBLE", 
		"DROP", "DSINTERVAL_UNCONSTRAINED", "DUPLICATE", "EACH", "EDITIONABLE", 
		"EDITION", "EDITIONING", "EDITIONS", "ELEMENT", "ELSE", "ELSIF", "EMPTY", 
		"ENABLE", "ENCODING", "ENCRYPT", "ENCRYPTION", "END", "ENTERPRISE", "ENTITYESCAPING", 
		"ERR", "ERRORS", "ESCAPE", "EVALNAME", "EVALUATION", "EXCEPT", "EXCEPTION", 
		"EXCEPTION_INIT", "EXCEPTIONS", "EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXEMPT", 
		"EXISTS", "EXIT", "EXPIRE", "EXPLAIN", "EXTENT", "EXTERNAL", "EXTERNALLY", 
		"EXTRACT", "FAILURE", "FALSE", "FETCH", "FILESYSTEM_LIKE_LOGGING", "FINAL", 
		"FIRST", "FIRST_VALUE", "FLASHBACK", "FLASH_CACHE", "FLOAT", "FOLDER", 
		"FOLLOWING", "FOLLOWS", "FORALL", "FORCE", "FOREIGN", "FOR", "FREELIST", 
		"FREELISTS", "FREEPOOLS", "FROM", "FULL", "FUNCTION", "GENERATED", "GLOBAL", 
		"GLOBALLY", "GOTO", "GRANT", "GROUP", "GROUPING", "GROUPS", "GUARANTEE", 
		"HASH", "HAVING", "HEAP", "HIDE", "HIERARCHY", "HIGH", "HOUR", "IDENTIFIED", 
		"IDENTIFIER", "IDENTITY", "ID", "IF", "IGNORE", "ILM", "IMMEDIATE", "INCLUDE", 
		"INCLUDING", "INCREMENT", "INDENT", "INDEXED", "INDEX", "INDEXING", "INDEXTYPE", 
		"INDICATOR", "INDICES", "INFINITE", "INHERIT", "IN", "INITIAL", "INITIALLY", 
		"INITRANS", "INLINE", "INMEMORY", "INNER", "INOUT", "INSERT", "INSTANTIABLE", 
		"INSTEAD", "INTEGER", "INTERSECT", "INTERVAL", "INTERVLEAVED", "INT", 
		"INTO", "INVALIDATE", "INVISIBLE", "IS", "ISOLATION", "ITERATE", "JAVA", 
		"JOB", "JOIN", "KEEP_DUPLICATES", "KEEP", "KEY", "LANGUAGE", "LAST", "LAST_VALUE", 
		"LEADING", "LEFT", "LESS", "LEVEL", "LEVELS", "LIBRARY", "LIKE2", "LIKE4", 
		"LIKEC", "LIKE", "LIMIT", "LINEAR", "LINK", "LIST", "LOAD", "LOB", "LOBS", 
		"LOCAL", "LOCATION", "LOCATOR", "LOCKED", "LOCKING", "LOCK", "LOGGING", 
		"LOG", "LOGMINING", "LOGOFF", "LOGON", "LONG", "LOOP", "LOW", "MAIN", 
		"MANAGE", "MANAGEMENT", "MANUAL", "MAP", "MAPPING", "MATCHED", "MATERIALIZED", 
		"MAXSIZE", "MAXTRANS", "MAXVALUE", "MEASURE", "MEASURES", "MEDIUM", "MEMBER", 
		"MEMCOMPRESS", "MERGE", "MINEXTENTS", "NEXTVAL", "MINIMUM", "MINING", 
		"MINUS", "MINUTE", "MINVALUE", "MLSLABEL", "MODEL", "MODE", "MODIFICATION", 
		"MODIFY", "MONTH", "MONTHS", "MOVEMENT", "MULTISET", "NAME", "NAN", "NATURAL", 
		"NATURALN", "NAV", "NCHAR_CS", "NCHAR", "NCLOB", "NESTED", "NEW", "NEXT", 
		"NOAUDIT", "NOCACHE", "NOCOMPRESS", "NOCOPY", "NOCYCLE", "NOEDITIONABLE", 
		"NOENTITYESCAPING", "NOGUARANTEE", "NOKEEP", "NOLOGGING", "NOMAPPING", 
		"NOMAXVALUE", "NOMINVALUE", "NONEDITIONABLE", "NONE", "NO", "NONSCHEMA", 
		"NOORDER", "NOPARALLEL", "NORELY", "NOROWDEPENDENCIES", "NOSCHEMACHECK", 
		"NOSORT", "NOTIFICATION", "NOT", "NOVALIDATE", "NOWAIT", "NULL", "NULLS", 
		"NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", "OFFLINE", "OFF", "OF", "OID", 
		"OLD", "OLTP", "ONLINE", "ONLY", "ON", "OPEN", "OPERATOR", "OPTIMAL", 
		"OPTION", "ORADATA", "ORDER", "ORDINALITY", "ORGANIZATION", "OR", "OSERROR", 
		"OUTER", "OUTLINE", "OUT", "OVERFLOW", "OVER", "OVERRIDING", "PACKAGE", 
		"PARALLEL_ENABLE", "PARALLEL", "PARAMETERS", "PARENT", "PARTIAL", "PARTITION", 
		"PARTITIONS", "PASSING", "PASSWORD", "PATH", "PCTFREE", "PCTINCREASE", 
		"PCTTHRESHOLD", "PCTUSED", "PCTVERSION", "PERCENT_FOUND", "PERCENT_ISOPEN", 
		"PERCENT_NOTFOUND", "PERCENT_ROWCOUNT", "PERCENT_ROWTYPE", "PERCENT_TYPE", 
		"PIPELINED", "PIPE", "PIVOT", "PLAN", "PLS_INTEGER", "PLUGGABLE", "POLICY", 
		"POSITIVEN", "POSITIVE", "PRAGMA", "PRECEDING", "PRECISION", "PRESENT", 
		"PRESERVE", "PRIMARY", "PRIORITY", "PRIOR", "PRIVILEGE", "PRIVILEGES", 
		"PROCEDURE", "PROCESS", "PROFILE", "PROGRAM", "PUBLIC", "PURGE", "QUERY", 
		"QUOTA", "RAISE", "RANGE", "RAW", "READ", "READS", "REAL", "RECORD", "RECYCLE", 
		"REDACTION", "REFERENCE", "REFERENCES", "REFERENCING", "REF", "REFRESH", 
		"REJECT", "RELATIONAL", "RELIES_ON", "RELY", "REMOVE", "RENAME", "REPLACE", 
		"REQUIRED", "RESOURCE", "RESPECT", "RESTRICTED", "RESTRICT_REFERENCES", 
		"RESULT_CACHE", "RESULT", "RESUMABLE", "RETENTION", "RETURNING", "RETURN", 
		"REUSE", "REVERSE", "REVOKE", "REWRITE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", 
		"ROLLUP", "ROWDEPENDENCIES", "ROWID", "ROWNUM", "ROW", "ROWS", "RULES", 
		"SALT", "SAMPLE", "SAVEPOINT", "SAVE", "SCHEDULER", "SCHEMACHECK", "SCHEMA", 
		"SCN", "SCOPE", "SEARCH", "SECOND", "SECUREFILE", "SEED", "SEGMENT", "SELECT", 
		"SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSION", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", 
		"SHARE", "SHARP", "SHOW", "SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", 
		"SINGLE", "SIZE", "SKIP_", "SMALLFILE", "SMALLINT", "SNAPSHOT", "SOME", 
		"SORT", "SOURCE", "SPACE_KEYWORD", "SPECIFICATION", "SQLDATA", "SQLERROR", 
		"SQL", "STANDALONE", "START", "STARTUP", "STATEMENT_ID", "STATEMENT", 
		"STATIC", "STATISTICS", "STORAGE", "STORE", "STRING", "SUBMULTISET", "SUBPARTITIONS", 
		"SUBPARTITION", "SUBSTITUTABLE", "SUBTYPE", "SUCCESS", "SUPPLEMENTAL", 
		"SUSPEND", "SYNONYM", "SYSBACKUP", "SYSDATE", "SYSDBA", "SYSDG", "SYSGUID", 
		"SYSKM", "SYSOPER", "SYSTEM", "TABLESPACE", "TABLES", "TABLE", "TEMPFILE", 
		"TEMPLATE", "TEMPORARY", "THAN", "THEN", "THE", "THROUGH", "TIER", "TIMESTAMP_LTZ_UNCONSTRAINED", 
		"TIMESTAMP", "TIMESTAMP_TZ_UNCONSTRAINED", "TIMESTAMP_UNCONSTRAINED", 
		"TIME", "TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", 
		"TO_NCLOB", "TO_NUMBER", "TO_SINGLE_BYTE", "TO_TIMESTAMP_TZ", "TO", "TO_YMINTERVAL", 
		"TRAILING", "TRANSACTION", "TRANSLATE", "TRANSLATION", "TREAT", "TRIGGER", 
		"TRUE", "TRUNCATE", "TRUNC", "TUNING", "TYPE", "UNBOUNDED", "UNDER", "UNDO", 
		"UNIFORM", "UNION", "UNIQUE", "UNLIMITED", "UNLOCK", "UNPIVOT", "UNTIL", 
		"UNUSABLE", "UPDATED", "UPDATE", "UPSERT", "UROWID", "USABLE", "USERS", 
		"USER", "USE", "USING", "VALIDATE", "VALUES", "VALUE", "VARCHAR2", "VARCHAR", 
		"VARIABLE", "VARRAYS", "VARRAY", "VARYING", "VERSIONS", "VERSION", "VIEW", 
		"VIRTUAL", "VISIBLE", "WAIT", "WARNING", "WELLFORMED", "WHENEVER", "WHEN", 
		"WHERE", "WHILE", "WITHIN", "WITHOUT", "WITH", "WORK", "WRITE", "XMLAGG", 
		"XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", "XMLELEMENT", "XMLEXISTS", 
		"XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", 
		"XMLSCHEMA", "XMLSERIALIZE", "XMLTABLE", "XMLTYPE", "XML", "YEARS", "YEAR", 
		"YES", "YMINTERVAL_UNCONSTRAINED", "ZONEMAP", "ZONE", "PREDICTION", "PREDICTION_BOUNDS", 
		"PREDICTION_COST", "PREDICTION_DETAILS", "PREDICTION_PROBABILITY", "PREDICTION_SET", 
		"CUME_DIST", "DENSE_RANK", "LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", 
		"PERCENTILE_DISC", "RANK", "AVG", "CORR", "COVAR_", "DECODE", "LAG", "LEAD", 
		"MAX", "MEDIAN", "MIN", "NTILE", "NVL", "RATIO_TO_REPORT", "REGR_", "ROUND", 
		"ROW_NUMBER", "SUBSTR", "TO_CHAR", "TRIM", "SUM", "STDDEV", "VAR_", "VARIANCE", 
		"LEAST", "GREATEST", "TO_DATE", "VARIABLE_SESSION", "NATIONAL_CHAR_STRING_LIT", 
		"BIT_STRING_LIT", "HEX_STRING_LIT", "DOUBLE_PERIOD", "PERIOD", "UNSIGNED_INTEGER", 
		"APPROXIMATE_NUM_LIT", "CHAR_STRING", "DELIMITED_ID", "PERCENT", "AMPERSAND", 
		"LEFT_PAREN", "RIGHT_PAREN", "DOUBLE_ASTERISK", "ASTERISK", "PLUS_SIGN", 
		"MINUS_SIGN", "COMMA", "SOLIDUS", "AT_SIGN", "ASSIGN_OP", "BINDVAR", "NOT_EQUAL_OP", 
		"CARRET_OPERATOR_PART", "TILDE_OPERATOR_PART", "EXCLAMATION_OPERATOR_PART", 
		"GREATER_THAN_OP", "LESS_THAN_OP", "COLON", "SEMICOLON", "BAR", "EQUALS_OP", 
		"LEFT_BRACKET", "RIGHT_BRACKET", "BIND_VAR", "INTRODUCER", "SPACES", "SINGLE_LINE_COMMENT", 
		"MULTI_LINE_COMMENT", "PROMPT", "START_CMD", "REGULAR_ID", "ZV"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "PlSqlParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static PlSqlParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public PlSqlParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public PlSqlParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class Sql_scriptContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(PlSqlParser.Eof, 0); }
		public Unit_statementContext[] unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Sql_plus_commandContext[] sql_plus_command() {
			return GetRuleContexts<Sql_plus_commandContext>();
		}
		public Sql_plus_commandContext sql_plus_command(int i) {
			return GetRuleContext<Sql_plus_commandContext>(i);
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(PlSqlParser.SEMICOLON); }
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(PlSqlParser.SEMICOLON, i);
		}
		public Sql_scriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_script; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_script(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_scriptContext sql_script() {
		Sql_scriptContext _localctx = new Sql_scriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_sql_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1203;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECLARE - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DROP - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GRANT - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSERT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOCK - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELECT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPDATE - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WITH - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (COMMA - 711)) | (1L << (SOLIDUS - 711)))) != 0) || ((((_la - 780)) & ~0x3f) == 0 && ((1L << (_la - 780)) & ((1L << (PROMPT - 780)) | (1L << (START_CMD - 780)) | (1L << (REGULAR_ID - 780)))) != 0)) {
				{
				{
				State = 1196;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
				case 1:
					{
					State = 1194; unit_statement();
					}
					break;
				case 2:
					{
					State = 1195; sql_plus_command();
					}
					break;
				}
				State = 1199;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEMICOLON) {
					{
					State = 1198; Match(SEMICOLON);
					}
				}

				}
				}
				State = 1205;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1206; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unit_statementContext : ParserRuleContext {
		public Transaction_control_statementsContext transaction_control_statements() {
			return GetRuleContext<Transaction_control_statementsContext>(0);
		}
		public Alter_functionContext alter_function() {
			return GetRuleContext<Alter_functionContext>(0);
		}
		public Alter_packageContext alter_package() {
			return GetRuleContext<Alter_packageContext>(0);
		}
		public Alter_procedureContext alter_procedure() {
			return GetRuleContext<Alter_procedureContext>(0);
		}
		public Alter_sequenceContext alter_sequence() {
			return GetRuleContext<Alter_sequenceContext>(0);
		}
		public Alter_triggerContext alter_trigger() {
			return GetRuleContext<Alter_triggerContext>(0);
		}
		public Alter_typeContext alter_type() {
			return GetRuleContext<Alter_typeContext>(0);
		}
		public Alter_tableContext alter_table() {
			return GetRuleContext<Alter_tableContext>(0);
		}
		public Alter_indexContext alter_index() {
			return GetRuleContext<Alter_indexContext>(0);
		}
		public Alter_userContext alter_user() {
			return GetRuleContext<Alter_userContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_packageContext create_package() {
			return GetRuleContext<Create_packageContext>(0);
		}
		public Create_package_bodyContext create_package_body() {
			return GetRuleContext<Create_package_bodyContext>(0);
		}
		public Create_indexContext create_index() {
			return GetRuleContext<Create_indexContext>(0);
		}
		public Create_tableContext create_table() {
			return GetRuleContext<Create_tableContext>(0);
		}
		public Create_tablespaceContext create_tablespace() {
			return GetRuleContext<Create_tablespaceContext>(0);
		}
		public Create_userContext create_user() {
			return GetRuleContext<Create_userContext>(0);
		}
		public Create_sequenceContext create_sequence() {
			return GetRuleContext<Create_sequenceContext>(0);
		}
		public Create_triggerContext create_trigger() {
			return GetRuleContext<Create_triggerContext>(0);
		}
		public Create_typeContext create_type() {
			return GetRuleContext<Create_typeContext>(0);
		}
		public Create_synonymContext create_synonym() {
			return GetRuleContext<Create_synonymContext>(0);
		}
		public Drop_functionContext drop_function() {
			return GetRuleContext<Drop_functionContext>(0);
		}
		public Drop_packageContext drop_package() {
			return GetRuleContext<Drop_packageContext>(0);
		}
		public Drop_procedureContext drop_procedure() {
			return GetRuleContext<Drop_procedureContext>(0);
		}
		public Drop_sequenceContext drop_sequence() {
			return GetRuleContext<Drop_sequenceContext>(0);
		}
		public Drop_triggerContext drop_trigger() {
			return GetRuleContext<Drop_triggerContext>(0);
		}
		public Drop_typeContext drop_type() {
			return GetRuleContext<Drop_typeContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Drop_tableContext drop_table() {
			return GetRuleContext<Drop_tableContext>(0);
		}
		public Drop_indexContext drop_index() {
			return GetRuleContext<Drop_indexContext>(0);
		}
		public Comment_on_columnContext comment_on_column() {
			return GetRuleContext<Comment_on_columnContext>(0);
		}
		public Comment_on_tableContext comment_on_table() {
			return GetRuleContext<Comment_on_tableContext>(0);
		}
		public Anonymous_blockContext anonymous_block() {
			return GetRuleContext<Anonymous_blockContext>(0);
		}
		public Grant_statementContext grant_statement() {
			return GetRuleContext<Grant_statementContext>(0);
		}
		public Revoke_statmentContext revoke_statment() {
			return GetRuleContext<Revoke_statmentContext>(0);
		}
		public Unit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unit_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unit_statementContext unit_statement() {
		Unit_statementContext _localctx = new Unit_statementContext(Context, State);
		EnterRule(_localctx, 2, RULE_unit_statement);
		try {
			State = 1244;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1208; transaction_control_statements();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1209; alter_function();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1210; alter_package();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1211; alter_procedure();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1212; alter_sequence();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1213; alter_trigger();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1214; alter_type();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1215; alter_table();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1216; alter_index();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1217; alter_user();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1218; create_function_body();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1219; create_procedure_body();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1220; create_package();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 1221; create_package_body();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 1222; create_index();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 1223; create_table();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 1224; create_tablespace();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 1225; create_user();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 1226; create_sequence();
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 1227; create_trigger();
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 1228; create_type();
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 1229; create_synonym();
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 1230; drop_function();
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 1231; drop_package();
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 1232; drop_procedure();
				}
				break;
			case 26:
				EnterOuterAlt(_localctx, 26);
				{
				State = 1233; drop_sequence();
				}
				break;
			case 27:
				EnterOuterAlt(_localctx, 27);
				{
				State = 1234; drop_trigger();
				}
				break;
			case 28:
				EnterOuterAlt(_localctx, 28);
				{
				State = 1235; drop_type();
				}
				break;
			case 29:
				EnterOuterAlt(_localctx, 29);
				{
				State = 1236; data_manipulation_language_statements();
				}
				break;
			case 30:
				EnterOuterAlt(_localctx, 30);
				{
				State = 1237; drop_table();
				}
				break;
			case 31:
				EnterOuterAlt(_localctx, 31);
				{
				State = 1238; drop_index();
				}
				break;
			case 32:
				EnterOuterAlt(_localctx, 32);
				{
				State = 1239; comment_on_column();
				}
				break;
			case 33:
				EnterOuterAlt(_localctx, 33);
				{
				State = 1240; comment_on_table();
				}
				break;
			case 34:
				EnterOuterAlt(_localctx, 34);
				{
				State = 1241; anonymous_block();
				}
				break;
			case 35:
				EnterOuterAlt(_localctx, 35);
				{
				State = 1242; grant_statement();
				}
				break;
			case 36:
				EnterOuterAlt(_localctx, 36);
				{
				State = 1243; revoke_statment();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_functionContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public Drop_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_functionContext drop_function() {
		Drop_functionContext _localctx = new Drop_functionContext(Context, State);
		EnterRule(_localctx, 4, RULE_drop_function);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1246; Match(DROP);
			State = 1247; Match(FUNCTION);
			State = 1248; function_name();
			State = 1249; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_functionContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public Alter_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_functionContext alter_function() {
		Alter_functionContext _localctx = new Alter_functionContext(Context, State);
		EnterRule(_localctx, 6, RULE_alter_function);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1251; Match(ALTER);
			State = 1252; Match(FUNCTION);
			State = 1253; function_name();
			State = 1254; Match(COMPILE);
			State = 1256;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 1255; Match(DEBUG);
				}
				break;
			}
			State = 1261;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1258; compiler_parameters_clause();
					}
					} 
				}
				State = 1263;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			State = 1266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 1264; Match(REUSE);
				State = 1265; Match(SETTINGS);
				}
			}

			State = 1268; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_function_bodyContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Implementation_type_nameContext implementation_type_name() {
			return GetRuleContext<Implementation_type_nameContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Invoker_rights_clauseContext[] invoker_rights_clause() {
			return GetRuleContexts<Invoker_rights_clauseContext>();
		}
		public Invoker_rights_clauseContext invoker_rights_clause(int i) {
			return GetRuleContext<Invoker_rights_clauseContext>(i);
		}
		public Parallel_enable_clauseContext[] parallel_enable_clause() {
			return GetRuleContexts<Parallel_enable_clauseContext>();
		}
		public Parallel_enable_clauseContext parallel_enable_clause(int i) {
			return GetRuleContext<Parallel_enable_clauseContext>(i);
		}
		public Result_cache_clauseContext[] result_cache_clause() {
			return GetRuleContexts<Result_cache_clauseContext>();
		}
		public Result_cache_clauseContext result_cache_clause(int i) {
			return GetRuleContext<Result_cache_clauseContext>(i);
		}
		public ITerminalNode[] DETERMINISTIC() { return GetTokens(PlSqlParser.DETERMINISTIC); }
		public ITerminalNode DETERMINISTIC(int i) {
			return GetToken(PlSqlParser.DETERMINISTIC, i);
		}
		public ITerminalNode PIPELINED() { return GetToken(PlSqlParser.PIPELINED, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(PlSqlParser.AGGREGATE, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public Create_function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_function_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_function_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_function_bodyContext create_function_body() {
		Create_function_bodyContext _localctx = new Create_function_bodyContext(Context, State);
		EnterRule(_localctx, 8, RULE_create_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1270; Match(CREATE);
			State = 1273;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1271; Match(OR);
				State = 1272; Match(REPLACE);
				}
			}

			State = 1275; Match(FUNCTION);
			State = 1276; function_name();
			State = 1288;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1277; Match(LEFT_PAREN);
				State = 1282;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 1279;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 1278; Match(COMMA);
						}
					}

					State = 1281; parameter();
					}
					}
					State = 1284;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				State = 1286; Match(RIGHT_PAREN);
				}
			}

			State = 1290; Match(RETURN);
			State = 1291; type_spec();
			State = 1298;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AUTHID || _la==DETERMINISTIC || _la==PARALLEL_ENABLE || _la==RESULT_CACHE) {
				{
				State = 1296;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AUTHID:
					{
					State = 1292; invoker_rights_clause();
					}
					break;
				case PARALLEL_ENABLE:
					{
					State = 1293; parallel_enable_clause();
					}
					break;
				case RESULT_CACHE:
					{
					State = 1294; result_cache_clause();
					}
					break;
				case DETERMINISTIC:
					{
					State = 1295; Match(DETERMINISTIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 1300;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1318;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				{
				{
				State = 1302;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PIPELINED) {
					{
					State = 1301; Match(PIPELINED);
					}
				}

				State = 1304;
				_la = TokenStream.LA(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1313;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
				case 1:
					{
					State = 1306;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DECLARE) {
						{
						State = 1305; Match(DECLARE);
						}
					}

					State = 1309;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 1308; seq_of_declare_specs();
						}
					}

					State = 1311; body();
					}
					break;
				case 2:
					{
					State = 1312; call_spec();
					}
					break;
				}
				}
				}
				break;
			case 2:
				{
				State = 1315;
				_la = TokenStream.LA(1);
				if ( !(_la==AGGREGATE || _la==PIPELINED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1316; Match(USING);
				State = 1317; implementation_type_name();
				}
				break;
			}
			State = 1320; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parallel_enable_clauseContext : ParserRuleContext {
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(PlSqlParser.PARALLEL_ENABLE, 0); }
		public Partition_by_clauseContext partition_by_clause() {
			return GetRuleContext<Partition_by_clauseContext>(0);
		}
		public Parallel_enable_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallel_enable_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParallel_enable_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parallel_enable_clauseContext parallel_enable_clause() {
		Parallel_enable_clauseContext _localctx = new Parallel_enable_clauseContext(Context, State);
		EnterRule(_localctx, 10, RULE_parallel_enable_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1322; Match(PARALLEL_ENABLE);
			State = 1324;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1323; partition_by_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_by_clauseContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode ANY() { return GetToken(PlSqlParser.ANY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public ITerminalNode LIST() { return GetToken(PlSqlParser.LIST, 0); }
		public Streaming_clauseContext streaming_clause() {
			return GetRuleContext<Streaming_clauseContext>(0);
		}
		public Partition_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_by_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_by_clauseContext partition_by_clause() {
		Partition_by_clauseContext _localctx = new Partition_by_clauseContext(Context, State);
		EnterRule(_localctx, 12, RULE_partition_by_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1326; Match(LEFT_PAREN);
			State = 1327; Match(PARTITION);
			State = 1328; expression();
			State = 1329; Match(BY);
			State = 1333;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ANY:
				{
				State = 1330; Match(ANY);
				}
				break;
			case HASH:
			case LIST:
			case RANGE:
				{
				State = 1331;
				_la = TokenStream.LA(1);
				if ( !(_la==HASH || _la==LIST || _la==RANGE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1332; paren_column_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1336;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CLUSTER || _la==ORDER) {
				{
				State = 1335; streaming_clause();
				}
			}

			State = 1338; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Result_cache_clauseContext : ParserRuleContext {
		public ITerminalNode RESULT_CACHE() { return GetToken(PlSqlParser.RESULT_CACHE, 0); }
		public Relies_on_partContext relies_on_part() {
			return GetRuleContext<Relies_on_partContext>(0);
		}
		public Result_cache_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_result_cache_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResult_cache_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Result_cache_clauseContext result_cache_clause() {
		Result_cache_clauseContext _localctx = new Result_cache_clauseContext(Context, State);
		EnterRule(_localctx, 14, RULE_result_cache_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1340; Match(RESULT_CACHE);
			State = 1342;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RELIES_ON) {
				{
				State = 1341; relies_on_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relies_on_partContext : ParserRuleContext {
		public ITerminalNode RELIES_ON() { return GetToken(PlSqlParser.RELIES_ON, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Tableview_nameContext[] tableview_name() {
			return GetRuleContexts<Tableview_nameContext>();
		}
		public Tableview_nameContext tableview_name(int i) {
			return GetRuleContext<Tableview_nameContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Relies_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relies_on_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelies_on_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relies_on_partContext relies_on_part() {
		Relies_on_partContext _localctx = new Relies_on_partContext(Context, State);
		EnterRule(_localctx, 16, RULE_relies_on_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1344; Match(RELIES_ON);
			State = 1345; Match(LEFT_PAREN);
			State = 1346; tableview_name();
			State = 1351;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1347; Match(COMMA);
				State = 1348; tableview_name();
				}
				}
				State = 1353;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1354; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Streaming_clauseContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode CLUSTER() { return GetToken(PlSqlParser.CLUSTER, 0); }
		public Streaming_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streaming_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreaming_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Streaming_clauseContext streaming_clause() {
		Streaming_clauseContext _localctx = new Streaming_clauseContext(Context, State);
		EnterRule(_localctx, 18, RULE_streaming_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1356;
			_la = TokenStream.LA(1);
			if ( !(_la==CLUSTER || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1357; expression();
			State = 1358; Match(BY);
			State = 1359; paren_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_packageContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Schema_object_nameContext schema_object_name() {
			return GetRuleContext<Schema_object_nameContext>(0);
		}
		public Drop_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_package; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_packageContext drop_package() {
		Drop_packageContext _localctx = new Drop_packageContext(Context, State);
		EnterRule(_localctx, 20, RULE_drop_package);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1361; Match(DROP);
			State = 1362; Match(PACKAGE);
			State = 1364;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 1363; Match(BODY);
				}
				break;
			}
			State = 1369;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,24,Context) ) {
			case 1:
				{
				State = 1366; schema_object_name();
				State = 1367; Match(PERIOD);
				}
				break;
			}
			State = 1371; package_name();
			State = 1372; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_packageContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode[] PACKAGE() { return GetTokens(PlSqlParser.PACKAGE); }
		public ITerminalNode PACKAGE(int i) {
			return GetToken(PlSqlParser.PACKAGE, i);
		}
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(PlSqlParser.SPECIFICATION, 0); }
		public Alter_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_package; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_packageContext alter_package() {
		Alter_packageContext _localctx = new Alter_packageContext(Context, State);
		EnterRule(_localctx, 22, RULE_alter_package);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1374; Match(ALTER);
			State = 1375; Match(PACKAGE);
			State = 1376; package_name();
			State = 1377; Match(COMPILE);
			State = 1379;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				{
				State = 1378; Match(DEBUG);
				}
				break;
			}
			State = 1382;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				{
				State = 1381;
				_la = TokenStream.LA(1);
				if ( !(_la==BODY || _la==PACKAGE || _la==SPECIFICATION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 1387;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,27,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1384; compiler_parameters_clause();
					}
					} 
				}
				State = 1389;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,27,Context);
			}
			State = 1392;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 1390; Match(REUSE);
				State = 1391; Match(SETTINGS);
				}
			}

			State = 1394; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_packageContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public Package_nameContext[] package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Schema_object_nameContext schema_object_name() {
			return GetRuleContext<Schema_object_nameContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Package_obj_specContext[] package_obj_spec() {
			return GetRuleContexts<Package_obj_specContext>();
		}
		public Package_obj_specContext package_obj_spec(int i) {
			return GetRuleContext<Package_obj_specContext>(i);
		}
		public Create_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_package; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_packageContext create_package() {
		Create_packageContext _localctx = new Create_packageContext(Context, State);
		EnterRule(_localctx, 24, RULE_create_package);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1396; Match(CREATE);
			State = 1399;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1397; Match(OR);
				State = 1398; Match(REPLACE);
				}
			}

			State = 1401; Match(PACKAGE);
			State = 1405;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				{
				State = 1402; schema_object_name();
				State = 1403; Match(PERIOD);
				}
				break;
			}
			State = 1407; package_name();
			State = 1409;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTHID) {
				{
				State = 1408; invoker_rights_clause();
				}
			}

			State = 1411;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1415;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 1412; package_obj_spec();
				}
				}
				State = 1417;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1418; Match(END);
			State = 1420;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 1419; package_name();
				}
			}

			State = 1422; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_package_bodyContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Package_nameContext[] package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Schema_object_nameContext schema_object_name() {
			return GetRuleContext<Schema_object_nameContext>(0);
		}
		public Package_obj_bodyContext[] package_obj_body() {
			return GetRuleContexts<Package_obj_bodyContext>();
		}
		public Package_obj_bodyContext package_obj_body(int i) {
			return GetRuleContext<Package_obj_bodyContext>(i);
		}
		public ITerminalNode BEGIN() { return GetToken(PlSqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Create_package_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_package_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_package_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_package_bodyContext create_package_body() {
		Create_package_bodyContext _localctx = new Create_package_bodyContext(Context, State);
		EnterRule(_localctx, 26, RULE_create_package_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1424; Match(CREATE);
			State = 1427;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1425; Match(OR);
				State = 1426; Match(REPLACE);
				}
			}

			State = 1429; Match(PACKAGE);
			State = 1430; Match(BODY);
			State = 1434;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
			case 1:
				{
				State = 1431; schema_object_name();
				State = 1432; Match(PERIOD);
				}
				break;
			}
			State = 1436; package_name();
			State = 1437;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1441;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 1438; package_obj_body();
				}
				}
				State = 1443;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1446;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BEGIN) {
				{
				State = 1444; Match(BEGIN);
				State = 1445; seq_of_statements();
				}
			}

			State = 1448; Match(END);
			State = 1450;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 1449; package_name();
				}
			}

			State = 1452; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_specContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Package_obj_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_obj_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_specContext package_obj_spec() {
		Package_obj_specContext _localctx = new Package_obj_specContext(Context, State);
		EnterRule(_localctx, 28, RULE_package_obj_spec);
		try {
			State = 1462;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1454; variable_declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1455; subtype_declaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1456; cursor_declaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1457; exception_declaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1458; pragma_declaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1459; type_declaration();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1460; procedure_spec();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1461; function_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_specContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_specContext procedure_spec() {
		Procedure_specContext _localctx = new Procedure_specContext(Context, State);
		EnterRule(_localctx, 30, RULE_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1464; Match(PROCEDURE);
			State = 1465; identifier();
			State = 1477;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1466; Match(LEFT_PAREN);
				State = 1467; parameter();
				State = 1472;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1468; Match(COMMA);
					State = 1469; parameter();
					}
					}
					State = 1474;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1475; Match(RIGHT_PAREN);
				}
			}

			State = 1479; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_specContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode DETERMINISTIC() { return GetToken(PlSqlParser.DETERMINISTIC, 0); }
		public ITerminalNode RESULT_CACHE() { return GetToken(PlSqlParser.RESULT_CACHE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_specContext function_spec() {
		Function_specContext _localctx = new Function_specContext(Context, State);
		EnterRule(_localctx, 32, RULE_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1481; Match(FUNCTION);
			State = 1482; identifier();
			State = 1494;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1483; Match(LEFT_PAREN);
				State = 1484; parameter();
				State = 1489;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1485; Match(COMMA);
					State = 1486; parameter();
					}
					}
					State = 1491;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1492; Match(RIGHT_PAREN);
				}
			}

			State = 1496; Match(RETURN);
			State = 1497; type_spec();
			State = 1499;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DETERMINISTIC) {
				{
				State = 1498; Match(DETERMINISTIC);
				}
			}

			State = 1502;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RESULT_CACHE) {
				{
				State = 1501; Match(RESULT_CACHE);
				}
			}

			State = 1504; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_bodyContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public Procedure_bodyContext procedure_body() {
			return GetRuleContext<Procedure_bodyContext>(0);
		}
		public Function_bodyContext function_body() {
			return GetRuleContext<Function_bodyContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Package_obj_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_obj_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_bodyContext package_obj_body() {
		Package_obj_bodyContext _localctx = new Package_obj_bodyContext(Context, State);
		EnterRule(_localctx, 34, RULE_package_obj_body);
		try {
			State = 1515;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1506; variable_declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1507; subtype_declaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1508; cursor_declaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1509; exception_declaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1510; type_declaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1511; procedure_body();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1512; function_body();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1513; procedure_spec();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1514; function_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_procedureContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Drop_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_procedure; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_procedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_procedureContext drop_procedure() {
		Drop_procedureContext _localctx = new Drop_procedureContext(Context, State);
		EnterRule(_localctx, 36, RULE_drop_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1517; Match(DROP);
			State = 1518; Match(PROCEDURE);
			State = 1519; procedure_name();
			State = 1520; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_procedureContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public Alter_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_procedure; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_procedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_procedureContext alter_procedure() {
		Alter_procedureContext _localctx = new Alter_procedureContext(Context, State);
		EnterRule(_localctx, 38, RULE_alter_procedure);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1522; Match(ALTER);
			State = 1523; Match(PROCEDURE);
			State = 1524; procedure_name();
			State = 1525; Match(COMPILE);
			State = 1527;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				{
				State = 1526; Match(DEBUG);
				}
				break;
			}
			State = 1532;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,48,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1529; compiler_parameters_clause();
					}
					} 
				}
				State = 1534;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,48,Context);
			}
			State = 1537;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 1535; Match(REUSE);
				State = 1536; Match(SETTINGS);
				}
			}

			State = 1539; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_bodyContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Implementation_type_nameContext implementation_type_name() {
			return GetRuleContext<Implementation_type_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Invoker_rights_clauseContext[] invoker_rights_clause() {
			return GetRuleContexts<Invoker_rights_clauseContext>();
		}
		public Invoker_rights_clauseContext invoker_rights_clause(int i) {
			return GetRuleContext<Invoker_rights_clauseContext>(i);
		}
		public Parallel_enable_clauseContext[] parallel_enable_clause() {
			return GetRuleContexts<Parallel_enable_clauseContext>();
		}
		public Parallel_enable_clauseContext parallel_enable_clause(int i) {
			return GetRuleContext<Parallel_enable_clauseContext>(i);
		}
		public Result_cache_clauseContext[] result_cache_clause() {
			return GetRuleContexts<Result_cache_clauseContext>();
		}
		public Result_cache_clauseContext result_cache_clause(int i) {
			return GetRuleContext<Result_cache_clauseContext>(i);
		}
		public ITerminalNode[] DETERMINISTIC() { return GetTokens(PlSqlParser.DETERMINISTIC); }
		public ITerminalNode DETERMINISTIC(int i) {
			return GetToken(PlSqlParser.DETERMINISTIC, i);
		}
		public ITerminalNode PIPELINED() { return GetToken(PlSqlParser.PIPELINED, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(PlSqlParser.AGGREGATE, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public Function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_bodyContext function_body() {
		Function_bodyContext _localctx = new Function_bodyContext(Context, State);
		EnterRule(_localctx, 40, RULE_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1541; Match(FUNCTION);
			State = 1542; function_name();
			State = 1554;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1543; Match(LEFT_PAREN);
				State = 1544; parameter();
				State = 1549;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1545; Match(COMMA);
					State = 1546; parameter();
					}
					}
					State = 1551;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1552; Match(RIGHT_PAREN);
				}
			}

			State = 1556; Match(RETURN);
			State = 1557; type_spec();
			State = 1564;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AUTHID || _la==DETERMINISTIC || _la==PARALLEL_ENABLE || _la==RESULT_CACHE) {
				{
				State = 1562;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AUTHID:
					{
					State = 1558; invoker_rights_clause();
					}
					break;
				case PARALLEL_ENABLE:
					{
					State = 1559; parallel_enable_clause();
					}
					break;
				case RESULT_CACHE:
					{
					State = 1560; result_cache_clause();
					}
					break;
				case DETERMINISTIC:
					{
					State = 1561; Match(DETERMINISTIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 1566;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1584;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
			case 1:
				{
				{
				State = 1568;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PIPELINED) {
					{
					State = 1567; Match(PIPELINED);
					}
				}

				State = 1570;
				_la = TokenStream.LA(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1579;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
				case 1:
					{
					State = 1572;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DECLARE) {
						{
						State = 1571; Match(DECLARE);
						}
					}

					State = 1575;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 1574; seq_of_declare_specs();
						}
					}

					State = 1577; body();
					}
					break;
				case 2:
					{
					State = 1578; call_spec();
					}
					break;
				}
				}
				}
				break;
			case 2:
				{
				State = 1581;
				_la = TokenStream.LA(1);
				if ( !(_la==AGGREGATE || _la==PIPELINED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1582; Match(USING);
				State = 1583; implementation_type_name();
				}
				break;
			}
			State = 1586; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_bodyContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Procedure_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_bodyContext procedure_body() {
		Procedure_bodyContext _localctx = new Procedure_bodyContext(Context, State);
		EnterRule(_localctx, 42, RULE_procedure_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1588; Match(PROCEDURE);
			State = 1589; procedure_name();
			State = 1601;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1590; Match(LEFT_PAREN);
				State = 1591; parameter();
				State = 1596;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1592; Match(COMMA);
					State = 1593; parameter();
					}
					}
					State = 1598;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1599; Match(RIGHT_PAREN);
				}
			}

			State = 1603;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1613;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,63,Context) ) {
			case 1:
				{
				State = 1605;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DECLARE) {
					{
					State = 1604; Match(DECLARE);
					}
				}

				State = 1608;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 1607; seq_of_declare_specs();
					}
				}

				State = 1610; body();
				}
				break;
			case 2:
				{
				State = 1611; call_spec();
				}
				break;
			case 3:
				{
				State = 1612; Match(EXTERNAL);
				}
				break;
			}
			State = 1615; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_procedure_bodyContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Create_procedure_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_procedure_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_procedure_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_procedure_bodyContext create_procedure_body() {
		Create_procedure_bodyContext _localctx = new Create_procedure_bodyContext(Context, State);
		EnterRule(_localctx, 44, RULE_create_procedure_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1617; Match(CREATE);
			State = 1620;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1618; Match(OR);
				State = 1619; Match(REPLACE);
				}
			}

			State = 1622; Match(PROCEDURE);
			State = 1623; procedure_name();
			State = 1635;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1624; Match(LEFT_PAREN);
				State = 1625; parameter();
				State = 1630;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1626; Match(COMMA);
					State = 1627; parameter();
					}
					}
					State = 1632;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1633; Match(RIGHT_PAREN);
				}
			}

			State = 1638;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTHID) {
				{
				State = 1637; invoker_rights_clause();
				}
			}

			State = 1640;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1650;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,70,Context) ) {
			case 1:
				{
				State = 1642;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DECLARE) {
					{
					State = 1641; Match(DECLARE);
					}
				}

				State = 1645;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 1644; seq_of_declare_specs();
					}
				}

				State = 1647; body();
				}
				break;
			case 2:
				{
				State = 1648; call_spec();
				}
				break;
			case 3:
				{
				State = 1649; Match(EXTERNAL);
				}
				break;
			}
			State = 1652; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_triggerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Drop_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_trigger; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_triggerContext drop_trigger() {
		Drop_triggerContext _localctx = new Drop_triggerContext(Context, State);
		EnterRule(_localctx, 46, RULE_drop_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1654; Match(DROP);
			State = 1655; Match(TRIGGER);
			State = 1656; trigger_name();
			State = 1657; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_triggerContext : ParserRuleContext {
		public Trigger_nameContext alter_trigger_name;
		public Trigger_nameContext rename_trigger_name;
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public Trigger_nameContext[] trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public Alter_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_trigger; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_triggerContext alter_trigger() {
		Alter_triggerContext _localctx = new Alter_triggerContext(Context, State);
		EnterRule(_localctx, 48, RULE_alter_trigger);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1659; Match(ALTER);
			State = 1660; Match(TRIGGER);
			State = 1661; _localctx.alter_trigger_name = trigger_name();
			State = 1680;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DISABLE:
			case ENABLE:
				{
				State = 1662;
				_la = TokenStream.LA(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case RENAME:
				{
				State = 1663; Match(RENAME);
				State = 1664; Match(TO);
				State = 1665; _localctx.rename_trigger_name = trigger_name();
				}
				break;
			case COMPILE:
				{
				State = 1666; Match(COMPILE);
				State = 1668;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,71,Context) ) {
				case 1:
					{
					State = 1667; Match(DEBUG);
					}
					break;
				}
				State = 1673;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,72,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1670; compiler_parameters_clause();
						}
						} 
					}
					State = 1675;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,72,Context);
				}
				State = 1678;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==REUSE) {
					{
					State = 1676; Match(REUSE);
					State = 1677; Match(SETTINGS);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1682; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_triggerContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Trigger_bodyContext trigger_body() {
			return GetRuleContext<Trigger_bodyContext>(0);
		}
		public Simple_dml_triggerContext simple_dml_trigger() {
			return GetRuleContext<Simple_dml_triggerContext>(0);
		}
		public Compound_dml_triggerContext compound_dml_trigger() {
			return GetRuleContext<Compound_dml_triggerContext>(0);
		}
		public Non_dml_triggerContext non_dml_trigger() {
			return GetRuleContext<Non_dml_triggerContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Trigger_follows_clauseContext trigger_follows_clause() {
			return GetRuleContext<Trigger_follows_clauseContext>(0);
		}
		public Trigger_when_clauseContext trigger_when_clause() {
			return GetRuleContext<Trigger_when_clauseContext>(0);
		}
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public Create_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_trigger; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_triggerContext create_trigger() {
		Create_triggerContext _localctx = new Create_triggerContext(Context, State);
		EnterRule(_localctx, 50, RULE_create_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1684; Match(CREATE);
			State = 1687;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1685; Match(OR);
				State = 1686; Match(REPLACE);
				}
			}

			State = 1689; Match(TRIGGER);
			State = 1690; trigger_name();
			State = 1694;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,76,Context) ) {
			case 1:
				{
				State = 1691; simple_dml_trigger();
				}
				break;
			case 2:
				{
				State = 1692; compound_dml_trigger();
				}
				break;
			case 3:
				{
				State = 1693; non_dml_trigger();
				}
				break;
			}
			State = 1697;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,77,Context) ) {
			case 1:
				{
				State = 1696; trigger_follows_clause();
				}
				break;
			}
			State = 1700;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,78,Context) ) {
			case 1:
				{
				State = 1699;
				_la = TokenStream.LA(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 1703;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 1702; trigger_when_clause();
				}
			}

			State = 1705; trigger_body();
			State = 1706; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_follows_clauseContext : ParserRuleContext {
		public ITerminalNode FOLLOWS() { return GetToken(PlSqlParser.FOLLOWS, 0); }
		public Trigger_nameContext[] trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Trigger_follows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_follows_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_follows_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_follows_clauseContext trigger_follows_clause() {
		Trigger_follows_clauseContext _localctx = new Trigger_follows_clauseContext(Context, State);
		EnterRule(_localctx, 52, RULE_trigger_follows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1708; Match(FOLLOWS);
			State = 1709; trigger_name();
			State = 1714;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1710; Match(COMMA);
				State = 1711; trigger_name();
				}
				}
				State = 1716;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_when_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Trigger_when_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_when_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_when_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_when_clauseContext trigger_when_clause() {
		Trigger_when_clauseContext _localctx = new Trigger_when_clauseContext(Context, State);
		EnterRule(_localctx, 54, RULE_trigger_when_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1717; Match(WHEN);
			State = 1718; Match(LEFT_PAREN);
			State = 1719; condition();
			State = 1720; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_dml_triggerContext : ParserRuleContext {
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public ITerminalNode INSTEAD() { return GetToken(PlSqlParser.INSTEAD, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public For_each_rowContext for_each_row() {
			return GetRuleContext<For_each_rowContext>(0);
		}
		public Simple_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_dml_trigger; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_dml_triggerContext simple_dml_trigger() {
		Simple_dml_triggerContext _localctx = new Simple_dml_triggerContext(Context, State);
		EnterRule(_localctx, 56, RULE_simple_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1726;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BEFORE:
				{
				State = 1722; Match(BEFORE);
				}
				break;
			case AFTER:
				{
				State = 1723; Match(AFTER);
				}
				break;
			case INSTEAD:
				{
				State = 1724; Match(INSTEAD);
				State = 1725; Match(OF);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1728; dml_event_clause();
			State = 1730;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,82,Context) ) {
			case 1:
				{
				State = 1729; referencing_clause();
				}
				break;
			}
			State = 1733;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 1732; for_each_row();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_each_rowContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode EACH() { return GetToken(PlSqlParser.EACH, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public For_each_rowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_each_row; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_each_row(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_each_rowContext for_each_row() {
		For_each_rowContext _localctx = new For_each_rowContext(Context, State);
		EnterRule(_localctx, 58, RULE_for_each_row);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1735; Match(FOR);
			State = 1736; Match(EACH);
			State = 1737; Match(ROW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_dml_triggerContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public Compound_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_dml_trigger; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_dml_triggerContext compound_dml_trigger() {
		Compound_dml_triggerContext _localctx = new Compound_dml_triggerContext(Context, State);
		EnterRule(_localctx, 60, RULE_compound_dml_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1739; Match(FOR);
			State = 1740; dml_event_clause();
			State = 1742;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,84,Context) ) {
			case 1:
				{
				State = 1741; referencing_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_triggerContext : ParserRuleContext {
		public Non_dml_eventContext[] non_dml_event() {
			return GetRuleContexts<Non_dml_eventContext>();
		}
		public Non_dml_eventContext non_dml_event(int i) {
			return GetRuleContext<Non_dml_eventContext>(i);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlSqlParser.SCHEMA, 0); }
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public Schema_nameContext schema_name() {
			return GetRuleContext<Schema_nameContext>(0);
		}
		public Non_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_trigger; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_triggerContext non_dml_trigger() {
		Non_dml_triggerContext _localctx = new Non_dml_triggerContext(Context, State);
		EnterRule(_localctx, 62, RULE_non_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1744;
			_la = TokenStream.LA(1);
			if ( !(_la==AFTER || _la==BEFORE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1745; non_dml_event();
			State = 1750;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 1746; Match(OR);
				State = 1747; non_dml_event();
				}
				}
				State = 1752;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1753; Match(ON);
			State = 1761;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,87,Context) ) {
			case 1:
				{
				State = 1754; Match(DATABASE);
				}
				break;
			case 2:
				{
				State = 1758;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,86,Context) ) {
				case 1:
					{
					State = 1755; schema_name();
					State = 1756; Match(PERIOD);
					}
					break;
				}
				State = 1760; Match(SCHEMA);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_bodyContext : ParserRuleContext {
		public ITerminalNode COMPOUND() { return GetToken(PlSqlParser.COMPOUND, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode CALL() { return GetToken(PlSqlParser.CALL, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public Trigger_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_bodyContext trigger_body() {
		Trigger_bodyContext _localctx = new Trigger_bodyContext(Context, State);
		EnterRule(_localctx, 64, RULE_trigger_body);
		try {
			State = 1768;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,88,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1763; Match(COMPOUND);
				State = 1764; Match(TRIGGER);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1765; Match(CALL);
				State = 1766; identifier();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1767; trigger_block();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_clauseContext : ParserRuleContext {
		public Function_argumentsContext function_arguments() {
			return GetRuleContext<Function_argumentsContext>(0);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Routine_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutine_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Routine_clauseContext routine_clause() {
		Routine_clauseContext _localctx = new Routine_clauseContext(Context, State);
		EnterRule(_localctx, 66, RULE_routine_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1771;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1770; function_arguments();
				}
			}

			State = 1774;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==KEEP) {
				{
				State = 1773; keep_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_trigger_blockContext : ParserRuleContext {
		public ITerminalNode COMPOUND() { return GetToken(PlSqlParser.COMPOUND, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public Timing_point_sectionContext[] timing_point_section() {
			return GetRuleContexts<Timing_point_sectionContext>();
		}
		public Timing_point_sectionContext timing_point_section(int i) {
			return GetRuleContext<Timing_point_sectionContext>(i);
		}
		public Compound_trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_trigger_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_trigger_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_trigger_blockContext compound_trigger_block() {
		Compound_trigger_blockContext _localctx = new Compound_trigger_blockContext(Context, State);
		EnterRule(_localctx, 68, RULE_compound_trigger_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1776; Match(COMPOUND);
			State = 1777; Match(TRIGGER);
			State = 1779;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,91,Context) ) {
			case 1:
				{
				State = 1778; seq_of_declare_specs();
				}
				break;
			}
			State = 1782;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1781; timing_point_section();
				}
				}
				State = 1784;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==AFTER || _la==BEFORE );
			State = 1786; Match(END);
			State = 1787; trigger_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Timing_point_sectionContext : ParserRuleContext {
		public IToken bk;
		public IToken ak;
		public ITerminalNode[] STATEMENT() { return GetTokens(PlSqlParser.STATEMENT); }
		public ITerminalNode STATEMENT(int i) {
			return GetToken(PlSqlParser.STATEMENT, i);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public ITerminalNode[] BEFORE() { return GetTokens(PlSqlParser.BEFORE); }
		public ITerminalNode BEFORE(int i) {
			return GetToken(PlSqlParser.BEFORE, i);
		}
		public ITerminalNode[] EACH() { return GetTokens(PlSqlParser.EACH); }
		public ITerminalNode EACH(int i) {
			return GetToken(PlSqlParser.EACH, i);
		}
		public ITerminalNode[] ROW() { return GetTokens(PlSqlParser.ROW); }
		public ITerminalNode ROW(int i) {
			return GetToken(PlSqlParser.ROW, i);
		}
		public ITerminalNode[] AFTER() { return GetTokens(PlSqlParser.AFTER); }
		public ITerminalNode AFTER(int i) {
			return GetToken(PlSqlParser.AFTER, i);
		}
		public Timing_point_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timing_point_section; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTiming_point_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Timing_point_sectionContext timing_point_section() {
		Timing_point_sectionContext _localctx = new Timing_point_sectionContext(Context, State);
		EnterRule(_localctx, 70, RULE_timing_point_section);
		try {
			State = 1825;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,93,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1789; _localctx.bk = Match(BEFORE);
				State = 1790; Match(STATEMENT);
				State = 1791; Match(IS);
				State = 1792; trigger_block();
				State = 1793; Match(BEFORE);
				State = 1794; Match(STATEMENT);
				State = 1795; Match(SEMICOLON);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1797; _localctx.bk = Match(BEFORE);
				State = 1798; Match(EACH);
				State = 1799; Match(ROW);
				State = 1800; Match(IS);
				State = 1801; trigger_block();
				State = 1802; Match(BEFORE);
				State = 1803; Match(EACH);
				State = 1804; Match(ROW);
				State = 1805; Match(SEMICOLON);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1807; _localctx.ak = Match(AFTER);
				State = 1808; Match(STATEMENT);
				State = 1809; Match(IS);
				State = 1810; trigger_block();
				State = 1811; Match(AFTER);
				State = 1812; Match(STATEMENT);
				State = 1813; Match(SEMICOLON);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1815; _localctx.ak = Match(AFTER);
				State = 1816; Match(EACH);
				State = 1817; Match(ROW);
				State = 1818; Match(IS);
				State = 1819; trigger_block();
				State = 1820; Match(AFTER);
				State = 1821; Match(EACH);
				State = 1822; Match(ROW);
				State = 1823; Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_eventContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlSqlParser.ANALYZE, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(PlSqlParser.ASSOCIATE, 0); }
		public ITerminalNode STATISTICS() { return GetToken(PlSqlParser.STATISTICS, 0); }
		public ITerminalNode AUDIT() { return GetToken(PlSqlParser.AUDIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(PlSqlParser.DISASSOCIATE, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode GRANT() { return GetToken(PlSqlParser.GRANT, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(PlSqlParser.NOAUDIT, 0); }
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode REVOKE() { return GetToken(PlSqlParser.REVOKE, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(PlSqlParser.TRUNCATE, 0); }
		public ITerminalNode DDL() { return GetToken(PlSqlParser.DDL, 0); }
		public ITerminalNode STARTUP() { return GetToken(PlSqlParser.STARTUP, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(PlSqlParser.SHUTDOWN, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(PlSqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode LOGON() { return GetToken(PlSqlParser.LOGON, 0); }
		public ITerminalNode LOGOFF() { return GetToken(PlSqlParser.LOGOFF, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(PlSqlParser.SERVERERROR, 0); }
		public ITerminalNode SUSPEND() { return GetToken(PlSqlParser.SUSPEND, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlSqlParser.SCHEMA, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(PlSqlParser.FOLLOWS, 0); }
		public Non_dml_eventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_event; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_dml_event(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_eventContext non_dml_event() {
		Non_dml_eventContext _localctx = new Non_dml_eventContext(Context, State);
		EnterRule(_localctx, 72, RULE_non_dml_event);
		try {
			State = 1853;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1827; Match(ALTER);
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1828; Match(ANALYZE);
				}
				break;
			case ASSOCIATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1829; Match(ASSOCIATE);
				State = 1830; Match(STATISTICS);
				}
				break;
			case AUDIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1831; Match(AUDIT);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1832; Match(COMMENT);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1833; Match(CREATE);
				}
				break;
			case DISASSOCIATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1834; Match(DISASSOCIATE);
				State = 1835; Match(STATISTICS);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1836; Match(DROP);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1837; Match(GRANT);
				}
				break;
			case NOAUDIT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1838; Match(NOAUDIT);
				}
				break;
			case RENAME:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1839; Match(RENAME);
				}
				break;
			case REVOKE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1840; Match(REVOKE);
				}
				break;
			case TRUNCATE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1841; Match(TRUNCATE);
				}
				break;
			case DDL:
				EnterOuterAlt(_localctx, 14);
				{
				State = 1842; Match(DDL);
				}
				break;
			case STARTUP:
				EnterOuterAlt(_localctx, 15);
				{
				State = 1843; Match(STARTUP);
				}
				break;
			case SHUTDOWN:
				EnterOuterAlt(_localctx, 16);
				{
				State = 1844; Match(SHUTDOWN);
				}
				break;
			case DB_ROLE_CHANGE:
				EnterOuterAlt(_localctx, 17);
				{
				State = 1845; Match(DB_ROLE_CHANGE);
				}
				break;
			case LOGON:
				EnterOuterAlt(_localctx, 18);
				{
				State = 1846; Match(LOGON);
				}
				break;
			case LOGOFF:
				EnterOuterAlt(_localctx, 19);
				{
				State = 1847; Match(LOGOFF);
				}
				break;
			case SERVERERROR:
				EnterOuterAlt(_localctx, 20);
				{
				State = 1848; Match(SERVERERROR);
				}
				break;
			case SUSPEND:
				EnterOuterAlt(_localctx, 21);
				{
				State = 1849; Match(SUSPEND);
				}
				break;
			case DATABASE:
				EnterOuterAlt(_localctx, 22);
				{
				State = 1850; Match(DATABASE);
				}
				break;
			case SCHEMA:
				EnterOuterAlt(_localctx, 23);
				{
				State = 1851; Match(SCHEMA);
				}
				break;
			case FOLLOWS:
				EnterOuterAlt(_localctx, 24);
				{
				State = 1852; Match(FOLLOWS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_clauseContext : ParserRuleContext {
		public Dml_event_elementContext[] dml_event_element() {
			return GetRuleContexts<Dml_event_elementContext>();
		}
		public Dml_event_elementContext dml_event_element(int i) {
			return GetRuleContext<Dml_event_elementContext>(i);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public Dml_event_nested_clauseContext dml_event_nested_clause() {
			return GetRuleContext<Dml_event_nested_clauseContext>(0);
		}
		public Dml_event_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_clauseContext dml_event_clause() {
		Dml_event_clauseContext _localctx = new Dml_event_clauseContext(Context, State);
		EnterRule(_localctx, 74, RULE_dml_event_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1855; dml_event_element();
			State = 1860;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 1856; Match(OR);
				State = 1857; dml_event_element();
				}
				}
				State = 1862;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1863; Match(ON);
			State = 1865;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,96,Context) ) {
			case 1:
				{
				State = 1864; dml_event_nested_clause();
				}
				break;
			}
			State = 1867; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_elementContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Column_listContext column_list() {
			return GetRuleContext<Column_listContext>(0);
		}
		public Dml_event_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_elementContext dml_event_element() {
		Dml_event_elementContext _localctx = new Dml_event_elementContext(Context, State);
		EnterRule(_localctx, 76, RULE_dml_event_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1869;
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1872;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 1870; Match(OF);
				State = 1871; column_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_nested_clauseContext : ParserRuleContext {
		public ITerminalNode NESTED() { return GetToken(PlSqlParser.NESTED, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Dml_event_nested_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_nested_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_nested_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_nested_clauseContext dml_event_nested_clause() {
		Dml_event_nested_clauseContext _localctx = new Dml_event_nested_clauseContext(Context, State);
		EnterRule(_localctx, 78, RULE_dml_event_nested_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1874; Match(NESTED);
			State = 1875; Match(TABLE);
			State = 1876; tableview_name();
			State = 1877; Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_clauseContext : ParserRuleContext {
		public ITerminalNode REFERENCING() { return GetToken(PlSqlParser.REFERENCING, 0); }
		public Referencing_elementContext[] referencing_element() {
			return GetRuleContexts<Referencing_elementContext>();
		}
		public Referencing_elementContext referencing_element(int i) {
			return GetRuleContext<Referencing_elementContext>(i);
		}
		public Referencing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferencing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_clauseContext referencing_clause() {
		Referencing_clauseContext _localctx = new Referencing_clauseContext(Context, State);
		EnterRule(_localctx, 80, RULE_referencing_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1879; Match(REFERENCING);
			State = 1881;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 1880; referencing_element();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1883;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,98,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_elementContext : ParserRuleContext {
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(PlSqlParser.NEW, 0); }
		public ITerminalNode OLD() { return GetToken(PlSqlParser.OLD, 0); }
		public ITerminalNode PARENT() { return GetToken(PlSqlParser.PARENT, 0); }
		public Referencing_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferencing_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_elementContext referencing_element() {
		Referencing_elementContext _localctx = new Referencing_elementContext(Context, State);
		EnterRule(_localctx, 82, RULE_referencing_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1885;
			_la = TokenStream.LA(1);
			if ( !(_la==NEW || _la==OLD || _la==PARENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1886; column_alias();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_typeContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode VALIDATE() { return GetToken(PlSqlParser.VALIDATE, 0); }
		public Drop_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_typeContext drop_type() {
		Drop_typeContext _localctx = new Drop_typeContext(Context, State);
		EnterRule(_localctx, 84, RULE_drop_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1888; Match(DROP);
			State = 1889; Match(TYPE);
			State = 1891;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,99,Context) ) {
			case 1:
				{
				State = 1890; Match(BODY);
				}
				break;
			}
			State = 1893; type_name();
			State = 1895;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE || _la==VALIDATE) {
				{
				State = 1894;
				_la = TokenStream.LA(1);
				if ( !(_la==FORCE || _la==VALIDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1897; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_typeContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public Compile_type_clauseContext compile_type_clause() {
			return GetRuleContext<Compile_type_clauseContext>(0);
		}
		public Replace_type_clauseContext replace_type_clause() {
			return GetRuleContext<Replace_type_clauseContext>(0);
		}
		public Alter_method_specContext alter_method_spec() {
			return GetRuleContext<Alter_method_specContext>(0);
		}
		public Alter_collection_clausesContext alter_collection_clauses() {
			return GetRuleContext<Alter_collection_clausesContext>(0);
		}
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Dependent_handling_clauseContext dependent_handling_clause() {
			return GetRuleContext<Dependent_handling_clauseContext>(0);
		}
		public Alter_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_typeContext alter_type() {
		Alter_typeContext _localctx = new Alter_typeContext(Context, State);
		EnterRule(_localctx, 86, RULE_alter_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1899; Match(ALTER);
			State = 1900; Match(TYPE);
			State = 1901; type_name();
			State = 1907;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPILE:
				{
				State = 1902; compile_type_clause();
				}
				break;
			case REPLACE:
				{
				State = 1903; replace_type_clause();
				}
				break;
			case ADD:
			case DROP:
				{
				State = 1904; alter_method_spec();
				}
				break;
			case MODIFY:
				{
				State = 1905; alter_collection_clauses();
				}
				break;
			case FINAL:
			case INSTANTIABLE:
			case NOT:
			case OVERRIDING:
				{
				State = 1906; modifier_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1910;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE || _la==INVALIDATE) {
				{
				State = 1909; dependent_handling_clause();
				}
			}

			State = 1912; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compile_type_clauseContext : ParserRuleContext {
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(PlSqlParser.SPECIFICATION, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Compile_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compile_type_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompile_type_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compile_type_clauseContext compile_type_clause() {
		Compile_type_clauseContext _localctx = new Compile_type_clauseContext(Context, State);
		EnterRule(_localctx, 88, RULE_compile_type_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1914; Match(COMPILE);
			State = 1916;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,103,Context) ) {
			case 1:
				{
				State = 1915; Match(DEBUG);
				}
				break;
			}
			State = 1919;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,104,Context) ) {
			case 1:
				{
				State = 1918;
				_la = TokenStream.LA(1);
				if ( !(_la==BODY || _la==SPECIFICATION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 1924;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,105,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1921; compiler_parameters_clause();
					}
					} 
				}
				State = 1926;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,105,Context);
			}
			State = 1929;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 1927; Match(REUSE);
				State = 1928; Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Replace_type_clauseContext : ParserRuleContext {
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Object_member_specContext[] object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Replace_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replace_type_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplace_type_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Replace_type_clauseContext replace_type_clause() {
		Replace_type_clauseContext _localctx = new Replace_type_clauseContext(Context, State);
		EnterRule(_localctx, 90, RULE_replace_type_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1931; Match(REPLACE);
			State = 1933;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTHID) {
				{
				State = 1932; invoker_rights_clause();
				}
			}

			State = 1935; Match(AS);
			State = 1936; Match(OBJECT);
			State = 1937; Match(LEFT_PAREN);
			State = 1938; object_member_spec();
			State = 1943;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1939; Match(COMMA);
				State = 1940; object_member_spec();
				}
				}
				State = 1945;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1946; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_specContext : ParserRuleContext {
		public Alter_method_elementContext[] alter_method_element() {
			return GetRuleContexts<Alter_method_elementContext>();
		}
		public Alter_method_elementContext alter_method_element(int i) {
			return GetRuleContext<Alter_method_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Alter_method_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_method_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_specContext alter_method_spec() {
		Alter_method_specContext _localctx = new Alter_method_specContext(Context, State);
		EnterRule(_localctx, 92, RULE_alter_method_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1948; alter_method_element();
			State = 1953;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1949; Match(COMMA);
				State = 1950; alter_method_element();
				}
				}
				State = 1955;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_elementContext : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Alter_method_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_method_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_elementContext alter_method_element() {
		Alter_method_elementContext _localctx = new Alter_method_elementContext(Context, State);
		EnterRule(_localctx, 94, RULE_alter_method_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1956;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==DROP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1959;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAP:
			case ORDER:
				{
				State = 1957; map_order_function_spec();
				}
				break;
			case MEMBER:
			case STATIC:
				{
				State = 1958; subprogram_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_attribute_definitionContext : ParserRuleContext {
		public ITerminalNode ATTRIBUTE() { return GetToken(PlSqlParser.ATTRIBUTE, 0); }
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode MODIFY() { return GetToken(PlSqlParser.MODIFY, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public Attribute_definitionContext[] attribute_definition() {
			return GetRuleContexts<Attribute_definitionContext>();
		}
		public Attribute_definitionContext attribute_definition(int i) {
			return GetRuleContext<Attribute_definitionContext>(i);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Alter_attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_attribute_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_attribute_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_attribute_definitionContext alter_attribute_definition() {
		Alter_attribute_definitionContext _localctx = new Alter_attribute_definitionContext(Context, State);
		EnterRule(_localctx, 96, RULE_alter_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1961;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==DROP || _la==MODIFY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1962; Match(ATTRIBUTE);
			State = 1975;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 1963; attribute_definition();
				}
				break;
			case LEFT_PAREN:
				{
				State = 1964; Match(LEFT_PAREN);
				State = 1965; attribute_definition();
				State = 1970;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1966; Match(COMMA);
					State = 1967; attribute_definition();
					}
					}
					State = 1972;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1973; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_definitionContext : ParserRuleContext {
		public Attribute_nameContext attribute_name() {
			return GetRuleContext<Attribute_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_definitionContext attribute_definition() {
		Attribute_definitionContext _localctx = new Attribute_definitionContext(Context, State);
		EnterRule(_localctx, 98, RULE_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1977; attribute_name();
			State = 1979;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 1978; type_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_collection_clausesContext : ParserRuleContext {
		public ITerminalNode MODIFY() { return GetToken(PlSqlParser.MODIFY, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ELEMENT() { return GetToken(PlSqlParser.ELEMENT, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Alter_collection_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_collection_clauses; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_collection_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_collection_clausesContext alter_collection_clauses() {
		Alter_collection_clausesContext _localctx = new Alter_collection_clausesContext(Context, State);
		EnterRule(_localctx, 100, RULE_alter_collection_clauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1981; Match(MODIFY);
			State = 1987;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LIMIT:
				{
				State = 1982; Match(LIMIT);
				State = 1983; expression();
				}
				break;
			case ELEMENT:
				{
				State = 1984; Match(ELEMENT);
				State = 1985; Match(TYPE);
				State = 1986; type_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_handling_clauseContext : ParserRuleContext {
		public ITerminalNode INVALIDATE() { return GetToken(PlSqlParser.INVALIDATE, 0); }
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode CONVERT() { return GetToken(PlSqlParser.CONVERT, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(PlSqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(PlSqlParser.INCLUDING, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode DATA() { return GetToken(PlSqlParser.DATA, 0); }
		public Dependent_exceptions_partContext dependent_exceptions_part() {
			return GetRuleContext<Dependent_exceptions_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Dependent_handling_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_handling_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDependent_handling_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_handling_clauseContext dependent_handling_clause() {
		Dependent_handling_clauseContext _localctx = new Dependent_handling_clauseContext(Context, State);
		EnterRule(_localctx, 102, RULE_dependent_handling_clause);
		int _la;
		try {
			State = 2005;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INVALIDATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1989; Match(INVALIDATE);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1990; Match(CASCADE);
				State = 2000;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CONVERT:
					{
					State = 1991; Match(CONVERT);
					State = 1992; Match(TO);
					State = 1993; Match(SUBSTITUTABLE);
					}
					break;
				case INCLUDING:
				case NOT:
					{
					State = 1995;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NOT) {
						{
						State = 1994; Match(NOT);
						}
					}

					State = 1997; Match(INCLUDING);
					State = 1998; Match(TABLE);
					State = 1999; Match(DATA);
					}
					break;
				case EXCEPTIONS:
				case FORCE:
				case SEMICOLON:
					break;
				default:
					break;
				}
				State = 2003;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EXCEPTIONS || _la==FORCE) {
					{
					State = 2002; dependent_exceptions_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_exceptions_partContext : ParserRuleContext {
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Dependent_exceptions_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_exceptions_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDependent_exceptions_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_exceptions_partContext dependent_exceptions_part() {
		Dependent_exceptions_partContext _localctx = new Dependent_exceptions_partContext(Context, State);
		EnterRule(_localctx, 104, RULE_dependent_exceptions_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2008;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE) {
				{
				State = 2007; Match(FORCE);
				}
			}

			State = 2010; Match(EXCEPTIONS);
			State = 2011; Match(INTO);
			State = 2012; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_typeContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_definitionContext type_definition() {
			return GetRuleContext<Type_definitionContext>(0);
		}
		public Type_bodyContext type_body() {
			return GetRuleContext<Type_bodyContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Create_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_typeContext create_type() {
		Create_typeContext _localctx = new Create_typeContext(Context, State);
		EnterRule(_localctx, 106, RULE_create_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2014; Match(CREATE);
			State = 2017;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 2015; Match(OR);
				State = 2016; Match(REPLACE);
				}
			}

			State = 2019; Match(TYPE);
			State = 2022;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,121,Context) ) {
			case 1:
				{
				State = 2020; type_definition();
				}
				break;
			case 2:
				{
				State = 2021; type_body();
				}
				break;
			}
			State = 2024; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_definitionContext : ParserRuleContext {
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode OID() { return GetToken(PlSqlParser.OID, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Object_type_defContext object_type_def() {
			return GetRuleContext<Object_type_defContext>(0);
		}
		public Type_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_definitionContext type_definition() {
		Type_definitionContext _localctx = new Type_definitionContext(Context, State);
		EnterRule(_localctx, 108, RULE_type_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2026; type_name();
			State = 2029;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OID) {
				{
				State = 2027; Match(OID);
				State = 2028; Match(CHAR_STRING);
				}
			}

			State = 2032;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==AUTHID || _la==IS || _la==UNDER) {
				{
				State = 2031; object_type_def();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_type_defContext : ParserRuleContext {
		public Object_as_partContext object_as_part() {
			return GetRuleContext<Object_as_partContext>(0);
		}
		public Object_under_partContext object_under_part() {
			return GetRuleContext<Object_under_partContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Sqlj_object_typeContext sqlj_object_type() {
			return GetRuleContext<Sqlj_object_typeContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Object_member_specContext[] object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Modifier_clauseContext[] modifier_clause() {
			return GetRuleContexts<Modifier_clauseContext>();
		}
		public Modifier_clauseContext modifier_clause(int i) {
			return GetRuleContext<Modifier_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Object_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_type_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_type_defContext object_type_def() {
		Object_type_defContext _localctx = new Object_type_defContext(Context, State);
		EnterRule(_localctx, 110, RULE_object_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2035;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTHID) {
				{
				State = 2034; invoker_rights_clause();
				}
			}

			State = 2039;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				{
				State = 2037; object_as_part();
				}
				break;
			case UNDER:
				{
				State = 2038; object_under_part();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2042;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTERNAL) {
				{
				State = 2041; sqlj_object_type();
				}
			}

			State = 2055;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2044; Match(LEFT_PAREN);
				State = 2045; object_member_spec();
				State = 2050;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2046; Match(COMMA);
					State = 2047; object_member_spec();
					}
					}
					State = 2052;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2053; Match(RIGHT_PAREN);
				}
			}

			State = 2060;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				{
				State = 2057; modifier_clause();
				}
				}
				State = 2062;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_as_partContext : ParserRuleContext {
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public Nested_table_type_defContext nested_table_type_def() {
			return GetRuleContext<Nested_table_type_defContext>(0);
		}
		public Object_as_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_as_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_as_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_as_partContext object_as_part() {
		Object_as_partContext _localctx = new Object_as_partContext(Context, State);
		EnterRule(_localctx, 112, RULE_object_as_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2063;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2067;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OBJECT:
				{
				State = 2064; Match(OBJECT);
				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 2065; varray_type_def();
				}
				break;
			case TABLE:
				{
				State = 2066; nested_table_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_under_partContext : ParserRuleContext {
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Object_under_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_under_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_under_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_under_partContext object_under_part() {
		Object_under_partContext _localctx = new Object_under_partContext(Context, State);
		EnterRule(_localctx, 114, RULE_object_under_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2069; Match(UNDER);
			State = 2070; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Nested_table_type_defContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Nested_table_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nested_table_type_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNested_table_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Nested_table_type_defContext nested_table_type_def() {
		Nested_table_type_defContext _localctx = new Nested_table_type_defContext(Context, State);
		EnterRule(_localctx, 116, RULE_nested_table_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2072; Match(TABLE);
			State = 2073; Match(OF);
			State = 2074; type_spec();
			State = 2077;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,131,Context) ) {
			case 1:
				{
				State = 2075; Match(NOT);
				State = 2076; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_typeContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LANGUAGE() { return GetToken(PlSqlParser.LANGUAGE, 0); }
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode SQLDATA() { return GetToken(PlSqlParser.SQLDATA, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(PlSqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode ORADATA() { return GetToken(PlSqlParser.ORADATA, 0); }
		public Sqlj_object_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlj_object_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_typeContext sqlj_object_type() {
		Sqlj_object_typeContext _localctx = new Sqlj_object_typeContext(Context, State);
		EnterRule(_localctx, 118, RULE_sqlj_object_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2079; Match(EXTERNAL);
			State = 2080; Match(NAME);
			State = 2081; expression();
			State = 2082; Match(LANGUAGE);
			State = 2083; Match(JAVA);
			State = 2084; Match(USING);
			State = 2085;
			_la = TokenStream.LA(1);
			if ( !(_la==CUSTOMDATUM || _la==ORADATA || _la==SQLDATA) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_bodyContext : ParserRuleContext {
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Type_body_elementsContext[] type_body_elements() {
			return GetRuleContexts<Type_body_elementsContext>();
		}
		public Type_body_elementsContext type_body_elements(int i) {
			return GetRuleContext<Type_body_elementsContext>(i);
		}
		public Type_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_bodyContext type_body() {
		Type_bodyContext _localctx = new Type_bodyContext(Context, State);
		EnterRule(_localctx, 120, RULE_type_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2087; Match(BODY);
			State = 2088; type_name();
			State = 2089;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2091;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2090; type_body_elements();
				}
				}
				State = 2093;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==MAP || _la==MEMBER || _la==ORDER || _la==STATIC );
			State = 2095; Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_body_elementsContext : ParserRuleContext {
		public Map_order_func_declarationContext map_order_func_declaration() {
			return GetRuleContext<Map_order_func_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext subprog_decl_in_type() {
			return GetRuleContext<Subprog_decl_in_typeContext>(0);
		}
		public Type_body_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_body_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_body_elementsContext type_body_elements() {
		Type_body_elementsContext _localctx = new Type_body_elementsContext(Context, State);
		EnterRule(_localctx, 122, RULE_type_body_elements);
		try {
			State = 2099;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2097; map_order_func_declaration();
				}
				break;
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2098; subprog_decl_in_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_func_declarationContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public ITerminalNode MAP() { return GetToken(PlSqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Map_order_func_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_func_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap_order_func_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_func_declarationContext map_order_func_declaration() {
		Map_order_func_declarationContext _localctx = new Map_order_func_declarationContext(Context, State);
		EnterRule(_localctx, 124, RULE_map_order_func_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2101;
			_la = TokenStream.LA(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2102; Match(MEMBER);
			State = 2103; func_decl_in_type();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprog_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode STATIC() { return GetToken(PlSqlParser.STATIC, 0); }
		public Proc_decl_in_typeContext proc_decl_in_type() {
			return GetRuleContext<Proc_decl_in_typeContext>(0);
		}
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public Constructor_declarationContext constructor_declaration() {
			return GetRuleContext<Constructor_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprog_decl_in_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubprog_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subprog_decl_in_typeContext subprog_decl_in_type() {
		Subprog_decl_in_typeContext _localctx = new Subprog_decl_in_typeContext(Context, State);
		EnterRule(_localctx, 126, RULE_subprog_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2105;
			_la = TokenStream.LA(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2109;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROCEDURE:
				{
				State = 2106; proc_decl_in_type();
				}
				break;
			case FUNCTION:
				{
				State = 2107; func_decl_in_type();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				{
				State = 2108; constructor_declaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public Proc_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_decl_in_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProc_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Proc_decl_in_typeContext proc_decl_in_type() {
		Proc_decl_in_typeContext _localctx = new Proc_decl_in_typeContext(Context, State);
		EnterRule(_localctx, 128, RULE_proc_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2111; Match(PROCEDURE);
			State = 2112; procedure_name();
			State = 2113; Match(LEFT_PAREN);
			State = 2114; type_elements_parameter();
			State = 2119;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2115; Match(COMMA);
				State = 2116; type_elements_parameter();
				}
				}
				State = 2121;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2122; Match(RIGHT_PAREN);
			State = 2123;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2134;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,138,Context) ) {
			case 1:
				{
				State = 2124; call_spec();
				}
				break;
			case 2:
				{
				State = 2126;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DECLARE) {
					{
					State = 2125; Match(DECLARE);
					}
				}

				State = 2129;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 2128; seq_of_declare_specs();
					}
				}

				State = 2131; body();
				State = 2132; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Func_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Func_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func_decl_in_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Func_decl_in_typeContext func_decl_in_type() {
		Func_decl_in_typeContext _localctx = new Func_decl_in_typeContext(Context, State);
		EnterRule(_localctx, 130, RULE_func_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2136; Match(FUNCTION);
			State = 2137; function_name();
			State = 2149;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2138; Match(LEFT_PAREN);
				State = 2139; type_elements_parameter();
				State = 2144;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2140; Match(COMMA);
					State = 2141; type_elements_parameter();
					}
					}
					State = 2146;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2147; Match(RIGHT_PAREN);
				}
			}

			State = 2151; Match(RETURN);
			State = 2152; type_spec();
			State = 2153;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2164;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,143,Context) ) {
			case 1:
				{
				State = 2154; call_spec();
				}
				break;
			case 2:
				{
				State = 2156;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DECLARE) {
					{
					State = 2155; Match(DECLARE);
					}
				}

				State = 2159;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 2158; seq_of_declare_specs();
					}
				}

				State = 2161; body();
				State = 2162; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_declarationContext : ParserRuleContext {
		public ITerminalNode CONSTRUCTOR() { return GetToken(PlSqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode[] SELF() { return GetTokens(PlSqlParser.SELF); }
		public ITerminalNode SELF(int i) {
			return GetToken(PlSqlParser.SELF, i);
		}
		public ITerminalNode[] AS() { return GetTokens(PlSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlSqlParser.AS, i);
		}
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public Constructor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructor_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_declarationContext constructor_declaration() {
		Constructor_declarationContext _localctx = new Constructor_declarationContext(Context, State);
		EnterRule(_localctx, 132, RULE_constructor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FINAL) {
				{
				State = 2166; Match(FINAL);
				}
			}

			State = 2170;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INSTANTIABLE) {
				{
				State = 2169; Match(INSTANTIABLE);
				}
			}

			State = 2172; Match(CONSTRUCTOR);
			State = 2173; Match(FUNCTION);
			State = 2174; type_spec();
			State = 2192;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2175; Match(LEFT_PAREN);
				{
				State = 2176; Match(SELF);
				State = 2177; Match(IN);
				State = 2178; Match(OUT);
				State = 2179; type_spec();
				State = 2180; Match(COMMA);
				}
				State = 2182; type_elements_parameter();
				State = 2187;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2183; Match(COMMA);
					State = 2184; type_elements_parameter();
					}
					}
					State = 2189;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2190; Match(RIGHT_PAREN);
				}
			}

			State = 2194; Match(RETURN);
			State = 2195; Match(SELF);
			State = 2196; Match(AS);
			State = 2197; Match(RESULT);
			State = 2198;
			_la = TokenStream.LA(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2209;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,150,Context) ) {
			case 1:
				{
				State = 2199; call_spec();
				}
				break;
			case 2:
				{
				State = 2201;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DECLARE) {
					{
					State = 2200; Match(DECLARE);
					}
				}

				State = 2204;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 2203; seq_of_declare_specs();
					}
				}

				State = 2206; body();
				State = 2207; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Modifier_clauseContext : ParserRuleContext {
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(PlSqlParser.OVERRIDING, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Modifier_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifier_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModifier_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Modifier_clauseContext modifier_clause() {
		Modifier_clauseContext _localctx = new Modifier_clauseContext(Context, State);
		EnterRule(_localctx, 134, RULE_modifier_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2212;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 2211; Match(NOT);
				}
			}

			State = 2214;
			_la = TokenStream.LA(1);
			if ( !(_la==FINAL || _la==INSTANTIABLE || _la==OVERRIDING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_member_specContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Sqlj_object_type_attrContext sqlj_object_type_attr() {
			return GetRuleContext<Sqlj_object_type_attrContext>(0);
		}
		public Element_specContext element_spec() {
			return GetRuleContext<Element_specContext>(0);
		}
		public Object_member_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_member_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_member_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_member_specContext object_member_spec() {
		Object_member_specContext _localctx = new Object_member_specContext(Context, State);
		EnterRule(_localctx, 136, RULE_object_member_spec);
		int _la;
		try {
			State = 2222;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,153,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2216; identifier();
				State = 2217; type_spec();
				State = 2219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EXTERNAL) {
					{
					State = 2218; sqlj_object_type_attr();
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2221; element_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_type_attrContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Sqlj_object_type_attrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type_attr; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlj_object_type_attr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_type_attrContext sqlj_object_type_attr() {
		Sqlj_object_type_attrContext _localctx = new Sqlj_object_type_attrContext(Context, State);
		EnterRule(_localctx, 138, RULE_sqlj_object_type_attr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2224; Match(EXTERNAL);
			State = 2225; Match(NAME);
			State = 2226; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_specContext : ParserRuleContext {
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Element_spec_optionsContext[] element_spec_options() {
			return GetRuleContexts<Element_spec_optionsContext>();
		}
		public Element_spec_optionsContext element_spec_options(int i) {
			return GetRuleContext<Element_spec_optionsContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Pragma_clauseContext pragma_clause() {
			return GetRuleContext<Pragma_clauseContext>(0);
		}
		public Element_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_specContext element_spec() {
		Element_specContext _localctx = new Element_specContext(Context, State);
		EnterRule(_localctx, 140, RULE_element_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2229;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,154,Context) ) {
			case 1:
				{
				State = 2228; modifier_clause();
				}
				break;
			}
			State = 2232;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2231; element_spec_options();
				}
				}
				State = 2234;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CONSTRUCTOR || _la==FINAL || _la==INSTANTIABLE || _la==MAP || _la==MEMBER || _la==ORDER || _la==STATIC );
			State = 2238;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
			case 1:
				{
				State = 2236; Match(COMMA);
				State = 2237; pragma_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_spec_optionsContext : ParserRuleContext {
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Constructor_specContext constructor_spec() {
			return GetRuleContext<Constructor_specContext>(0);
		}
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Element_spec_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec_options; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_spec_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_spec_optionsContext element_spec_options() {
		Element_spec_optionsContext _localctx = new Element_spec_optionsContext(Context, State);
		EnterRule(_localctx, 142, RULE_element_spec_options);
		try {
			State = 2243;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2240; subprogram_spec();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2241; constructor_spec();
				}
				break;
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2242; map_order_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprogram_specContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode STATIC() { return GetToken(PlSqlParser.STATIC, 0); }
		public Type_procedure_specContext type_procedure_spec() {
			return GetRuleContext<Type_procedure_specContext>(0);
		}
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public Subprogram_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprogram_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubprogram_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subprogram_specContext subprogram_spec() {
		Subprogram_specContext _localctx = new Subprogram_specContext(Context, State);
		EnterRule(_localctx, 144, RULE_subprogram_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2245;
			_la = TokenStream.LA(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2248;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROCEDURE:
				{
				State = 2246; type_procedure_spec();
				}
				break;
			case FUNCTION:
				{
				State = 2247; type_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_procedure_specContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Type_procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_procedure_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_procedure_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_procedure_specContext type_procedure_spec() {
		Type_procedure_specContext _localctx = new Type_procedure_specContext(Context, State);
		EnterRule(_localctx, 146, RULE_type_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2250; Match(PROCEDURE);
			State = 2251; procedure_name();
			State = 2252; Match(LEFT_PAREN);
			State = 2253; type_elements_parameter();
			State = 2258;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2254; Match(COMMA);
				State = 2255; type_elements_parameter();
				}
				}
				State = 2260;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2261; Match(RIGHT_PAREN);
			State = 2264;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IS) {
				{
				State = 2262;
				_la = TokenStream.LA(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2263; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_function_specContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode SELF() { return GetToken(PlSqlParser.SELF, 0); }
		public ITerminalNode[] AS() { return GetTokens(PlSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlSqlParser.AS, i);
		}
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode VARIABLE() { return GetToken(PlSqlParser.VARIABLE, 0); }
		public Type_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_function_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_function_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_function_specContext type_function_spec() {
		Type_function_specContext _localctx = new Type_function_specContext(Context, State);
		EnterRule(_localctx, 148, RULE_type_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2266; Match(FUNCTION);
			State = 2267; function_name();
			State = 2279;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2268; Match(LEFT_PAREN);
				State = 2269; type_elements_parameter();
				State = 2274;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2270; Match(COMMA);
					State = 2271; type_elements_parameter();
					}
					}
					State = 2276;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2277; Match(RIGHT_PAREN);
				}
			}

			State = 2281; Match(RETURN);
			State = 2286;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,163,Context) ) {
			case 1:
				{
				State = 2282; type_spec();
				}
				break;
			case 2:
				{
				State = 2283; Match(SELF);
				State = 2284; Match(AS);
				State = 2285; Match(RESULT);
				}
				break;
			}
			State = 2296;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
			case IS:
				{
				State = 2288;
				_la = TokenStream.LA(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2289; call_spec();
				}
				break;
			case EXTERNAL:
				{
				State = 2290; Match(EXTERNAL);
				State = 2292;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VARIABLE) {
					{
					State = 2291; Match(VARIABLE);
					}
				}

				State = 2294; Match(NAME);
				State = 2295; expression();
				}
				break;
			case CASCADE:
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
			case INVALIDATE:
			case MAP:
			case MEMBER:
			case ORDER:
			case STATIC:
			case RIGHT_PAREN:
			case COMMA:
			case SEMICOLON:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_specContext : ParserRuleContext {
		public ITerminalNode CONSTRUCTOR() { return GetToken(PlSqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode[] SELF() { return GetTokens(PlSqlParser.SELF); }
		public ITerminalNode SELF(int i) {
			return GetToken(PlSqlParser.SELF, i);
		}
		public ITerminalNode[] AS() { return GetTokens(PlSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlSqlParser.AS, i);
		}
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Constructor_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructor_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_specContext constructor_spec() {
		Constructor_specContext _localctx = new Constructor_specContext(Context, State);
		EnterRule(_localctx, 150, RULE_constructor_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2299;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FINAL) {
				{
				State = 2298; Match(FINAL);
				}
			}

			State = 2302;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INSTANTIABLE) {
				{
				State = 2301; Match(INSTANTIABLE);
				}
			}

			State = 2304; Match(CONSTRUCTOR);
			State = 2305; Match(FUNCTION);
			State = 2306; type_spec();
			State = 2324;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2307; Match(LEFT_PAREN);
				{
				State = 2308; Match(SELF);
				State = 2309; Match(IN);
				State = 2310; Match(OUT);
				State = 2311; type_spec();
				State = 2312; Match(COMMA);
				}
				State = 2314; type_elements_parameter();
				State = 2319;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2315; Match(COMMA);
					State = 2316; type_elements_parameter();
					}
					}
					State = 2321;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2322; Match(RIGHT_PAREN);
				}
			}

			State = 2326; Match(RETURN);
			State = 2327; Match(SELF);
			State = 2328; Match(AS);
			State = 2329; Match(RESULT);
			State = 2332;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IS) {
				{
				State = 2330;
				_la = TokenStream.LA(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2331; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_function_specContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public ITerminalNode MAP() { return GetToken(PlSqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Map_order_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_function_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap_order_function_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_function_specContext map_order_function_spec() {
		Map_order_function_specContext _localctx = new Map_order_function_specContext(Context, State);
		EnterRule(_localctx, 152, RULE_map_order_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2334;
			_la = TokenStream.LA(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2335; Match(MEMBER);
			State = 2336; type_function_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_clauseContext : ParserRuleContext {
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(PlSqlParser.RESTRICT_REFERENCES, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Pragma_elementsContext[] pragma_elements() {
			return GetRuleContexts<Pragma_elementsContext>();
		}
		public Pragma_elementsContext pragma_elements(int i) {
			return GetRuleContext<Pragma_elementsContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Pragma_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_clauseContext pragma_clause() {
		Pragma_clauseContext _localctx = new Pragma_clauseContext(Context, State);
		EnterRule(_localctx, 154, RULE_pragma_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2338; Match(PRAGMA);
			State = 2339; Match(RESTRICT_REFERENCES);
			State = 2340; Match(LEFT_PAREN);
			State = 2341; pragma_elements();
			State = 2346;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2342; Match(COMMA);
				State = 2343; pragma_elements();
				}
				}
				State = 2348;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2349; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_elementsContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Pragma_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_elementsContext pragma_elements() {
		Pragma_elementsContext _localctx = new Pragma_elementsContext(Context, State);
		EnterRule(_localctx, 156, RULE_pragma_elements);
		try {
			State = 2353;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2351; identifier();
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2352; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_elements_parameterContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Type_elements_parameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_elements_parameter; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_elements_parameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_elements_parameterContext type_elements_parameter() {
		Type_elements_parameterContext _localctx = new Type_elements_parameterContext(Context, State);
		EnterRule(_localctx, 158, RULE_type_elements_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2355; parameter_name();
			State = 2356; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_sequenceContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Drop_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_sequence; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_sequenceContext drop_sequence() {
		Drop_sequenceContext _localctx = new Drop_sequenceContext(Context, State);
		EnterRule(_localctx, 160, RULE_drop_sequence);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2358; Match(DROP);
			State = 2359; Match(SEQUENCE);
			State = 2360; sequence_name();
			State = 2361; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_sequenceContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Sequence_specContext[] sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Alter_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_sequence; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_sequenceContext alter_sequence() {
		Alter_sequenceContext _localctx = new Alter_sequenceContext(Context, State);
		EnterRule(_localctx, 162, RULE_alter_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2363; Match(ALTER);
			State = 2364; Match(SEQUENCE);
			State = 2365; sequence_name();
			State = 2367;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2366; sequence_spec();
				}
				}
				State = 2369;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CACHE || _la==CYCLE || ((((_la - 227)) & ~0x3f) == 0 && ((1L << (_la - 227)) & ((1L << (GLOBAL - 227)) | (1L << (INCREMENT - 227)) | (1L << (KEEP - 227)))) != 0) || ((((_la - 334)) & ~0x3f) == 0 && ((1L << (_la - 334)) & ((1L << (MAXVALUE - 334)) | (1L << (MINVALUE - 334)) | (1L << (NOCACHE - 334)) | (1L << (NOCYCLE - 334)) | (1L << (NOKEEP - 334)) | (1L << (NOMAXVALUE - 334)) | (1L << (NOMINVALUE - 334)) | (1L << (NOORDER - 334)))) != 0) || _la==ORDER || _la==SESSION || _la==START );
			State = 2371; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_sequenceContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Sequence_specContext[] sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Create_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_sequence; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_sequenceContext create_sequence() {
		Create_sequenceContext _localctx = new Create_sequenceContext(Context, State);
		EnterRule(_localctx, 164, RULE_create_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2373; Match(CREATE);
			State = 2374; Match(SEQUENCE);
			State = 2375; sequence_name();
			State = 2379;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CACHE || _la==CYCLE || ((((_la - 227)) & ~0x3f) == 0 && ((1L << (_la - 227)) & ((1L << (GLOBAL - 227)) | (1L << (INCREMENT - 227)) | (1L << (KEEP - 227)))) != 0) || ((((_la - 334)) & ~0x3f) == 0 && ((1L << (_la - 334)) & ((1L << (MAXVALUE - 334)) | (1L << (MINVALUE - 334)) | (1L << (NOCACHE - 334)) | (1L << (NOCYCLE - 334)) | (1L << (NOKEEP - 334)) | (1L << (NOMAXVALUE - 334)) | (1L << (NOMINVALUE - 334)) | (1L << (NOORDER - 334)))) != 0) || _la==ORDER || _la==SESSION || _la==START) {
				{
				{
				State = 2376; sequence_spec();
				}
				}
				State = 2381;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2382; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_specContext : ParserRuleContext {
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode NOMAXVALUE() { return GetToken(PlSqlParser.NOMAXVALUE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode NOMINVALUE() { return GetToken(PlSqlParser.NOMINVALUE, 0); }
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public ITerminalNode CACHE() { return GetToken(PlSqlParser.CACHE, 0); }
		public ITerminalNode NOCACHE() { return GetToken(PlSqlParser.NOCACHE, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode NOORDER() { return GetToken(PlSqlParser.NOORDER, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode NOKEEP() { return GetToken(PlSqlParser.NOKEEP, 0); }
		public ITerminalNode SESSION() { return GetToken(PlSqlParser.SESSION, 0); }
		public ITerminalNode GLOBAL() { return GetToken(PlSqlParser.GLOBAL, 0); }
		public Sequence_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_specContext sequence_spec() {
		Sequence_specContext _localctx = new Sequence_specContext(Context, State);
		EnterRule(_localctx, 166, RULE_sequence_spec);
		int _la;
		try {
			State = 2410;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCREMENT:
			case START:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2388;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INCREMENT:
					{
					State = 2384; Match(INCREMENT);
					State = 2385; Match(BY);
					}
					break;
				case START:
					{
					State = 2386; Match(START);
					State = 2387; Match(WITH);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2390; integer();
				}
				break;
			case MAXVALUE:
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2394;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MAXVALUE:
					{
					State = 2391; Match(MAXVALUE);
					State = 2392; integer();
					}
					break;
				case NOMAXVALUE:
					{
					State = 2393; Match(NOMAXVALUE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case MINVALUE:
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2399;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MINVALUE:
					{
					State = 2396; Match(MINVALUE);
					State = 2397; integer();
					}
					break;
				case NOMINVALUE:
					{
					State = 2398; Match(NOMINVALUE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case CYCLE:
			case NOCYCLE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2401;
				_la = TokenStream.LA(1);
				if ( !(_la==CYCLE || _la==NOCYCLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2405;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CACHE:
					{
					State = 2402; Match(CACHE);
					State = 2403; integer();
					}
					break;
				case NOCACHE:
					{
					State = 2404; Match(NOCACHE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NOORDER:
			case ORDER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2407;
				_la = TokenStream.LA(1);
				if ( !(_la==NOORDER || _la==ORDER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case KEEP:
			case NOKEEP:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2408;
				_la = TokenStream.LA(1);
				if ( !(_la==KEEP || _la==NOKEEP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case GLOBAL:
			case SESSION:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2409;
				_la = TokenStream.LA(1);
				if ( !(_la==GLOBAL || _la==SESSION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_indexContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(PlSqlParser.TABLESPACE, 0); }
		public ITerminalNode REGULAR_ID() { return GetToken(PlSqlParser.REGULAR_ID, 0); }
		public ITerminalNode COMPUTE() { return GetToken(PlSqlParser.COMPUTE, 0); }
		public ITerminalNode STATISTICS() { return GetToken(PlSqlParser.STATISTICS, 0); }
		public Create_indexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_index; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_index(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_indexContext create_index() {
		Create_indexContext _localctx = new Create_indexContext(Context, State);
		EnterRule(_localctx, 168, RULE_create_index);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2412; Match(CREATE);
			State = 2414;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNIQUE) {
				{
				State = 2413; Match(UNIQUE);
				}
			}

			State = 2416; Match(INDEX);
			State = 2417; index_name();
			State = 2418; Match(ON);
			State = 2419; tableview_name();
			State = 2420; paren_column_list();
			State = 2423;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 2421; Match(TABLESPACE);
				State = 2422; Match(REGULAR_ID);
				}
			}

			State = 2427;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPUTE) {
				{
				State = 2425; Match(COMPUTE);
				State = 2426; Match(STATISTICS);
				}
			}

			State = 2429; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_indexContext : ParserRuleContext {
		public Index_nameContext old_index_name;
		public Index_nameContext new_index_name;
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public Index_nameContext[] index_name() {
			return GetRuleContexts<Index_nameContext>();
		}
		public Index_nameContext index_name(int i) {
			return GetRuleContext<Index_nameContext>(i);
		}
		public Alter_indexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_index; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_index(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_indexContext alter_index() {
		Alter_indexContext _localctx = new Alter_indexContext(Context, State);
		EnterRule(_localctx, 170, RULE_alter_index);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2431; Match(ALTER);
			State = 2432; Match(INDEX);
			State = 2433; _localctx.old_index_name = index_name();
			State = 2434; Match(RENAME);
			State = 2435; Match(TO);
			State = 2436; _localctx.new_index_name = index_name();
			State = 2437; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_userContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(PlSqlParser.USER, 0); }
		public User_object_nameContext user_object_name() {
			return GetRuleContext<User_object_nameContext>(0);
		}
		public Identified_byContext[] identified_by() {
			return GetRuleContexts<Identified_byContext>();
		}
		public Identified_byContext identified_by(int i) {
			return GetRuleContext<Identified_byContext>(i);
		}
		public Identified_other_clauseContext[] identified_other_clause() {
			return GetRuleContexts<Identified_other_clauseContext>();
		}
		public Identified_other_clauseContext identified_other_clause(int i) {
			return GetRuleContext<Identified_other_clauseContext>(i);
		}
		public User_tablespace_clauseContext[] user_tablespace_clause() {
			return GetRuleContexts<User_tablespace_clauseContext>();
		}
		public User_tablespace_clauseContext user_tablespace_clause(int i) {
			return GetRuleContext<User_tablespace_clauseContext>(i);
		}
		public Quota_clauseContext[] quota_clause() {
			return GetRuleContexts<Quota_clauseContext>();
		}
		public Quota_clauseContext quota_clause(int i) {
			return GetRuleContext<Quota_clauseContext>(i);
		}
		public Profile_clauseContext[] profile_clause() {
			return GetRuleContexts<Profile_clauseContext>();
		}
		public Profile_clauseContext profile_clause(int i) {
			return GetRuleContext<Profile_clauseContext>(i);
		}
		public Password_expire_clauseContext[] password_expire_clause() {
			return GetRuleContexts<Password_expire_clauseContext>();
		}
		public Password_expire_clauseContext password_expire_clause(int i) {
			return GetRuleContext<Password_expire_clauseContext>(i);
		}
		public User_lock_clauseContext[] user_lock_clause() {
			return GetRuleContexts<User_lock_clauseContext>();
		}
		public User_lock_clauseContext user_lock_clause(int i) {
			return GetRuleContext<User_lock_clauseContext>(i);
		}
		public User_editions_clauseContext[] user_editions_clause() {
			return GetRuleContexts<User_editions_clauseContext>();
		}
		public User_editions_clauseContext user_editions_clause(int i) {
			return GetRuleContext<User_editions_clauseContext>(i);
		}
		public Container_clauseContext[] container_clause() {
			return GetRuleContexts<Container_clauseContext>();
		}
		public Container_clauseContext container_clause(int i) {
			return GetRuleContext<Container_clauseContext>(i);
		}
		public Create_userContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_user; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_user(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_userContext create_user() {
		Create_userContext _localctx = new Create_userContext(Context, State);
		EnterRule(_localctx, 172, RULE_create_user);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2439; Match(CREATE);
			State = 2440; Match(USER);
			State = 2441; user_object_name();
			State = 2451;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 2451;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,183,Context) ) {
				case 1:
					{
					State = 2442; identified_by();
					}
					break;
				case 2:
					{
					State = 2443; identified_other_clause();
					}
					break;
				case 3:
					{
					State = 2444; user_tablespace_clause();
					}
					break;
				case 4:
					{
					State = 2445; quota_clause();
					}
					break;
				case 5:
					{
					State = 2446; profile_clause();
					}
					break;
				case 6:
					{
					State = 2447; password_expire_clause();
					}
					break;
				case 7:
					{
					State = 2448; user_lock_clause();
					}
					break;
				case 8:
					{
					State = 2449; user_editions_clause();
					}
					break;
				case 9:
					{
					State = 2450; container_clause();
					}
					break;
				}
				}
				State = 2453;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==ACCOUNT || _la==CONTAINER || _la==DEFAULT || _la==ENABLE || _la==IDENTIFIED || ((((_la - 435)) & ~0x3f) == 0 && ((1L << (_la - 435)) & ((1L << (PASSWORD - 435)) | (1L << (PROFILE - 435)) | (1L << (QUOTA - 435)))) != 0) || _la==TEMPORARY );
			State = 2455; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_userContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode USER() { return GetToken(PlSqlParser.USER, 0); }
		public User_object_nameContext[] user_object_name() {
			return GetRuleContexts<User_object_nameContext>();
		}
		public User_object_nameContext user_object_name(int i) {
			return GetRuleContext<User_object_nameContext>(i);
		}
		public Alter_identified_byContext[] alter_identified_by() {
			return GetRuleContexts<Alter_identified_byContext>();
		}
		public Alter_identified_byContext alter_identified_by(int i) {
			return GetRuleContext<Alter_identified_byContext>(i);
		}
		public Identified_other_clauseContext[] identified_other_clause() {
			return GetRuleContexts<Identified_other_clauseContext>();
		}
		public Identified_other_clauseContext identified_other_clause(int i) {
			return GetRuleContext<Identified_other_clauseContext>(i);
		}
		public User_tablespace_clauseContext[] user_tablespace_clause() {
			return GetRuleContexts<User_tablespace_clauseContext>();
		}
		public User_tablespace_clauseContext user_tablespace_clause(int i) {
			return GetRuleContext<User_tablespace_clauseContext>(i);
		}
		public Quota_clauseContext[] quota_clause() {
			return GetRuleContexts<Quota_clauseContext>();
		}
		public Quota_clauseContext quota_clause(int i) {
			return GetRuleContext<Quota_clauseContext>(i);
		}
		public Profile_clauseContext[] profile_clause() {
			return GetRuleContexts<Profile_clauseContext>();
		}
		public Profile_clauseContext profile_clause(int i) {
			return GetRuleContext<Profile_clauseContext>(i);
		}
		public User_default_role_clauseContext[] user_default_role_clause() {
			return GetRuleContexts<User_default_role_clauseContext>();
		}
		public User_default_role_clauseContext user_default_role_clause(int i) {
			return GetRuleContext<User_default_role_clauseContext>(i);
		}
		public Password_expire_clauseContext[] password_expire_clause() {
			return GetRuleContexts<Password_expire_clauseContext>();
		}
		public Password_expire_clauseContext password_expire_clause(int i) {
			return GetRuleContext<Password_expire_clauseContext>(i);
		}
		public User_lock_clauseContext[] user_lock_clause() {
			return GetRuleContexts<User_lock_clauseContext>();
		}
		public User_lock_clauseContext user_lock_clause(int i) {
			return GetRuleContext<User_lock_clauseContext>(i);
		}
		public Alter_user_editions_clauseContext[] alter_user_editions_clause() {
			return GetRuleContexts<Alter_user_editions_clauseContext>();
		}
		public Alter_user_editions_clauseContext alter_user_editions_clause(int i) {
			return GetRuleContext<Alter_user_editions_clauseContext>(i);
		}
		public Container_clauseContext[] container_clause() {
			return GetRuleContexts<Container_clauseContext>();
		}
		public Container_clauseContext container_clause(int i) {
			return GetRuleContext<Container_clauseContext>(i);
		}
		public Container_data_clauseContext[] container_data_clause() {
			return GetRuleContexts<Container_data_clauseContext>();
		}
		public Container_data_clauseContext container_data_clause(int i) {
			return GetRuleContext<Container_data_clauseContext>(i);
		}
		public Proxy_clauseContext proxy_clause() {
			return GetRuleContext<Proxy_clauseContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Alter_userContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_user; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_user(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_userContext alter_user() {
		Alter_userContext _localctx = new Alter_userContext(Context, State);
		EnterRule(_localctx, 174, RULE_alter_user);
		int _la;
		try {
			int _alt;
			State = 2488;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2457; Match(ALTER);
				State = 2458; Match(USER);
				State = 2459; user_object_name();
				State = 2471;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 2471;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,185,Context) ) {
					case 1:
						{
						State = 2460; alter_identified_by();
						}
						break;
					case 2:
						{
						State = 2461; identified_other_clause();
						}
						break;
					case 3:
						{
						State = 2462; user_tablespace_clause();
						}
						break;
					case 4:
						{
						State = 2463; quota_clause();
						}
						break;
					case 5:
						{
						State = 2464; profile_clause();
						}
						break;
					case 6:
						{
						State = 2465; user_default_role_clause();
						}
						break;
					case 7:
						{
						State = 2466; password_expire_clause();
						}
						break;
					case 8:
						{
						State = 2467; user_lock_clause();
						}
						break;
					case 9:
						{
						State = 2468; alter_user_editions_clause();
						}
						break;
					case 10:
						{
						State = 2469; container_clause();
						}
						break;
					case 11:
						{
						State = 2470; container_data_clause();
						}
						break;
					}
					}
					State = 2473;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==ACCOUNT || _la==ADD || _la==CONTAINER || _la==DEFAULT || _la==ENABLE || _la==IDENTIFIED || ((((_la - 435)) & ~0x3f) == 0 && ((1L << (_la - 435)) & ((1L << (PASSWORD - 435)) | (1L << (PROFILE - 435)) | (1L << (QUOTA - 435)) | (1L << (REMOVE - 435)))) != 0) || _la==SET || _la==TEMPORARY );
				State = 2475; Match(SEMICOLON);
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case COMMA:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2481;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2478;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2477; Match(COMMA);
							}
						}

						State = 2480; user_object_name();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2483;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,188,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 2485; proxy_clause();
				State = 2486; Match(SEMICOLON);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_identified_byContext : ParserRuleContext {
		public Identified_byContext identified_by() {
			return GetRuleContext<Identified_byContext>(0);
		}
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Alter_identified_byContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_identified_by; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_identified_by(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_identified_byContext alter_identified_by() {
		Alter_identified_byContext _localctx = new Alter_identified_byContext(Context, State);
		EnterRule(_localctx, 176, RULE_alter_identified_by);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2490; identified_by();
			State = 2493;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REPLACE) {
				{
				State = 2491; Match(REPLACE);
				State = 2492; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Identified_byContext : ParserRuleContext {
		public ITerminalNode IDENTIFIED() { return GetToken(PlSqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Identified_byContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identified_by; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentified_by(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Identified_byContext identified_by() {
		Identified_byContext _localctx = new Identified_byContext(Context, State);
		EnterRule(_localctx, 178, RULE_identified_by);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2495; Match(IDENTIFIED);
			State = 2496; Match(BY);
			State = 2497; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Identified_other_clauseContext : ParserRuleContext {
		public ITerminalNode IDENTIFIED() { return GetToken(PlSqlParser.IDENTIFIED, 0); }
		public ITerminalNode EXTERNALLY() { return GetToken(PlSqlParser.EXTERNALLY, 0); }
		public ITerminalNode GLOBALLY() { return GetToken(PlSqlParser.GLOBALLY, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public Identified_other_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identified_other_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentified_other_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Identified_other_clauseContext identified_other_clause() {
		Identified_other_clauseContext _localctx = new Identified_other_clauseContext(Context, State);
		EnterRule(_localctx, 180, RULE_identified_other_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2499; Match(IDENTIFIED);
			State = 2500;
			_la = TokenStream.LA(1);
			if ( !(_la==EXTERNALLY || _la==GLOBALLY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2503;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2501; Match(AS);
				State = 2502; @string();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class User_tablespace_clauseContext : ParserRuleContext {
		public ITerminalNode TABLESPACE() { return GetToken(PlSqlParser.TABLESPACE, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(PlSqlParser.TEMPORARY, 0); }
		public User_tablespace_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_user_tablespace_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUser_tablespace_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public User_tablespace_clauseContext user_tablespace_clause() {
		User_tablespace_clauseContext _localctx = new User_tablespace_clauseContext(Context, State);
		EnterRule(_localctx, 182, RULE_user_tablespace_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2505;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==TEMPORARY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2506; Match(TABLESPACE);
			State = 2507; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quota_clauseContext : ParserRuleContext {
		public ITerminalNode QUOTA() { return GetToken(PlSqlParser.QUOTA, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Size_clauseContext size_clause() {
			return GetRuleContext<Size_clauseContext>(0);
		}
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public Quota_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quota_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuota_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quota_clauseContext quota_clause() {
		Quota_clauseContext _localctx = new Quota_clauseContext(Context, State);
		EnterRule(_localctx, 184, RULE_quota_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2509; Match(QUOTA);
			State = 2512;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNSIGNED_INTEGER:
				{
				State = 2510; size_clause();
				}
				break;
			case UNLIMITED:
				{
				State = 2511; Match(UNLIMITED);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2514; Match(ON);
			State = 2515; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Profile_clauseContext : ParserRuleContext {
		public ITerminalNode PROFILE() { return GetToken(PlSqlParser.PROFILE, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Profile_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_profile_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProfile_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Profile_clauseContext profile_clause() {
		Profile_clauseContext _localctx = new Profile_clauseContext(Context, State);
		EnterRule(_localctx, 186, RULE_profile_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2517; Match(PROFILE);
			State = 2518; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Role_clauseContext : ParserRuleContext {
		public Role_nameContext[] role_name() {
			return GetRuleContexts<Role_nameContext>();
		}
		public Role_nameContext role_name(int i) {
			return GetRuleContext<Role_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode[] EXCEPT() { return GetTokens(PlSqlParser.EXCEPT); }
		public ITerminalNode EXCEPT(int i) {
			return GetToken(PlSqlParser.EXCEPT, i);
		}
		public Role_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_role_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRole_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Role_clauseContext role_clause() {
		Role_clauseContext _localctx = new Role_clauseContext(Context, State);
		EnterRule(_localctx, 188, RULE_role_clause);
		int _la;
		try {
			int _alt;
			State = 2543;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case COMMA:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2524;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2521;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2520; Match(COMMA);
							}
						}

						State = 2523; role_name();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2526;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,194,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case ALL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2528; Match(ALL);
				State = 2540;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==EXCEPT) {
					{
					{
					State = 2529; Match(EXCEPT);
					State = 2534;
					ErrorHandler.Sync(this);
					_alt = 1;
					do {
						switch (_alt) {
						case 1:
							{
							{
							State = 2531;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==COMMA) {
								{
								State = 2530; Match(COMMA);
								}
							}

							State = 2533; role_name();
							}
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 2536;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,196,Context);
					} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
					}
					}
					State = 2542;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class User_default_role_clauseContext : ParserRuleContext {
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode ROLE() { return GetToken(PlSqlParser.ROLE, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public Role_clauseContext role_clause() {
			return GetRuleContext<Role_clauseContext>(0);
		}
		public User_default_role_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_user_default_role_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUser_default_role_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public User_default_role_clauseContext user_default_role_clause() {
		User_default_role_clauseContext _localctx = new User_default_role_clauseContext(Context, State);
		EnterRule(_localctx, 190, RULE_user_default_role_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2545; Match(DEFAULT);
			State = 2546; Match(ROLE);
			State = 2549;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,199,Context) ) {
			case 1:
				{
				State = 2547; Match(NONE);
				}
				break;
			case 2:
				{
				State = 2548; role_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Password_expire_clauseContext : ParserRuleContext {
		public ITerminalNode PASSWORD() { return GetToken(PlSqlParser.PASSWORD, 0); }
		public ITerminalNode EXPIRE() { return GetToken(PlSqlParser.EXPIRE, 0); }
		public Password_expire_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_password_expire_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPassword_expire_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Password_expire_clauseContext password_expire_clause() {
		Password_expire_clauseContext _localctx = new Password_expire_clauseContext(Context, State);
		EnterRule(_localctx, 192, RULE_password_expire_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2551; Match(PASSWORD);
			State = 2552; Match(EXPIRE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class User_lock_clauseContext : ParserRuleContext {
		public ITerminalNode ACCOUNT() { return GetToken(PlSqlParser.ACCOUNT, 0); }
		public ITerminalNode LOCK() { return GetToken(PlSqlParser.LOCK, 0); }
		public ITerminalNode UNLOCK() { return GetToken(PlSqlParser.UNLOCK, 0); }
		public User_lock_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_user_lock_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUser_lock_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public User_lock_clauseContext user_lock_clause() {
		User_lock_clauseContext _localctx = new User_lock_clauseContext(Context, State);
		EnterRule(_localctx, 194, RULE_user_lock_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2554; Match(ACCOUNT);
			State = 2555;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCK || _la==UNLOCK) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class User_editions_clauseContext : ParserRuleContext {
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode EDITIONS() { return GetToken(PlSqlParser.EDITIONS, 0); }
		public User_editions_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_user_editions_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUser_editions_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public User_editions_clauseContext user_editions_clause() {
		User_editions_clauseContext _localctx = new User_editions_clauseContext(Context, State);
		EnterRule(_localctx, 196, RULE_user_editions_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2557; Match(ENABLE);
			State = 2558; Match(EDITIONS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_user_editions_clauseContext : ParserRuleContext {
		public User_editions_clauseContext user_editions_clause() {
			return GetRuleContext<User_editions_clauseContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Regular_idContext[] regular_id() {
			return GetRuleContexts<Regular_idContext>();
		}
		public Regular_idContext regular_id(int i) {
			return GetRuleContext<Regular_idContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Alter_user_editions_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_user_editions_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_user_editions_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_user_editions_clauseContext alter_user_editions_clause() {
		Alter_user_editions_clauseContext _localctx = new Alter_user_editions_clauseContext(Context, State);
		EnterRule(_localctx, 198, RULE_alter_user_editions_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2560; user_editions_clause();
			State = 2570;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 2561; Match(FOR);
				State = 2566;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2563;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2562; Match(COMMA);
							}
						}

						State = 2565; regular_id();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2568;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,201,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
			}

			State = 2573;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE) {
				{
				State = 2572; Match(FORCE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proxy_clauseContext : ParserRuleContext {
		public ITerminalNode REVOKE() { return GetToken(PlSqlParser.REVOKE, 0); }
		public ITerminalNode CONNECT() { return GetToken(PlSqlParser.CONNECT, 0); }
		public ITerminalNode THROUGH() { return GetToken(PlSqlParser.THROUGH, 0); }
		public ITerminalNode ENTERPRISE() { return GetToken(PlSqlParser.ENTERPRISE, 0); }
		public ITerminalNode USERS() { return GetToken(PlSqlParser.USERS, 0); }
		public User_object_nameContext user_object_name() {
			return GetRuleContext<User_object_nameContext>(0);
		}
		public ITerminalNode GRANT() { return GetToken(PlSqlParser.GRANT, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode AUTHENTICATION() { return GetToken(PlSqlParser.AUTHENTICATION, 0); }
		public ITerminalNode REQUIRED() { return GetToken(PlSqlParser.REQUIRED, 0); }
		public ITerminalNode AUTHENTICATED() { return GetToken(PlSqlParser.AUTHENTICATED, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode ROLES() { return GetToken(PlSqlParser.ROLES, 0); }
		public ITerminalNode ROLE() { return GetToken(PlSqlParser.ROLE, 0); }
		public Role_clauseContext role_clause() {
			return GetRuleContext<Role_clauseContext>(0);
		}
		public ITerminalNode PASSWORD() { return GetToken(PlSqlParser.PASSWORD, 0); }
		public ITerminalNode CERTIFICATE() { return GetToken(PlSqlParser.CERTIFICATE, 0); }
		public ITerminalNode DISTINGUISHED() { return GetToken(PlSqlParser.DISTINGUISHED, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public Proxy_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proxy_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProxy_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Proxy_clauseContext proxy_clause() {
		Proxy_clauseContext _localctx = new Proxy_clauseContext(Context, State);
		EnterRule(_localctx, 200, RULE_proxy_clause);
		int _la;
		try {
			State = 2614;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REVOKE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2575; Match(REVOKE);
				State = 2576; Match(CONNECT);
				State = 2577; Match(THROUGH);
				State = 2581;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ENTERPRISE:
					{
					State = 2578; Match(ENTERPRISE);
					State = 2579; Match(USERS);
					}
					break;
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case REGULAR_ID:
					{
					State = 2580; user_object_name();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2583; Match(GRANT);
				State = 2584; Match(CONNECT);
				State = 2585; Match(THROUGH);
				State = 2612;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ENTERPRISE:
					{
					State = 2586; Match(ENTERPRISE);
					State = 2587; Match(USERS);
					}
					break;
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case REGULAR_ID:
					{
					State = 2588; user_object_name();
					State = 2596;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==WITH) {
						{
						State = 2589; Match(WITH);
						State = 2594;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case NO:
							{
							State = 2590; Match(NO);
							State = 2591; Match(ROLES);
							}
							break;
						case ROLE:
							{
							State = 2592; Match(ROLE);
							State = 2593; role_clause();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
					}

					State = 2600;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AUTHENTICATION) {
						{
						State = 2598; Match(AUTHENTICATION);
						State = 2599; Match(REQUIRED);
						}
					}

					State = 2610;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AUTHENTICATED) {
						{
						State = 2602; Match(AUTHENTICATED);
						State = 2603; Match(USING);
						State = 2608;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case PASSWORD:
							{
							State = 2604; Match(PASSWORD);
							}
							break;
						case CERTIFICATE:
							{
							State = 2605; Match(CERTIFICATE);
							}
							break;
						case DISTINGUISHED:
							{
							State = 2606; Match(DISTINGUISHED);
							State = 2607; Match(NAME);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Container_namesContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Container_namesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_container_names; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContainer_names(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Container_namesContext container_names() {
		Container_namesContext _localctx = new Container_namesContext(Context, State);
		EnterRule(_localctx, 202, RULE_container_names);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2616; Match(LEFT_PAREN);
			State = 2621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2618;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2617; Match(COMMA);
					}
				}

				State = 2620; id_expression();
				}
				}
				State = 2623;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==REGULAR_ID );
			State = 2625; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_container_dataContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode CONTAINER_DATA() { return GetToken(PlSqlParser.CONTAINER_DATA, 0); }
		public ITerminalNode EQUALS_OP() { return GetToken(PlSqlParser.EQUALS_OP, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Container_namesContext container_names() {
			return GetRuleContext<Container_namesContext>(0);
		}
		public Set_container_dataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_container_data; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_container_data(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_container_dataContext set_container_data() {
		Set_container_dataContext _localctx = new Set_container_dataContext(Context, State);
		EnterRule(_localctx, 204, RULE_set_container_data);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2627; Match(SET);
			State = 2628; Match(CONTAINER_DATA);
			State = 2629; Match(EQUALS_OP);
			State = 2633;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				{
				State = 2630; Match(ALL);
				}
				break;
			case DEFAULT:
				{
				State = 2631; Match(DEFAULT);
				}
				break;
			case LEFT_PAREN:
				{
				State = 2632; container_names();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_rem_container_dataContext : ParserRuleContext {
		public ITerminalNode CONTAINER_DATA() { return GetToken(PlSqlParser.CONTAINER_DATA, 0); }
		public ITerminalNode EQUALS_OP() { return GetToken(PlSqlParser.EQUALS_OP, 0); }
		public Container_namesContext container_names() {
			return GetRuleContext<Container_namesContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode REMOVE() { return GetToken(PlSqlParser.REMOVE, 0); }
		public Add_rem_container_dataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_rem_container_data; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_rem_container_data(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_rem_container_dataContext add_rem_container_data() {
		Add_rem_container_dataContext _localctx = new Add_rem_container_dataContext(Context, State);
		EnterRule(_localctx, 206, RULE_add_rem_container_data);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2635;
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==REMOVE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2636; Match(CONTAINER_DATA);
			State = 2637; Match(EQUALS_OP);
			State = 2638; container_names();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Container_data_clauseContext : ParserRuleContext {
		public Set_container_dataContext set_container_data() {
			return GetRuleContext<Set_container_dataContext>(0);
		}
		public Add_rem_container_dataContext add_rem_container_data() {
			return GetRuleContext<Add_rem_container_dataContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Container_tableview_nameContext container_tableview_name() {
			return GetRuleContext<Container_tableview_nameContext>(0);
		}
		public Container_data_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_container_data_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContainer_data_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Container_data_clauseContext container_data_clause() {
		Container_data_clauseContext _localctx = new Container_data_clauseContext(Context, State);
		EnterRule(_localctx, 208, RULE_container_data_clause);
		int _la;
		try {
			State = 2646;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SET:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2640; set_container_data();
				}
				break;
			case ADD:
			case REMOVE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2641; add_rem_container_data();
				State = 2644;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 2642; Match(FOR);
					State = 2643; container_tableview_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_indexContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public Drop_indexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_index; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_index(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_indexContext drop_index() {
		Drop_indexContext _localctx = new Drop_indexContext(Context, State);
		EnterRule(_localctx, 210, RULE_drop_index);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2648; Match(DROP);
			State = 2649; Match(INDEX);
			State = 2650; index_name();
			State = 2651; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Revoke_statmentContext : ParserRuleContext {
		public ITerminalNode REVOKE() { return GetToken(PlSqlParser.REVOKE, 0); }
		public Revoke_system_privilegesContext revoke_system_privileges() {
			return GetRuleContext<Revoke_system_privilegesContext>(0);
		}
		public Revoke_object_privilegesContext revoke_object_privileges() {
			return GetRuleContext<Revoke_object_privilegesContext>(0);
		}
		public Revoke_statmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revoke_statment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRevoke_statment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Revoke_statmentContext revoke_statment() {
		Revoke_statmentContext _localctx = new Revoke_statmentContext(Context, State);
		EnterRule(_localctx, 212, RULE_revoke_statment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2653; Match(REVOKE);
			State = 2656;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,217,Context) ) {
			case 1:
				{
				State = 2654; revoke_system_privileges();
				}
				break;
			case 2:
				{
				State = 2655; revoke_object_privileges();
				}
				break;
			}
			State = 2658; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Revoke_system_privilegesContext : ParserRuleContext {
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public Grantee_nameContext[] grantee_name() {
			return GetRuleContexts<Grantee_nameContext>();
		}
		public Grantee_nameContext grantee_name(int i) {
			return GetRuleContext<Grantee_nameContext>(i);
		}
		public ITerminalNode[] PUBLIC() { return GetTokens(PlSqlParser.PUBLIC); }
		public ITerminalNode PUBLIC(int i) {
			return GetToken(PlSqlParser.PUBLIC, i);
		}
		public Role_nameContext role_name() {
			return GetRuleContext<Role_nameContext>(0);
		}
		public System_privilegeContext system_privilege() {
			return GetRuleContext<System_privilegeContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Revoke_system_privilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revoke_system_privileges; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRevoke_system_privileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Revoke_system_privilegesContext revoke_system_privileges() {
		Revoke_system_privilegesContext _localctx = new Revoke_system_privilegesContext(Context, State);
		EnterRule(_localctx, 214, RULE_revoke_system_privileges);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 2661;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2660; Match(COMMA);
				}
			}

			State = 2665;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,219,Context) ) {
			case 1:
				{
				State = 2663; role_name();
				}
				break;
			case 2:
				{
				State = 2664; system_privilege();
				}
				break;
			}
			}
			State = 2667; Match(FROM);
			State = 2673;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 2673;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case COMMA:
				case REGULAR_ID:
					{
					State = 2669;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 2668; Match(COMMA);
						}
					}

					State = 2671; grantee_name();
					}
					break;
				case PUBLIC:
					{
					State = 2672; Match(PUBLIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2675;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (PUBLIC - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==REGULAR_ID );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Revoke_object_privilegesContext : ParserRuleContext {
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Grant_object_nameContext grant_object_name() {
			return GetRuleContext<Grant_object_nameContext>(0);
		}
		public Grantee_nameContext[] grantee_name() {
			return GetRuleContexts<Grantee_nameContext>();
		}
		public Grantee_nameContext grantee_name(int i) {
			return GetRuleContext<Grantee_nameContext>(i);
		}
		public ITerminalNode[] PUBLIC() { return GetTokens(PlSqlParser.PUBLIC); }
		public ITerminalNode PUBLIC(int i) {
			return GetToken(PlSqlParser.PUBLIC, i);
		}
		public Role_nameContext[] role_name() {
			return GetRuleContexts<Role_nameContext>();
		}
		public Role_nameContext role_name(int i) {
			return GetRuleContext<Role_nameContext>(i);
		}
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(PlSqlParser.CONSTRAINTS, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Object_privilegeContext[] object_privilege() {
			return GetRuleContexts<Object_privilegeContext>();
		}
		public Object_privilegeContext object_privilege(int i) {
			return GetRuleContext<Object_privilegeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Revoke_object_privilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revoke_object_privileges; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRevoke_object_privileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Revoke_object_privilegesContext revoke_object_privileges() {
		Revoke_object_privilegesContext _localctx = new Revoke_object_privilegesContext(Context, State);
		EnterRule(_localctx, 216, RULE_revoke_object_privileges);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2684;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 2678;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 2677; Match(COMMA);
						}
					}

					State = 2682;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,224,Context) ) {
					case 1:
						{
						State = 2680; role_name();
						}
						break;
					case 2:
						{
						State = 2681; object_privilege();
						}
						break;
					}
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2686;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,225,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			{
			State = 2688; Match(ON);
			State = 2689; grant_object_name();
			}
			State = 2691; Match(FROM);
			State = 2698;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 2698;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,227,Context) ) {
					case 1:
						{
						State = 2693;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2692; Match(COMMA);
							}
						}

						State = 2695; grantee_name();
						}
						break;
					case 2:
						{
						State = 2696; Match(PUBLIC);
						}
						break;
					case 3:
						{
						State = 2697; role_name();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2700;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,228,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 2705;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASCADE:
				{
				State = 2702; Match(CASCADE);
				State = 2703; Match(CONSTRAINTS);
				}
				break;
			case FORCE:
				{
				State = 2704; Match(FORCE);
				}
				break;
			case SEMICOLON:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grant_statementContext : ParserRuleContext {
		public ITerminalNode[] GRANT() { return GetTokens(PlSqlParser.GRANT); }
		public ITerminalNode GRANT(int i) {
			return GetToken(PlSqlParser.GRANT, i);
		}
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Grant_object_nameContext grant_object_name() {
			return GetRuleContext<Grant_object_nameContext>(0);
		}
		public Grantee_nameContext[] grantee_name() {
			return GetRuleContexts<Grantee_nameContext>();
		}
		public Grantee_nameContext grantee_name(int i) {
			return GetRuleContext<Grantee_nameContext>(i);
		}
		public ITerminalNode[] PUBLIC() { return GetTokens(PlSqlParser.PUBLIC); }
		public ITerminalNode PUBLIC(int i) {
			return GetToken(PlSqlParser.PUBLIC, i);
		}
		public ITerminalNode[] WITH() { return GetTokens(PlSqlParser.WITH); }
		public ITerminalNode WITH(int i) {
			return GetToken(PlSqlParser.WITH, i);
		}
		public ITerminalNode[] OPTION() { return GetTokens(PlSqlParser.OPTION); }
		public ITerminalNode OPTION(int i) {
			return GetToken(PlSqlParser.OPTION, i);
		}
		public ITerminalNode HIERARCHY() { return GetToken(PlSqlParser.HIERARCHY, 0); }
		public Container_clauseContext container_clause() {
			return GetRuleContext<Container_clauseContext>(0);
		}
		public ITerminalNode ADMIN() { return GetToken(PlSqlParser.ADMIN, 0); }
		public ITerminalNode DELEGATE() { return GetToken(PlSqlParser.DELEGATE, 0); }
		public Role_nameContext[] role_name() {
			return GetRuleContexts<Role_nameContext>();
		}
		public Role_nameContext role_name(int i) {
			return GetRuleContext<Role_nameContext>(i);
		}
		public System_privilegeContext[] system_privilege() {
			return GetRuleContexts<System_privilegeContext>();
		}
		public System_privilegeContext system_privilege(int i) {
			return GetRuleContext<System_privilegeContext>(i);
		}
		public Object_privilegeContext[] object_privilege() {
			return GetRuleContexts<Object_privilegeContext>();
		}
		public Object_privilegeContext object_privilege(int i) {
			return GetRuleContext<Object_privilegeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Paren_column_listContext[] paren_column_list() {
			return GetRuleContexts<Paren_column_listContext>();
		}
		public Paren_column_listContext paren_column_list(int i) {
			return GetRuleContext<Paren_column_listContext>(i);
		}
		public Grant_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grant_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrant_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grant_statementContext grant_statement() {
		Grant_statementContext _localctx = new Grant_statementContext(Context, State);
		EnterRule(_localctx, 218, RULE_grant_statement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2707; Match(GRANT);
			State = 2719;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 2709;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 2708; Match(COMMA);
						}
					}

					State = 2717;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,232,Context) ) {
					case 1:
						{
						State = 2711; role_name();
						}
						break;
					case 2:
						{
						State = 2712; system_privilege();
						}
						break;
					case 3:
						{
						State = 2713; object_privilege();
						State = 2715;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==LEFT_PAREN) {
							{
							State = 2714; paren_column_list();
							}
						}

						}
						break;
					}
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2721;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,233,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 2725;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 2723; Match(ON);
				State = 2724; grant_object_name();
				}
			}

			State = 2727; Match(TO);
			State = 2733;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 2733;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case COMMA:
				case REGULAR_ID:
					{
					State = 2729;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 2728; Match(COMMA);
						}
					}

					State = 2731; grantee_name();
					}
					break;
				case PUBLIC:
					{
					State = 2732; Match(PUBLIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2735;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (PUBLIC - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==REGULAR_ID );
			State = 2740;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,238,Context) ) {
			case 1:
				{
				State = 2737; Match(WITH);
				State = 2738;
				_la = TokenStream.LA(1);
				if ( !(_la==ADMIN || _la==DELEGATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2739; Match(OPTION);
				}
				break;
			}
			State = 2745;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,239,Context) ) {
			case 1:
				{
				State = 2742; Match(WITH);
				State = 2743; Match(HIERARCHY);
				State = 2744; Match(OPTION);
				}
				break;
			}
			State = 2750;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 2747; Match(WITH);
				State = 2748; Match(GRANT);
				State = 2749; Match(OPTION);
				}
			}

			State = 2753;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONTAINER) {
				{
				State = 2752; container_clause();
				}
			}

			State = 2755; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Container_clauseContext : ParserRuleContext {
		public ITerminalNode CONTAINER() { return GetToken(PlSqlParser.CONTAINER, 0); }
		public ITerminalNode EQUALS_OP() { return GetToken(PlSqlParser.EQUALS_OP, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Container_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_container_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContainer_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Container_clauseContext container_clause() {
		Container_clauseContext _localctx = new Container_clauseContext(Context, State);
		EnterRule(_localctx, 220, RULE_container_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2757; Match(CONTAINER);
			State = 2758; Match(EQUALS_OP);
			State = 2759;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==CURRENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_viewContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode VIEW() { return GetToken(PlSqlParser.VIEW, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode EDITIONING() { return GetToken(PlSqlParser.EDITIONING, 0); }
		public ITerminalNode EDITIONABLE() { return GetToken(PlSqlParser.EDITIONABLE, 0); }
		public ITerminalNode NOEDITIONABLE() { return GetToken(PlSqlParser.NOEDITIONABLE, 0); }
		public View_optionsContext view_options() {
			return GetRuleContext<View_optionsContext>(0);
		}
		public Subquery_restriction_clauseContext subquery_restriction_clause() {
			return GetRuleContext<Subquery_restriction_clauseContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Create_viewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_view; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_view(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_viewContext create_view() {
		Create_viewContext _localctx = new Create_viewContext(Context, State);
		EnterRule(_localctx, 222, RULE_create_view);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2761; Match(CREATE);
			State = 2764;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 2762; Match(OR);
				State = 2763; Match(REPLACE);
				}
			}

			State = 2770;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FORCE || _la==NO) {
				{
				State = 2767;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 2766; Match(NO);
					}
				}

				State = 2769; Match(FORCE);
				}
			}

			State = 2778;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EDITIONING:
				{
				State = 2772; Match(EDITIONING);
				}
				break;
			case EDITIONABLE:
				{
				State = 2773; Match(EDITIONABLE);
				State = 2775;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EDITIONING) {
					{
					State = 2774; Match(EDITIONING);
					}
				}

				}
				break;
			case NOEDITIONABLE:
				{
				State = 2777; Match(NOEDITIONABLE);
				}
				break;
			case VIEW:
				break;
			default:
				break;
			}
			State = 2780; Match(VIEW);
			State = 2781; tableview_name();
			State = 2783;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF || _la==LEFT_PAREN) {
				{
				State = 2782; view_options();
				}
			}

			State = 2785; Match(AS);
			State = 2786; subquery();
			State = 2788;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 2787; subquery_restriction_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class View_optionsContext : ParserRuleContext {
		public View_alias_constraintContext view_alias_constraint() {
			return GetRuleContext<View_alias_constraintContext>(0);
		}
		public Object_view_clauseContext object_view_clause() {
			return GetRuleContext<Object_view_clauseContext>(0);
		}
		public View_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_view_options; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitView_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public View_optionsContext view_options() {
		View_optionsContext _localctx = new View_optionsContext(Context, State);
		EnterRule(_localctx, 224, RULE_view_options);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2792;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_PAREN:
				{
				State = 2790; view_alias_constraint();
				}
				break;
			case OF:
				{
				State = 2791; object_view_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class View_alias_constraintContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Table_aliasContext[] table_alias() {
			return GetRuleContexts<Table_aliasContext>();
		}
		public Table_aliasContext table_alias(int i) {
			return GetRuleContext<Table_aliasContext>(i);
		}
		public Out_of_line_constraintContext[] out_of_line_constraint() {
			return GetRuleContexts<Out_of_line_constraintContext>();
		}
		public Out_of_line_constraintContext out_of_line_constraint(int i) {
			return GetRuleContext<Out_of_line_constraintContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Inline_constraintContext[] inline_constraint() {
			return GetRuleContexts<Inline_constraintContext>();
		}
		public Inline_constraintContext inline_constraint(int i) {
			return GetRuleContext<Inline_constraintContext>(i);
		}
		public ITerminalNode[] VISIBLE() { return GetTokens(PlSqlParser.VISIBLE); }
		public ITerminalNode VISIBLE(int i) {
			return GetToken(PlSqlParser.VISIBLE, i);
		}
		public ITerminalNode[] INVISIBLE() { return GetTokens(PlSqlParser.INVISIBLE); }
		public ITerminalNode INVISIBLE(int i) {
			return GetToken(PlSqlParser.INVISIBLE, i);
		}
		public View_alias_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_view_alias_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitView_alias_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public View_alias_constraintContext view_alias_constraint() {
		View_alias_constraintContext _localctx = new View_alias_constraintContext(Context, State);
		EnterRule(_localctx, 226, RULE_view_alias_constraint);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2794; Match(LEFT_PAREN);
			State = 2811;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2796;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2795; Match(COMMA);
					}
				}

				State = 2809;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,253,Context) ) {
				case 1:
					{
					State = 2798; table_alias();
					State = 2800;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==INVISIBLE || _la==VISIBLE) {
						{
						State = 2799;
						_la = TokenStream.LA(1);
						if ( !(_la==INVISIBLE || _la==VISIBLE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 2805;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,252,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 2802; inline_constraint();
							}
							} 
						}
						State = 2807;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,252,Context);
					}
					}
					break;
				case 2:
					{
					State = 2808; out_of_line_constraint();
					}
					break;
				}
				}
				}
				State = 2813;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHECK - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FOREIGN - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIMARY - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNIQUE - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 2815; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_view_clauseContext : ParserRuleContext {
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(PlSqlParser.IDENTIFIER, 0); }
		public ITerminalNode ID() { return GetToken(PlSqlParser.ID, 0); }
		public ITerminalNode OID() { return GetToken(PlSqlParser.OID, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode[] REGULAR_ID() { return GetTokens(PlSqlParser.REGULAR_ID); }
		public ITerminalNode REGULAR_ID(int i) {
			return GetToken(PlSqlParser.REGULAR_ID, i);
		}
		public Out_of_line_constraintContext[] out_of_line_constraint() {
			return GetRuleContexts<Out_of_line_constraintContext>();
		}
		public Out_of_line_constraintContext out_of_line_constraint(int i) {
			return GetRuleContext<Out_of_line_constraintContext>(i);
		}
		public Inline_constraintContext[] inline_constraint() {
			return GetRuleContexts<Inline_constraintContext>();
		}
		public Inline_constraintContext inline_constraint(int i) {
			return GetRuleContext<Inline_constraintContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Object_view_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_view_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_view_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_view_clauseContext object_view_clause() {
		Object_view_clauseContext _localctx = new Object_view_clauseContext(Context, State);
		EnterRule(_localctx, 228, RULE_object_view_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2817; Match(OF);
			State = 2818; type_name();
			State = 2837;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				{
				State = 2819; Match(WITH);
				State = 2820; Match(OBJECT);
				State = 2821;
				_la = TokenStream.LA(1);
				if ( !(_la==IDENTIFIER || _la==ID || _la==OID) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2833;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DEFAULT:
					{
					State = 2822; Match(DEFAULT);
					}
					break;
				case LEFT_PAREN:
					{
					State = 2823; Match(LEFT_PAREN);
					State = 2828;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 2825;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2824; Match(COMMA);
							}
						}

						State = 2827; Match(REGULAR_ID);
						}
						}
						State = 2830;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==COMMA || _la==REGULAR_ID );
					State = 2832; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case UNDER:
				{
				State = 2835; Match(UNDER);
				State = 2836; tableview_name();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2856;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==LEFT_PAREN) {
				{
				{
				State = 2839; Match(LEFT_PAREN);
				State = 2848;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2841;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 2840; Match(COMMA);
						}
					}

					State = 2846;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHECK:
					case CONSTRAINT:
					case FOREIGN:
					case PRIMARY:
					case UNIQUE:
						{
						State = 2843; out_of_line_constraint();
						}
						break;
					case REGULAR_ID:
						{
						State = 2844; Match(REGULAR_ID);
						State = 2845; inline_constraint();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					State = 2850;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CHECK || _la==CONSTRAINT || _la==FOREIGN || _la==PRIMARY || _la==UNIQUE || _la==COMMA || _la==REGULAR_ID );
				State = 2852; Match(RIGHT_PAREN);
				}
				}
				State = 2858;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintContext : ParserRuleContext {
		public Inline_constraintContext inline_constraint() {
			return GetRuleContext<Inline_constraintContext>(0);
		}
		public Out_of_line_constraintContext out_of_line_constraint() {
			return GetRuleContext<Out_of_line_constraintContext>(0);
		}
		public Inline_ref_constraintContext inline_ref_constraint() {
			return GetRuleContext<Inline_ref_constraintContext>(0);
		}
		public Out_of_line_ref_constraintContext out_of_line_ref_constraint() {
			return GetRuleContext<Out_of_line_ref_constraintContext>(0);
		}
		public ConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintContext constraint() {
		ConstraintContext _localctx = new ConstraintContext(Context, State);
		EnterRule(_localctx, 230, RULE_constraint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2859; inline_constraint();
			State = 2860; out_of_line_constraint();
			State = 2861; inline_ref_constraint();
			State = 2862; out_of_line_ref_constraint();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inline_constraintContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode PRIMARY() { return GetToken(PlSqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public References_clauseContext references_clause() {
			return GetRuleContext<References_clauseContext>(0);
		}
		public Check_constraintContext check_constraint() {
			return GetRuleContext<Check_constraintContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Constraint_stateContext constraint_state() {
			return GetRuleContext<Constraint_stateContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Inline_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inline_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInline_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inline_constraintContext inline_constraint() {
		Inline_constraintContext _localctx = new Inline_constraintContext(Context, State);
		EnterRule(_localctx, 232, RULE_inline_constraint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2866;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 2864; Match(CONSTRAINT);
				State = 2865; constraint_name();
				}
			}

			State = 2877;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
			case NULL:
				{
				State = 2869;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2868; Match(NOT);
					}
				}

				State = 2871; Match(NULL);
				}
				break;
			case UNIQUE:
				{
				State = 2872; Match(UNIQUE);
				}
				break;
			case PRIMARY:
				{
				State = 2873; Match(PRIMARY);
				State = 2874; Match(KEY);
				}
				break;
			case REFERENCES:
				{
				State = 2875; references_clause();
				}
				break;
			case CHECK:
				{
				State = 2876; check_constraint();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2880;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,266,Context) ) {
			case 1:
				{
				State = 2879; constraint_state();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Out_of_line_constraintContext : ParserRuleContext {
		public Out_of_line_constraintsContext[] out_of_line_constraints() {
			return GetRuleContexts<Out_of_line_constraintsContext>();
		}
		public Out_of_line_constraintsContext out_of_line_constraints(int i) {
			return GetRuleContext<Out_of_line_constraintsContext>(i);
		}
		public Constraint_stateContext constraint_state() {
			return GetRuleContext<Constraint_stateContext>(0);
		}
		public Out_of_line_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_out_of_line_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOut_of_line_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Out_of_line_constraintContext out_of_line_constraint() {
		Out_of_line_constraintContext _localctx = new Out_of_line_constraintContext(Context, State);
		EnterRule(_localctx, 234, RULE_out_of_line_constraint);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2883;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 2882; out_of_line_constraints();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2885;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,267,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 2888;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,268,Context) ) {
			case 1:
				{
				State = 2887; constraint_state();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Out_of_line_constraintsContext : ParserRuleContext {
		public Primary_key_clauseContext primary_key_clause() {
			return GetRuleContext<Primary_key_clauseContext>(0);
		}
		public Foreign_key_clauseContext foreign_key_clause() {
			return GetRuleContext<Foreign_key_clauseContext>(0);
		}
		public Unique_key_clauseContext unique_key_clause() {
			return GetRuleContext<Unique_key_clauseContext>(0);
		}
		public Check_constraintContext check_constraint() {
			return GetRuleContext<Check_constraintContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Out_of_line_constraintsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_out_of_line_constraints; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOut_of_line_constraints(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Out_of_line_constraintsContext out_of_line_constraints() {
		Out_of_line_constraintsContext _localctx = new Out_of_line_constraintsContext(Context, State);
		EnterRule(_localctx, 236, RULE_out_of_line_constraints);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2892;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 2890; Match(CONSTRAINT);
				State = 2891; constraint_name();
				}
			}

			State = 2898;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIMARY:
				{
				State = 2894; primary_key_clause();
				}
				break;
			case FOREIGN:
				{
				State = 2895; foreign_key_clause();
				}
				break;
			case UNIQUE:
				{
				State = 2896; unique_key_clause();
				}
				break;
			case CHECK:
				{
				State = 2897; check_constraint();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constraint_stateContext : ParserRuleContext {
		public ITerminalNode[] DEFERRABLE() { return GetTokens(PlSqlParser.DEFERRABLE); }
		public ITerminalNode DEFERRABLE(int i) {
			return GetToken(PlSqlParser.DEFERRABLE, i);
		}
		public ITerminalNode[] INITIALLY() { return GetTokens(PlSqlParser.INITIALLY); }
		public ITerminalNode INITIALLY(int i) {
			return GetToken(PlSqlParser.INITIALLY, i);
		}
		public Using_index_clauseContext[] using_index_clause() {
			return GetRuleContexts<Using_index_clauseContext>();
		}
		public Using_index_clauseContext using_index_clause(int i) {
			return GetRuleContext<Using_index_clauseContext>(i);
		}
		public Exceptions_clauseContext[] exceptions_clause() {
			return GetRuleContexts<Exceptions_clauseContext>();
		}
		public Exceptions_clauseContext exceptions_clause(int i) {
			return GetRuleContext<Exceptions_clauseContext>(i);
		}
		public ITerminalNode[] IMMEDIATE() { return GetTokens(PlSqlParser.IMMEDIATE); }
		public ITerminalNode IMMEDIATE(int i) {
			return GetToken(PlSqlParser.IMMEDIATE, i);
		}
		public ITerminalNode[] DEFERRED() { return GetTokens(PlSqlParser.DEFERRED); }
		public ITerminalNode DEFERRED(int i) {
			return GetToken(PlSqlParser.DEFERRED, i);
		}
		public ITerminalNode[] RELY() { return GetTokens(PlSqlParser.RELY); }
		public ITerminalNode RELY(int i) {
			return GetToken(PlSqlParser.RELY, i);
		}
		public ITerminalNode[] NORELY() { return GetTokens(PlSqlParser.NORELY); }
		public ITerminalNode NORELY(int i) {
			return GetToken(PlSqlParser.NORELY, i);
		}
		public ITerminalNode[] ENABLE() { return GetTokens(PlSqlParser.ENABLE); }
		public ITerminalNode ENABLE(int i) {
			return GetToken(PlSqlParser.ENABLE, i);
		}
		public ITerminalNode[] DISABLE() { return GetTokens(PlSqlParser.DISABLE); }
		public ITerminalNode DISABLE(int i) {
			return GetToken(PlSqlParser.DISABLE, i);
		}
		public ITerminalNode[] VALIDATE() { return GetTokens(PlSqlParser.VALIDATE); }
		public ITerminalNode VALIDATE(int i) {
			return GetToken(PlSqlParser.VALIDATE, i);
		}
		public ITerminalNode[] NOVALIDATE() { return GetTokens(PlSqlParser.NOVALIDATE); }
		public ITerminalNode NOVALIDATE(int i) {
			return GetToken(PlSqlParser.NOVALIDATE, i);
		}
		public ITerminalNode[] NOT() { return GetTokens(PlSqlParser.NOT); }
		public ITerminalNode NOT(int i) {
			return GetToken(PlSqlParser.NOT, i);
		}
		public Constraint_stateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraint_state; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraint_state(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constraint_stateContext constraint_state() {
		Constraint_stateContext _localctx = new Constraint_stateContext(Context, State);
		EnterRule(_localctx, 238, RULE_constraint_state);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2911;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 2911;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case DEFERRABLE:
					case NOT:
						{
						State = 2901;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 2900; Match(NOT);
							}
						}

						State = 2903; Match(DEFERRABLE);
						}
						break;
					case INITIALLY:
						{
						State = 2904; Match(INITIALLY);
						State = 2905;
						_la = TokenStream.LA(1);
						if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case NORELY:
					case RELY:
						{
						State = 2906;
						_la = TokenStream.LA(1);
						if ( !(_la==NORELY || _la==RELY) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case USING:
						{
						State = 2907; using_index_clause();
						}
						break;
					case DISABLE:
					case ENABLE:
						{
						State = 2908;
						_la = TokenStream.LA(1);
						if ( !(_la==DISABLE || _la==ENABLE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case NOVALIDATE:
					case VALIDATE:
						{
						State = 2909;
						_la = TokenStream.LA(1);
						if ( !(_la==NOVALIDATE || _la==VALIDATE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case EXCEPTIONS:
						{
						State = 2910; exceptions_clause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2913;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,273,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_index_clauseContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Create_indexContext create_index() {
			return GetRuleContext<Create_indexContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Index_propertiesContext index_properties() {
			return GetRuleContext<Index_propertiesContext>(0);
		}
		public Using_index_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_index_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_index_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_index_clauseContext using_index_clause() {
		Using_index_clauseContext _localctx = new Using_index_clauseContext(Context, State);
		EnterRule(_localctx, 240, RULE_using_index_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2915; Match(USING);
			State = 2916; Match(INDEX);
			State = 2925;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,275,Context) ) {
			case 1:
				{
				State = 2917; index_name();
				}
				break;
			case 2:
				{
				State = 2918; Match(LEFT_PAREN);
				State = 2919; create_index();
				State = 2920; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				{
				State = 2923;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,274,Context) ) {
				case 1:
					{
					State = 2922; index_properties();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_propertiesContext : ParserRuleContext {
		public Global_partitioned_indexContext[] global_partitioned_index() {
			return GetRuleContexts<Global_partitioned_indexContext>();
		}
		public Global_partitioned_indexContext global_partitioned_index(int i) {
			return GetRuleContext<Global_partitioned_indexContext>(i);
		}
		public Local_partitioned_indexContext[] local_partitioned_index() {
			return GetRuleContexts<Local_partitioned_indexContext>();
		}
		public Local_partitioned_indexContext local_partitioned_index(int i) {
			return GetRuleContext<Local_partitioned_indexContext>(i);
		}
		public Index_attributesContext[] index_attributes() {
			return GetRuleContexts<Index_attributesContext>();
		}
		public Index_attributesContext index_attributes(int i) {
			return GetRuleContext<Index_attributesContext>(i);
		}
		public ITerminalNode INDEXTYPE() { return GetToken(PlSqlParser.INDEXTYPE, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Domain_index_clauseContext domain_index_clause() {
			return GetRuleContext<Domain_index_clauseContext>(0);
		}
		public Xmlindex_clauseContext xmlindex_clause() {
			return GetRuleContext<Xmlindex_clauseContext>(0);
		}
		public Index_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_propertiesContext index_properties() {
		Index_propertiesContext _localctx = new Index_propertiesContext(Context, State);
		EnterRule(_localctx, 242, RULE_index_properties);
		try {
			int _alt;
			State = 2946;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
			case FILESYSTEM_LIKE_LOGGING:
			case GLOBAL:
			case INDEXING:
			case INITRANS:
			case INVISIBLE:
			case LOCAL:
			case LOGGING:
			case MAXTRANS:
			case NOCOMPRESS:
			case NOLOGGING:
			case NOPARALLEL:
			case NOSORT:
			case ONLINE:
			case PARALLEL:
			case PCTFREE:
			case PCTUSED:
			case REVERSE:
			case SORT:
			case STORAGE:
			case TABLESPACE:
			case VISIBLE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2936;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 2936;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case GLOBAL:
						case LOCAL:
							{
							State = 2929;
							ErrorHandler.Sync(this);
							switch (TokenStream.LA(1)) {
							case GLOBAL:
								{
								State = 2927; global_partitioned_index();
								}
								break;
							case LOCAL:
								{
								State = 2928; local_partitioned_index();
								}
								break;
							default:
								throw new NoViableAltException(this);
							}
							}
							break;
						case COMPRESS:
						case FILESYSTEM_LIKE_LOGGING:
						case INDEXING:
						case INITRANS:
						case INVISIBLE:
						case LOGGING:
						case MAXTRANS:
						case NOCOMPRESS:
						case NOLOGGING:
						case NOPARALLEL:
						case NOSORT:
						case ONLINE:
						case PARALLEL:
						case PCTFREE:
						case PCTUSED:
						case REVERSE:
						case SORT:
						case STORAGE:
						case TABLESPACE:
						case VISIBLE:
							{
							State = 2932;
							ErrorHandler.Sync(this);
							_alt = 1;
							do {
								switch (_alt) {
								case 1:
									{
									{
									State = 2931; index_attributes();
									}
									}
									break;
								default:
									throw new NoViableAltException(this);
								}
								State = 2934;
								ErrorHandler.Sync(this);
								_alt = Interpreter.AdaptivePredict(TokenStream,277,Context);
							} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2938;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,279,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case INDEXTYPE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2940; Match(INDEXTYPE);
				State = 2941; Match(IS);
				State = 2944;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,280,Context) ) {
				case 1:
					{
					State = 2942; domain_index_clause();
					}
					break;
				case 2:
					{
					State = 2943; xmlindex_clause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Global_partitioned_indexContext : ParserRuleContext {
		public ITerminalNode GLOBAL() { return GetToken(PlSqlParser.GLOBAL, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Index_partitioning_clauseContext index_partitioning_clause() {
			return GetRuleContext<Index_partitioning_clauseContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Individual_hash_partitionsContext individual_hash_partitions() {
			return GetRuleContext<Individual_hash_partitionsContext>(0);
		}
		public Hash_partitions_by_quantityContext hash_partitions_by_quantity() {
			return GetRuleContext<Hash_partitions_by_quantityContext>(0);
		}
		public Global_partitioned_indexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_global_partitioned_index; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobal_partitioned_index(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Global_partitioned_indexContext global_partitioned_index() {
		Global_partitioned_indexContext _localctx = new Global_partitioned_indexContext(Context, State);
		EnterRule(_localctx, 244, RULE_global_partitioned_index);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2948; Match(GLOBAL);
			State = 2949; Match(PARTITION);
			State = 2950; Match(BY);
			State = 2963;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RANGE:
				{
				State = 2951; Match(RANGE);
				State = 2952; paren_column_list();
				State = 2953; Match(LEFT_PAREN);
				State = 2954; index_partitioning_clause();
				State = 2955; Match(RIGHT_PAREN);
				}
				break;
			case HASH:
				{
				State = 2957; Match(HASH);
				State = 2958; paren_column_list();
				State = 2961;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LEFT_PAREN:
					{
					State = 2959; individual_hash_partitions();
					}
					break;
				case PARTITIONS:
					{
					State = 2960; hash_partitions_by_quantity();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Individual_hash_partitionsContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Partition_clauseContext[] partition_clause() {
			return GetRuleContexts<Partition_clauseContext>();
		}
		public Partition_clauseContext partition_clause(int i) {
			return GetRuleContext<Partition_clauseContext>(i);
		}
		public Partitioning_storage_clauseContext[] partitioning_storage_clause() {
			return GetRuleContexts<Partitioning_storage_clauseContext>();
		}
		public Partitioning_storage_clauseContext partitioning_storage_clause(int i) {
			return GetRuleContext<Partitioning_storage_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Indexing_clauseContext[] indexing_clause() {
			return GetRuleContexts<Indexing_clauseContext>();
		}
		public Indexing_clauseContext indexing_clause(int i) {
			return GetRuleContext<Indexing_clauseContext>(i);
		}
		public Individual_hash_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_individual_hash_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndividual_hash_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Individual_hash_partitionsContext individual_hash_partitions() {
		Individual_hash_partitionsContext _localctx = new Individual_hash_partitionsContext(Context, State);
		EnterRule(_localctx, 246, RULE_individual_hash_partitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2965; Match(LEFT_PAREN);
			State = 2975;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2967;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2966; Match(COMMA);
					}
				}

				{
				State = 2969; partition_clause();
				State = 2971;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEXING) {
					{
					State = 2970; indexing_clause();
					}
				}

				State = 2973; partitioning_storage_clause();
				}
				}
				}
				State = 2977;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==PARTITION || _la==COMMA );
			State = 2979; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_partitioning_clauseContext : ParserRuleContext {
		public Partition_clause_optionalContext partition_clause_optional() {
			return GetRuleContext<Partition_clause_optionalContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode LESS() { return GetToken(PlSqlParser.LESS, 0); }
		public ITerminalNode THAN() { return GetToken(PlSqlParser.THAN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Segment_attributes_clauseContext segment_attributes_clause() {
			return GetRuleContext<Segment_attributes_clauseContext>(0);
		}
		public Index_partitioning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_partitioning_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_partitioning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_partitioning_clauseContext index_partitioning_clause() {
		Index_partitioning_clauseContext _localctx = new Index_partitioning_clauseContext(Context, State);
		EnterRule(_localctx, 248, RULE_index_partitioning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2981; partition_clause_optional();
			State = 2982; Match(VALUES);
			State = 2983; Match(LESS);
			State = 2984; Match(THAN);
			State = 2985; Match(LEFT_PAREN);
			State = 2986; literal();
			State = 2991;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2987; Match(COMMA);
				State = 2988; literal();
				}
				}
				State = 2993;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2994; Match(RIGHT_PAREN);
			State = 2996;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 2995; segment_attributes_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Segment_attributes_clauseContext : ParserRuleContext {
		public Physical_attributes_clausesContext[] physical_attributes_clauses() {
			return GetRuleContexts<Physical_attributes_clausesContext>();
		}
		public Physical_attributes_clausesContext physical_attributes_clauses(int i) {
			return GetRuleContext<Physical_attributes_clausesContext>(i);
		}
		public Tablespace_clauseContext[] tablespace_clause() {
			return GetRuleContexts<Tablespace_clauseContext>();
		}
		public Tablespace_clauseContext tablespace_clause(int i) {
			return GetRuleContext<Tablespace_clauseContext>(i);
		}
		public Logging_clauseContext[] logging_clause() {
			return GetRuleContexts<Logging_clauseContext>();
		}
		public Logging_clauseContext logging_clause(int i) {
			return GetRuleContext<Logging_clauseContext>(i);
		}
		public Segment_attributes_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_segment_attributes_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSegment_attributes_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Segment_attributes_clauseContext segment_attributes_clause() {
		Segment_attributes_clauseContext _localctx = new Segment_attributes_clauseContext(Context, State);
		EnterRule(_localctx, 250, RULE_segment_attributes_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3001;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 3001;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case INITRANS:
					case MAXTRANS:
					case PCTFREE:
					case PCTUSED:
					case STORAGE:
						{
						State = 2998; physical_attributes_clauses();
						}
						break;
					case TABLESPACE:
						{
						State = 2999; tablespace_clause();
						}
						break;
					case FILESYSTEM_LIKE_LOGGING:
					case LOGGING:
					case NOLOGGING:
						{
						State = 3000; logging_clause();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3003;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,290,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_attributesContext : ParserRuleContext {
		public Physical_attributes_clausesContext physical_attributes_clauses() {
			return GetRuleContext<Physical_attributes_clausesContext>(0);
		}
		public Logging_clauseContext logging_clause() {
			return GetRuleContext<Logging_clauseContext>(0);
		}
		public ITerminalNode ONLINE() { return GetToken(PlSqlParser.ONLINE, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(PlSqlParser.TABLESPACE, 0); }
		public Tablespace_nameContext tablespace_name() {
			return GetRuleContext<Tablespace_nameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Advanced_index_compressionContext advanced_index_compression() {
			return GetRuleContext<Advanced_index_compressionContext>(0);
		}
		public ITerminalNode SORT() { return GetToken(PlSqlParser.SORT, 0); }
		public ITerminalNode NOSORT() { return GetToken(PlSqlParser.NOSORT, 0); }
		public ITerminalNode REVERSE() { return GetToken(PlSqlParser.REVERSE, 0); }
		public ITerminalNode VISIBLE() { return GetToken(PlSqlParser.VISIBLE, 0); }
		public ITerminalNode INVISIBLE() { return GetToken(PlSqlParser.INVISIBLE, 0); }
		public Partial_index_clauseContext partial_index_clause() {
			return GetRuleContext<Partial_index_clauseContext>(0);
		}
		public Parallel_clauseContext parallel_clause() {
			return GetRuleContext<Parallel_clauseContext>(0);
		}
		public Index_attributesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_attributes; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_attributes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_attributesContext index_attributes() {
		Index_attributesContext _localctx = new Index_attributesContext(Context, State);
		EnterRule(_localctx, 252, RULE_index_attributes);
		int _la;
		try {
			State = 3019;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITRANS:
			case MAXTRANS:
			case PCTFREE:
			case PCTUSED:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3005; physical_attributes_clauses();
				}
				break;
			case FILESYSTEM_LIKE_LOGGING:
			case LOGGING:
			case NOLOGGING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3006; logging_clause();
				}
				break;
			case ONLINE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3007; Match(ONLINE);
				}
				break;
			case TABLESPACE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3008; Match(TABLESPACE);
				State = 3011;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case REGULAR_ID:
					{
					State = 3009; tablespace_name();
					}
					break;
				case DEFAULT:
					{
					State = 3010; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3013; advanced_index_compression();
				}
				break;
			case NOSORT:
			case SORT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3014;
				_la = TokenStream.LA(1);
				if ( !(_la==NOSORT || _la==SORT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case REVERSE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3015; Match(REVERSE);
				}
				break;
			case INVISIBLE:
			case VISIBLE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3016;
				_la = TokenStream.LA(1);
				if ( !(_la==INVISIBLE || _la==VISIBLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case INDEXING:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3017; partial_index_clause();
				}
				break;
			case NOPARALLEL:
			case PARALLEL:
				EnterOuterAlt(_localctx, 10);
				{
				State = 3018; parallel_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Physical_attributes_clausesContext : ParserRuleContext {
		public Physical_attributes_clauseContext[] physical_attributes_clause() {
			return GetRuleContexts<Physical_attributes_clauseContext>();
		}
		public Physical_attributes_clauseContext physical_attributes_clause(int i) {
			return GetRuleContext<Physical_attributes_clauseContext>(i);
		}
		public Physical_attributes_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physical_attributes_clauses; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPhysical_attributes_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Physical_attributes_clausesContext physical_attributes_clauses() {
		Physical_attributes_clausesContext _localctx = new Physical_attributes_clausesContext(Context, State);
		EnterRule(_localctx, 254, RULE_physical_attributes_clauses);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3022;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 3021; physical_attributes_clause();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3024;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,293,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Physical_attributes_clauseContext : ParserRuleContext {
		public ITerminalNode PCTFREE() { return GetToken(PlSqlParser.PCTFREE, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode PCTUSED() { return GetToken(PlSqlParser.PCTUSED, 0); }
		public ITerminalNode INITRANS() { return GetToken(PlSqlParser.INITRANS, 0); }
		public ITerminalNode MAXTRANS() { return GetToken(PlSqlParser.MAXTRANS, 0); }
		public Storage_clausesContext storage_clauses() {
			return GetRuleContext<Storage_clausesContext>(0);
		}
		public Physical_attributes_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physical_attributes_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPhysical_attributes_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Physical_attributes_clauseContext physical_attributes_clause() {
		Physical_attributes_clauseContext _localctx = new Physical_attributes_clauseContext(Context, State);
		EnterRule(_localctx, 256, RULE_physical_attributes_clause);
		try {
			State = 3035;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PCTFREE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3026; Match(PCTFREE);
				State = 3027; integer();
				}
				break;
			case PCTUSED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3028; Match(PCTUSED);
				State = 3029; integer();
				}
				break;
			case INITRANS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3030; Match(INITRANS);
				State = 3031; integer();
				}
				break;
			case MAXTRANS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3032; Match(MAXTRANS);
				State = 3033; integer();
				}
				break;
			case STORAGE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3034; storage_clauses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hash_partitions_by_quantityContext : ParserRuleContext {
		public ITerminalNode PARTITIONS() { return GetToken(PlSqlParser.PARTITIONS, 0); }
		public Hash_partition_quantityContext hash_partition_quantity() {
			return GetRuleContext<Hash_partition_quantityContext>(0);
		}
		public ITerminalNode[] STORE() { return GetTokens(PlSqlParser.STORE); }
		public ITerminalNode STORE(int i) {
			return GetToken(PlSqlParser.STORE, i);
		}
		public ITerminalNode[] IN() { return GetTokens(PlSqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(PlSqlParser.IN, i);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public Table_compressionContext table_compression() {
			return GetRuleContext<Table_compressionContext>(0);
		}
		public Index_compressionContext index_compression() {
			return GetRuleContext<Index_compressionContext>(0);
		}
		public ITerminalNode OVERFLOW() { return GetToken(PlSqlParser.OVERFLOW, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Hash_partitions_by_quantityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hash_partitions_by_quantity; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHash_partitions_by_quantity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hash_partitions_by_quantityContext hash_partitions_by_quantity() {
		Hash_partitions_by_quantityContext _localctx = new Hash_partitions_by_quantityContext(Context, State);
		EnterRule(_localctx, 258, RULE_hash_partitions_by_quantity);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3037; Match(PARTITIONS);
			State = 3038; hash_partition_quantity();
			State = 3052;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,296,Context) ) {
			case 1:
				{
				State = 3039; Match(STORE);
				State = 3040; Match(IN);
				State = 3041; Match(LEFT_PAREN);
				State = 3042; tablespace_name();
				State = 3047;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3043; Match(COMMA);
					State = 3044; tablespace_name();
					}
					}
					State = 3049;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3050; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3056;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,297,Context) ) {
			case 1:
				{
				State = 3054; table_compression();
				}
				break;
			case 2:
				{
				State = 3055; index_compression();
				}
				break;
			}
			State = 3072;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERFLOW) {
				{
				State = 3058; Match(OVERFLOW);
				State = 3059; Match(STORE);
				State = 3060; Match(IN);
				State = 3061; Match(LEFT_PAREN);
				State = 3062; tablespace_name();
				State = 3067;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3063; Match(COMMA);
					State = 3064; tablespace_name();
					}
					}
					State = 3069;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3070; Match(RIGHT_PAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Local_partitioned_indexContext : ParserRuleContext {
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public On_range_partitioned_tableContext on_range_partitioned_table() {
			return GetRuleContext<On_range_partitioned_tableContext>(0);
		}
		public On_list_partitioned_tableContext on_list_partitioned_table() {
			return GetRuleContext<On_list_partitioned_tableContext>(0);
		}
		public On_hash_partitioned_tableContext on_hash_partitioned_table() {
			return GetRuleContext<On_hash_partitioned_tableContext>(0);
		}
		public On_comp_partitioned_tableContext on_comp_partitioned_table() {
			return GetRuleContext<On_comp_partitioned_tableContext>(0);
		}
		public Local_partitioned_indexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_local_partitioned_index; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLocal_partitioned_index(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Local_partitioned_indexContext local_partitioned_index() {
		Local_partitioned_indexContext _localctx = new Local_partitioned_indexContext(Context, State);
		EnterRule(_localctx, 260, RULE_local_partitioned_index);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3074; Match(LOCAL);
			State = 3079;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,300,Context) ) {
			case 1:
				{
				State = 3075; on_range_partitioned_table();
				}
				break;
			case 2:
				{
				State = 3076; on_list_partitioned_table();
				}
				break;
			case 3:
				{
				State = 3077; on_hash_partitioned_table();
				}
				break;
			case 4:
				{
				State = 3078; on_comp_partitioned_table();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class On_range_partitioned_tableContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Partition_clause_optionalContext partition_clause_optional() {
			return GetRuleContext<Partition_clause_optionalContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] UNUSABLE() { return GetTokens(PlSqlParser.UNUSABLE); }
		public ITerminalNode UNUSABLE(int i) {
			return GetToken(PlSqlParser.UNUSABLE, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode[] PARTITION() { return GetTokens(PlSqlParser.PARTITION); }
		public ITerminalNode PARTITION(int i) {
			return GetToken(PlSqlParser.PARTITION, i);
		}
		public Segment_attributes_clauseContext[] segment_attributes_clause() {
			return GetRuleContexts<Segment_attributes_clauseContext>();
		}
		public Segment_attributes_clauseContext segment_attributes_clause(int i) {
			return GetRuleContext<Segment_attributes_clauseContext>(i);
		}
		public Index_compressionContext[] index_compression() {
			return GetRuleContexts<Index_compressionContext>();
		}
		public Index_compressionContext index_compression(int i) {
			return GetRuleContext<Index_compressionContext>(i);
		}
		public Partition_nameContext[] partition_name() {
			return GetRuleContexts<Partition_nameContext>();
		}
		public Partition_nameContext partition_name(int i) {
			return GetRuleContext<Partition_nameContext>(i);
		}
		public On_range_partitioned_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_on_range_partitioned_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOn_range_partitioned_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public On_range_partitioned_tableContext on_range_partitioned_table() {
		On_range_partitioned_tableContext _localctx = new On_range_partitioned_tableContext(Context, State);
		EnterRule(_localctx, 262, RULE_on_range_partitioned_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3081; Match(LEFT_PAREN);
			State = 3082; partition_clause_optional();
			State = 3089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 3085;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 3085;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FILESYSTEM_LIKE_LOGGING:
					case INITRANS:
					case LOGGING:
					case MAXTRANS:
					case NOLOGGING:
					case PCTFREE:
					case PCTUSED:
					case STORAGE:
					case TABLESPACE:
						{
						State = 3083; segment_attributes_clause();
						}
						break;
					case COMPRESS:
					case NOCOMPRESS:
						{
						State = 3084; index_compression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 3087;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
				}
			}

			State = 3092;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE) {
				{
				State = 3091; Match(UNUSABLE);
				}
			}

			State = 3112;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3094; Match(COMMA);
				State = 3095; Match(PARTITION);
				State = 3097;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
					{
					State = 3096; partition_name();
					}
				}

				State = 3105;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 3101;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						State = 3101;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 3099; segment_attributes_clause();
							}
							break;
						case COMPRESS:
						case NOCOMPRESS:
							{
							State = 3100; index_compression();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						State = 3103;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
					}
				}

				State = 3108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNUSABLE) {
					{
					State = 3107; Match(UNUSABLE);
					}
				}

				}
				}
				State = 3114;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3115; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class On_list_partitioned_tableContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Partition_clause_optionalContext[] partition_clause_optional() {
			return GetRuleContexts<Partition_clause_optionalContext>();
		}
		public Partition_clause_optionalContext partition_clause_optional(int i) {
			return GetRuleContext<Partition_clause_optionalContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Usable_clauseContext[] usable_clause() {
			return GetRuleContexts<Usable_clauseContext>();
		}
		public Usable_clauseContext usable_clause(int i) {
			return GetRuleContext<Usable_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Segment_attributes_clauseContext[] segment_attributes_clause() {
			return GetRuleContexts<Segment_attributes_clauseContext>();
		}
		public Segment_attributes_clauseContext segment_attributes_clause(int i) {
			return GetRuleContext<Segment_attributes_clauseContext>(i);
		}
		public Index_compressionContext[] index_compression() {
			return GetRuleContexts<Index_compressionContext>();
		}
		public Index_compressionContext index_compression(int i) {
			return GetRuleContext<Index_compressionContext>(i);
		}
		public On_list_partitioned_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_on_list_partitioned_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOn_list_partitioned_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public On_list_partitioned_tableContext on_list_partitioned_table() {
		On_list_partitioned_tableContext _localctx = new On_list_partitioned_tableContext(Context, State);
		EnterRule(_localctx, 264, RULE_on_list_partitioned_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3117; Match(LEFT_PAREN);
			State = 3118; partition_clause_optional();
			State = 3125;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 3121;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 3121;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FILESYSTEM_LIKE_LOGGING:
					case INITRANS:
					case LOGGING:
					case MAXTRANS:
					case NOLOGGING:
					case PCTFREE:
					case PCTUSED:
					case STORAGE:
					case TABLESPACE:
						{
						State = 3119; segment_attributes_clause();
						}
						break;
					case COMPRESS:
					case NOCOMPRESS:
						{
						State = 3120; index_compression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 3123;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
				}
			}

			State = 3128;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE || _la==USABLE) {
				{
				State = 3127; usable_clause();
				}
			}

			State = 3145;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3130; Match(COMMA);
				State = 3131; partition_clause_optional();
				State = 3138;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 3134;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						State = 3134;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 3132; segment_attributes_clause();
							}
							break;
						case COMPRESS:
						case NOCOMPRESS:
							{
							State = 3133; index_compression();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						State = 3136;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
					}
				}

				State = 3141;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNUSABLE || _la==USABLE) {
					{
					State = 3140; usable_clause();
					}
				}

				}
				}
				State = 3147;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3148; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class On_hash_partitioned_tableContext : ParserRuleContext {
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Partition_clause_optionalContext[] partition_clause_optional() {
			return GetRuleContexts<Partition_clause_optionalContext>();
		}
		public Partition_clause_optionalContext partition_clause_optional(int i) {
			return GetRuleContext<Partition_clause_optionalContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Tablespace_clauseContext[] tablespace_clause() {
			return GetRuleContexts<Tablespace_clauseContext>();
		}
		public Tablespace_clauseContext tablespace_clause(int i) {
			return GetRuleContext<Tablespace_clauseContext>(i);
		}
		public Advanced_index_compressionContext[] advanced_index_compression() {
			return GetRuleContexts<Advanced_index_compressionContext>();
		}
		public Advanced_index_compressionContext advanced_index_compression(int i) {
			return GetRuleContext<Advanced_index_compressionContext>(i);
		}
		public Usable_clauseContext[] usable_clause() {
			return GetRuleContexts<Usable_clauseContext>();
		}
		public Usable_clauseContext usable_clause(int i) {
			return GetRuleContext<Usable_clauseContext>(i);
		}
		public On_hash_partitioned_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_on_hash_partitioned_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOn_hash_partitioned_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public On_hash_partitioned_tableContext on_hash_partitioned_table() {
		On_hash_partitioned_tableContext _localctx = new On_hash_partitioned_tableContext(Context, State);
		EnterRule(_localctx, 266, RULE_on_hash_partitioned_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3192;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STORE:
				{
				State = 3150; Match(STORE);
				State = 3151; Match(IN);
				State = 3152; Match(LEFT_PAREN);
				State = 3153; tablespace_name();
				State = 3158;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3154; Match(COMMA);
					State = 3155; tablespace_name();
					}
					}
					State = 3160;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3161; Match(RIGHT_PAREN);
				}
				break;
			case LEFT_PAREN:
				{
				State = 3163; Match(LEFT_PAREN);
				State = 3164; partition_clause_optional();
				State = 3166;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TABLESPACE) {
					{
					State = 3165; tablespace_clause();
					}
				}

				State = 3169;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPRESS || _la==NOCOMPRESS) {
					{
					State = 3168; advanced_index_compression();
					}
				}

				State = 3172;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNUSABLE || _la==USABLE) {
					{
					State = 3171; usable_clause();
					}
				}

				State = 3187;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3174; Match(COMMA);
					State = 3175; partition_clause_optional();
					State = 3177;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==TABLESPACE) {
						{
						State = 3176; tablespace_clause();
						}
					}

					State = 3180;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMPRESS || _la==NOCOMPRESS) {
						{
						State = 3179; advanced_index_compression();
						}
					}

					State = 3183;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==UNUSABLE || _la==USABLE) {
						{
						State = 3182; usable_clause();
						}
					}

					}
					}
					State = 3189;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3190; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class On_comp_partitioned_tableContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Partition_clause_optionalContext[] partition_clause_optional() {
			return GetRuleContexts<Partition_clause_optionalContext>();
		}
		public Partition_clause_optionalContext partition_clause_optional(int i) {
			return GetRuleContext<Partition_clause_optionalContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Store_inContext store_in() {
			return GetRuleContext<Store_inContext>(0);
		}
		public Usable_clauseContext[] usable_clause() {
			return GetRuleContexts<Usable_clauseContext>();
		}
		public Usable_clauseContext usable_clause(int i) {
			return GetRuleContext<Usable_clauseContext>(i);
		}
		public Index_subpartition_clauseContext[] index_subpartition_clause() {
			return GetRuleContexts<Index_subpartition_clauseContext>();
		}
		public Index_subpartition_clauseContext index_subpartition_clause(int i) {
			return GetRuleContext<Index_subpartition_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Segment_attributes_clauseContext[] segment_attributes_clause() {
			return GetRuleContexts<Segment_attributes_clauseContext>();
		}
		public Segment_attributes_clauseContext segment_attributes_clause(int i) {
			return GetRuleContext<Segment_attributes_clauseContext>(i);
		}
		public Advanced_index_compressionContext[] advanced_index_compression() {
			return GetRuleContexts<Advanced_index_compressionContext>();
		}
		public Advanced_index_compressionContext advanced_index_compression(int i) {
			return GetRuleContext<Advanced_index_compressionContext>(i);
		}
		public On_comp_partitioned_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_on_comp_partitioned_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOn_comp_partitioned_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public On_comp_partitioned_tableContext on_comp_partitioned_table() {
		On_comp_partitioned_tableContext _localctx = new On_comp_partitioned_tableContext(Context, State);
		EnterRule(_localctx, 268, RULE_on_comp_partitioned_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 3194; store_in();
				}
			}

			State = 3197; Match(LEFT_PAREN);
			State = 3198; partition_clause_optional();
			State = 3205;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 3201;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 3201;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FILESYSTEM_LIKE_LOGGING:
					case INITRANS:
					case LOGGING:
					case MAXTRANS:
					case NOLOGGING:
					case PCTFREE:
					case PCTUSED:
					case STORAGE:
					case TABLESPACE:
						{
						State = 3199; segment_attributes_clause();
						}
						break;
					case COMPRESS:
					case NOCOMPRESS:
						{
						State = 3200; advanced_index_compression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 3203;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
				}
			}

			State = 3208;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE || _la==USABLE) {
				{
				State = 3207; usable_clause();
				}
			}

			State = 3211;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE || _la==LEFT_PAREN) {
				{
				State = 3210; index_subpartition_clause();
				}
			}

			State = 3231;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3213; Match(COMMA);
				State = 3214; partition_clause_optional();
				State = 3221;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 3217;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						State = 3217;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FILESYSTEM_LIKE_LOGGING:
						case INITRANS:
						case LOGGING:
						case MAXTRANS:
						case NOLOGGING:
						case PCTFREE:
						case PCTUSED:
						case STORAGE:
						case TABLESPACE:
							{
							State = 3215; segment_attributes_clause();
							}
							break;
						case COMPRESS:
						case NOCOMPRESS:
							{
							State = 3216; advanced_index_compression();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						State = 3219;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==COMPRESS || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOCOMPRESS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE );
					}
				}

				State = 3224;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNUSABLE || _la==USABLE) {
					{
					State = 3223; usable_clause();
					}
				}

				State = 3227;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORE || _la==LEFT_PAREN) {
					{
					State = 3226; index_subpartition_clause();
					}
				}

				}
				}
				State = 3233;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3234; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmltable_index_clauseContext : ParserRuleContext {
		public ITerminalNode EMPTY() { return GetToken(PlSqlParser.EMPTY, 0); }
		public Xmltable_index_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmltable_index_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmltable_index_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmltable_index_clauseContext xmltable_index_clause() {
		Xmltable_index_clauseContext _localctx = new Xmltable_index_clauseContext(Context, State);
		EnterRule(_localctx, 270, RULE_xmltable_index_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3236; Match(EMPTY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlindex_clauseContext : ParserRuleContext {
		public ITerminalNode EMPTY() { return GetToken(PlSqlParser.EMPTY, 0); }
		public Xmlindex_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlindex_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlindex_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlindex_clauseContext xmlindex_clause() {
		Xmlindex_clauseContext _localctx = new Xmlindex_clauseContext(Context, State);
		EnterRule(_localctx, 272, RULE_xmlindex_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3238; Match(EMPTY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_clauseContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public Partition_nameContext partition_name() {
			return GetRuleContext<Partition_nameContext>(0);
		}
		public Partition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_clauseContext partition_clause() {
		Partition_clauseContext _localctx = new Partition_clauseContext(Context, State);
		EnterRule(_localctx, 274, RULE_partition_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3240; Match(PARTITION);
			State = 3241; partition_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_clause_optionalContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public Partition_nameContext partition_name() {
			return GetRuleContext<Partition_nameContext>(0);
		}
		public Partition_clause_optionalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_clause_optional; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_clause_optional(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_clause_optionalContext partition_clause_optional() {
		Partition_clause_optionalContext _localctx = new Partition_clause_optionalContext(Context, State);
		EnterRule(_localctx, 276, RULE_partition_clause_optional);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3243; Match(PARTITION);
			State = 3245;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,341,Context) ) {
			case 1:
				{
				State = 3244; partition_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Indexing_clauseContext : ParserRuleContext {
		public ITerminalNode INDEXING() { return GetToken(PlSqlParser.INDEXING, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode OFF() { return GetToken(PlSqlParser.OFF, 0); }
		public Indexing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexing_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Indexing_clauseContext indexing_clause() {
		Indexing_clauseContext _localctx = new Indexing_clauseContext(Context, State);
		EnterRule(_localctx, 278, RULE_indexing_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3247; Match(INDEXING);
			State = 3248;
			_la = TokenStream.LA(1);
			if ( !(_la==OFF || _la==ON) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partitioning_storage_clauseContext : ParserRuleContext {
		public Tablespace_clauseContext[] tablespace_clause() {
			return GetRuleContexts<Tablespace_clauseContext>();
		}
		public Tablespace_clauseContext tablespace_clause(int i) {
			return GetRuleContext<Tablespace_clauseContext>(i);
		}
		public ITerminalNode[] OVERFLOW() { return GetTokens(PlSqlParser.OVERFLOW); }
		public ITerminalNode OVERFLOW(int i) {
			return GetToken(PlSqlParser.OVERFLOW, i);
		}
		public Table_compressionContext[] table_compression() {
			return GetRuleContexts<Table_compressionContext>();
		}
		public Table_compressionContext table_compression(int i) {
			return GetRuleContext<Table_compressionContext>(i);
		}
		public Index_compressionContext[] index_compression() {
			return GetRuleContexts<Index_compressionContext>();
		}
		public Index_compressionContext index_compression(int i) {
			return GetRuleContext<Index_compressionContext>(i);
		}
		public Inmemory_clauseContext[] inmemory_clause() {
			return GetRuleContexts<Inmemory_clauseContext>();
		}
		public Inmemory_clauseContext inmemory_clause(int i) {
			return GetRuleContext<Inmemory_clauseContext>(i);
		}
		public Lob_partitioning_storageContext[] lob_partitioning_storage() {
			return GetRuleContexts<Lob_partitioning_storageContext>();
		}
		public Lob_partitioning_storageContext lob_partitioning_storage(int i) {
			return GetRuleContext<Lob_partitioning_storageContext>(i);
		}
		public ITerminalNode[] VARRAY() { return GetTokens(PlSqlParser.VARRAY); }
		public ITerminalNode VARRAY(int i) {
			return GetToken(PlSqlParser.VARRAY, i);
		}
		public Varray_itemContext[] varray_item() {
			return GetRuleContexts<Varray_itemContext>();
		}
		public Varray_itemContext varray_item(int i) {
			return GetRuleContext<Varray_itemContext>(i);
		}
		public ITerminalNode[] STORE() { return GetTokens(PlSqlParser.STORE); }
		public ITerminalNode STORE(int i) {
			return GetToken(PlSqlParser.STORE, i);
		}
		public ITerminalNode[] AS() { return GetTokens(PlSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlSqlParser.AS, i);
		}
		public ITerminalNode[] LOB() { return GetTokens(PlSqlParser.LOB); }
		public ITerminalNode LOB(int i) {
			return GetToken(PlSqlParser.LOB, i);
		}
		public Lob_segnameContext[] lob_segname() {
			return GetRuleContexts<Lob_segnameContext>();
		}
		public Lob_segnameContext lob_segname(int i) {
			return GetRuleContext<Lob_segnameContext>(i);
		}
		public ITerminalNode[] SECUREFILE() { return GetTokens(PlSqlParser.SECUREFILE); }
		public ITerminalNode SECUREFILE(int i) {
			return GetToken(PlSqlParser.SECUREFILE, i);
		}
		public ITerminalNode[] BASICFILE() { return GetTokens(PlSqlParser.BASICFILE); }
		public ITerminalNode BASICFILE(int i) {
			return GetToken(PlSqlParser.BASICFILE, i);
		}
		public Partitioning_storage_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitioning_storage_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitioning_storage_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partitioning_storage_clauseContext partitioning_storage_clause() {
		Partitioning_storage_clauseContext _localctx = new Partitioning_storage_clauseContext(Context, State);
		EnterRule(_localctx, 280, RULE_partitioning_storage_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3269;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 3269;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,344,Context) ) {
					case 1:
						{
						State = 3250; tablespace_clause();
						}
						break;
					case 2:
						{
						State = 3251; Match(OVERFLOW);
						State = 3253;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,342,Context) ) {
						case 1:
							{
							State = 3252; tablespace_clause();
							}
							break;
						}
						}
						break;
					case 3:
						{
						State = 3255; table_compression();
						}
						break;
					case 4:
						{
						State = 3256; index_compression();
						}
						break;
					case 5:
						{
						State = 3257; inmemory_clause();
						}
						break;
					case 6:
						{
						State = 3258; lob_partitioning_storage();
						}
						break;
					case 7:
						{
						State = 3259; Match(VARRAY);
						State = 3260; varray_item();
						State = 3261; Match(STORE);
						State = 3262; Match(AS);
						State = 3264;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==BASICFILE || _la==SECUREFILE) {
							{
							State = 3263;
							_la = TokenStream.LA(1);
							if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
							ErrorHandler.RecoverInline(this);
							}
							else {
								ErrorHandler.ReportMatch(this);
							    Consume();
							}
							}
						}

						State = 3266; Match(LOB);
						State = 3267; lob_segname();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3271;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,345,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_table_clauseContext : ParserRuleContext {
		public ITerminalNode INMEMORY() { return GetToken(PlSqlParser.INMEMORY, 0); }
		public Inmemory_parametersContext inmemory_parameters() {
			return GetRuleContext<Inmemory_parametersContext>(0);
		}
		public Inmemory_column_clauseContext inmemory_column_clause() {
			return GetRuleContext<Inmemory_column_clauseContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Inmemory_table_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_table_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_table_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_table_clauseContext inmemory_table_clause() {
		Inmemory_table_clauseContext _localctx = new Inmemory_table_clauseContext(Context, State);
		EnterRule(_localctx, 282, RULE_inmemory_table_clause);
		try {
			State = 3281;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INMEMORY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3273; Match(INMEMORY);
				State = 3277;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,346,Context) ) {
				case 1:
					{
					State = 3274; inmemory_parameters();
					State = 3275; inmemory_column_clause();
					}
					break;
				}
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3279; Match(NO);
				State = 3280; Match(INMEMORY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_column_clauseContext : ParserRuleContext {
		public ITerminalNode INMEMORY() { return GetToken(PlSqlParser.INMEMORY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Inmemory_memcompressContext inmemory_memcompress() {
			return GetRuleContext<Inmemory_memcompressContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Inmemory_column_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_column_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_column_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_column_clauseContext inmemory_column_clause() {
		Inmemory_column_clauseContext _localctx = new Inmemory_column_clauseContext(Context, State);
		EnterRule(_localctx, 284, RULE_inmemory_column_clause);
		int _la;
		try {
			State = 3290;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INMEMORY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3283; Match(INMEMORY);
				State = 3285;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MEMCOMPRESS || _la==NO) {
					{
					State = 3284; inmemory_memcompress();
					}
				}

				State = 3287; paren_column_list();
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3288; Match(NO);
				State = 3289; Match(INMEMORY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_clauseContext : ParserRuleContext {
		public ITerminalNode INMEMORY() { return GetToken(PlSqlParser.INMEMORY, 0); }
		public Inmemory_parametersContext inmemory_parameters() {
			return GetRuleContext<Inmemory_parametersContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Inmemory_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_clauseContext inmemory_clause() {
		Inmemory_clauseContext _localctx = new Inmemory_clauseContext(Context, State);
		EnterRule(_localctx, 286, RULE_inmemory_clause);
		try {
			State = 3296;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INMEMORY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3292; Match(INMEMORY);
				State = 3293; inmemory_parameters();
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3294; Match(NO);
				State = 3295; Match(INMEMORY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_parametersContext : ParserRuleContext {
		public Inmemory_memcompressContext inmemory_memcompress() {
			return GetRuleContext<Inmemory_memcompressContext>(0);
		}
		public Inmemory_priorityContext inmemory_priority() {
			return GetRuleContext<Inmemory_priorityContext>(0);
		}
		public Inmemory_distributeContext inmemory_distribute() {
			return GetRuleContext<Inmemory_distributeContext>(0);
		}
		public Inmemory_duplicateContext inmemory_duplicate() {
			return GetRuleContext<Inmemory_duplicateContext>(0);
		}
		public Inmemory_parametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_parameters; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_parameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_parametersContext inmemory_parameters() {
		Inmemory_parametersContext _localctx = new Inmemory_parametersContext(Context, State);
		EnterRule(_localctx, 288, RULE_inmemory_parameters);
		int _la;
		try {
			State = 3310;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,355,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3299;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,351,Context) ) {
				case 1:
					{
					State = 3298; inmemory_memcompress();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3302;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,352,Context) ) {
				case 1:
					{
					State = 3301; inmemory_priority();
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3305;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTRIBUTE) {
					{
					State = 3304; inmemory_distribute();
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3308;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,354,Context) ) {
				case 1:
					{
					State = 3307; inmemory_duplicate();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_memcompressContext : ParserRuleContext {
		public ITerminalNode MEMCOMPRESS() { return GetToken(PlSqlParser.MEMCOMPRESS, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode DML() { return GetToken(PlSqlParser.DML, 0); }
		public ITerminalNode QUERY() { return GetToken(PlSqlParser.QUERY, 0); }
		public ITerminalNode CAPACITY() { return GetToken(PlSqlParser.CAPACITY, 0); }
		public ITerminalNode LOW() { return GetToken(PlSqlParser.LOW, 0); }
		public ITerminalNode HIGH() { return GetToken(PlSqlParser.HIGH, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Inmemory_memcompressContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_memcompress; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_memcompress(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_memcompressContext inmemory_memcompress() {
		Inmemory_memcompressContext _localctx = new Inmemory_memcompressContext(Context, State);
		EnterRule(_localctx, 290, RULE_inmemory_memcompress);
		int _la;
		try {
			State = 3323;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MEMCOMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3312; Match(MEMCOMPRESS);
				State = 3313; Match(FOR);
				State = 3319;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DML:
					{
					State = 3314; Match(DML);
					}
					break;
				case CAPACITY:
				case QUERY:
					{
					State = 3315;
					_la = TokenStream.LA(1);
					if ( !(_la==CAPACITY || _la==QUERY) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 3317;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==HIGH || _la==LOW) {
						{
						State = 3316;
						_la = TokenStream.LA(1);
						if ( !(_la==HIGH || _la==LOW) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3321; Match(NO);
				State = 3322; Match(MEMCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_priorityContext : ParserRuleContext {
		public ITerminalNode PRIORITY() { return GetToken(PlSqlParser.PRIORITY, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public ITerminalNode LOW() { return GetToken(PlSqlParser.LOW, 0); }
		public ITerminalNode MEDIUM() { return GetToken(PlSqlParser.MEDIUM, 0); }
		public ITerminalNode HIGH() { return GetToken(PlSqlParser.HIGH, 0); }
		public ITerminalNode CRITICAL() { return GetToken(PlSqlParser.CRITICAL, 0); }
		public Inmemory_priorityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_priority; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_priority(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_priorityContext inmemory_priority() {
		Inmemory_priorityContext _localctx = new Inmemory_priorityContext(Context, State);
		EnterRule(_localctx, 292, RULE_inmemory_priority);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3325; Match(PRIORITY);
			State = 3326;
			_la = TokenStream.LA(1);
			if ( !(_la==CRITICAL || _la==HIGH || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (LOW - 323)) | (1L << (MEDIUM - 323)) | (1L << (NONE - 323)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_distributeContext : ParserRuleContext {
		public ITerminalNode DISTRIBUTE() { return GetToken(PlSqlParser.DISTRIBUTE, 0); }
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public Inmemory_distributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_distribute; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_distribute(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_distributeContext inmemory_distribute() {
		Inmemory_distributeContext _localctx = new Inmemory_distributeContext(Context, State);
		EnterRule(_localctx, 294, RULE_inmemory_distribute);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3328; Match(DISTRIBUTE);
			State = 3337;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,360,Context) ) {
			case 1:
				{
				State = 3329; Match(AUTO);
				}
				break;
			case 2:
				{
				{
				State = 3330; Match(BY);
				State = 3335;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ROWID:
					{
					State = 3331; Match(ROWID);
					State = 3332; Match(RANGE);
					}
					break;
				case PARTITION:
					{
					State = 3333; Match(PARTITION);
					}
					break;
				case SUBPARTITION:
					{
					State = 3334; Match(SUBPARTITION);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmemory_duplicateContext : ParserRuleContext {
		public ITerminalNode DUPLICATE() { return GetToken(PlSqlParser.DUPLICATE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Inmemory_duplicateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmemory_duplicate; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmemory_duplicate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inmemory_duplicateContext inmemory_duplicate() {
		Inmemory_duplicateContext _localctx = new Inmemory_duplicateContext(Context, State);
		EnterRule(_localctx, 296, RULE_inmemory_duplicate);
		int _la;
		try {
			State = 3345;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DUPLICATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3339; Match(DUPLICATE);
				State = 3341;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL) {
					{
					State = 3340; Match(ALL);
					}
				}

				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3343; Match(NO);
				State = 3344; Match(DUPLICATE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_compressionContext : ParserRuleContext {
		public ITerminalNode COMPRESS() { return GetToken(PlSqlParser.COMPRESS, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode BASIC() { return GetToken(PlSqlParser.BASIC, 0); }
		public ITerminalNode ADVANCED() { return GetToken(PlSqlParser.ADVANCED, 0); }
		public ITerminalNode COLUMN() { return GetToken(PlSqlParser.COLUMN, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlSqlParser.LEVEL, 0); }
		public ITerminalNode LOCKING() { return GetToken(PlSqlParser.LOCKING, 0); }
		public ITerminalNode QUERY() { return GetToken(PlSqlParser.QUERY, 0); }
		public ITerminalNode ARCHIVE() { return GetToken(PlSqlParser.ARCHIVE, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode LOW() { return GetToken(PlSqlParser.LOW, 0); }
		public ITerminalNode HIGH() { return GetToken(PlSqlParser.HIGH, 0); }
		public Table_compressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_compression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_compression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_compressionContext table_compression() {
		Table_compressionContext _localctx = new Table_compressionContext(Context, State);
		EnterRule(_localctx, 298, RULE_table_compression);
		int _la;
		try {
			State = 3374;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3347; Match(COMPRESS);
				}
				break;
			case ROW:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3348; Match(ROW);
				State = 3349; Match(STORE);
				State = 3350; Match(COMPRESS);
				State = 3352;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ADVANCED || _la==BASIC) {
					{
					State = 3351;
					_la = TokenStream.LA(1);
					if ( !(_la==ADVANCED || _la==BASIC) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case COLUMN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3354; Match(COLUMN);
				State = 3355; Match(STORE);
				State = 3356; Match(COMPRESS);
				State = 3362;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 3357; Match(FOR);
					State = 3358;
					_la = TokenStream.LA(1);
					if ( !(_la==ARCHIVE || _la==QUERY) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 3360;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==HIGH || _la==LOW) {
						{
						State = 3359;
						_la = TokenStream.LA(1);
						if ( !(_la==HIGH || _la==LOW) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					}
				}

				State = 3370;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,367,Context) ) {
				case 1:
					{
					State = 3365;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 3364; Match(NO);
						}
					}

					State = 3367; Match(ROW);
					State = 3368; Match(LEVEL);
					State = 3369; Match(LOCKING);
					}
					break;
				}
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3372; Match(NO);
				State = 3373; Match(COMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_compressionContext : ParserRuleContext {
		public Prefix_compressionContext prefix_compression() {
			return GetRuleContext<Prefix_compressionContext>(0);
		}
		public Advanced_index_compressionContext advanced_index_compression() {
			return GetRuleContext<Advanced_index_compressionContext>(0);
		}
		public Index_compressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_compression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_compression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_compressionContext index_compression() {
		Index_compressionContext _localctx = new Index_compressionContext(Context, State);
		EnterRule(_localctx, 300, RULE_index_compression);
		try {
			State = 3378;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,369,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3376; prefix_compression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3377; advanced_index_compression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prefix_compressionContext : ParserRuleContext {
		public ITerminalNode COMPRESS() { return GetToken(PlSqlParser.COMPRESS, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode NOCOMPRESS() { return GetToken(PlSqlParser.NOCOMPRESS, 0); }
		public Prefix_compressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prefix_compression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrefix_compression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prefix_compressionContext prefix_compression() {
		Prefix_compressionContext _localctx = new Prefix_compressionContext(Context, State);
		EnterRule(_localctx, 302, RULE_prefix_compression);
		int _la;
		try {
			State = 3385;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3380; Match(COMPRESS);
				State = 3382;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 746)) & ~0x3f) == 0 && ((1L << (_la - 746)) & ((1L << (UNSIGNED_INTEGER - 746)) | (1L << (APPROXIMATE_NUM_LIT - 746)) | (1L << (PLUS_SIGN - 746)) | (1L << (MINUS_SIGN - 746)))) != 0)) {
					{
					State = 3381; integer();
					}
				}

				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3384; Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Advanced_index_compressionContext : ParserRuleContext {
		public ITerminalNode COMPRESS() { return GetToken(PlSqlParser.COMPRESS, 0); }
		public ITerminalNode ADVANCED() { return GetToken(PlSqlParser.ADVANCED, 0); }
		public ITerminalNode LOW() { return GetToken(PlSqlParser.LOW, 0); }
		public ITerminalNode NOCOMPRESS() { return GetToken(PlSqlParser.NOCOMPRESS, 0); }
		public Advanced_index_compressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_advanced_index_compression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdvanced_index_compression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Advanced_index_compressionContext advanced_index_compression() {
		Advanced_index_compressionContext _localctx = new Advanced_index_compressionContext(Context, State);
		EnterRule(_localctx, 304, RULE_advanced_index_compression);
		try {
			State = 3391;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3387; Match(COMPRESS);
				State = 3388; Match(ADVANCED);
				State = 3389; Match(LOW);
				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3390; Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_partitioning_storageContext : ParserRuleContext {
		public ITerminalNode LOB() { return GetToken(PlSqlParser.LOB, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public Lob_item_nameContext lob_item_name() {
			return GetRuleContext<Lob_item_nameContext>(0);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Lob_segnameContext lob_segname() {
			return GetRuleContext<Lob_segnameContext>(0);
		}
		public Tablespace_clauseContext tablespace_clause() {
			return GetRuleContext<Tablespace_clauseContext>(0);
		}
		public ITerminalNode BASICFILE() { return GetToken(PlSqlParser.BASICFILE, 0); }
		public ITerminalNode SECUREFILE() { return GetToken(PlSqlParser.SECUREFILE, 0); }
		public Lob_partitioning_storageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_partitioning_storage; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_partitioning_storage(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_partitioning_storageContext lob_partitioning_storage() {
		Lob_partitioning_storageContext _localctx = new Lob_partitioning_storageContext(Context, State);
		EnterRule(_localctx, 306, RULE_lob_partitioning_storage);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3393; Match(LOB);
			State = 3394; Match(LEFT_PAREN);
			State = 3395; lob_item_name();
			State = 3396; Match(RIGHT_PAREN);
			State = 3397; Match(STORE);
			State = 3398; Match(AS);
			State = 3400;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BASICFILE || _la==SECUREFILE) {
				{
				State = 3399;
				_la = TokenStream.LA(1);
				if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3413;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,375,Context) ) {
			case 1:
				{
				State = 3402; lob_segname();
				State = 3407;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,374,Context) ) {
				case 1:
					{
					State = 3403; Match(LEFT_PAREN);
					State = 3404; tablespace_clause();
					State = 3405; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 3409; Match(LEFT_PAREN);
				State = 3410; tablespace_clause();
				State = 3411; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_subpartition_clauseContext : ParserRuleContext {
		public Store_inContext store_in() {
			return GetRuleContext<Store_inContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Partition_clause_optionalContext[] partition_clause_optional() {
			return GetRuleContexts<Partition_clause_optionalContext>();
		}
		public Partition_clause_optionalContext partition_clause_optional(int i) {
			return GetRuleContext<Partition_clause_optionalContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Tablespace_clauseContext[] tablespace_clause() {
			return GetRuleContexts<Tablespace_clauseContext>();
		}
		public Tablespace_clauseContext tablespace_clause(int i) {
			return GetRuleContext<Tablespace_clauseContext>(i);
		}
		public Advanced_index_compressionContext[] advanced_index_compression() {
			return GetRuleContexts<Advanced_index_compressionContext>();
		}
		public Advanced_index_compressionContext advanced_index_compression(int i) {
			return GetRuleContext<Advanced_index_compressionContext>(i);
		}
		public Usable_clauseContext[] usable_clause() {
			return GetRuleContexts<Usable_clauseContext>();
		}
		public Usable_clauseContext usable_clause(int i) {
			return GetRuleContext<Usable_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Index_subpartition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_subpartition_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_subpartition_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_subpartition_clauseContext index_subpartition_clause() {
		Index_subpartition_clauseContext _localctx = new Index_subpartition_clauseContext(Context, State);
		EnterRule(_localctx, 308, RULE_index_subpartition_clause);
		int _la;
		try {
			State = 3445;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STORE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3415; store_in();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3416; Match(LEFT_PAREN);
				State = 3417; partition_clause_optional();
				State = 3419;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TABLESPACE) {
					{
					State = 3418; tablespace_clause();
					}
				}

				State = 3422;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPRESS || _la==NOCOMPRESS) {
					{
					State = 3421; advanced_index_compression();
					}
				}

				State = 3425;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNUSABLE || _la==USABLE) {
					{
					State = 3424; usable_clause();
					}
				}

				State = 3440;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3427; Match(COMMA);
					State = 3428; partition_clause_optional();
					State = 3430;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==TABLESPACE) {
						{
						State = 3429; tablespace_clause();
						}
					}

					State = 3433;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMPRESS || _la==NOCOMPRESS) {
						{
						State = 3432; advanced_index_compression();
						}
					}

					State = 3436;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==UNUSABLE || _la==USABLE) {
						{
						State = 3435; usable_clause();
						}
					}

					}
					}
					State = 3442;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3443; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Usable_clauseContext : ParserRuleContext {
		public ITerminalNode USABLE() { return GetToken(PlSqlParser.USABLE, 0); }
		public ITerminalNode UNUSABLE() { return GetToken(PlSqlParser.UNUSABLE, 0); }
		public Usable_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usable_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsable_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Usable_clauseContext usable_clause() {
		Usable_clauseContext _localctx = new Usable_clauseContext(Context, State);
		EnterRule(_localctx, 310, RULE_usable_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3447;
			_la = TokenStream.LA(1);
			if ( !(_la==UNUSABLE || _la==USABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hash_partition_quantityContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public Hash_partition_quantityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hash_partition_quantity; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHash_partition_quantity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hash_partition_quantityContext hash_partition_quantity() {
		Hash_partition_quantityContext _localctx = new Hash_partition_quantityContext(Context, State);
		EnterRule(_localctx, 312, RULE_hash_partition_quantity);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3449; Match(UNSIGNED_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_itemContext : ParserRuleContext {
		public ITerminalNode REGULAR_ID() { return GetToken(PlSqlParser.REGULAR_ID, 0); }
		public Varray_itemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_item; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarray_item(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Varray_itemContext varray_item() {
		Varray_itemContext _localctx = new Varray_itemContext(Context, State);
		EnterRule(_localctx, 314, RULE_varray_item);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3451; Match(REGULAR_ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partial_index_clauseContext : ParserRuleContext {
		public ITerminalNode INDEXING() { return GetToken(PlSqlParser.INDEXING, 0); }
		public ITerminalNode PARTIAL() { return GetToken(PlSqlParser.PARTIAL, 0); }
		public ITerminalNode FULL() { return GetToken(PlSqlParser.FULL, 0); }
		public Partial_index_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partial_index_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartial_index_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partial_index_clauseContext partial_index_clause() {
		Partial_index_clauseContext _localctx = new Partial_index_clauseContext(Context, State);
		EnterRule(_localctx, 316, RULE_partial_index_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3453; Match(INDEXING);
			State = 3454;
			_la = TokenStream.LA(1);
			if ( !(_la==FULL || _la==PARTIAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parallel_clauseContext : ParserRuleContext {
		public ITerminalNode NOPARALLEL() { return GetToken(PlSqlParser.NOPARALLEL, 0); }
		public ITerminalNode PARALLEL() { return GetToken(PlSqlParser.PARALLEL, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Parallel_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallel_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParallel_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parallel_clauseContext parallel_clause() {
		Parallel_clauseContext _localctx = new Parallel_clauseContext(Context, State);
		EnterRule(_localctx, 318, RULE_parallel_clause);
		try {
			State = 3459;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOPARALLEL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3456; Match(NOPARALLEL);
				}
				break;
			case PARALLEL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3457; Match(PARALLEL);
				State = 3458; integer();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Domain_index_clauseContext : ParserRuleContext {
		public IndextypeContext indextype() {
			return GetRuleContext<IndextypeContext>(0);
		}
		public Local_domain_index_clauseContext local_domain_index_clause() {
			return GetRuleContext<Local_domain_index_clauseContext>(0);
		}
		public Parallel_clauseContext parallel_clause() {
			return GetRuleContext<Parallel_clauseContext>(0);
		}
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Odci_parametersContext odci_parameters() {
			return GetRuleContext<Odci_parametersContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Domain_index_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_domain_index_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDomain_index_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Domain_index_clauseContext domain_index_clause() {
		Domain_index_clauseContext _localctx = new Domain_index_clauseContext(Context, State);
		EnterRule(_localctx, 320, RULE_domain_index_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3461; indextype();
			State = 3463;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,385,Context) ) {
			case 1:
				{
				State = 3462; local_domain_index_clause();
				}
				break;
			}
			State = 3466;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 3465; parallel_clause();
				}
			}

			State = 3473;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,387,Context) ) {
			case 1:
				{
				State = 3468; Match(PARAMETERS);
				State = 3469; Match(LEFT_PAREN);
				State = 3470; odci_parameters();
				State = 3471; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Local_domain_index_clauseContext : ParserRuleContext {
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public Local_domain_index_parameters_clauseContext[] local_domain_index_parameters_clause() {
			return GetRuleContexts<Local_domain_index_parameters_clauseContext>();
		}
		public Local_domain_index_parameters_clauseContext local_domain_index_parameters_clause(int i) {
			return GetRuleContext<Local_domain_index_parameters_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Local_domain_index_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_local_domain_index_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLocal_domain_index_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Local_domain_index_clauseContext local_domain_index_clause() {
		Local_domain_index_clauseContext _localctx = new Local_domain_index_clauseContext(Context, State);
		EnterRule(_localctx, 322, RULE_local_domain_index_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3475; Match(LOCAL);
			State = 3477;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 3476; local_domain_index_parameters_clause();
				}
			}

			State = 3483;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,389,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3479; Match(COMMA);
					State = 3480; local_domain_index_parameters_clause();
					}
					} 
				}
				State = 3485;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,389,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Local_domain_index_parameters_clauseContext : ParserRuleContext {
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public Partition_nameContext partition_name() {
			return GetRuleContext<Partition_nameContext>(0);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public Odci_parametersContext odci_parameters() {
			return GetRuleContext<Odci_parametersContext>(0);
		}
		public Local_domain_index_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_local_domain_index_parameters_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLocal_domain_index_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Local_domain_index_parameters_clauseContext local_domain_index_parameters_clause() {
		Local_domain_index_parameters_clauseContext _localctx = new Local_domain_index_parameters_clauseContext(Context, State);
		EnterRule(_localctx, 324, RULE_local_domain_index_parameters_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3486; Match(LEFT_PAREN);
			State = 3487; Match(PARTITION);
			State = 3488; partition_name();
			State = 3494;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 3489; Match(PARAMETERS);
				State = 3490; Match(LEFT_PAREN);
				State = 3491; odci_parameters();
				State = 3492; Match(RIGHT_PAREN);
				}
			}

			State = 3496; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Odci_parametersContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Odci_parametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_odci_parameters; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOdci_parameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Odci_parametersContext odci_parameters() {
		Odci_parametersContext _localctx = new Odci_parametersContext(Context, State);
		EnterRule(_localctx, 326, RULE_odci_parameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3498; Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exceptions_clauseContext : ParserRuleContext {
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Table_fullnameContext table_fullname() {
			return GetRuleContext<Table_fullnameContext>(0);
		}
		public Exceptions_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exceptions_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExceptions_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exceptions_clauseContext exceptions_clause() {
		Exceptions_clauseContext _localctx = new Exceptions_clauseContext(Context, State);
		EnterRule(_localctx, 328, RULE_exceptions_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3500; Match(EXCEPTIONS);
			State = 3501; Match(INTO);
			State = 3502; table_fullname();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_tablespaceContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public Permanent_tablespace_clauseContext permanent_tablespace_clause() {
			return GetRuleContext<Permanent_tablespace_clauseContext>(0);
		}
		public Temporary_tablespace_clauseContext temporary_tablespace_clause() {
			return GetRuleContext<Temporary_tablespace_clauseContext>(0);
		}
		public Undo_tablespace_clauseContext undo_tablespace_clause() {
			return GetRuleContext<Undo_tablespace_clauseContext>(0);
		}
		public ITerminalNode BIGFILE() { return GetToken(PlSqlParser.BIGFILE, 0); }
		public ITerminalNode SMALLFILE() { return GetToken(PlSqlParser.SMALLFILE, 0); }
		public Create_tablespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_tablespace; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_tablespace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_tablespaceContext create_tablespace() {
		Create_tablespaceContext _localctx = new Create_tablespaceContext(Context, State);
		EnterRule(_localctx, 330, RULE_create_tablespace);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3504; Match(CREATE);
			State = 3506;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BIGFILE || _la==SMALLFILE) {
				{
				State = 3505;
				_la = TokenStream.LA(1);
				if ( !(_la==BIGFILE || _la==SMALLFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3511;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TABLESPACE:
				{
				State = 3508; permanent_tablespace_clause();
				}
				break;
			case TEMPORARY:
				{
				State = 3509; temporary_tablespace_clause();
				}
				break;
			case UNDO:
				{
				State = 3510; undo_tablespace_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3513; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Permanent_tablespace_clauseContext : ParserRuleContext {
		public Tablespace_clauseContext tablespace_clause() {
			return GetRuleContext<Tablespace_clauseContext>(0);
		}
		public Datafile_specificationContext datafile_specification() {
			return GetRuleContext<Datafile_specificationContext>(0);
		}
		public ITerminalNode[] MINIMUM() { return GetTokens(PlSqlParser.MINIMUM); }
		public ITerminalNode MINIMUM(int i) {
			return GetToken(PlSqlParser.MINIMUM, i);
		}
		public ITerminalNode[] EXTENT() { return GetTokens(PlSqlParser.EXTENT); }
		public ITerminalNode EXTENT(int i) {
			return GetToken(PlSqlParser.EXTENT, i);
		}
		public Size_clauseContext[] size_clause() {
			return GetRuleContexts<Size_clauseContext>();
		}
		public Size_clauseContext size_clause(int i) {
			return GetRuleContext<Size_clauseContext>(i);
		}
		public ITerminalNode[] BLOCKSIZE() { return GetTokens(PlSqlParser.BLOCKSIZE); }
		public ITerminalNode BLOCKSIZE(int i) {
			return GetToken(PlSqlParser.BLOCKSIZE, i);
		}
		public Logging_clauseContext[] logging_clause() {
			return GetRuleContexts<Logging_clauseContext>();
		}
		public Logging_clauseContext logging_clause(int i) {
			return GetRuleContext<Logging_clauseContext>(i);
		}
		public ITerminalNode[] FORCE() { return GetTokens(PlSqlParser.FORCE); }
		public ITerminalNode FORCE(int i) {
			return GetToken(PlSqlParser.FORCE, i);
		}
		public ITerminalNode[] LOGGING() { return GetTokens(PlSqlParser.LOGGING); }
		public ITerminalNode LOGGING(int i) {
			return GetToken(PlSqlParser.LOGGING, i);
		}
		public ITerminalNode[] ENCRYPTION() { return GetTokens(PlSqlParser.ENCRYPTION); }
		public ITerminalNode ENCRYPTION(int i) {
			return GetToken(PlSqlParser.ENCRYPTION, i);
		}
		public Tablespace_encryption_specContext[] tablespace_encryption_spec() {
			return GetRuleContexts<Tablespace_encryption_specContext>();
		}
		public Tablespace_encryption_specContext tablespace_encryption_spec(int i) {
			return GetRuleContext<Tablespace_encryption_specContext>(i);
		}
		public ITerminalNode[] DEFAULT() { return GetTokens(PlSqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(PlSqlParser.DEFAULT, i);
		}
		public Extent_management_clauseContext[] extent_management_clause() {
			return GetRuleContexts<Extent_management_clauseContext>();
		}
		public Extent_management_clauseContext extent_management_clause(int i) {
			return GetRuleContext<Extent_management_clauseContext>(i);
		}
		public Segment_management_clauseContext[] segment_management_clause() {
			return GetRuleContexts<Segment_management_clauseContext>();
		}
		public Segment_management_clauseContext segment_management_clause(int i) {
			return GetRuleContext<Segment_management_clauseContext>(i);
		}
		public Flashback_mode_clauseContext[] flashback_mode_clause() {
			return GetRuleContexts<Flashback_mode_clauseContext>();
		}
		public Flashback_mode_clauseContext flashback_mode_clause(int i) {
			return GetRuleContext<Flashback_mode_clauseContext>(i);
		}
		public ITerminalNode[] ONLINE() { return GetTokens(PlSqlParser.ONLINE); }
		public ITerminalNode ONLINE(int i) {
			return GetToken(PlSqlParser.ONLINE, i);
		}
		public ITerminalNode[] OFFLINE() { return GetTokens(PlSqlParser.OFFLINE); }
		public ITerminalNode OFFLINE(int i) {
			return GetToken(PlSqlParser.OFFLINE, i);
		}
		public Permanent_tablespace_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_permanent_tablespace_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPermanent_tablespace_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Permanent_tablespace_clauseContext permanent_tablespace_clause() {
		Permanent_tablespace_clauseContext _localctx = new Permanent_tablespace_clauseContext(Context, State);
		EnterRule(_localctx, 332, RULE_permanent_tablespace_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3515; tablespace_clause();
			State = 3517;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATAFILE) {
				{
				State = 3516; datafile_specification();
				}
			}

			State = 3536;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==BLOCKSIZE || ((((_la - 141)) & ~0x3f) == 0 && ((1L << (_la - 141)) & ((1L << (DEFAULT - 141)) | (1L << (ENCRYPTION - 141)) | (1L << (EXTENT - 141)))) != 0) || ((((_la - 206)) & ~0x3f) == 0 && ((1L << (_la - 206)) & ((1L << (FILESYSTEM_LIKE_LOGGING - 206)) | (1L << (FLASHBACK - 206)) | (1L << (FORCE - 206)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MINIMUM - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==OFFLINE || _la==ONLINE || _la==SEGMENT) {
				{
				State = 3534;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MINIMUM:
					{
					State = 3519; Match(MINIMUM);
					State = 3520; Match(EXTENT);
					State = 3521; size_clause();
					}
					break;
				case BLOCKSIZE:
					{
					State = 3522; Match(BLOCKSIZE);
					State = 3523; size_clause();
					}
					break;
				case FILESYSTEM_LIKE_LOGGING:
				case LOGGING:
				case NOLOGGING:
					{
					State = 3524; logging_clause();
					}
					break;
				case FORCE:
					{
					State = 3525; Match(FORCE);
					State = 3526; Match(LOGGING);
					}
					break;
				case OFFLINE:
				case ONLINE:
					{
					State = 3527;
					_la = TokenStream.LA(1);
					if ( !(_la==OFFLINE || _la==ONLINE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				case ENCRYPTION:
					{
					State = 3528; Match(ENCRYPTION);
					State = 3529; tablespace_encryption_spec();
					}
					break;
				case DEFAULT:
					{
					State = 3530; Match(DEFAULT);
					}
					break;
				case EXTENT:
					{
					State = 3531; extent_management_clause();
					}
					break;
				case SEGMENT:
					{
					State = 3532; segment_management_clause();
					}
					break;
				case FLASHBACK:
					{
					State = 3533; flashback_mode_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 3538;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tablespace_encryption_specContext : ParserRuleContext {
		public IToken encrypt_algorithm;
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Tablespace_encryption_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespace_encryption_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablespace_encryption_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tablespace_encryption_specContext tablespace_encryption_spec() {
		Tablespace_encryption_specContext _localctx = new Tablespace_encryption_specContext(Context, State);
		EnterRule(_localctx, 334, RULE_tablespace_encryption_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3539; Match(USING);
			State = 3540; _localctx.encrypt_algorithm = Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Logging_clauseContext : ParserRuleContext {
		public ITerminalNode LOGGING() { return GetToken(PlSqlParser.LOGGING, 0); }
		public ITerminalNode NOLOGGING() { return GetToken(PlSqlParser.NOLOGGING, 0); }
		public ITerminalNode FILESYSTEM_LIKE_LOGGING() { return GetToken(PlSqlParser.FILESYSTEM_LIKE_LOGGING, 0); }
		public Logging_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logging_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogging_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logging_clauseContext logging_clause() {
		Logging_clauseContext _localctx = new Logging_clauseContext(Context, State);
		EnterRule(_localctx, 336, RULE_logging_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3542;
			_la = TokenStream.LA(1);
			if ( !(_la==FILESYSTEM_LIKE_LOGGING || _la==LOGGING || _la==NOLOGGING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Extent_management_clauseContext : ParserRuleContext {
		public ITerminalNode EXTENT() { return GetToken(PlSqlParser.EXTENT, 0); }
		public ITerminalNode MANAGEMENT() { return GetToken(PlSqlParser.MANAGEMENT, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode AUTOALLOCATE() { return GetToken(PlSqlParser.AUTOALLOCATE, 0); }
		public ITerminalNode UNIFORM() { return GetToken(PlSqlParser.UNIFORM, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public Size_clauseContext size_clause() {
			return GetRuleContext<Size_clauseContext>(0);
		}
		public Extent_management_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extent_management_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtent_management_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Extent_management_clauseContext extent_management_clause() {
		Extent_management_clauseContext _localctx = new Extent_management_clauseContext(Context, State);
		EnterRule(_localctx, 338, RULE_extent_management_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3544; Match(EXTENT);
			State = 3545; Match(MANAGEMENT);
			State = 3546; Match(LOCAL);
			State = 3553;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AUTOALLOCATE:
				{
				State = 3547; Match(AUTOALLOCATE);
				}
				break;
			case UNIFORM:
				{
				State = 3548; Match(UNIFORM);
				State = 3551;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SIZE) {
					{
					State = 3549; Match(SIZE);
					State = 3550; size_clause();
					}
				}

				}
				break;
			case BLOCKSIZE:
			case DEFAULT:
			case ENCRYPTION:
			case EXTENT:
			case FILESYSTEM_LIKE_LOGGING:
			case FLASHBACK:
			case FORCE:
			case LOGGING:
			case MINIMUM:
			case NOLOGGING:
			case OFFLINE:
			case ONLINE:
			case RETENTION:
			case SEGMENT:
			case SEMICOLON:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Segment_management_clauseContext : ParserRuleContext {
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode SPACE_KEYWORD() { return GetToken(PlSqlParser.SPACE_KEYWORD, 0); }
		public ITerminalNode MANAGEMENT() { return GetToken(PlSqlParser.MANAGEMENT, 0); }
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public ITerminalNode MANUAL() { return GetToken(PlSqlParser.MANUAL, 0); }
		public Segment_management_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_segment_management_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSegment_management_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Segment_management_clauseContext segment_management_clause() {
		Segment_management_clauseContext _localctx = new Segment_management_clauseContext(Context, State);
		EnterRule(_localctx, 340, RULE_segment_management_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3555; Match(SEGMENT);
			State = 3556; Match(SPACE_KEYWORD);
			State = 3557; Match(MANAGEMENT);
			State = 3558;
			_la = TokenStream.LA(1);
			if ( !(_la==AUTO || _la==MANUAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_mode_clauseContext : ParserRuleContext {
		public ITerminalNode FLASHBACK() { return GetToken(PlSqlParser.FLASHBACK, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode OFF() { return GetToken(PlSqlParser.OFF, 0); }
		public Flashback_mode_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_mode_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlashback_mode_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_mode_clauseContext flashback_mode_clause() {
		Flashback_mode_clauseContext _localctx = new Flashback_mode_clauseContext(Context, State);
		EnterRule(_localctx, 342, RULE_flashback_mode_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3560; Match(FLASHBACK);
			State = 3561;
			_la = TokenStream.LA(1);
			if ( !(_la==OFF || _la==ON) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Temporary_tablespace_clauseContext : ParserRuleContext {
		public ITerminalNode TEMPORARY() { return GetToken(PlSqlParser.TEMPORARY, 0); }
		public Tablespace_clauseContext tablespace_clause() {
			return GetRuleContext<Tablespace_clauseContext>(0);
		}
		public Tempfile_specificationContext tempfile_specification() {
			return GetRuleContext<Tempfile_specificationContext>(0);
		}
		public Tablespace_group_clauseContext tablespace_group_clause() {
			return GetRuleContext<Tablespace_group_clauseContext>(0);
		}
		public Extent_management_clauseContext extent_management_clause() {
			return GetRuleContext<Extent_management_clauseContext>(0);
		}
		public Temporary_tablespace_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_temporary_tablespace_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTemporary_tablespace_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Temporary_tablespace_clauseContext temporary_tablespace_clause() {
		Temporary_tablespace_clauseContext _localctx = new Temporary_tablespace_clauseContext(Context, State);
		EnterRule(_localctx, 344, RULE_temporary_tablespace_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3563; Match(TEMPORARY);
			State = 3564; tablespace_clause();
			State = 3566;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TEMPFILE) {
				{
				State = 3565; tempfile_specification();
				}
			}

			State = 3569;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 3568; tablespace_group_clause();
				}
			}

			State = 3572;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENT) {
				{
				State = 3571; extent_management_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tablespace_group_clauseContext : ParserRuleContext {
		public ITerminalNode TABLESPACE() { return GetToken(PlSqlParser.TABLESPACE, 0); }
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode REGULAR_ID() { return GetToken(PlSqlParser.REGULAR_ID, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Tablespace_group_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespace_group_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablespace_group_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tablespace_group_clauseContext tablespace_group_clause() {
		Tablespace_group_clauseContext _localctx = new Tablespace_group_clauseContext(Context, State);
		EnterRule(_localctx, 346, RULE_tablespace_group_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3574; Match(TABLESPACE);
			State = 3575; Match(GROUP);
			State = 3576;
			_la = TokenStream.LA(1);
			if ( !(_la==CHAR_STRING || _la==REGULAR_ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Undo_tablespace_clauseContext : ParserRuleContext {
		public ITerminalNode UNDO() { return GetToken(PlSqlParser.UNDO, 0); }
		public Tablespace_clauseContext tablespace_clause() {
			return GetRuleContext<Tablespace_clauseContext>(0);
		}
		public Datafile_specificationContext datafile_specification() {
			return GetRuleContext<Datafile_specificationContext>(0);
		}
		public Extent_management_clauseContext extent_management_clause() {
			return GetRuleContext<Extent_management_clauseContext>(0);
		}
		public Tablespace_retention_clauseContext tablespace_retention_clause() {
			return GetRuleContext<Tablespace_retention_clauseContext>(0);
		}
		public Undo_tablespace_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_undo_tablespace_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUndo_tablespace_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Undo_tablespace_clauseContext undo_tablespace_clause() {
		Undo_tablespace_clauseContext _localctx = new Undo_tablespace_clauseContext(Context, State);
		EnterRule(_localctx, 348, RULE_undo_tablespace_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3578; Match(UNDO);
			State = 3579; tablespace_clause();
			State = 3581;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATAFILE) {
				{
				State = 3580; datafile_specification();
				}
			}

			State = 3584;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENT) {
				{
				State = 3583; extent_management_clause();
				}
			}

			State = 3587;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETENTION) {
				{
				State = 3586; tablespace_retention_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tablespace_retention_clauseContext : ParserRuleContext {
		public ITerminalNode RETENTION() { return GetToken(PlSqlParser.RETENTION, 0); }
		public ITerminalNode GUARANTEE() { return GetToken(PlSqlParser.GUARANTEE, 0); }
		public ITerminalNode NOGUARANTEE() { return GetToken(PlSqlParser.NOGUARANTEE, 0); }
		public Tablespace_retention_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespace_retention_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablespace_retention_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tablespace_retention_clauseContext tablespace_retention_clause() {
		Tablespace_retention_clauseContext _localctx = new Tablespace_retention_clauseContext(Context, State);
		EnterRule(_localctx, 350, RULE_tablespace_retention_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3589; Match(RETENTION);
			State = 3590;
			_la = TokenStream.LA(1);
			if ( !(_la==GUARANTEE || _la==NOGUARANTEE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Datafile_specificationContext : ParserRuleContext {
		public ITerminalNode DATAFILE() { return GetToken(PlSqlParser.DATAFILE, 0); }
		public Datafile_tempfile_specContext datafile_tempfile_spec() {
			return GetRuleContext<Datafile_tempfile_specContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Datafile_specificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datafile_specification; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatafile_specification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Datafile_specificationContext datafile_specification() {
		Datafile_specificationContext _localctx = new Datafile_specificationContext(Context, State);
		EnterRule(_localctx, 352, RULE_datafile_specification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3592; Match(DATAFILE);
			{
			State = 3594;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 3593; Match(COMMA);
				}
			}

			State = 3596; datafile_tempfile_spec();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tempfile_specificationContext : ParserRuleContext {
		public ITerminalNode TEMPFILE() { return GetToken(PlSqlParser.TEMPFILE, 0); }
		public Datafile_tempfile_specContext datafile_tempfile_spec() {
			return GetRuleContext<Datafile_tempfile_specContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Tempfile_specificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tempfile_specification; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTempfile_specification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tempfile_specificationContext tempfile_specification() {
		Tempfile_specificationContext _localctx = new Tempfile_specificationContext(Context, State);
		EnterRule(_localctx, 354, RULE_tempfile_specification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3598; Match(TEMPFILE);
			{
			State = 3600;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 3599; Match(COMMA);
				}
			}

			State = 3602; datafile_tempfile_spec();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Datafile_tempfile_specContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public Size_clauseContext size_clause() {
			return GetRuleContext<Size_clauseContext>(0);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public Autoextend_clauseContext autoextend_clause() {
			return GetRuleContext<Autoextend_clauseContext>(0);
		}
		public Datafile_tempfile_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datafile_tempfile_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatafile_tempfile_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Datafile_tempfile_specContext datafile_tempfile_spec() {
		Datafile_tempfile_specContext _localctx = new Datafile_tempfile_specContext(Context, State);
		EnterRule(_localctx, 356, RULE_datafile_tempfile_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3605;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHAR_STRING) {
				{
				State = 3604; Match(CHAR_STRING);
				}
			}

			State = 3609;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIZE) {
				{
				State = 3607; Match(SIZE);
				State = 3608; size_clause();
				}
			}

			State = 3612;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 3611; Match(REUSE);
				}
			}

			State = 3615;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTOEXTEND) {
				{
				State = 3614; autoextend_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Redo_log_file_specContext : ParserRuleContext {
		public ITerminalNode DATAFILE() { return GetToken(PlSqlParser.DATAFILE, 0); }
		public ITerminalNode[] CHAR_STRING() { return GetTokens(PlSqlParser.CHAR_STRING); }
		public ITerminalNode CHAR_STRING(int i) {
			return GetToken(PlSqlParser.CHAR_STRING, i);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public Size_clauseContext[] size_clause() {
			return GetRuleContexts<Size_clauseContext>();
		}
		public Size_clauseContext size_clause(int i) {
			return GetRuleContext<Size_clauseContext>(i);
		}
		public ITerminalNode BLOCKSIZE() { return GetToken(PlSqlParser.BLOCKSIZE, 0); }
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Redo_log_file_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_redo_log_file_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRedo_log_file_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Redo_log_file_specContext redo_log_file_spec() {
		Redo_log_file_specContext _localctx = new Redo_log_file_specContext(Context, State);
		EnterRule(_localctx, 358, RULE_redo_log_file_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3617; Match(DATAFILE);
			State = 3629;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHAR_STRING:
				{
				State = 3618; Match(CHAR_STRING);
				}
				break;
			case LEFT_PAREN:
				{
				State = 3619; Match(LEFT_PAREN);
				State = 3624;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 3621;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 3620; Match(COMMA);
						}
					}

					State = 3623; Match(CHAR_STRING);
					}
					}
					State = 3626;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CHAR_STRING || _la==COMMA );
				State = 3628; Match(RIGHT_PAREN);
				}
				break;
			case Eof:
			case BLOCKSIZE:
			case REUSE:
			case SIZE:
				break;
			default:
				break;
			}
			State = 3633;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIZE) {
				{
				State = 3631; Match(SIZE);
				State = 3632; size_clause();
				}
			}

			State = 3637;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BLOCKSIZE) {
				{
				State = 3635; Match(BLOCKSIZE);
				State = 3636; size_clause();
				}
			}

			State = 3640;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REUSE) {
				{
				State = 3639; Match(REUSE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Autoextend_clauseContext : ParserRuleContext {
		public ITerminalNode AUTOEXTEND() { return GetToken(PlSqlParser.AUTOEXTEND, 0); }
		public ITerminalNode OFF() { return GetToken(PlSqlParser.OFF, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode NEXT() { return GetToken(PlSqlParser.NEXT, 0); }
		public Size_clauseContext size_clause() {
			return GetRuleContext<Size_clauseContext>(0);
		}
		public Maxsize_clauseContext maxsize_clause() {
			return GetRuleContext<Maxsize_clauseContext>(0);
		}
		public Autoextend_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_autoextend_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAutoextend_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Autoextend_clauseContext autoextend_clause() {
		Autoextend_clauseContext _localctx = new Autoextend_clauseContext(Context, State);
		EnterRule(_localctx, 360, RULE_autoextend_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3642; Match(AUTOEXTEND);
			State = 3652;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OFF:
				{
				State = 3643; Match(OFF);
				}
				break;
			case ON:
				{
				State = 3644; Match(ON);
				State = 3647;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NEXT) {
					{
					State = 3645; Match(NEXT);
					State = 3646; size_clause();
					}
				}

				State = 3650;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MAXSIZE) {
					{
					State = 3649; maxsize_clause();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Maxsize_clauseContext : ParserRuleContext {
		public ITerminalNode MAXSIZE() { return GetToken(PlSqlParser.MAXSIZE, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public Size_clauseContext size_clause() {
			return GetRuleContext<Size_clauseContext>(0);
		}
		public Maxsize_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_maxsize_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMaxsize_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Maxsize_clauseContext maxsize_clause() {
		Maxsize_clauseContext _localctx = new Maxsize_clauseContext(Context, State);
		EnterRule(_localctx, 362, RULE_maxsize_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3654; Match(MAXSIZE);
			State = 3657;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNLIMITED:
				{
				State = 3655; Match(UNLIMITED);
				}
				break;
			case UNSIGNED_INTEGER:
				{
				State = 3656; size_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryContext : ParserRuleContext {
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public SubqueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryContext subquery() {
		SubqueryContext _localctx = new SubqueryContext(Context, State);
		EnterRule(_localctx, 364, RULE_subquery);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3659; subquery_basic_elements();
			State = 3663;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==INTERSECT || _la==MINUS || _la==UNION) {
				{
				{
				State = 3660; subquery_operation_part();
				}
				}
				State = 3665;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_tableContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Table_fullnameContext table_fullname() {
			return GetRuleContext<Table_fullnameContext>(0);
		}
		public Relational_tableContext relational_table() {
			return GetRuleContext<Relational_tableContext>(0);
		}
		public ITerminalNode GLOBAL() { return GetToken(PlSqlParser.GLOBAL, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(PlSqlParser.TEMPORARY, 0); }
		public Create_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_tableContext create_table() {
		Create_tableContext _localctx = new Create_tableContext(Context, State);
		EnterRule(_localctx, 366, RULE_create_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3666; Match(CREATE);
			State = 3669;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GLOBAL) {
				{
				State = 3667; Match(GLOBAL);
				State = 3668; Match(TEMPORARY);
				}
			}

			State = 3671; Match(TABLE);
			State = 3672; table_fullname();
			{
			State = 3673; relational_table();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_tableContext : ParserRuleContext {
		public Table_propertiesContext table_properties() {
			return GetRuleContext<Table_propertiesContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Relational_propertiesContext relational_properties() {
			return GetRuleContext<Relational_propertiesContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public Physical_propertiesContext physical_properties() {
			return GetRuleContext<Physical_propertiesContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(PlSqlParser.PRESERVE, 0); }
		public Relational_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_tableContext relational_table() {
		Relational_tableContext _localctx = new Relational_tableContext(Context, State);
		EnterRule(_localctx, 368, RULE_relational_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3679;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,422,Context) ) {
			case 1:
				{
				State = 3675; Match(LEFT_PAREN);
				State = 3676; relational_properties();
				State = 3677; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3687;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 3681; Match(ON);
				State = 3682; Match(COMMIT);
				State = 3684;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DELETE || _la==PRESERVE) {
					{
					State = 3683;
					_la = TokenStream.LA(1);
					if ( !(_la==DELETE || _la==PRESERVE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 3686; Match(ROWS);
				}
			}

			State = 3690;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,425,Context) ) {
			case 1:
				{
				State = 3689; physical_properties();
				}
				break;
			}
			State = 3692; table_properties();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_propertiesContext : ParserRuleContext {
		public Relational_propertyContext[] relational_property() {
			return GetRuleContexts<Relational_propertyContext>();
		}
		public Relational_propertyContext relational_property(int i) {
			return GetRuleContext<Relational_propertyContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Relational_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_propertiesContext relational_properties() {
		Relational_propertiesContext _localctx = new Relational_propertiesContext(Context, State);
		EnterRule(_localctx, 370, RULE_relational_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3694; relational_property();
			State = 3699;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3695; Match(COMMA);
				State = 3696; relational_property();
				}
				}
				State = 3701;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_propertyContext : ParserRuleContext {
		public Column_definitionContext column_definition() {
			return GetRuleContext<Column_definitionContext>(0);
		}
		public Virtual_column_definitionContext virtual_column_definition() {
			return GetRuleContext<Virtual_column_definitionContext>(0);
		}
		public Period_definitionContext period_definition() {
			return GetRuleContext<Period_definitionContext>(0);
		}
		public Out_of_line_constraintContext out_of_line_constraint() {
			return GetRuleContext<Out_of_line_constraintContext>(0);
		}
		public Out_of_line_ref_constraintContext out_of_line_ref_constraint() {
			return GetRuleContext<Out_of_line_ref_constraintContext>(0);
		}
		public Supplemental_logging_propsContext supplemental_logging_props() {
			return GetRuleContext<Supplemental_logging_propsContext>(0);
		}
		public Relational_propertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_property; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_property(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_propertyContext relational_property() {
		Relational_propertyContext _localctx = new Relational_propertyContext(Context, State);
		EnterRule(_localctx, 372, RULE_relational_property);
		try {
			State = 3710;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,428,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3702; column_definition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3703; virtual_column_definition();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3704; period_definition();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3707;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,427,Context) ) {
				case 1:
					{
					State = 3705; out_of_line_constraint();
					}
					break;
				case 2:
					{
					State = 3706; out_of_line_ref_constraint();
					}
					break;
				}
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3709; supplemental_logging_props();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_propertiesContext : ParserRuleContext {
		public Column_propertiesContext column_properties() {
			return GetRuleContext<Column_propertiesContext>(0);
		}
		public Indexing_clauseContext indexing_clause() {
			return GetRuleContext<Indexing_clauseContext>(0);
		}
		public Table_partitioning_clausesContext table_partitioning_clauses() {
			return GetRuleContext<Table_partitioning_clausesContext>(0);
		}
		public Attribute_clustering_clauseContext attribute_clustering_clause() {
			return GetRuleContext<Attribute_clustering_clauseContext>(0);
		}
		public ITerminalNode RESULT_CACHE() { return GetToken(PlSqlParser.RESULT_CACHE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode MODE() { return GetToken(PlSqlParser.MODE, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Parallel_clauseContext parallel_clause() {
			return GetRuleContext<Parallel_clauseContext>(0);
		}
		public Enable_disable_clauseContext[] enable_disable_clause() {
			return GetRuleContexts<Enable_disable_clauseContext>();
		}
		public Enable_disable_clauseContext enable_disable_clause(int i) {
			return GetRuleContext<Enable_disable_clauseContext>(i);
		}
		public Row_movement_clauseContext row_movement_clause() {
			return GetRuleContext<Row_movement_clauseContext>(0);
		}
		public Flashback_archive_clauseContext flashback_archive_clause() {
			return GetRuleContext<Flashback_archive_clauseContext>(0);
		}
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode ARCHIVAL() { return GetToken(PlSqlParser.ARCHIVAL, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode CACHE() { return GetToken(PlSqlParser.CACHE, 0); }
		public ITerminalNode NOCACHE() { return GetToken(PlSqlParser.NOCACHE, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode ROWDEPENDENCIES() { return GetToken(PlSqlParser.ROWDEPENDENCIES, 0); }
		public ITerminalNode NOROWDEPENDENCIES() { return GetToken(PlSqlParser.NOROWDEPENDENCIES, 0); }
		public Table_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_propertiesContext table_properties() {
		Table_propertiesContext _localctx = new Table_propertiesContext(Context, State);
		EnterRule(_localctx, 374, RULE_table_properties);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3713;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,429,Context) ) {
			case 1:
				{
				State = 3712; column_properties();
				}
				break;
			}
			State = 3716;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEXING) {
				{
				State = 3715; indexing_clause();
				}
			}

			State = 3719;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,431,Context) ) {
			case 1:
				{
				State = 3718; table_partitioning_clauses();
				}
				break;
			}
			State = 3722;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CLUSTERING) {
				{
				State = 3721; attribute_clustering_clause();
				}
			}

			State = 3725;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CACHE || _la==NOCACHE) {
				{
				State = 3724;
				_la = TokenStream.LA(1);
				if ( !(_la==CACHE || _la==NOCACHE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3732;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,434,Context) ) {
			case 1:
				{
				State = 3727; Match(RESULT_CACHE);
				State = 3728; Match(LEFT_PAREN);
				State = 3729; Match(MODE);
				State = 3730;
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==FORCE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3731; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3735;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOPARALLEL || _la==PARALLEL) {
				{
				State = 3734; parallel_clause();
				}
			}

			State = 3738;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOROWDEPENDENCIES || _la==ROWDEPENDENCIES) {
				{
				State = 3737;
				_la = TokenStream.LA(1);
				if ( !(_la==NOROWDEPENDENCIES || _la==ROWDEPENDENCIES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3743;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,437,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3740; enable_disable_clause();
					}
					} 
				}
				State = 3745;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,437,Context);
			}
			State = 3747;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,438,Context) ) {
			case 1:
				{
				State = 3746; row_movement_clause();
				}
				break;
			}
			State = 3750;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,439,Context) ) {
			case 1:
				{
				State = 3749; flashback_archive_clause();
				}
				break;
			}
			State = 3754;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,440,Context) ) {
			case 1:
				{
				State = 3752; Match(ROW);
				State = 3753; Match(ARCHIVAL);
				}
				break;
			}
			State = 3758;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3756; Match(AS);
				State = 3757; subquery();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_archive_clauseContext : ParserRuleContext {
		public ITerminalNode FLASHBACK() { return GetToken(PlSqlParser.FLASHBACK, 0); }
		public ITerminalNode ARCHIVE() { return GetToken(PlSqlParser.ARCHIVE, 0); }
		public Flashback_archive_nameContext flashback_archive_name() {
			return GetRuleContext<Flashback_archive_nameContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Flashback_archive_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_archive_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlashback_archive_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_archive_clauseContext flashback_archive_clause() {
		Flashback_archive_clauseContext _localctx = new Flashback_archive_clauseContext(Context, State);
		EnterRule(_localctx, 376, RULE_flashback_archive_clause);
		try {
			State = 3768;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FLASHBACK:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3760; Match(FLASHBACK);
				State = 3761; Match(ARCHIVE);
				State = 3763;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,442,Context) ) {
				case 1:
					{
					State = 3762; flashback_archive_name();
					}
					break;
				}
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3765; Match(NO);
				State = 3766; Match(FLASHBACK);
				State = 3767; Match(ARCHIVE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Row_movement_clauseContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode MOVEMENT() { return GetToken(PlSqlParser.MOVEMENT, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public Row_movement_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_row_movement_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRow_movement_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Row_movement_clauseContext row_movement_clause() {
		Row_movement_clauseContext _localctx = new Row_movement_clauseContext(Context, State);
		EnterRule(_localctx, 378, RULE_row_movement_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3770;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3771; Match(ROW);
			State = 3772; Match(MOVEMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_clustering_clauseContext : ParserRuleContext {
		public ITerminalNode CLUSTERING() { return GetToken(PlSqlParser.CLUSTERING, 0); }
		public Cluster_clauseContext cluster_clause() {
			return GetRuleContext<Cluster_clauseContext>(0);
		}
		public Zonemap_clauseContext zonemap_clause() {
			return GetRuleContext<Zonemap_clauseContext>(0);
		}
		public Clustering_joinContext clustering_join() {
			return GetRuleContext<Clustering_joinContext>(0);
		}
		public Clustering_whenContext clustering_when() {
			return GetRuleContext<Clustering_whenContext>(0);
		}
		public Attribute_clustering_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_clustering_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_clustering_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_clustering_clauseContext attribute_clustering_clause() {
		Attribute_clustering_clauseContext _localctx = new Attribute_clustering_clauseContext(Context, State);
		EnterRule(_localctx, 380, RULE_attribute_clustering_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3774; Match(CLUSTERING);
			State = 3776;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3775; clustering_join();
				}
			}

			State = 3778; cluster_clause();
			State = 3780;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO || _la==YES) {
				{
				State = 3779; clustering_when();
				}
			}

			State = 3782; zonemap_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Clustering_joinContext : ParserRuleContext {
		public Table_fullnameContext[] table_fullname() {
			return GetRuleContexts<Table_fullnameContext>();
		}
		public Table_fullnameContext table_fullname(int i) {
			return GetRuleContext<Table_fullnameContext>(i);
		}
		public ITerminalNode JOIN() { return GetToken(PlSqlParser.JOIN, 0); }
		public Clustering_joinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clustering_join; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClustering_join(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Clustering_joinContext clustering_join() {
		Clustering_joinContext _localctx = new Clustering_joinContext(Context, State);
		EnterRule(_localctx, 382, RULE_clustering_join);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3784; table_fullname();
			State = 3785; Match(JOIN);
			State = 3786; table_fullname();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cluster_clauseContext : ParserRuleContext {
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Clustering_columnsContext clustering_columns() {
			return GetRuleContext<Clustering_columnsContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(PlSqlParser.LINEAR, 0); }
		public ITerminalNode INTERVLEAVED() { return GetToken(PlSqlParser.INTERVLEAVED, 0); }
		public Cluster_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cluster_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCluster_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cluster_clauseContext cluster_clause() {
		Cluster_clauseContext _localctx = new Cluster_clauseContext(Context, State);
		EnterRule(_localctx, 384, RULE_cluster_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3788; Match(BY);
			State = 3790;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTERVLEAVED || _la==LINEAR) {
				{
				State = 3789;
				_la = TokenStream.LA(1);
				if ( !(_la==INTERVLEAVED || _la==LINEAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3792; Match(ORDER);
			State = 3793; clustering_columns();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Clustering_columnsContext : ParserRuleContext {
		public Clustering_columns_groupContext clustering_columns_group() {
			return GetRuleContext<Clustering_columns_groupContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Clustering_columnsContext[] clustering_columns() {
			return GetRuleContexts<Clustering_columnsContext>();
		}
		public Clustering_columnsContext clustering_columns(int i) {
			return GetRuleContext<Clustering_columnsContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Clustering_columnsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clustering_columns; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClustering_columns(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Clustering_columnsContext clustering_columns() {
		Clustering_columnsContext _localctx = new Clustering_columnsContext(Context, State);
		EnterRule(_localctx, 386, RULE_clustering_columns);
		int _la;
		try {
			State = 3806;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,448,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3795; clustering_columns_group();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3796; Match(LEFT_PAREN);
				State = 3797; clustering_columns();
				State = 3800;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 3798; Match(COMMA);
					State = 3799; clustering_columns();
					}
					}
					State = 3802;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMMA );
				State = 3804; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Clustering_columns_groupContext : ParserRuleContext {
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Clustering_columns_groupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clustering_columns_group; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClustering_columns_group(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Clustering_columns_groupContext clustering_columns_group() {
		Clustering_columns_groupContext _localctx = new Clustering_columns_groupContext(Context, State);
		EnterRule(_localctx, 388, RULE_clustering_columns_group);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3808; paren_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Clustering_whenContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode LOAD() { return GetToken(PlSqlParser.LOAD, 0); }
		public ITerminalNode YES() { return GetToken(PlSqlParser.YES, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode DATA() { return GetToken(PlSqlParser.DATA, 0); }
		public ITerminalNode MOVEMENT() { return GetToken(PlSqlParser.MOVEMENT, 0); }
		public Clustering_whenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clustering_when; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClustering_when(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Clustering_whenContext clustering_when() {
		Clustering_whenContext _localctx = new Clustering_whenContext(Context, State);
		EnterRule(_localctx, 390, RULE_clustering_when);
		int _la;
		try {
			State = 3817;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,449,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 3810;
				_la = TokenStream.LA(1);
				if ( !(_la==NO || _la==YES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3811; Match(ON);
				State = 3812; Match(LOAD);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 3813;
				_la = TokenStream.LA(1);
				if ( !(_la==NO || _la==YES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3814; Match(ON);
				State = 3815; Match(DATA);
				State = 3816; Match(MOVEMENT);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zonemap_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode MATERIALIZED() { return GetToken(PlSqlParser.MATERIALIZED, 0); }
		public ITerminalNode ZONEMAP() { return GetToken(PlSqlParser.ZONEMAP, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Zonemap_nameContext zonemap_name() {
			return GetRuleContext<Zonemap_nameContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode WITHOUT() { return GetToken(PlSqlParser.WITHOUT, 0); }
		public Zonemap_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zonemap_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZonemap_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zonemap_clauseContext zonemap_clause() {
		Zonemap_clauseContext _localctx = new Zonemap_clauseContext(Context, State);
		EnterRule(_localctx, 392, RULE_zonemap_clause);
		try {
			State = 3829;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3819; Match(WITH);
				State = 3820; Match(MATERIALIZED);
				State = 3821; Match(ZONEMAP);
				State = 3822; Match(LEFT_PAREN);
				State = 3823; zonemap_name();
				State = 3824; Match(RIGHT_PAREN);
				}
				break;
			case WITHOUT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3826; Match(WITHOUT);
				State = 3827; Match(MATERIALIZED);
				State = 3828; Match(ZONEMAP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Enable_disable_clauseContext : ParserRuleContext {
		public Exceptions_clauseContext exceptions_clause() {
			return GetRuleContext<Exceptions_clauseContext>(0);
		}
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode PRIMARY() { return GetToken(PlSqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Using_index_clauseContext using_index_clause() {
			return GetRuleContext<Using_index_clauseContext>(0);
		}
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode VALIDATE() { return GetToken(PlSqlParser.VALIDATE, 0); }
		public ITerminalNode NOVALIDATE() { return GetToken(PlSqlParser.NOVALIDATE, 0); }
		public Enable_disable_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enable_disable_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnable_disable_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Enable_disable_clauseContext enable_disable_clause() {
		Enable_disable_clauseContext _localctx = new Enable_disable_clauseContext(Context, State);
		EnterRule(_localctx, 394, RULE_enable_disable_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3831;
			_la = TokenStream.LA(1);
			if ( !(_la==DISABLE || _la==ENABLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3833;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOVALIDATE || _la==VALIDATE) {
				{
				State = 3832;
				_la = TokenStream.LA(1);
				if ( !(_la==NOVALIDATE || _la==VALIDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3841;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNIQUE:
				{
				State = 3835; Match(UNIQUE);
				State = 3836; paren_column_list();
				}
				break;
			case PRIMARY:
				{
				State = 3837; Match(PRIMARY);
				State = 3838; Match(KEY);
				}
				break;
			case CONSTRAINT:
				{
				State = 3839; Match(CONSTRAINT);
				State = 3840; constraint_name();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3844;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 3843; using_index_clause();
				}
			}

			State = 3846; exceptions_clause();
			State = 3848;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,454,Context) ) {
			case 1:
				{
				State = 3847; Match(CASCADE);
				}
				break;
			}
			State = 3853;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,455,Context) ) {
			case 1:
				{
				State = 3850; Match(KEEP);
				State = 3851; Match(INDEX);
				}
				break;
			case 2:
				{
				State = 3852; Match(DROP);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_partitioning_clausesContext : ParserRuleContext {
		public Range_partitionsContext range_partitions() {
			return GetRuleContext<Range_partitionsContext>(0);
		}
		public List_partitionsContext list_partitions() {
			return GetRuleContext<List_partitionsContext>(0);
		}
		public Hash_partitionsContext hash_partitions() {
			return GetRuleContext<Hash_partitionsContext>(0);
		}
		public Composite_range_partitionsContext composite_range_partitions() {
			return GetRuleContext<Composite_range_partitionsContext>(0);
		}
		public Composite_list_partitionsContext composite_list_partitions() {
			return GetRuleContext<Composite_list_partitionsContext>(0);
		}
		public Composite_hash_partitionsContext composite_hash_partitions() {
			return GetRuleContext<Composite_hash_partitionsContext>(0);
		}
		public Reference_partitioningContext reference_partitioning() {
			return GetRuleContext<Reference_partitioningContext>(0);
		}
		public Table_partitioning_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_partitioning_clauses; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_partitioning_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_partitioning_clausesContext table_partitioning_clauses() {
		Table_partitioning_clausesContext _localctx = new Table_partitioning_clausesContext(Context, State);
		EnterRule(_localctx, 396, RULE_table_partitioning_clauses);
		try {
			State = 3862;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,456,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3855; range_partitions();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3856; list_partitions();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3857; hash_partitions();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3858; composite_range_partitions();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3859; composite_list_partitions();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3860; composite_hash_partitions();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3861; reference_partitioning();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Range_partitionsContext : ParserRuleContext {
		public ITerminalNode[] PARTITION() { return GetTokens(PlSqlParser.PARTITION); }
		public ITerminalNode PARTITION(int i) {
			return GetToken(PlSqlParser.PARTITION, i);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public Range_values_clauseContext range_values_clause() {
			return GetRuleContext<Range_values_clauseContext>(0);
		}
		public Table_partition_descriptionContext table_partition_description() {
			return GetRuleContext<Table_partition_descriptionContext>(0);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode STORAGE() { return GetToken(PlSqlParser.STORAGE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public Partition_nameContext partition_name() {
			return GetRuleContext<Partition_nameContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Range_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_range_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRange_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Range_partitionsContext range_partitions() {
		Range_partitionsContext _localctx = new Range_partitionsContext(Context, State);
		EnterRule(_localctx, 398, RULE_range_partitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3864; Match(PARTITION);
			State = 3865; Match(BY);
			State = 3866; Match(RANGE);
			State = 3867; paren_column_list();
			State = 3885;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTERVAL) {
				{
				State = 3868; Match(INTERVAL);
				State = 3869; Match(LEFT_PAREN);
				State = 3870; expression();
				State = 3871; Match(RIGHT_PAREN);
				State = 3872; Match(STORAGE);
				State = 3873; Match(IN);
				State = 3874; Match(LEFT_PAREN);
				State = 3875; tablespace_name();
				State = 3880;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3876; Match(COMMA);
					State = 3877; tablespace_name();
					}
					}
					State = 3882;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3883; Match(RIGHT_PAREN);
				}
			}

			State = 3887; Match(LEFT_PAREN);
			State = 3888; Match(PARTITION);
			State = 3890;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 3889; partition_name();
				}
			}

			State = 3892; range_values_clause();
			State = 3893; table_partition_description();
			State = 3894; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hash_partitionsContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Individual_hash_partitionsContext individual_hash_partitions() {
			return GetRuleContext<Individual_hash_partitionsContext>(0);
		}
		public Hash_partition_quantityContext hash_partition_quantity() {
			return GetRuleContext<Hash_partition_quantityContext>(0);
		}
		public Hash_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hash_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHash_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hash_partitionsContext hash_partitions() {
		Hash_partitionsContext _localctx = new Hash_partitionsContext(Context, State);
		EnterRule(_localctx, 400, RULE_hash_partitions);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3896; Match(PARTITION);
			State = 3897; Match(BY);
			State = 3898; Match(HASH);
			State = 3899; paren_column_list();
			State = 3902;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_PAREN:
				{
				State = 3900; individual_hash_partitions();
				}
				break;
			case UNSIGNED_INTEGER:
				{
				State = 3901; hash_partition_quantity();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_propertiesContext : ParserRuleContext {
		public Object_type_col_propertiesContext object_type_col_properties() {
			return GetRuleContext<Object_type_col_propertiesContext>(0);
		}
		public Nested_table_col_propertiesContext nested_table_col_properties() {
			return GetRuleContext<Nested_table_col_propertiesContext>(0);
		}
		public Varray_col_propertiesContext varray_col_properties() {
			return GetRuleContext<Varray_col_propertiesContext>(0);
		}
		public Lob_storage_clauseContext lob_storage_clause() {
			return GetRuleContext<Lob_storage_clauseContext>(0);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public Lob_partitioning_storageContext[] lob_partitioning_storage() {
			return GetRuleContexts<Lob_partitioning_storageContext>();
		}
		public Lob_partitioning_storageContext lob_partitioning_storage(int i) {
			return GetRuleContext<Lob_partitioning_storageContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public Xmltype_column_propertiesContext xmltype_column_properties() {
			return GetRuleContext<Xmltype_column_propertiesContext>(0);
		}
		public Column_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_propertiesContext column_properties() {
		Column_propertiesContext _localctx = new Column_propertiesContext(Context, State);
		EnterRule(_localctx, 402, RULE_column_properties);
		try {
			int _alt;
			State = 3920;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COLUMN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3904; object_type_col_properties();
				}
				break;
			case NESTED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3905; nested_table_col_properties();
				}
				break;
			case LOB:
			case VARRAY:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3908;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VARRAY:
					{
					State = 3906; varray_col_properties();
					}
					break;
				case LOB:
					{
					State = 3907; lob_storage_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3916;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,462,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3910; Match(LEFT_PAREN);
						State = 3911; lob_partitioning_storage();
						State = 3912; Match(RIGHT_PAREN);
						}
						} 
					}
					State = 3918;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,462,Context);
				}
				}
				break;
			case XMLTYPE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3919; xmltype_column_properties();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmltype_column_propertiesContext : ParserRuleContext {
		public ITerminalNode XMLTYPE() { return GetToken(PlSqlParser.XMLTYPE, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Xmlschema_specContext xmlschema_spec() {
			return GetRuleContext<Xmlschema_specContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(PlSqlParser.COLUMN, 0); }
		public Xmltype_storageContext xmltype_storage() {
			return GetRuleContext<Xmltype_storageContext>(0);
		}
		public Xmltype_column_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmltype_column_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmltype_column_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmltype_column_propertiesContext xmltype_column_properties() {
		Xmltype_column_propertiesContext _localctx = new Xmltype_column_propertiesContext(Context, State);
		EnterRule(_localctx, 404, RULE_xmltype_column_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3922; Match(XMLTYPE);
			State = 3924;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN) {
				{
				State = 3923; Match(COLUMN);
				}
			}

			State = 3926; column_name();
			State = 3928;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STORE) {
				{
				State = 3927; xmltype_storage();
				}
			}

			State = 3930; xmlschema_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmltype_storageContext : ParserRuleContext {
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode VARRAYS() { return GetToken(PlSqlParser.VARRAYS, 0); }
		public ITerminalNode LOBS() { return GetToken(PlSqlParser.LOBS, 0); }
		public ITerminalNode TABLES() { return GetToken(PlSqlParser.TABLES, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public ITerminalNode RELATIONAL() { return GetToken(PlSqlParser.RELATIONAL, 0); }
		public ITerminalNode CLOB() { return GetToken(PlSqlParser.CLOB, 0); }
		public ITerminalNode BINARY() { return GetToken(PlSqlParser.BINARY, 0); }
		public ITerminalNode XML() { return GetToken(PlSqlParser.XML, 0); }
		public Lob_segnameContext lob_segname() {
			return GetRuleContext<Lob_segnameContext>(0);
		}
		public Paren_lob_parametersContext paren_lob_parameters() {
			return GetRuleContext<Paren_lob_parametersContext>(0);
		}
		public ITerminalNode SECUREFILE() { return GetToken(PlSqlParser.SECUREFILE, 0); }
		public ITerminalNode BASICFILE() { return GetToken(PlSqlParser.BASICFILE, 0); }
		public Xmltype_storageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmltype_storage; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmltype_storage(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmltype_storageContext xmltype_storage() {
		Xmltype_storageContext _localctx = new Xmltype_storageContext(Context, State);
		EnterRule(_localctx, 406, RULE_xmltype_storage);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3932; Match(STORE);
			State = 3957;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 3933; Match(AS);
				State = 3951;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,470,Context) ) {
				case 1:
					{
					State = 3934; Match(OBJECT);
					State = 3935; Match(RELATIONAL);
					}
					break;
				case 2:
					{
					State = 3937;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==BASICFILE || _la==SECUREFILE) {
						{
						State = 3936;
						_la = TokenStream.LA(1);
						if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 3942;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,467,Context) ) {
					case 1:
						{
						State = 3939; Match(CLOB);
						}
						break;
					case 2:
						{
						State = 3940; Match(BINARY);
						State = 3941; Match(XML);
						}
						break;
					}
					State = 3949;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,469,Context) ) {
					case 1:
						{
						State = 3944; lob_segname();
						State = 3946;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==LEFT_PAREN) {
							{
							State = 3945; paren_lob_parameters();
							}
						}

						}
						break;
					case 2:
						{
						State = 3948; paren_lob_parameters();
						}
						break;
					}
					}
					break;
				}
				}
				break;
			case ALL:
				{
				State = 3953; Match(ALL);
				State = 3954; Match(VARRAYS);
				State = 3955; Match(AS);
				State = 3956;
				_la = TokenStream.LA(1);
				if ( !(_la==LOBS || _la==TABLES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlschema_specContext : ParserRuleContext {
		public IToken xmlschema_url;
		public IToken xmlschema_url2;
		public ITerminalNode ELEMENT() { return GetToken(PlSqlParser.ELEMENT, 0); }
		public Element_nameContext element_name() {
			return GetRuleContext<Element_nameContext>(0);
		}
		public ITerminalNode SHARP() { return GetToken(PlSqlParser.SHARP, 0); }
		public ITerminalNode XMLSCHEMA() { return GetToken(PlSqlParser.XMLSCHEMA, 0); }
		public ITerminalNode[] CHAR_STRING() { return GetTokens(PlSqlParser.CHAR_STRING); }
		public ITerminalNode CHAR_STRING(int i) {
			return GetToken(PlSqlParser.CHAR_STRING, i);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode VARRAYS() { return GetToken(PlSqlParser.VARRAYS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode NONSCHEMA() { return GetToken(PlSqlParser.NONSCHEMA, 0); }
		public ITerminalNode ANYSCHEMA() { return GetToken(PlSqlParser.ANYSCHEMA, 0); }
		public ITerminalNode LOBS() { return GetToken(PlSqlParser.LOBS, 0); }
		public ITerminalNode TABLES() { return GetToken(PlSqlParser.TABLES, 0); }
		public ITerminalNode[] ALLOW() { return GetTokens(PlSqlParser.ALLOW); }
		public ITerminalNode ALLOW(int i) {
			return GetToken(PlSqlParser.ALLOW, i);
		}
		public ITerminalNode[] DISALLOW() { return GetTokens(PlSqlParser.DISALLOW); }
		public ITerminalNode DISALLOW(int i) {
			return GetToken(PlSqlParser.DISALLOW, i);
		}
		public Xmlschema_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlschema_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlschema_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlschema_specContext xmlschema_spec() {
		Xmlschema_specContext _localctx = new Xmlschema_specContext(Context, State);
		EnterRule(_localctx, 408, RULE_xmlschema_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3961;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XMLSCHEMA) {
				{
				State = 3959; Match(XMLSCHEMA);
				State = 3960; _localctx.xmlschema_url = Match(CHAR_STRING);
				}
			}

			State = 3963; Match(ELEMENT);
			State = 3968;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case REGULAR_ID:
				{
				State = 3964; element_name();
				}
				break;
			case CHAR_STRING:
				{
				State = 3965; _localctx.xmlschema_url2 = Match(CHAR_STRING);
				State = 3966; Match(SHARP);
				State = 3967; element_name();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3975;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,474,Context) ) {
			case 1:
				{
				State = 3970; Match(STORE);
				State = 3971; Match(ALL);
				State = 3972; Match(VARRAYS);
				State = 3973; Match(AS);
				State = 3974;
				_la = TokenStream.LA(1);
				if ( !(_la==LOBS || _la==TABLES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 3979;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,475,Context) ) {
			case 1:
				{
				State = 3977;
				_la = TokenStream.LA(1);
				if ( !(_la==ALLOW || _la==DISALLOW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3978; Match(NONSCHEMA);
				}
				break;
			}
			State = 3983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALLOW || _la==DISALLOW) {
				{
				State = 3981;
				_la = TokenStream.LA(1);
				if ( !(_la==ALLOW || _la==DISALLOW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3982; Match(ANYSCHEMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class List_partitionsContext : ParserRuleContext {
		public ITerminalNode[] PARTITION() { return GetTokens(PlSqlParser.PARTITION); }
		public ITerminalNode PARTITION(int i) {
			return GetToken(PlSqlParser.PARTITION, i);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode LIST() { return GetToken(PlSqlParser.LIST, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public List_values_clauseContext[] list_values_clause() {
			return GetRuleContexts<List_values_clauseContext>();
		}
		public List_values_clauseContext list_values_clause(int i) {
			return GetRuleContext<List_values_clauseContext>(i);
		}
		public Table_partition_descriptionContext[] table_partition_description() {
			return GetRuleContexts<Table_partition_descriptionContext>();
		}
		public Table_partition_descriptionContext table_partition_description(int i) {
			return GetRuleContext<Table_partition_descriptionContext>(i);
		}
		public Partition_nameContext[] partition_name() {
			return GetRuleContexts<Partition_nameContext>();
		}
		public Partition_nameContext partition_name(int i) {
			return GetRuleContext<Partition_nameContext>(i);
		}
		public List_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_list_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitList_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public List_partitionsContext list_partitions() {
		List_partitionsContext _localctx = new List_partitionsContext(Context, State);
		EnterRule(_localctx, 410, RULE_list_partitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3985; Match(PARTITION);
			State = 3986; Match(BY);
			State = 3987; Match(LIST);
			State = 3988; paren_column_list();
			State = 3989; Match(LEFT_PAREN);
			State = 3997;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 3990; Match(PARTITION);
				State = 3992;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
					{
					State = 3991; partition_name();
					}
				}

				State = 3994; list_values_clause();
				State = 3995; table_partition_description();
				}
				}
				State = 3999;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==PARTITION );
			State = 4001; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Composite_range_partitionsContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public Range_partition_descContext range_partition_desc() {
			return GetRuleContext<Range_partition_descContext>(0);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public Subpartition_by_rangeContext subpartition_by_range() {
			return GetRuleContext<Subpartition_by_rangeContext>(0);
		}
		public Subpartition_by_listContext subpartition_by_list() {
			return GetRuleContext<Subpartition_by_listContext>(0);
		}
		public Subpartition_by_hashContext subpartition_by_hash() {
			return GetRuleContext<Subpartition_by_hashContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Composite_range_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_composite_range_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComposite_range_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Composite_range_partitionsContext composite_range_partitions() {
		Composite_range_partitionsContext _localctx = new Composite_range_partitionsContext(Context, State);
		EnterRule(_localctx, 412, RULE_composite_range_partitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4003; Match(PARTITION);
			State = 4004; Match(BY);
			State = 4005; Match(RANGE);
			State = 4006; paren_column_list();
			State = 4007; Match(INTERVAL);
			State = 4008; Match(LEFT_PAREN);
			State = 4009; expression();
			State = 4010; Match(RIGHT_PAREN);
			{
			State = 4011; Match(STORE);
			State = 4012; Match(IN);
			State = 4013; Match(LEFT_PAREN);
			State = 4014; tablespace_name();
			State = 4019;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4015; Match(COMMA);
				State = 4016; tablespace_name();
				}
				}
				State = 4021;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4022; Match(RIGHT_PAREN);
			}
			State = 4027;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,480,Context) ) {
			case 1:
				{
				State = 4024; subpartition_by_range();
				}
				break;
			case 2:
				{
				State = 4025; subpartition_by_list();
				}
				break;
			case 3:
				{
				State = 4026; subpartition_by_hash();
				}
				break;
			}
			State = 4029; Match(LEFT_PAREN);
			State = 4030; range_partition_desc();
			State = 4031; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Composite_hash_partitionsContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Subpartition_by_rangeContext subpartition_by_range() {
			return GetRuleContext<Subpartition_by_rangeContext>(0);
		}
		public Subpartition_by_listContext subpartition_by_list() {
			return GetRuleContext<Subpartition_by_listContext>(0);
		}
		public Subpartition_by_hashContext subpartition_by_hash() {
			return GetRuleContext<Subpartition_by_hashContext>(0);
		}
		public Individual_hash_partitionsContext individual_hash_partitions() {
			return GetRuleContext<Individual_hash_partitionsContext>(0);
		}
		public Hash_partitions_by_quantityContext hash_partitions_by_quantity() {
			return GetRuleContext<Hash_partitions_by_quantityContext>(0);
		}
		public Composite_hash_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_composite_hash_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComposite_hash_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Composite_hash_partitionsContext composite_hash_partitions() {
		Composite_hash_partitionsContext _localctx = new Composite_hash_partitionsContext(Context, State);
		EnterRule(_localctx, 414, RULE_composite_hash_partitions);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4033; Match(PARTITION);
			State = 4034; Match(BY);
			State = 4035; Match(HASH);
			State = 4036; paren_column_list();
			State = 4040;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,481,Context) ) {
			case 1:
				{
				State = 4037; subpartition_by_range();
				}
				break;
			case 2:
				{
				State = 4038; subpartition_by_list();
				}
				break;
			case 3:
				{
				State = 4039; subpartition_by_hash();
				}
				break;
			}
			State = 4044;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_PAREN:
				{
				State = 4042; individual_hash_partitions();
				}
				break;
			case PARTITIONS:
				{
				State = 4043; hash_partitions_by_quantity();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Composite_list_partitionsContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode LIST() { return GetToken(PlSqlParser.LIST, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public List_partition_descContext[] list_partition_desc() {
			return GetRuleContexts<List_partition_descContext>();
		}
		public List_partition_descContext list_partition_desc(int i) {
			return GetRuleContext<List_partition_descContext>(i);
		}
		public Subpartition_by_rangeContext subpartition_by_range() {
			return GetRuleContext<Subpartition_by_rangeContext>(0);
		}
		public Subpartition_by_listContext subpartition_by_list() {
			return GetRuleContext<Subpartition_by_listContext>(0);
		}
		public Subpartition_by_hashContext subpartition_by_hash() {
			return GetRuleContext<Subpartition_by_hashContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Composite_list_partitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_composite_list_partitions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComposite_list_partitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Composite_list_partitionsContext composite_list_partitions() {
		Composite_list_partitionsContext _localctx = new Composite_list_partitionsContext(Context, State);
		EnterRule(_localctx, 416, RULE_composite_list_partitions);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4046; Match(PARTITION);
			State = 4047; Match(BY);
			State = 4048; Match(LIST);
			State = 4049; paren_column_list();
			State = 4053;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,483,Context) ) {
			case 1:
				{
				State = 4050; subpartition_by_range();
				}
				break;
			case 2:
				{
				State = 4051; subpartition_by_list();
				}
				break;
			case 3:
				{
				State = 4052; subpartition_by_hash();
				}
				break;
			}
			State = 4055; list_partition_desc();
			State = 4060;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,484,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 4056; Match(COMMA);
					State = 4057; list_partition_desc();
					}
					} 
				}
				State = 4062;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,484,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Range_partition_descContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public Partition_nameContext partition_name() {
			return GetRuleContext<Partition_nameContext>(0);
		}
		public Range_values_clauseContext range_values_clause() {
			return GetRuleContext<Range_values_clauseContext>(0);
		}
		public Table_partition_descriptionContext table_partition_description() {
			return GetRuleContext<Table_partition_descriptionContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Range_subpartition_descContext[] range_subpartition_desc() {
			return GetRuleContexts<Range_subpartition_descContext>();
		}
		public Range_subpartition_descContext range_subpartition_desc(int i) {
			return GetRuleContext<Range_subpartition_descContext>(i);
		}
		public List_subpartition_descContext[] list_subpartition_desc() {
			return GetRuleContexts<List_subpartition_descContext>();
		}
		public List_subpartition_descContext list_subpartition_desc(int i) {
			return GetRuleContext<List_subpartition_descContext>(i);
		}
		public Individual_hash_subpartsContext[] individual_hash_subparts() {
			return GetRuleContexts<Individual_hash_subpartsContext>();
		}
		public Individual_hash_subpartsContext individual_hash_subparts(int i) {
			return GetRuleContext<Individual_hash_subpartsContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Hash_subparts_by_quantityContext hash_subparts_by_quantity() {
			return GetRuleContext<Hash_subparts_by_quantityContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Range_partition_descContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_range_partition_desc; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRange_partition_desc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Range_partition_descContext range_partition_desc() {
		Range_partition_descContext _localctx = new Range_partition_descContext(Context, State);
		EnterRule(_localctx, 418, RULE_range_partition_desc);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4063; Match(PARTITION);
			State = 4064; partition_name();
			State = 4065; range_values_clause();
			State = 4066; table_partition_description();
			State = 4095;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,488,Context) ) {
			case 1:
				{
				State = 4067; Match(LEFT_PAREN);
				State = 4068; range_subpartition_desc();
				State = 4073;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4069; Match(COMMA);
					State = 4070; range_subpartition_desc();
					}
					}
					State = 4075;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				{
				State = 4076; list_subpartition_desc();
				State = 4081;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4077; Match(COMMA);
					State = 4078; list_subpartition_desc();
					}
					}
					State = 4083;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 3:
				{
				State = 4084; individual_hash_subparts();
				State = 4089;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4085; Match(COMMA);
					State = 4086; individual_hash_subparts();
					}
					}
					State = 4091;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4092; Match(RIGHT_PAREN);
				}
				break;
			case 4:
				{
				State = 4094; hash_subparts_by_quantity();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class List_partition_descContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public Partition_nameContext partition_name() {
			return GetRuleContext<Partition_nameContext>(0);
		}
		public List_values_clauseContext list_values_clause() {
			return GetRuleContext<List_values_clauseContext>(0);
		}
		public Table_partition_descriptionContext table_partition_description() {
			return GetRuleContext<Table_partition_descriptionContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Range_subpartition_descContext[] range_subpartition_desc() {
			return GetRuleContexts<Range_subpartition_descContext>();
		}
		public Range_subpartition_descContext range_subpartition_desc(int i) {
			return GetRuleContext<Range_subpartition_descContext>(i);
		}
		public List_subpartition_descContext[] list_subpartition_desc() {
			return GetRuleContexts<List_subpartition_descContext>();
		}
		public List_subpartition_descContext list_subpartition_desc(int i) {
			return GetRuleContext<List_subpartition_descContext>(i);
		}
		public Individual_hash_subpartsContext[] individual_hash_subparts() {
			return GetRuleContexts<Individual_hash_subpartsContext>();
		}
		public Individual_hash_subpartsContext individual_hash_subparts(int i) {
			return GetRuleContext<Individual_hash_subpartsContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Hash_subparts_by_quantityContext hash_subparts_by_quantity() {
			return GetRuleContext<Hash_subparts_by_quantityContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public List_partition_descContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_list_partition_desc; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitList_partition_desc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public List_partition_descContext list_partition_desc() {
		List_partition_descContext _localctx = new List_partition_descContext(Context, State);
		EnterRule(_localctx, 420, RULE_list_partition_desc);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4097; Match(PARTITION);
			State = 4098; partition_name();
			State = 4099; list_values_clause();
			State = 4100; table_partition_description();
			State = 4129;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,492,Context) ) {
			case 1:
				{
				State = 4101; Match(LEFT_PAREN);
				State = 4102; range_subpartition_desc();
				State = 4107;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,489,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4103; Match(COMMA);
						State = 4104; range_subpartition_desc();
						}
						} 
					}
					State = 4109;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,489,Context);
				}
				}
				break;
			case 2:
				{
				State = 4110; list_subpartition_desc();
				State = 4115;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,490,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4111; Match(COMMA);
						State = 4112; list_subpartition_desc();
						}
						} 
					}
					State = 4117;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,490,Context);
				}
				}
				break;
			case 3:
				{
				State = 4118; individual_hash_subparts();
				State = 4123;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4119; Match(COMMA);
					State = 4120; individual_hash_subparts();
					}
					}
					State = 4125;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4126; Match(RIGHT_PAREN);
				}
				break;
			case 4:
				{
				State = 4128; hash_subparts_by_quantity();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Range_subpartition_descContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public Range_values_clauseContext range_values_clause() {
			return GetRuleContext<Range_values_clauseContext>(0);
		}
		public Subpartition_nameContext subpartition_name() {
			return GetRuleContext<Subpartition_nameContext>(0);
		}
		public Indexing_clauseContext indexing_clause() {
			return GetRuleContext<Indexing_clauseContext>(0);
		}
		public Partitioning_storage_clauseContext partitioning_storage_clause() {
			return GetRuleContext<Partitioning_storage_clauseContext>(0);
		}
		public Range_subpartition_descContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_range_subpartition_desc; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRange_subpartition_desc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Range_subpartition_descContext range_subpartition_desc() {
		Range_subpartition_descContext _localctx = new Range_subpartition_descContext(Context, State);
		EnterRule(_localctx, 422, RULE_range_subpartition_desc);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4131; Match(SUBPARTITION);
			State = 4133;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4132; subpartition_name();
				}
			}

			State = 4135; range_values_clause();
			State = 4137;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEXING) {
				{
				State = 4136; indexing_clause();
				}
			}

			State = 4140;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,495,Context) ) {
			case 1:
				{
				State = 4139; partitioning_storage_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class List_subpartition_descContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public List_values_clauseContext list_values_clause() {
			return GetRuleContext<List_values_clauseContext>(0);
		}
		public Subpartition_nameContext subpartition_name() {
			return GetRuleContext<Subpartition_nameContext>(0);
		}
		public Indexing_clauseContext indexing_clause() {
			return GetRuleContext<Indexing_clauseContext>(0);
		}
		public Partitioning_storage_clauseContext partitioning_storage_clause() {
			return GetRuleContext<Partitioning_storage_clauseContext>(0);
		}
		public List_subpartition_descContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_list_subpartition_desc; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitList_subpartition_desc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public List_subpartition_descContext list_subpartition_desc() {
		List_subpartition_descContext _localctx = new List_subpartition_descContext(Context, State);
		EnterRule(_localctx, 424, RULE_list_subpartition_desc);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4142; Match(SUBPARTITION);
			State = 4144;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4143; subpartition_name();
				}
			}

			State = 4146; list_values_clause();
			State = 4148;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEXING) {
				{
				State = 4147; indexing_clause();
				}
			}

			State = 4151;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,498,Context) ) {
			case 1:
				{
				State = 4150; partitioning_storage_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Individual_hash_subpartsContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public Subpartition_nameContext subpartition_name() {
			return GetRuleContext<Subpartition_nameContext>(0);
		}
		public Indexing_clauseContext indexing_clause() {
			return GetRuleContext<Indexing_clauseContext>(0);
		}
		public Partitioning_storage_clauseContext partitioning_storage_clause() {
			return GetRuleContext<Partitioning_storage_clauseContext>(0);
		}
		public Individual_hash_subpartsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_individual_hash_subparts; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndividual_hash_subparts(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Individual_hash_subpartsContext individual_hash_subparts() {
		Individual_hash_subpartsContext _localctx = new Individual_hash_subpartsContext(Context, State);
		EnterRule(_localctx, 426, RULE_individual_hash_subparts);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4153; Match(SUBPARTITION);
			State = 4155;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,499,Context) ) {
			case 1:
				{
				State = 4154; subpartition_name();
				}
				break;
			}
			State = 4158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEXING) {
				{
				State = 4157; indexing_clause();
				}
			}

			State = 4161;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMN || _la==COMPRESS || _la==INMEMORY || _la==LOB || ((((_la - 370)) & ~0x3f) == 0 && ((1L << (_la - 370)) & ((1L << (NOCOMPRESS - 370)) | (1L << (NO - 370)) | (1L << (OVERFLOW - 370)))) != 0) || _la==ROW || _la==TABLESPACE || _la==VARRAY) {
				{
				State = 4160; partitioning_storage_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hash_subparts_by_quantityContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Hash_subparts_by_quantityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hash_subparts_by_quantity; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHash_subparts_by_quantity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hash_subparts_by_quantityContext hash_subparts_by_quantity() {
		Hash_subparts_by_quantityContext _localctx = new Hash_subparts_by_quantityContext(Context, State);
		EnterRule(_localctx, 428, RULE_hash_subparts_by_quantity);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4163; Match(SUBPARTITION);
			State = 4164; integer();
			State = 4178;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,503,Context) ) {
			case 1:
				{
				State = 4165; Match(STORE);
				State = 4166; Match(IN);
				{
				State = 4167; Match(LEFT_PAREN);
				State = 4168; tablespace_name();
				State = 4173;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4169; Match(COMMA);
					State = 4170; tablespace_name();
					}
					}
					State = 4175;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4176; Match(RIGHT_PAREN);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_partition_descriptionContext : ParserRuleContext {
		public Deferred_segment_creationContext deferred_segment_creation() {
			return GetRuleContext<Deferred_segment_creationContext>(0);
		}
		public Indexing_clauseContext indexing_clause() {
			return GetRuleContext<Indexing_clauseContext>(0);
		}
		public Segment_attributes_clauseContext[] segment_attributes_clause() {
			return GetRuleContexts<Segment_attributes_clauseContext>();
		}
		public Segment_attributes_clauseContext segment_attributes_clause(int i) {
			return GetRuleContext<Segment_attributes_clauseContext>(i);
		}
		public Table_compressionContext table_compression() {
			return GetRuleContext<Table_compressionContext>(0);
		}
		public Prefix_compressionContext prefix_compression() {
			return GetRuleContext<Prefix_compressionContext>(0);
		}
		public Inmemory_clauseContext inmemory_clause() {
			return GetRuleContext<Inmemory_clauseContext>(0);
		}
		public Ilm_clauseContext ilm_clause() {
			return GetRuleContext<Ilm_clauseContext>(0);
		}
		public ITerminalNode OVERFLOW() { return GetToken(PlSqlParser.OVERFLOW, 0); }
		public Lob_storage_clauseContext[] lob_storage_clause() {
			return GetRuleContexts<Lob_storage_clauseContext>();
		}
		public Lob_storage_clauseContext lob_storage_clause(int i) {
			return GetRuleContext<Lob_storage_clauseContext>(i);
		}
		public Varray_col_propertiesContext[] varray_col_properties() {
			return GetRuleContexts<Varray_col_propertiesContext>();
		}
		public Varray_col_propertiesContext varray_col_properties(int i) {
			return GetRuleContext<Varray_col_propertiesContext>(i);
		}
		public Nested_table_col_propertiesContext[] nested_table_col_properties() {
			return GetRuleContexts<Nested_table_col_propertiesContext>();
		}
		public Nested_table_col_propertiesContext nested_table_col_properties(int i) {
			return GetRuleContext<Nested_table_col_propertiesContext>(i);
		}
		public Table_partition_descriptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_partition_description; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_partition_description(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_partition_descriptionContext table_partition_description() {
		Table_partition_descriptionContext _localctx = new Table_partition_descriptionContext(Context, State);
		EnterRule(_localctx, 430, RULE_table_partition_description);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4181;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,504,Context) ) {
			case 1:
				{
				State = 4180; deferred_segment_creation();
				}
				break;
			}
			State = 4184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEXING) {
				{
				State = 4183; indexing_clause();
				}
			}

			State = 4187;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
				{
				State = 4186; segment_attributes_clause();
				}
			}

			State = 4191;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,507,Context) ) {
			case 1:
				{
				State = 4189; table_compression();
				}
				break;
			case 2:
				{
				State = 4190; prefix_compression();
				}
				break;
			}
			State = 4194;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,508,Context) ) {
			case 1:
				{
				State = 4193; inmemory_clause();
				}
				break;
			}
			State = 4197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,509,Context) ) {
			case 1:
				{
				State = 4196; ilm_clause();
				}
				break;
			}
			State = 4203;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERFLOW) {
				{
				State = 4199; Match(OVERFLOW);
				State = 4201;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
					{
					State = 4200; segment_attributes_clause();
					}
				}

				}
			}

			State = 4210;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,513,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 4208;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case LOB:
						{
						State = 4205; lob_storage_clause();
						}
						break;
					case VARRAY:
						{
						State = 4206; varray_col_properties();
						}
						break;
					case NESTED:
						{
						State = 4207; nested_table_col_properties();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 4212;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,513,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Range_values_clauseContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode LESS() { return GetToken(PlSqlParser.LESS, 0); }
		public ITerminalNode THAN() { return GetToken(PlSqlParser.THAN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Range_values_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_range_values_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRange_values_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Range_values_clauseContext range_values_clause() {
		Range_values_clauseContext _localctx = new Range_values_clauseContext(Context, State);
		EnterRule(_localctx, 432, RULE_range_values_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4213; Match(VALUES);
			State = 4214; Match(LESS);
			State = 4215; Match(THAN);
			State = 4216; Match(LEFT_PAREN);
			State = 4226;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,515,Context) ) {
			case 1:
				{
				State = 4217; literal();
				State = 4222;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4218; Match(COMMA);
					State = 4219; literal();
					}
					}
					State = 4224;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				{
				State = 4225; Match(MAXVALUE);
				}
				break;
			}
			State = 4228; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class List_values_clauseContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public List_values_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_list_values_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitList_values_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public List_values_clauseContext list_values_clause() {
		List_values_clauseContext _localctx = new List_values_clauseContext(Context, State);
		EnterRule(_localctx, 434, RULE_list_values_clause);
		try {
			int _alt;
			State = 4245;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUES:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4230; Match(VALUES);
				State = 4231; Match(LEFT_PAREN);
				State = 4241;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,517,Context) ) {
				case 1:
					{
					State = 4232; literal();
					State = 4237;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,516,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 4233; Match(COMMA);
							State = 4234; literal();
							}
							} 
						}
						State = 4239;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,516,Context);
					}
					}
					break;
				case 2:
					{
					State = 4240; Match(NULL);
					}
					break;
				}
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4243; Match(DEFAULT);
				State = 4244; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subpartition_by_rangeContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Subpartition_templateContext subpartition_template() {
			return GetRuleContext<Subpartition_templateContext>(0);
		}
		public Subpartition_by_rangeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartition_by_range; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubpartition_by_range(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subpartition_by_rangeContext subpartition_by_range() {
		Subpartition_by_rangeContext _localctx = new Subpartition_by_rangeContext(Context, State);
		EnterRule(_localctx, 436, RULE_subpartition_by_range);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4247; Match(SUBPARTITION);
			State = 4248; Match(BY);
			State = 4249; Match(RANGE);
			State = 4250; paren_column_list();
			State = 4251; subpartition_template();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subpartition_by_listContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode LIST() { return GetToken(PlSqlParser.LIST, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Subpartition_templateContext subpartition_template() {
			return GetRuleContext<Subpartition_templateContext>(0);
		}
		public Subpartition_by_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartition_by_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubpartition_by_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subpartition_by_listContext subpartition_by_list() {
		Subpartition_by_listContext _localctx = new Subpartition_by_listContext(Context, State);
		EnterRule(_localctx, 438, RULE_subpartition_by_list);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4253; Match(SUBPARTITION);
			State = 4254; Match(BY);
			State = 4255; Match(LIST);
			State = 4256; paren_column_list();
			State = 4257; subpartition_template();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subpartition_by_hashContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode SUBPARTITIONS() { return GetToken(PlSqlParser.SUBPARTITIONS, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Subpartition_templateContext subpartition_template() {
			return GetRuleContext<Subpartition_templateContext>(0);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Subpartition_by_hashContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartition_by_hash; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubpartition_by_hash(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subpartition_by_hashContext subpartition_by_hash() {
		Subpartition_by_hashContext _localctx = new Subpartition_by_hashContext(Context, State);
		EnterRule(_localctx, 440, RULE_subpartition_by_hash);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4259; Match(SUBPARTITION);
			State = 4260; Match(BY);
			State = 4261; Match(HASH);
			State = 4262; paren_column_list();
			{
			State = 4263; Match(SUBPARTITIONS);
			State = 4264; integer();
			{
			State = 4265; Match(STORE);
			State = 4266; Match(IN);
			State = 4267; Match(LEFT_PAREN);
			State = 4268; tablespace_name();
			State = 4273;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4269; Match(COMMA);
				State = 4270; tablespace_name();
				}
				}
				State = 4275;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4276; Match(RIGHT_PAREN);
			}
			State = 4278; subpartition_template();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subpartition_templateContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode TEMPLATE() { return GetToken(PlSqlParser.TEMPLATE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Range_subpartition_descContext[] range_subpartition_desc() {
			return GetRuleContexts<Range_subpartition_descContext>();
		}
		public Range_subpartition_descContext range_subpartition_desc(int i) {
			return GetRuleContext<Range_subpartition_descContext>(i);
		}
		public List_subpartition_descContext[] list_subpartition_desc() {
			return GetRuleContexts<List_subpartition_descContext>();
		}
		public List_subpartition_descContext list_subpartition_desc(int i) {
			return GetRuleContext<List_subpartition_descContext>(i);
		}
		public Individual_hash_subpartsContext[] individual_hash_subparts() {
			return GetRuleContexts<Individual_hash_subpartsContext>();
		}
		public Individual_hash_subpartsContext individual_hash_subparts(int i) {
			return GetRuleContext<Individual_hash_subpartsContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Hash_partition_quantityContext hash_partition_quantity() {
			return GetRuleContext<Hash_partition_quantityContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Subpartition_templateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartition_template; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubpartition_template(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subpartition_templateContext subpartition_template() {
		Subpartition_templateContext _localctx = new Subpartition_templateContext(Context, State);
		EnterRule(_localctx, 442, RULE_subpartition_template);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4280; Match(SUBPARTITION);
			State = 4281; Match(TEMPLATE);
			State = 4310;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,523,Context) ) {
			case 1:
				{
				State = 4282; Match(LEFT_PAREN);
				State = 4283; range_subpartition_desc();
				State = 4288;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4284; Match(COMMA);
					State = 4285; range_subpartition_desc();
					}
					}
					State = 4290;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				{
				State = 4291; list_subpartition_desc();
				State = 4296;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4292; Match(COMMA);
					State = 4293; list_subpartition_desc();
					}
					}
					State = 4298;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 3:
				{
				State = 4299; individual_hash_subparts();
				State = 4304;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4300; Match(COMMA);
					State = 4301; individual_hash_subparts();
					}
					}
					State = 4306;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4307; Match(RIGHT_PAREN);
				}
				break;
			case 4:
				{
				State = 4309; hash_partition_quantity();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_partitioningContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ConstraintContext constraint() {
			return GetRuleContext<ConstraintContext>(0);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public Reference_partition_descContext[] reference_partition_desc() {
			return GetRuleContexts<Reference_partition_descContext>();
		}
		public Reference_partition_descContext reference_partition_desc(int i) {
			return GetRuleContext<Reference_partition_descContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Reference_partitioningContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_partitioning; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_partitioning(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_partitioningContext reference_partitioning() {
		Reference_partitioningContext _localctx = new Reference_partitioningContext(Context, State);
		EnterRule(_localctx, 444, RULE_reference_partitioning);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4312; Match(PARTITION);
			State = 4313; Match(BY);
			State = 4314; Match(REFERENCE);
			State = 4315; Match(LEFT_PAREN);
			State = 4316; constraint();
			State = 4317; Match(RIGHT_PAREN);
			State = 4326;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,525,Context) ) {
			case 1:
				{
				State = 4318; Match(LEFT_PAREN);
				State = 4319; reference_partition_desc();
				State = 4322;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 4320; Match(COMMA);
					State = 4321; reference_partition_desc();
					}
				}

				State = 4324; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_partition_descContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode SYSTEM() { return GetToken(PlSqlParser.SYSTEM, 0); }
		public ITerminalNode PARTITIONS() { return GetToken(PlSqlParser.PARTITIONS, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Reference_partition_descContext[] reference_partition_desc() {
			return GetRuleContexts<Reference_partition_descContext>();
		}
		public Reference_partition_descContext reference_partition_desc(int i) {
			return GetRuleContext<Reference_partition_descContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Reference_partition_descContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_partition_desc; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_partition_desc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_partition_descContext reference_partition_desc() {
		Reference_partition_descContext _localctx = new Reference_partition_descContext(Context, State);
		EnterRule(_localctx, 446, RULE_reference_partition_desc);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4328; Match(PARTITION);
			State = 4329; Match(BY);
			State = 4330; Match(SYSTEM);
			State = 4340;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PARTITIONS:
				{
				State = 4331; Match(PARTITIONS);
				State = 4332; integer();
				}
				break;
			case PARTITION:
				{
				{
				State = 4333; reference_partition_desc();
				State = 4336;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4334; Match(COMMA);
						State = 4335; reference_partition_desc();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4338;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,526,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				}
				break;
			case RIGHT_PAREN:
			case COMMA:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_type_col_propertiesContext : ParserRuleContext {
		public ITerminalNode COLUMN() { return GetToken(PlSqlParser.COLUMN, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Substituable_column_clauseContext substituable_column_clause() {
			return GetRuleContext<Substituable_column_clauseContext>(0);
		}
		public Object_type_col_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_type_col_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_type_col_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_type_col_propertiesContext object_type_col_properties() {
		Object_type_col_propertiesContext _localctx = new Object_type_col_propertiesContext(Context, State);
		EnterRule(_localctx, 448, RULE_object_type_col_properties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4342; Match(COLUMN);
			State = 4343; column_name();
			State = 4344; substituable_column_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Substituable_column_clauseContext : ParserRuleContext {
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode ELEMENT() { return GetToken(PlSqlParser.ELEMENT, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(PlSqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode LEVELS() { return GetToken(PlSqlParser.LEVELS, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Substituable_column_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substituable_column_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstituable_column_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Substituable_column_clauseContext substituable_column_clause() {
		Substituable_column_clauseContext _localctx = new Substituable_column_clauseContext(Context, State);
		EnterRule(_localctx, 450, RULE_substituable_column_clause);
		int _la;
		try {
			State = 4366;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ELEMENT:
			case IS:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 4347;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELEMENT) {
					{
					State = 4346; Match(ELEMENT);
					}
				}

				State = 4349; Match(IS);
				State = 4350; Match(OF);
				State = 4352;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TYPE) {
					{
					State = 4351; Match(TYPE);
					}
				}

				State = 4354; Match(LEFT_PAREN);
				State = 4355; Match(ONLY);
				State = 4356; type_name();
				State = 4357; Match(RIGHT_PAREN);
				}
				}
				break;
			case NOT:
			case SUBSTITUTABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4360;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 4359; Match(NOT);
					}
				}

				State = 4362; Match(SUBSTITUTABLE);
				State = 4363; Match(AT);
				State = 4364; Match(ALL);
				State = 4365; Match(LEVELS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Nested_table_col_propertiesContext : ParserRuleContext {
		public Collection_nameContext nested_item;
		public Table_fullnameContext storage_table;
		public ITerminalNode NESTED() { return GetToken(PlSqlParser.NESTED, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode[] AS() { return GetTokens(PlSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlSqlParser.AS, i);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Table_fullnameContext table_fullname() {
			return GetRuleContext<Table_fullnameContext>(0);
		}
		public ITerminalNode LOCATOR() { return GetToken(PlSqlParser.LOCATOR, 0); }
		public ITerminalNode[] VALUE() { return GetTokens(PlSqlParser.VALUE); }
		public ITerminalNode VALUE(int i) {
			return GetToken(PlSqlParser.VALUE, i);
		}
		public ITerminalNode COLUMN() { return GetToken(PlSqlParser.COLUMN, 0); }
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public Substituable_column_clauseContext substituable_column_clause() {
			return GetRuleContext<Substituable_column_clauseContext>(0);
		}
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode GLOBAL() { return GetToken(PlSqlParser.GLOBAL, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public Object_propertiesContext[] object_properties() {
			return GetRuleContexts<Object_propertiesContext>();
		}
		public Object_propertiesContext object_properties(int i) {
			return GetRuleContext<Object_propertiesContext>(i);
		}
		public Physical_propertiesContext[] physical_properties() {
			return GetRuleContexts<Physical_propertiesContext>();
		}
		public Physical_propertiesContext physical_properties(int i) {
			return GetRuleContext<Physical_propertiesContext>(i);
		}
		public Column_propertiesContext[] column_properties() {
			return GetRuleContexts<Column_propertiesContext>();
		}
		public Column_propertiesContext column_properties(int i) {
			return GetRuleContext<Column_propertiesContext>(i);
		}
		public Nested_table_col_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nested_table_col_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNested_table_col_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Nested_table_col_propertiesContext nested_table_col_properties() {
		Nested_table_col_propertiesContext _localctx = new Nested_table_col_propertiesContext(Context, State);
		EnterRule(_localctx, 452, RULE_nested_table_col_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4368; Match(NESTED);
			State = 4369; Match(TABLE);
			State = 4373;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4370; _localctx.nested_item = collection_name();
				}
				break;
			case COLUMN:
				{
				State = 4371; Match(COLUMN);
				State = 4372; Match(VALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4376;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELEMENT || _la==IS || _la==NOT || _la==SUBSTITUTABLE) {
				{
				State = 4375; substituable_column_clause();
				}
			}

			State = 4380;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 4378; Match(LOCAL);
				State = 4379; Match(GLOBAL);
				}
			}

			State = 4382; Match(STORE);
			State = 4383; Match(AS);
			State = 4384; _localctx.storage_table = table_fullname();
			State = 4398;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 4385; Match(LEFT_PAREN);
				State = 4392;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 4392;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case LEFT_PAREN:
						{
						State = 4386; Match(LEFT_PAREN);
						State = 4387; object_properties();
						State = 4388; Match(RIGHT_PAREN);
						}
						break;
					case FILESYSTEM_LIKE_LOGGING:
					case INITRANS:
					case LOGGING:
					case MAXTRANS:
					case NOLOGGING:
					case ORGANIZATION:
					case PCTFREE:
					case PCTUSED:
					case SEGMENT:
					case STORAGE:
					case TABLESPACE:
						{
						State = 4390; physical_properties();
						}
						break;
					case COLUMN:
					case LOB:
					case NESTED:
					case VARRAY:
					case XMLTYPE:
						{
						State = 4391; column_properties();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 4394;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COLUMN || _la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 308)) & ~0x3f) == 0 && ((1L << (_la - 308)) & ((1L << (LOB - 308)) | (1L << (LOGGING - 308)) | (1L << (MAXTRANS - 308)) | (1L << (NESTED - 308)))) != 0) || ((((_la - 377)) & ~0x3f) == 0 && ((1L << (_la - 377)) & ((1L << (NOLOGGING - 377)) | (1L << (ORGANIZATION - 377)) | (1L << (PCTFREE - 377)) | (1L << (PCTUSED - 377)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (SEGMENT - 535)) | (1L << (STORAGE - 535)) | (1L << (TABLESPACE - 535)))) != 0) || _la==VARRAY || _la==XMLTYPE || _la==LEFT_PAREN );
				State = 4396; Match(RIGHT_PAREN);
				}
			}

			State = 4400; Match(RETURN);
			State = 4401; Match(AS);
			State = 4402;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCATOR || _la==VALUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_propertiesContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Attribute_nameContext attribute_name() {
			return GetRuleContext<Attribute_nameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Inline_ref_constraintContext inline_ref_constraint() {
			return GetRuleContext<Inline_ref_constraintContext>(0);
		}
		public Inline_constraintContext[] inline_constraint() {
			return GetRuleContexts<Inline_constraintContext>();
		}
		public Inline_constraintContext inline_constraint(int i) {
			return GetRuleContext<Inline_constraintContext>(i);
		}
		public Out_of_line_constraintContext out_of_line_constraint() {
			return GetRuleContext<Out_of_line_constraintContext>(0);
		}
		public Out_of_line_ref_constraintContext out_of_line_ref_constraint() {
			return GetRuleContext<Out_of_line_ref_constraintContext>(0);
		}
		public Supplemental_logging_propsContext supplemental_logging_props() {
			return GetRuleContext<Supplemental_logging_propsContext>(0);
		}
		public Object_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_propertiesContext object_properties() {
		Object_propertiesContext _localctx = new Object_propertiesContext(Context, State);
		EnterRule(_localctx, 454, RULE_object_properties);
		int _la;
		try {
			State = 4425;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,543,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4406;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,538,Context) ) {
				case 1:
					{
					State = 4404; column_name();
					}
					break;
				case 2:
					{
					State = 4405; attribute_name();
					}
					break;
				}
				State = 4410;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 4408; Match(DEFAULT);
					State = 4409; expression();
					}
				}

				State = 4418;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,541,Context) ) {
				case 1:
					{
					State = 4413;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 4412; inline_constraint();
						}
						}
						State = 4415;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==CHECK || _la==CONSTRAINT || _la==NOT || _la==NULL || _la==PRIMARY || _la==REFERENCES || _la==UNIQUE );
					}
					break;
				case 2:
					{
					State = 4417; inline_ref_constraint();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4423;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,542,Context) ) {
				case 1:
					{
					State = 4420; out_of_line_constraint();
					}
					break;
				case 2:
					{
					State = 4421; out_of_line_ref_constraint();
					}
					break;
				case 3:
					{
					State = 4422; supplemental_logging_props();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_col_propertiesContext : ParserRuleContext {
		public ITerminalNode VARRAY() { return GetToken(PlSqlParser.VARRAY, 0); }
		public Varray_itemContext varray_item() {
			return GetRuleContext<Varray_itemContext>(0);
		}
		public Varray_storage_clauseContext varray_storage_clause() {
			return GetRuleContext<Varray_storage_clauseContext>(0);
		}
		public Substituable_column_clauseContext substituable_column_clause() {
			return GetRuleContext<Substituable_column_clauseContext>(0);
		}
		public Varray_col_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_col_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarray_col_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Varray_col_propertiesContext varray_col_properties() {
		Varray_col_propertiesContext _localctx = new Varray_col_propertiesContext(Context, State);
		EnterRule(_localctx, 456, RULE_varray_col_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4427; Match(VARRAY);
			State = 4428; varray_item();
			State = 4434;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,545,Context) ) {
			case 1:
				{
				State = 4430;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELEMENT || _la==IS || _la==NOT || _la==SUBSTITUTABLE) {
					{
					State = 4429; substituable_column_clause();
					}
				}

				State = 4432; varray_storage_clause();
				}
				break;
			case 2:
				{
				State = 4433; substituable_column_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_storage_clauseContext : ParserRuleContext {
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode LOB() { return GetToken(PlSqlParser.LOB, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Lob_storage_parametersContext lob_storage_parameters() {
			return GetRuleContext<Lob_storage_parametersContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode SECUREFILE() { return GetToken(PlSqlParser.SECUREFILE, 0); }
		public ITerminalNode BASICFILE() { return GetToken(PlSqlParser.BASICFILE, 0); }
		public Lob_segnameContext lob_segname() {
			return GetRuleContext<Lob_segnameContext>(0);
		}
		public Varray_storage_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_storage_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarray_storage_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Varray_storage_clauseContext varray_storage_clause() {
		Varray_storage_clauseContext _localctx = new Varray_storage_clauseContext(Context, State);
		EnterRule(_localctx, 458, RULE_varray_storage_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4436; Match(STORE);
			State = 4437; Match(AS);
			State = 4439;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BASICFILE || _la==SECUREFILE) {
				{
				State = 4438;
				_la = TokenStream.LA(1);
				if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4441; Match(LOB);
			State = 4450;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,548,Context) ) {
			case 1:
				{
				State = 4443;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
					{
					State = 4442; lob_segname();
					}
				}

				State = 4445; Match(LEFT_PAREN);
				State = 4446; lob_storage_parameters();
				State = 4447; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				{
				State = 4449; lob_storage_parameters();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_storage_clauseContext : ParserRuleContext {
		public ITerminalNode LOB() { return GetToken(PlSqlParser.LOB, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public Lob_item_nameContext[] lob_item_name() {
			return GetRuleContexts<Lob_item_nameContext>();
		}
		public Lob_item_nameContext lob_item_name(int i) {
			return GetRuleContext<Lob_item_nameContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Lob_storage_parametersContext lob_storage_parameters() {
			return GetRuleContext<Lob_storage_parametersContext>(0);
		}
		public Lob_segnameContext lob_segname() {
			return GetRuleContext<Lob_segnameContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode SECUREFILE() { return GetToken(PlSqlParser.SECUREFILE, 0); }
		public ITerminalNode BASICFILE() { return GetToken(PlSqlParser.BASICFILE, 0); }
		public Lob_storage_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_storage_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_storage_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_storage_clauseContext lob_storage_clause() {
		Lob_storage_clauseContext _localctx = new Lob_storage_clauseContext(Context, State);
		EnterRule(_localctx, 460, RULE_lob_storage_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4452; Match(LOB);
			State = 4492;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,553,Context) ) {
			case 1:
				{
				State = 4453; Match(LEFT_PAREN);
				State = 4454; lob_item_name();
				State = 4459;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4455; Match(COMMA);
					State = 4456; lob_item_name();
					}
					}
					State = 4461;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4462; Match(RIGHT_PAREN);
				State = 4463; Match(STORE);
				State = 4464; Match(AS);
				State = 4470;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BASICFILE:
				case SECUREFILE:
					{
					State = 4465;
					_la = TokenStream.LA(1);
					if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				case LEFT_PAREN:
					{
					State = 4466; Match(LEFT_PAREN);
					State = 4467; lob_storage_parameters();
					State = 4468; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				{
				State = 4472; Match(LEFT_PAREN);
				State = 4473; lob_item_name();
				State = 4478;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4474; Match(COMMA);
					State = 4475; lob_item_name();
					}
					}
					State = 4480;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4481; Match(RIGHT_PAREN);
				State = 4482; Match(STORE);
				State = 4483; Match(AS);
				State = 4490;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BASICFILE:
				case SECUREFILE:
					{
					State = 4484;
					_la = TokenStream.LA(1);
					if ( !(_la==BASICFILE || _la==SECUREFILE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case REGULAR_ID:
					{
					State = 4485; lob_segname();
					}
					break;
				case LEFT_PAREN:
					{
					State = 4486; Match(LEFT_PAREN);
					State = 4487; lob_storage_parameters();
					State = 4488; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_storage_parametersContext : ParserRuleContext {
		public Tablespace_clauseContext tablespace_clause() {
			return GetRuleContext<Tablespace_clauseContext>(0);
		}
		public Lob_parametersContext[] lob_parameters() {
			return GetRuleContexts<Lob_parametersContext>();
		}
		public Lob_parametersContext lob_parameters(int i) {
			return GetRuleContext<Lob_parametersContext>(i);
		}
		public Storage_clauseContext storage_clause() {
			return GetRuleContext<Storage_clauseContext>(0);
		}
		public Lob_storage_parametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_storage_parameters; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_storage_parameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_storage_parametersContext lob_storage_parameters() {
		Lob_storage_parametersContext _localctx = new Lob_storage_parametersContext(Context, State);
		EnterRule(_localctx, 462, RULE_lob_storage_parameters);
		int _la;
		try {
			int _alt;
			State = 4506;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,557,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4503;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TABLESPACE:
					{
					State = 4494; tablespace_clause();
					}
					break;
				case CACHE:
				case CHUNK:
				case COMPRESS:
				case DECRYPT:
				case DEDUPLICATE:
				case DISABLE:
				case ENABLE:
				case ENCRYPT:
				case FREEPOOLS:
				case KEEP_DUPLICATES:
				case NOCACHE:
				case NOCOMPRESS:
				case PCTVERSION:
				case RETENTION:
					{
					State = 4496;
					ErrorHandler.Sync(this);
					_alt = 1;
					do {
						switch (_alt) {
						case 1:
							{
							{
							State = 4495; lob_parameters();
							}
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 4498;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,554,Context);
					} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
					State = 4501;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==BUFFER_POOL || ((((_la - 177)) & ~0x3f) == 0 && ((1L << (_la - 177)) & ((1L << (ENCRYPT - 177)) | (1L << (FLASH_CACHE - 177)) | (1L << (FREELIST - 177)) | (1L << (FREELISTS - 177)))) != 0) || _la==INITIAL || _la==MINEXTENTS || _la==NEXT || _la==OPTIMAL || _la==PCTINCREASE) {
						{
						State = 4500; storage_clause();
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4505; storage_clause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Paren_lob_parametersContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Lob_parametersContext lob_parameters() {
			return GetRuleContext<Lob_parametersContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Paren_lob_parametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paren_lob_parameters; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParen_lob_parameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Paren_lob_parametersContext paren_lob_parameters() {
		Paren_lob_parametersContext _localctx = new Paren_lob_parametersContext(Context, State);
		EnterRule(_localctx, 464, RULE_paren_lob_parameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4508; Match(LEFT_PAREN);
			State = 4509; lob_parameters();
			State = 4510; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_parametersContext : ParserRuleContext {
		public IntegerContext ChunkInteger;
		public IntegerContext PctVersionIntger;
		public IntegerContext FreePoolsInteger;
		public ITerminalNode STORAGE() { return GetToken(PlSqlParser.STORAGE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode CHUNK() { return GetToken(PlSqlParser.CHUNK, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode PCTVERSION() { return GetToken(PlSqlParser.PCTVERSION, 0); }
		public ITerminalNode FREEPOOLS() { return GetToken(PlSqlParser.FREEPOOLS, 0); }
		public Lob_retention_clauseContext lob_retention_clause() {
			return GetRuleContext<Lob_retention_clauseContext>(0);
		}
		public Lob_deduplicate_clauseContext lob_deduplicate_clause() {
			return GetRuleContext<Lob_deduplicate_clauseContext>(0);
		}
		public Lob_compresssion_clauseContext lob_compresssion_clause() {
			return GetRuleContext<Lob_compresssion_clauseContext>(0);
		}
		public ITerminalNode ENCRYPT() { return GetToken(PlSqlParser.ENCRYPT, 0); }
		public Encryption_specContext encryption_spec() {
			return GetRuleContext<Encryption_specContext>(0);
		}
		public ITerminalNode DECRYPT() { return GetToken(PlSqlParser.DECRYPT, 0); }
		public Logging_clauseContext logging_clause() {
			return GetRuleContext<Logging_clauseContext>(0);
		}
		public ITerminalNode CACHE() { return GetToken(PlSqlParser.CACHE, 0); }
		public ITerminalNode NOCACHE() { return GetToken(PlSqlParser.NOCACHE, 0); }
		public ITerminalNode READS() { return GetToken(PlSqlParser.READS, 0); }
		public Lob_parametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_parameters; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_parameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_parametersContext lob_parameters() {
		Lob_parametersContext _localctx = new Lob_parametersContext(Context, State);
		EnterRule(_localctx, 466, RULE_lob_parameters);
		int _la;
		try {
			State = 4537;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DISABLE:
			case ENABLE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4512;
				_la = TokenStream.LA(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4513; Match(STORAGE);
				State = 4514; Match(IN);
				State = 4515; Match(ROW);
				}
				break;
			case CHUNK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4516; Match(CHUNK);
				State = 4517; _localctx.ChunkInteger = integer();
				}
				break;
			case PCTVERSION:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4518; Match(PCTVERSION);
				State = 4519; _localctx.PctVersionIntger = integer();
				}
				break;
			case FREEPOOLS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4520; Match(FREEPOOLS);
				State = 4521; _localctx.FreePoolsInteger = integer();
				}
				break;
			case RETENTION:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4522; lob_retention_clause();
				}
				break;
			case DEDUPLICATE:
			case KEEP_DUPLICATES:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4523; lob_deduplicate_clause();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4524; lob_compresssion_clause();
				}
				break;
			case DECRYPT:
			case ENCRYPT:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4528;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ENCRYPT:
					{
					State = 4525; Match(ENCRYPT);
					State = 4526; encryption_spec();
					}
					break;
				case DECRYPT:
					{
					State = 4527; Match(DECRYPT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4534;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,559,Context) ) {
				case 1:
					{
					State = 4530; Match(CACHE);
					}
					break;
				case 2:
					{
					State = 4531; Match(NOCACHE);
					}
					break;
				case 3:
					{
					State = 4532; Match(CACHE);
					State = 4533; Match(READS);
					}
					break;
				}
				State = 4536; logging_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_retention_clauseContext : ParserRuleContext {
		public IntegerContext MinIntger;
		public ITerminalNode RETENTION() { return GetToken(PlSqlParser.RETENTION, 0); }
		public ITerminalNode MAX() { return GetToken(PlSqlParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(PlSqlParser.MIN, 0); }
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Lob_retention_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_retention_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_retention_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_retention_clauseContext lob_retention_clause() {
		Lob_retention_clauseContext _localctx = new Lob_retention_clauseContext(Context, State);
		EnterRule(_localctx, 468, RULE_lob_retention_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4539; Match(RETENTION);
			State = 4545;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,561,Context) ) {
			case 1:
				{
				State = 4540; Match(MAX);
				}
				break;
			case 2:
				{
				State = 4541; Match(MIN);
				State = 4542; _localctx.MinIntger = integer();
				}
				break;
			case 3:
				{
				State = 4543; Match(AUTO);
				}
				break;
			case 4:
				{
				State = 4544; Match(NONE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_deduplicate_clauseContext : ParserRuleContext {
		public ITerminalNode DEDUPLICATE() { return GetToken(PlSqlParser.DEDUPLICATE, 0); }
		public ITerminalNode KEEP_DUPLICATES() { return GetToken(PlSqlParser.KEEP_DUPLICATES, 0); }
		public Lob_deduplicate_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_deduplicate_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_deduplicate_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_deduplicate_clauseContext lob_deduplicate_clause() {
		Lob_deduplicate_clauseContext _localctx = new Lob_deduplicate_clauseContext(Context, State);
		EnterRule(_localctx, 470, RULE_lob_deduplicate_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4547;
			_la = TokenStream.LA(1);
			if ( !(_la==DEDUPLICATE || _la==KEEP_DUPLICATES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_compresssion_clauseContext : ParserRuleContext {
		public ITerminalNode COMPRESS() { return GetToken(PlSqlParser.COMPRESS, 0); }
		public ITerminalNode HIGH() { return GetToken(PlSqlParser.HIGH, 0); }
		public ITerminalNode MEDIUM() { return GetToken(PlSqlParser.MEDIUM, 0); }
		public ITerminalNode LOW() { return GetToken(PlSqlParser.LOW, 0); }
		public ITerminalNode NOCOMPRESS() { return GetToken(PlSqlParser.NOCOMPRESS, 0); }
		public Lob_compresssion_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_compresssion_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_compresssion_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_compresssion_clauseContext lob_compresssion_clause() {
		Lob_compresssion_clauseContext _localctx = new Lob_compresssion_clauseContext(Context, State);
		EnterRule(_localctx, 472, RULE_lob_compresssion_clause);
		int _la;
		try {
			State = 4554;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMPRESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4549; Match(COMPRESS);
				State = 4551;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==HIGH || _la==LOW || _la==MEDIUM) {
					{
					State = 4550;
					_la = TokenStream.LA(1);
					if ( !(_la==HIGH || _la==LOW || _la==MEDIUM) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case NOCOMPRESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4553; Match(NOCOMPRESS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Physical_propertiesContext : ParserRuleContext {
		public Segment_attributes_clauseContext segment_attributes_clause() {
			return GetRuleContext<Segment_attributes_clauseContext>(0);
		}
		public Ilm_clauseContext ilm_clause() {
			return GetRuleContext<Ilm_clauseContext>(0);
		}
		public Deferred_segment_creationContext deferred_segment_creation() {
			return GetRuleContext<Deferred_segment_creationContext>(0);
		}
		public Table_compressionContext table_compression() {
			return GetRuleContext<Table_compressionContext>(0);
		}
		public Inmemory_table_clauseContext inmemory_table_clause() {
			return GetRuleContext<Inmemory_table_clauseContext>(0);
		}
		public ITerminalNode ORGANIZATION() { return GetToken(PlSqlParser.ORGANIZATION, 0); }
		public ITerminalNode HEAP() { return GetToken(PlSqlParser.HEAP, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public Index_org_table_clauseContext index_org_table_clause() {
			return GetRuleContext<Index_org_table_clauseContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public External_table_clauseContext external_table_clause() {
			return GetRuleContext<External_table_clauseContext>(0);
		}
		public Physical_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physical_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPhysical_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Physical_propertiesContext physical_properties() {
		Physical_propertiesContext _localctx = new Physical_propertiesContext(Context, State);
		EnterRule(_localctx, 474, RULE_physical_properties);
		int _la;
		try {
			State = 4594;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,574,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4557;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEGMENT) {
					{
					State = 4556; deferred_segment_creation();
					}
				}

				State = 4559; segment_attributes_clause();
				State = 4561;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,565,Context) ) {
				case 1:
					{
					State = 4560; table_compression();
					}
					break;
				}
				State = 4564;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INMEMORY || _la==NO) {
					{
					State = 4563; inmemory_table_clause();
					}
				}

				State = 4566; ilm_clause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEGMENT) {
					{
					State = 4568; deferred_segment_creation();
					}
				}

				State = 4571; Match(ORGANIZATION);
				State = 4592;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case HEAP:
					{
					State = 4572; Match(HEAP);
					State = 4574;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,568,Context) ) {
					case 1:
						{
						State = 4573; segment_attributes_clause();
						}
						break;
					}
					State = 4577;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,569,Context) ) {
					case 1:
						{
						State = 4576; table_compression();
						}
						break;
					}
					State = 4580;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,570,Context) ) {
					case 1:
						{
						State = 4579; inmemory_table_clause();
						}
						break;
					}
					State = 4583;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,571,Context) ) {
					case 1:
						{
						State = 4582; ilm_clause();
						}
						break;
					}
					}
					break;
				case INDEX:
					{
					State = 4585; Match(INDEX);
					State = 4587;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==FILESYSTEM_LIKE_LOGGING || _la==INITRANS || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (LOGGING - 316)) | (1L << (MAXTRANS - 316)) | (1L << (NOLOGGING - 316)))) != 0) || _la==PCTFREE || _la==PCTUSED || _la==STORAGE || _la==TABLESPACE) {
						{
						State = 4586; segment_attributes_clause();
						}
					}

					State = 4589; index_org_table_clause();
					}
					break;
				case EXTERNAL:
					{
					State = 4590; Match(EXTERNAL);
					State = 4591; external_table_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class External_table_clauseContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public External_data_propertiesContext external_data_properties() {
			return GetRuleContext<External_data_propertiesContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public ITerminalNode REJECT() { return GetToken(PlSqlParser.REJECT, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public External_table_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_external_table_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternal_table_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public External_table_clauseContext external_table_clause() {
		External_table_clauseContext _localctx = new External_table_clauseContext(Context, State);
		EnterRule(_localctx, 476, RULE_external_table_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4596; Match(LEFT_PAREN);
			State = 4598;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TYPE) {
				{
				State = 4597; Match(TYPE);
				}
			}

			State = 4600; external_data_properties();
			State = 4601; Match(RIGHT_PAREN);
			State = 4608;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,577,Context) ) {
			case 1:
				{
				State = 4602; Match(REJECT);
				State = 4603; Match(LIMIT);
				State = 4606;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case PLUS_SIGN:
				case MINUS_SIGN:
					{
					State = 4604; integer();
					}
					break;
				case UNLIMITED:
					{
					State = 4605; Match(UNLIMITED);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class External_data_propertiesContext : ParserRuleContext {
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(PlSqlParser.DIRECTORY, 0); }
		public Directory_nameContext directory_name() {
			return GetRuleContext<Directory_nameContext>(0);
		}
		public ITerminalNode LOCATION() { return GetToken(PlSqlParser.LOCATION, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public External_data_properties_locationContext[] external_data_properties_location() {
			return GetRuleContexts<External_data_properties_locationContext>();
		}
		public External_data_properties_locationContext external_data_properties_location(int i) {
			return GetRuleContext<External_data_properties_locationContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode ACCESS() { return GetToken(PlSqlParser.ACCESS, 0); }
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode CLOB() { return GetToken(PlSqlParser.CLOB, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public External_data_propertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_external_data_properties; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternal_data_properties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public External_data_propertiesContext external_data_properties() {
		External_data_propertiesContext _localctx = new External_data_propertiesContext(Context, State);
		EnterRule(_localctx, 478, RULE_external_data_properties);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4610; Match(DEFAULT);
			State = 4611; Match(DIRECTORY);
			State = 4612; directory_name();
			{
			State = 4613; Match(ACCESS);
			State = 4614; Match(PARAMETERS);
			State = 4620;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_PAREN:
				{
				State = 4615; Match(LEFT_PAREN);
				State = 4616; Match(RIGHT_PAREN);
				}
				break;
			case USING:
				{
				State = 4617; Match(USING);
				State = 4618; Match(CLOB);
				State = 4619; subquery();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
			State = 4622; Match(LOCATION);
			State = 4623; Match(LEFT_PAREN);
			State = 4624; external_data_properties_location();
			State = 4627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4625; Match(COMMA);
				State = 4626; external_data_properties_location();
				}
				}
				State = 4629;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			State = 4631; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class External_data_properties_locationContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Directory_nameContext directory_name() {
			return GetRuleContext<Directory_nameContext>(0);
		}
		public External_data_properties_locationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_external_data_properties_location; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternal_data_properties_location(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public External_data_properties_locationContext external_data_properties_location() {
		External_data_properties_locationContext _localctx = new External_data_properties_locationContext(Context, State);
		EnterRule(_localctx, 480, RULE_external_data_properties_location);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4637;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COLON - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4634;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
					{
					State = 4633; directory_name();
					}
				}

				State = 4636; Match(COLON);
				}
			}

			State = 4639; Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_org_table_clauseContext : ParserRuleContext {
		public Index_org_overflow_clauseContext index_org_overflow_clause() {
			return GetRuleContext<Index_org_overflow_clauseContext>(0);
		}
		public Mapping_table_clauseContext mapping_table_clause() {
			return GetRuleContext<Mapping_table_clauseContext>(0);
		}
		public ITerminalNode PCTTHRESHOLD() { return GetToken(PlSqlParser.PCTTHRESHOLD, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Prefix_compressionContext prefix_compression() {
			return GetRuleContext<Prefix_compressionContext>(0);
		}
		public Index_org_table_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_org_table_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_org_table_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_org_table_clauseContext index_org_table_clause() {
		Index_org_table_clauseContext _localctx = new Index_org_table_clauseContext(Context, State);
		EnterRule(_localctx, 482, RULE_index_org_table_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4645;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAPPING:
			case NOMAPPING:
				{
				State = 4641; mapping_table_clause();
				}
				break;
			case PCTTHRESHOLD:
				{
				State = 4642; Match(PCTTHRESHOLD);
				State = 4643; integer();
				}
				break;
			case COMPRESS:
			case NOCOMPRESS:
				{
				State = 4644; prefix_compression();
				}
				break;
			case INCLUDING:
			case OVERFLOW:
				break;
			default:
				break;
			}
			State = 4647; index_org_overflow_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Mapping_table_clauseContext : ParserRuleContext {
		public ITerminalNode MAPPING() { return GetToken(PlSqlParser.MAPPING, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode NOMAPPING() { return GetToken(PlSqlParser.NOMAPPING, 0); }
		public Mapping_table_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapping_table_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapping_table_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mapping_table_clauseContext mapping_table_clause() {
		Mapping_table_clauseContext _localctx = new Mapping_table_clauseContext(Context, State);
		EnterRule(_localctx, 484, RULE_mapping_table_clause);
		try {
			State = 4652;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAPPING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4649; Match(MAPPING);
				State = 4650; Match(TABLE);
				}
				break;
			case NOMAPPING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4651; Match(NOMAPPING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_org_overflow_clauseContext : ParserRuleContext {
		public ITerminalNode OVERFLOW() { return GetToken(PlSqlParser.OVERFLOW, 0); }
		public ITerminalNode INCLUDING() { return GetToken(PlSqlParser.INCLUDING, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Segment_attributes_clauseContext segment_attributes_clause() {
			return GetRuleContext<Segment_attributes_clauseContext>(0);
		}
		public Index_org_overflow_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_org_overflow_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_org_overflow_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_org_overflow_clauseContext index_org_overflow_clause() {
		Index_org_overflow_clauseContext _localctx = new Index_org_overflow_clauseContext(Context, State);
		EnterRule(_localctx, 486, RULE_index_org_overflow_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4656;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INCLUDING) {
				{
				State = 4654; Match(INCLUDING);
				State = 4655; column_name();
				}
			}

			State = 4658; Match(OVERFLOW);
			State = 4660;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,585,Context) ) {
			case 1:
				{
				State = 4659; segment_attributes_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Deferred_segment_creationContext : ParserRuleContext {
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode CREATION() { return GetToken(PlSqlParser.CREATION, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode DEFERRED() { return GetToken(PlSqlParser.DEFERRED, 0); }
		public Deferred_segment_creationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferred_segment_creation; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeferred_segment_creation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Deferred_segment_creationContext deferred_segment_creation() {
		Deferred_segment_creationContext _localctx = new Deferred_segment_creationContext(Context, State);
		EnterRule(_localctx, 488, RULE_deferred_segment_creation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4662; Match(SEGMENT);
			State = 4663; Match(CREATION);
			State = 4664;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tablespace_clauseContext : ParserRuleContext {
		public ITerminalNode TABLESPACE() { return GetToken(PlSqlParser.TABLESPACE, 0); }
		public Tablespace_nameContext tablespace_name() {
			return GetRuleContext<Tablespace_nameContext>(0);
		}
		public Tablespace_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespace_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablespace_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tablespace_clauseContext tablespace_clause() {
		Tablespace_clauseContext _localctx = new Tablespace_clauseContext(Context, State);
		EnterRule(_localctx, 490, RULE_tablespace_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4666; Match(TABLESPACE);
			State = 4667; tablespace_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Store_inContext : ParserRuleContext {
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Tablespace_nameContext[] tablespace_name() {
			return GetRuleContexts<Tablespace_nameContext>();
		}
		public Tablespace_nameContext tablespace_name(int i) {
			return GetRuleContext<Tablespace_nameContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Store_inContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_store_in; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStore_in(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Store_inContext store_in() {
		Store_inContext _localctx = new Store_inContext(Context, State);
		EnterRule(_localctx, 492, RULE_store_in);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4669; Match(STORE);
			State = 4670; Match(IN);
			State = 4671; Match(LEFT_PAREN);
			State = 4672; tablespace_name();
			State = 4677;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4673; Match(COMMA);
				State = 4674; tablespace_name();
				}
				}
				State = 4679;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4680; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ilm_clauseContext : ParserRuleContext {
		public ITerminalNode ILM() { return GetToken(PlSqlParser.ILM, 0); }
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode POLICY() { return GetToken(PlSqlParser.POLICY, 0); }
		public Ilm_policy_clauseContext ilm_policy_clause() {
			return GetRuleContext<Ilm_policy_clauseContext>(0);
		}
		public Ilm_policy_nameContext ilm_policy_name() {
			return GetRuleContext<Ilm_policy_nameContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Ilm_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ilm_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIlm_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ilm_clauseContext ilm_clause() {
		Ilm_clauseContext _localctx = new Ilm_clauseContext(Context, State);
		EnterRule(_localctx, 494, RULE_ilm_clause);
		int _la;
		try {
			State = 4697;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,588,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4682; Match(ILM);
				State = 4683; Match(ADD);
				State = 4684; Match(POLICY);
				State = 4685; ilm_policy_clause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4686;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 147)) & ~0x3f) == 0 && ((1L << (_la - 147)) & ((1L << (DELETE - 147)) | (1L << (DISABLE - 147)) | (1L << (ENABLE - 147)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4687; Match(POLICY);
				State = 4688; ilm_policy_name();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4695;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DELETE:
					{
					State = 4689; Match(DELETE);
					State = 4690; Match(ALL);
					}
					break;
				case ENABLE:
					{
					State = 4691; Match(ENABLE);
					State = 4692; Match(ALL);
					}
					break;
				case DISABLE:
					{
					State = 4693; Match(DISABLE);
					State = 4694; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ilm_policy_clauseContext : ParserRuleContext {
		public Ilm_compression_policyContext ilm_compression_policy() {
			return GetRuleContext<Ilm_compression_policyContext>(0);
		}
		public Ilm_tiering_policyContext ilm_tiering_policy() {
			return GetRuleContext<Ilm_tiering_policyContext>(0);
		}
		public Ilm_policy_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ilm_policy_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIlm_policy_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ilm_policy_clauseContext ilm_policy_clause() {
		Ilm_policy_clauseContext _localctx = new Ilm_policy_clauseContext(Context, State);
		EnterRule(_localctx, 496, RULE_ilm_policy_clause);
		try {
			State = 4701;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COLUMN:
			case COMPRESS:
			case NO:
			case ROW:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4699; ilm_compression_policy();
				}
				break;
			case TIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4700; ilm_tiering_policy();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ilm_compression_policyContext : ParserRuleContext {
		public Table_compressionContext table_compression() {
			return GetRuleContext<Table_compressionContext>(0);
		}
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public Ilm_time_periodContext ilm_time_period() {
			return GetRuleContext<Ilm_time_periodContext>(0);
		}
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode ACCESS() { return GetToken(PlSqlParser.ACCESS, 0); }
		public ITerminalNode MODIFICATION() { return GetToken(PlSqlParser.MODIFICATION, 0); }
		public ITerminalNode CREATION() { return GetToken(PlSqlParser.CREATION, 0); }
		public ITerminalNode[] ROW() { return GetTokens(PlSqlParser.ROW); }
		public ITerminalNode ROW(int i) {
			return GetToken(PlSqlParser.ROW, i);
		}
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode COMPRESS() { return GetToken(PlSqlParser.COMPRESS, 0); }
		public ITerminalNode ADVANCED() { return GetToken(PlSqlParser.ADVANCED, 0); }
		public Ilm_compression_policyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ilm_compression_policy; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIlm_compression_policy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ilm_compression_policyContext ilm_compression_policy() {
		Ilm_compression_policyContext _localctx = new Ilm_compression_policyContext(Context, State);
		EnterRule(_localctx, 498, RULE_ilm_compression_policy);
		int _la;
		try {
			State = 4730;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,592,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4703; table_compression();
				State = 4704;
				_la = TokenStream.LA(1);
				if ( !(_la==GROUP || _la==SEGMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4717;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AFTER:
					{
					State = 4705; Match(AFTER);
					State = 4706; ilm_time_period();
					State = 4707; Match(OF);
					State = 4713;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,590,Context) ) {
					case 1:
						{
						State = 4708; Match(NO);
						State = 4709; Match(ACCESS);
						}
						break;
					case 2:
						{
						State = 4710; Match(NO);
						State = 4711; Match(MODIFICATION);
						}
						break;
					case 3:
						{
						State = 4712; Match(CREATION);
						}
						break;
					}
					}
					break;
				case ON:
					{
					State = 4715; Match(ON);
					State = 4716; function_name();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4719; Match(ROW);
				State = 4720; Match(STORE);
				State = 4721; Match(COMPRESS);
				State = 4722; Match(ADVANCED);
				State = 4723; Match(ROW);
				State = 4724; Match(AFTER);
				State = 4725; ilm_time_period();
				State = 4726; Match(OF);
				State = 4727; Match(NO);
				State = 4728; Match(MODIFICATION);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ilm_tiering_policyContext : ParserRuleContext {
		public ITerminalNode TIER() { return GetToken(PlSqlParser.TIER, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public Tablespace_nameContext tablespace_name() {
			return GetRuleContext<Tablespace_nameContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public Ilm_time_periodContext ilm_time_period() {
			return GetRuleContext<Ilm_time_periodContext>(0);
		}
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode ACCESS() { return GetToken(PlSqlParser.ACCESS, 0); }
		public ITerminalNode MODIFICATION() { return GetToken(PlSqlParser.MODIFICATION, 0); }
		public ITerminalNode CREATION() { return GetToken(PlSqlParser.CREATION, 0); }
		public Ilm_tiering_policyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ilm_tiering_policy; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIlm_tiering_policy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ilm_tiering_policyContext ilm_tiering_policy() {
		Ilm_tiering_policyContext _localctx = new Ilm_tiering_policyContext(Context, State);
		EnterRule(_localctx, 500, RULE_ilm_tiering_policy);
		int _la;
		try {
			State = 4763;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,597,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4732; Match(TIER);
				State = 4733; Match(TO);
				State = 4734; tablespace_name();
				State = 4736;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GROUP || _la==SEGMENT) {
					{
					State = 4735;
					_la = TokenStream.LA(1);
					if ( !(_la==GROUP || _la==SEGMENT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 4738; Match(ON);
				State = 4739; function_name();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4741; Match(TIER);
				State = 4742; Match(TO);
				State = 4743; tablespace_name();
				State = 4744; Match(READ);
				State = 4745; Match(ONLY);
				State = 4747;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GROUP || _la==SEGMENT) {
					{
					State = 4746;
					_la = TokenStream.LA(1);
					if ( !(_la==GROUP || _la==SEGMENT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 4761;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AFTER:
					{
					State = 4749; Match(AFTER);
					State = 4750; ilm_time_period();
					State = 4751; Match(OF);
					State = 4757;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,595,Context) ) {
					case 1:
						{
						State = 4752; Match(NO);
						State = 4753; Match(ACCESS);
						}
						break;
					case 2:
						{
						State = 4754; Match(NO);
						State = 4755; Match(MODIFICATION);
						}
						break;
					case 3:
						{
						State = 4756; Match(CREATION);
						}
						break;
					}
					}
					break;
				case ON:
					{
					State = 4759; Match(ON);
					State = 4760; function_name();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ilm_time_periodContext : ParserRuleContext {
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode DAYS() { return GetToken(PlSqlParser.DAYS, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode MONTHS() { return GetToken(PlSqlParser.MONTHS, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode YEARS() { return GetToken(PlSqlParser.YEARS, 0); }
		public Ilm_time_periodContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ilm_time_period; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIlm_time_period(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ilm_time_periodContext ilm_time_period() {
		Ilm_time_periodContext _localctx = new Ilm_time_periodContext(Context, State);
		EnterRule(_localctx, 502, RULE_ilm_time_period);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4765; integer();
			State = 4766;
			_la = TokenStream.LA(1);
			if ( !(_la==DAY || _la==DAYS || _la==MONTH || _la==MONTHS || _la==YEARS || _la==YEAR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Storage_clausesContext : ParserRuleContext {
		public ITerminalNode STORAGE() { return GetToken(PlSqlParser.STORAGE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Storage_clauseContext[] storage_clause() {
			return GetRuleContexts<Storage_clauseContext>();
		}
		public Storage_clauseContext storage_clause(int i) {
			return GetRuleContext<Storage_clauseContext>(i);
		}
		public Storage_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storage_clauses; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorage_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Storage_clausesContext storage_clauses() {
		Storage_clausesContext _localctx = new Storage_clausesContext(Context, State);
		EnterRule(_localctx, 504, RULE_storage_clauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4768; Match(STORAGE);
			State = 4769; Match(LEFT_PAREN);
			State = 4771;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4770; storage_clause();
				}
				}
				State = 4773;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==BUFFER_POOL || ((((_la - 177)) & ~0x3f) == 0 && ((1L << (_la - 177)) & ((1L << (ENCRYPT - 177)) | (1L << (FLASH_CACHE - 177)) | (1L << (FREELIST - 177)) | (1L << (FREELISTS - 177)))) != 0) || _la==INITIAL || _la==MINEXTENTS || _la==NEXT || _la==OPTIMAL || _la==PCTINCREASE );
			State = 4775; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Storage_clauseContext : ParserRuleContext {
		public Size_clauseContext initial_size;
		public Size_clauseContext next_size;
		public IToken minextents;
		public IToken pctincrease;
		public IToken freelists;
		public IToken freelist_groups;
		public ITerminalNode INITIAL() { return GetToken(PlSqlParser.INITIAL, 0); }
		public Size_clauseContext size_clause() {
			return GetRuleContext<Size_clauseContext>(0);
		}
		public ITerminalNode NEXT() { return GetToken(PlSqlParser.NEXT, 0); }
		public ITerminalNode MINEXTENTS() { return GetToken(PlSqlParser.MINEXTENTS, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public ITerminalNode PCTINCREASE() { return GetToken(PlSqlParser.PCTINCREASE, 0); }
		public ITerminalNode FREELISTS() { return GetToken(PlSqlParser.FREELISTS, 0); }
		public ITerminalNode FREELIST() { return GetToken(PlSqlParser.FREELIST, 0); }
		public ITerminalNode GROUPS() { return GetToken(PlSqlParser.GROUPS, 0); }
		public ITerminalNode OPTIMAL() { return GetToken(PlSqlParser.OPTIMAL, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode BUFFER_POOL() { return GetToken(PlSqlParser.BUFFER_POOL, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode RECYCLE() { return GetToken(PlSqlParser.RECYCLE, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode FLASH_CACHE() { return GetToken(PlSqlParser.FLASH_CACHE, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public ITerminalNode ENCRYPT() { return GetToken(PlSqlParser.ENCRYPT, 0); }
		public Storage_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storage_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorage_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Storage_clauseContext storage_clause() {
		Storage_clauseContext _localctx = new Storage_clauseContext(Context, State);
		EnterRule(_localctx, 506, RULE_storage_clause);
		int _la;
		try {
			State = 4800;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INITIAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4777; Match(INITIAL);
				State = 4778; _localctx.initial_size = size_clause();
				}
				break;
			case NEXT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4779; Match(NEXT);
				State = 4780; _localctx.next_size = size_clause();
				}
				break;
			case MINEXTENTS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4781; Match(MINEXTENTS);
				State = 4782;
				_localctx.minextents = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==UNLIMITED || _la==UNSIGNED_INTEGER) ) {
					_localctx.minextents = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case PCTINCREASE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4783; Match(PCTINCREASE);
				State = 4784; _localctx.pctincrease = Match(UNSIGNED_INTEGER);
				}
				break;
			case FREELISTS:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4785; Match(FREELISTS);
				State = 4786; _localctx.freelists = Match(UNSIGNED_INTEGER);
				}
				break;
			case FREELIST:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4787; Match(FREELIST);
				State = 4788; Match(GROUPS);
				State = 4789; _localctx.freelist_groups = Match(UNSIGNED_INTEGER);
				}
				break;
			case OPTIMAL:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4790; Match(OPTIMAL);
				State = 4793;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case UNSIGNED_INTEGER:
					{
					State = 4791; size_clause();
					}
					break;
				case NULL:
					{
					State = 4792; Match(NULL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case BUFFER_POOL:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4795; Match(BUFFER_POOL);
				State = 4796;
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==KEEP || _la==RECYCLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case FLASH_CACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4797; Match(FLASH_CACHE);
				State = 4798;
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==KEEP || _la==NONE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case ENCRYPT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4799; Match(ENCRYPT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_definitionContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ITerminalNode SORT() { return GetToken(PlSqlParser.SORT, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ENCRYPT() { return GetToken(PlSqlParser.ENCRYPT, 0); }
		public Encryption_specContext encryption_spec() {
			return GetRuleContext<Encryption_specContext>(0);
		}
		public Inline_ref_constraintContext inline_ref_constraint() {
			return GetRuleContext<Inline_ref_constraintContext>(0);
		}
		public ITerminalNode VISIBLE() { return GetToken(PlSqlParser.VISIBLE, 0); }
		public ITerminalNode INVISIBLE() { return GetToken(PlSqlParser.INVISIBLE, 0); }
		public ITerminalNode GENERATED() { return GetToken(PlSqlParser.GENERATED, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode IDENTITY() { return GetToken(PlSqlParser.IDENTITY, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Inline_constraintContext[] inline_constraint() {
			return GetRuleContexts<Inline_constraintContext>();
		}
		public Inline_constraintContext inline_constraint(int i) {
			return GetRuleContext<Inline_constraintContext>(i);
		}
		public ITerminalNode ALWAYS() { return GetToken(PlSqlParser.ALWAYS, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Identity_optionsContext identity_options() {
			return GetRuleContext<Identity_optionsContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Column_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_definitionContext column_definition() {
		Column_definitionContext _localctx = new Column_definitionContext(Context, State);
		EnterRule(_localctx, 508, RULE_column_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4802; column_name();
			State = 4804;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BOOLEAN))) != 0) || ((((_la - 72)) & ~0x3f) == 0 && ((1L << (_la - 72)) & ((1L << (CHARACTER - 72)) | (1L << (CHAR - 72)) | (1L << (CLOB - 72)) | (1L << (DATE - 72)) | (1L << (DAY - 72)) | (1L << (DEC - 72)) | (1L << (DECIMAL - 72)))) != 0) || ((((_la - 162)) & ~0x3f) == 0 && ((1L << (_la - 162)) & ((1L << (DOUBLE - 162)) | (1L << (DSINTERVAL_UNCONSTRAINED - 162)) | (1L << (FLOAT - 162)))) != 0) || ((((_la - 241)) & ~0x3f) == 0 && ((1L << (_la - 241)) & ((1L << (HOUR - 241)) | (1L << (INTEGER - 241)) | (1L << (INTERVAL - 241)) | (1L << (INT - 241)))) != 0) || ((((_la - 321)) & ~0x3f) == 0 && ((1L << (_la - 321)) & ((1L << (LONG - 321)) | (1L << (MINUTE - 321)) | (1L << (MLSLABEL - 321)) | (1L << (MONTH - 321)) | (1L << (NATURAL - 321)) | (1L << (NATURALN - 321)) | (1L << (NCHAR - 321)) | (1L << (NCLOB - 321)))) != 0) || ((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (NUMBER - 397)) | (1L << (NUMERIC - 397)) | (1L << (NVARCHAR2 - 397)) | (1L << (PLS_INTEGER - 397)) | (1L << (POSITIVEN - 397)) | (1L << (POSITIVE - 397)))) != 0) || ((((_la - 477)) & ~0x3f) == 0 && ((1L << (_la - 477)) & ((1L << (RAW - 477)) | (1L << (REAL - 477)) | (1L << (ROWID - 477)) | (1L << (SECOND - 477)))) != 0) || ((((_la - 553)) & ~0x3f) == 0 && ((1L << (_la - 553)) & ((1L << (SIGNTYPE - 553)) | (1L << (SIMPLE_INTEGER - 553)) | (1L << (SMALLINT - 553)) | (1L << (STRING - 553)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 553)) | (1L << (TIMESTAMP - 553)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 553)) | (1L << (TIMESTAMP_UNCONSTRAINED - 553)) | (1L << (TIMEZONE_ABBR - 553)) | (1L << (TIMEZONE_HOUR - 553)) | (1L << (TIMEZONE_MINUTE - 553)) | (1L << (TIMEZONE_REGION - 553)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (YEAR - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)))) != 0)) {
				{
				State = 4803; datatype();
				}
			}

			State = 4807;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SORT) {
				{
				State = 4806; Match(SORT);
				}
			}

			State = 4810;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INVISIBLE || _la==VISIBLE) {
				{
				State = 4809;
				_la = TokenStream.LA(1);
				if ( !(_la==INVISIBLE || _la==VISIBLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4836;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4812; Match(DEFAULT);
				State = 4815;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ON) {
					{
					State = 4813; Match(ON);
					State = 4814; Match(NULL);
					}
				}

				State = 4817; expression();
				}
				break;
			case GENERATED:
				{
				{
				State = 4818; Match(GENERATED);
				State = 4826;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALWAYS:
					{
					State = 4819; Match(ALWAYS);
					}
					break;
				case BY:
					{
					State = 4820; Match(BY);
					State = 4821; Match(DEFAULT);
					State = 4824;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ON) {
						{
						State = 4822; Match(ON);
						State = 4823; Match(NULL);
						}
					}

					}
					break;
				case AS:
					break;
				default:
					break;
				}
				State = 4828; Match(AS);
				State = 4829; Match(IDENTITY);
				State = 4834;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 4830; Match(LEFT_PAREN);
					State = 4831; identity_options();
					State = 4832; Match(RIGHT_PAREN);
					}
				}

				}
				}
				break;
			case CHECK:
			case CONSTRAINT:
			case ENCRYPT:
			case NOT:
			case NULL:
			case PRIMARY:
			case REFERENCES:
			case SCOPE:
			case UNIQUE:
			case WITH:
			case RIGHT_PAREN:
			case COMMA:
				break;
			default:
				break;
			}
			State = 4840;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENCRYPT) {
				{
				State = 4838; Match(ENCRYPT);
				State = 4839; encryption_spec();
				}
			}

			State = 4848;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,611,Context) ) {
			case 1:
				{
				State = 4843;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 4842; inline_constraint();
					}
					}
					State = 4845;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CHECK || _la==CONSTRAINT || _la==NOT || _la==NULL || _la==PRIMARY || _la==REFERENCES || _la==UNIQUE );
				}
				break;
			case 2:
				{
				State = 4847; inline_ref_constraint();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Virtual_column_definitionContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Column_expresssionContext column_expresssion() {
			return GetRuleContext<Column_expresssionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ITerminalNode SORT() { return GetToken(PlSqlParser.SORT, 0); }
		public ITerminalNode GENERATED() { return GetToken(PlSqlParser.GENERATED, 0); }
		public ITerminalNode ALWAYS() { return GetToken(PlSqlParser.ALWAYS, 0); }
		public ITerminalNode VIRTUAL() { return GetToken(PlSqlParser.VIRTUAL, 0); }
		public Evaluation_edition_clauseContext evaluation_edition_clause() {
			return GetRuleContext<Evaluation_edition_clauseContext>(0);
		}
		public Unusable_editions_clauseContext unusable_editions_clause() {
			return GetRuleContext<Unusable_editions_clauseContext>(0);
		}
		public Inline_constraintContext[] inline_constraint() {
			return GetRuleContexts<Inline_constraintContext>();
		}
		public Inline_constraintContext inline_constraint(int i) {
			return GetRuleContext<Inline_constraintContext>(i);
		}
		public ITerminalNode VISIBLE() { return GetToken(PlSqlParser.VISIBLE, 0); }
		public ITerminalNode INVISIBLE() { return GetToken(PlSqlParser.INVISIBLE, 0); }
		public Virtual_column_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_virtual_column_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVirtual_column_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Virtual_column_definitionContext virtual_column_definition() {
		Virtual_column_definitionContext _localctx = new Virtual_column_definitionContext(Context, State);
		EnterRule(_localctx, 510, RULE_virtual_column_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4850; column_name();
			State = 4852;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BOOLEAN))) != 0) || ((((_la - 72)) & ~0x3f) == 0 && ((1L << (_la - 72)) & ((1L << (CHARACTER - 72)) | (1L << (CHAR - 72)) | (1L << (CLOB - 72)) | (1L << (DATE - 72)) | (1L << (DAY - 72)) | (1L << (DEC - 72)) | (1L << (DECIMAL - 72)))) != 0) || ((((_la - 162)) & ~0x3f) == 0 && ((1L << (_la - 162)) & ((1L << (DOUBLE - 162)) | (1L << (DSINTERVAL_UNCONSTRAINED - 162)) | (1L << (FLOAT - 162)))) != 0) || ((((_la - 241)) & ~0x3f) == 0 && ((1L << (_la - 241)) & ((1L << (HOUR - 241)) | (1L << (INTEGER - 241)) | (1L << (INTERVAL - 241)) | (1L << (INT - 241)))) != 0) || ((((_la - 321)) & ~0x3f) == 0 && ((1L << (_la - 321)) & ((1L << (LONG - 321)) | (1L << (MINUTE - 321)) | (1L << (MLSLABEL - 321)) | (1L << (MONTH - 321)) | (1L << (NATURAL - 321)) | (1L << (NATURALN - 321)) | (1L << (NCHAR - 321)) | (1L << (NCLOB - 321)))) != 0) || ((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (NUMBER - 397)) | (1L << (NUMERIC - 397)) | (1L << (NVARCHAR2 - 397)) | (1L << (PLS_INTEGER - 397)) | (1L << (POSITIVEN - 397)) | (1L << (POSITIVE - 397)))) != 0) || ((((_la - 477)) & ~0x3f) == 0 && ((1L << (_la - 477)) & ((1L << (RAW - 477)) | (1L << (REAL - 477)) | (1L << (ROWID - 477)) | (1L << (SECOND - 477)))) != 0) || ((((_la - 553)) & ~0x3f) == 0 && ((1L << (_la - 553)) & ((1L << (SIGNTYPE - 553)) | (1L << (SIMPLE_INTEGER - 553)) | (1L << (SMALLINT - 553)) | (1L << (STRING - 553)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 553)) | (1L << (TIMESTAMP - 553)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 553)) | (1L << (TIMESTAMP_UNCONSTRAINED - 553)) | (1L << (TIMEZONE_ABBR - 553)) | (1L << (TIMEZONE_HOUR - 553)) | (1L << (TIMEZONE_MINUTE - 553)) | (1L << (TIMEZONE_REGION - 553)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (YEAR - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)))) != 0)) {
				{
				State = 4851; datatype();
				}
			}

			State = 4855;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SORT) {
				{
				State = 4854; Match(SORT);
				}
			}

			State = 4858;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INVISIBLE || _la==VISIBLE) {
				{
				State = 4857;
				_la = TokenStream.LA(1);
				if ( !(_la==INVISIBLE || _la==VISIBLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4862;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GENERATED) {
				{
				State = 4860; Match(GENERATED);
				State = 4861; Match(ALWAYS);
				}
			}

			State = 4864; Match(AS);
			State = 4865; Match(LEFT_PAREN);
			State = 4866; column_expresssion();
			State = 4867; Match(RIGHT_PAREN);
			State = 4869;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VIRTUAL) {
				{
				State = 4868; Match(VIRTUAL);
				}
			}

			State = 4872;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EVALUATION) {
				{
				State = 4871; evaluation_edition_clause();
				}
			}

			State = 4875;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNUSABLE) {
				{
				State = 4874; unusable_editions_clause();
				}
			}

			State = 4880;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CHECK || _la==CONSTRAINT || _la==NOT || _la==NULL || _la==PRIMARY || _la==REFERENCES || _la==UNIQUE) {
				{
				{
				State = 4877; inline_constraint();
				}
				}
				State = 4882;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_expresssionContext : ParserRuleContext {
		public Compound_expressionContext compound_expression() {
			return GetRuleContext<Compound_expressionContext>(0);
		}
		public Simple_expressionContext simple_expression() {
			return GetRuleContext<Simple_expressionContext>(0);
		}
		public Column_expresssionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_expresssion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_expresssion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_expresssionContext column_expresssion() {
		Column_expresssionContext _localctx = new Column_expresssionContext(Context, State);
		EnterRule(_localctx, 512, RULE_column_expresssion);
		try {
			State = 4885;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,620,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4883; compound_expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4884; simple_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Period_definitionContext : ParserRuleContext {
		public Column_nameContext valid_time_column;
		public Column_nameContext start_time_column;
		public Column_nameContext end_time_column;
		public ITerminalNode PERIOD() { return GetToken(PlSqlParser.PERIOD, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Period_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_period_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPeriod_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Period_definitionContext period_definition() {
		Period_definitionContext _localctx = new Period_definitionContext(Context, State);
		EnterRule(_localctx, 514, RULE_period_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4887; Match(PERIOD);
			State = 4888; Match(FOR);
			State = 4889; _localctx.valid_time_column = column_name();
			State = 4894;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 4890; _localctx.start_time_column = column_name();
				State = 4891; Match(COMMA);
				State = 4892; _localctx.end_time_column = column_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Supplemental_logging_propsContext : ParserRuleContext {
		public ITerminalNode SUPPLEMENTAL() { return GetToken(PlSqlParser.SUPPLEMENTAL, 0); }
		public ITerminalNode LOG() { return GetToken(PlSqlParser.LOG, 0); }
		public Supplemental_log_grp_clauseContext supplemental_log_grp_clause() {
			return GetRuleContext<Supplemental_log_grp_clauseContext>(0);
		}
		public Supplemental_id_key_clauseContext supplemental_id_key_clause() {
			return GetRuleContext<Supplemental_id_key_clauseContext>(0);
		}
		public Supplemental_logging_propsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplemental_logging_props; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSupplemental_logging_props(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Supplemental_logging_propsContext supplemental_logging_props() {
		Supplemental_logging_propsContext _localctx = new Supplemental_logging_propsContext(Context, State);
		EnterRule(_localctx, 516, RULE_supplemental_logging_props);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4896; Match(SUPPLEMENTAL);
			State = 4897; Match(LOG);
			State = 4900;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GROUP:
				{
				State = 4898; supplemental_log_grp_clause();
				}
				break;
			case DATA:
				{
				State = 4899; supplemental_id_key_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Supplemental_log_grp_clauseContext : ParserRuleContext {
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public Log_group_nameContext log_group_name() {
			return GetRuleContext<Log_group_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Column_loggedContext[] column_logged() {
			return GetRuleContexts<Column_loggedContext>();
		}
		public Column_loggedContext column_logged(int i) {
			return GetRuleContext<Column_loggedContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode ALWAYS() { return GetToken(PlSqlParser.ALWAYS, 0); }
		public Supplemental_log_grp_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplemental_log_grp_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSupplemental_log_grp_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Supplemental_log_grp_clauseContext supplemental_log_grp_clause() {
		Supplemental_log_grp_clauseContext _localctx = new Supplemental_log_grp_clauseContext(Context, State);
		EnterRule(_localctx, 518, RULE_supplemental_log_grp_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4902; Match(GROUP);
			State = 4903; log_group_name();
			State = 4904; Match(LEFT_PAREN);
			State = 4905; column_logged();
			State = 4910;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4906; Match(COMMA);
				State = 4907; column_logged();
				}
				}
				State = 4912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4913; Match(RIGHT_PAREN);
			State = 4915;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALWAYS) {
				{
				State = 4914; Match(ALWAYS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Supplemental_id_key_clauseContext : ParserRuleContext {
		public ITerminalNode DATA() { return GetToken(PlSqlParser.DATA, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode COLUMNS() { return GetToken(PlSqlParser.COLUMNS, 0); }
		public ITerminalNode[] ALL() { return GetTokens(PlSqlParser.ALL); }
		public ITerminalNode ALL(int i) {
			return GetToken(PlSqlParser.ALL, i);
		}
		public ITerminalNode[] PRIMARY() { return GetTokens(PlSqlParser.PRIMARY); }
		public ITerminalNode PRIMARY(int i) {
			return GetToken(PlSqlParser.PRIMARY, i);
		}
		public ITerminalNode[] KEY() { return GetTokens(PlSqlParser.KEY); }
		public ITerminalNode KEY(int i) {
			return GetToken(PlSqlParser.KEY, i);
		}
		public ITerminalNode[] UNIQUE() { return GetTokens(PlSqlParser.UNIQUE); }
		public ITerminalNode UNIQUE(int i) {
			return GetToken(PlSqlParser.UNIQUE, i);
		}
		public ITerminalNode[] FOREIGN() { return GetTokens(PlSqlParser.FOREIGN); }
		public ITerminalNode FOREIGN(int i) {
			return GetToken(PlSqlParser.FOREIGN, i);
		}
		public Supplemental_id_key_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_supplemental_id_key_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSupplemental_id_key_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Supplemental_id_key_clauseContext supplemental_id_key_clause() {
		Supplemental_id_key_clauseContext _localctx = new Supplemental_id_key_clauseContext(Context, State);
		EnterRule(_localctx, 520, RULE_supplemental_id_key_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4917; Match(DATA);
			State = 4918; Match(LEFT_PAREN);
			State = 4925;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4925;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALL:
					{
					State = 4919; Match(ALL);
					}
					break;
				case PRIMARY:
					{
					State = 4920; Match(PRIMARY);
					State = 4921; Match(KEY);
					}
					break;
				case UNIQUE:
					{
					State = 4922; Match(UNIQUE);
					}
					break;
				case FOREIGN:
					{
					State = 4923; Match(FOREIGN);
					State = 4924; Match(KEY);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4927;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==ALL || _la==FOREIGN || _la==PRIMARY || _la==UNIQUE );
			State = 4929; Match(RIGHT_PAREN);
			State = 4930; Match(COLUMNS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_loggedContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode LOG() { return GetToken(PlSqlParser.LOG, 0); }
		public Column_loggedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_logged; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_logged(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_loggedContext column_logged() {
		Column_loggedContext _localctx = new Column_loggedContext(Context, State);
		EnterRule(_localctx, 522, RULE_column_logged);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4932; column_name();
			State = 4935;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO) {
				{
				State = 4933; Match(NO);
				State = 4934; Match(LOG);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Evaluation_edition_clauseContext : ParserRuleContext {
		public ITerminalNode EVALUATION() { return GetToken(PlSqlParser.EVALUATION, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode EDITION() { return GetToken(PlSqlParser.EDITION, 0); }
		public Edition_nameContext edition_name() {
			return GetRuleContext<Edition_nameContext>(0);
		}
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Evaluation_edition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evaluation_edition_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvaluation_edition_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Evaluation_edition_clauseContext evaluation_edition_clause() {
		Evaluation_edition_clauseContext _localctx = new Evaluation_edition_clauseContext(Context, State);
		EnterRule(_localctx, 524, RULE_evaluation_edition_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4937; Match(EVALUATION);
			State = 4938; Match(USING);
			State = 4945;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4939; Match(CURRENT);
				State = 4940; Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4941; Match(EDITION);
				State = 4942; edition_name();
				}
				break;
			case NULL:
				{
				State = 4943; Match(NULL);
				State = 4944; Match(EDITION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Edition_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Edition_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_edition_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEdition_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Edition_nameContext edition_name() {
		Edition_nameContext _localctx = new Edition_nameContext(Context, State);
		EnterRule(_localctx, 526, RULE_edition_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4947; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unusable_editions_clauseContext : ParserRuleContext {
		public ITerminalNode UNUSABLE() { return GetToken(PlSqlParser.UNUSABLE, 0); }
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode EDITION() { return GetToken(PlSqlParser.EDITION, 0); }
		public Edition_nameContext edition_name() {
			return GetRuleContext<Edition_nameContext>(0);
		}
		public Unusable_editions_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unusable_editions_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnusable_editions_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unusable_editions_clauseContext unusable_editions_clause() {
		Unusable_editions_clauseContext _localctx = new Unusable_editions_clauseContext(Context, State);
		EnterRule(_localctx, 528, RULE_unusable_editions_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4949; Match(UNUSABLE);
			State = 4950; Match(BEFORE);
			State = 4955;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 4951; Match(CURRENT);
				State = 4952; Match(EDITION);
				}
				break;
			case EDITION:
				{
				State = 4953; Match(EDITION);
				State = 4954; edition_name();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Identity_optionsContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode NOMAXVALUE() { return GetToken(PlSqlParser.NOMAXVALUE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode NOMINVALUE() { return GetToken(PlSqlParser.NOMINVALUE, 0); }
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public ITerminalNode CACHE() { return GetToken(PlSqlParser.CACHE, 0); }
		public ITerminalNode NOCACHE() { return GetToken(PlSqlParser.NOCACHE, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode NOORDER() { return GetToken(PlSqlParser.NOORDER, 0); }
		public Identity_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identity_options; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentity_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Identity_optionsContext identity_options() {
		Identity_optionsContext _localctx = new Identity_optionsContext(Context, State);
		EnterRule(_localctx, 530, RULE_identity_options);
		int _la;
		try {
			State = 4981;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INCREMENT:
			case START:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4961;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INCREMENT:
					{
					State = 4957; Match(INCREMENT);
					State = 4958; Match(BY);
					}
					break;
				case START:
					{
					State = 4959; Match(START);
					State = 4960; Match(WITH);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4963; Match(UNSIGNED_INTEGER);
				}
				break;
			case MAXVALUE:
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4967;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MAXVALUE:
					{
					State = 4964; Match(MAXVALUE);
					State = 4965; Match(UNSIGNED_INTEGER);
					}
					break;
				case NOMAXVALUE:
					{
					State = 4966; Match(NOMAXVALUE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case MINVALUE:
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4972;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MINVALUE:
					{
					State = 4969; Match(MINVALUE);
					State = 4970; Match(UNSIGNED_INTEGER);
					}
					break;
				case NOMINVALUE:
					{
					State = 4971; Match(NOMINVALUE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case CYCLE:
			case NOCYCLE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4974;
				_la = TokenStream.LA(1);
				if ( !(_la==CYCLE || _la==NOCYCLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case CACHE:
			case NOCACHE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4978;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CACHE:
					{
					State = 4975; Match(CACHE);
					State = 4976; Match(UNSIGNED_INTEGER);
					}
					break;
				case NOCACHE:
					{
					State = 4977; Match(NOCACHE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NOORDER:
			case ORDER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4980;
				_la = TokenStream.LA(1);
				if ( !(_la==NOORDER || _la==ORDER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Encryption_specContext : ParserRuleContext {
		public IToken Encrypt_Algoritm;
		public IToken Password;
		public IToken Integrity_Algoritm;
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode IDENTIFIED() { return GetToken(PlSqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode SALT() { return GetToken(PlSqlParser.SALT, 0); }
		public ITerminalNode[] CHAR_STRING() { return GetTokens(PlSqlParser.CHAR_STRING); }
		public ITerminalNode CHAR_STRING(int i) {
			return GetToken(PlSqlParser.CHAR_STRING, i);
		}
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public Encryption_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_encryption_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEncryption_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Encryption_specContext encryption_spec() {
		Encryption_specContext _localctx = new Encryption_specContext(Context, State);
		EnterRule(_localctx, 532, RULE_encryption_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4985;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 4983; Match(USING);
				State = 4984; _localctx.Encrypt_Algoritm = Match(CHAR_STRING);
				}
			}

			State = 4990;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENTIFIED) {
				{
				State = 4987; Match(IDENTIFIED);
				State = 4988; Match(BY);
				State = 4989; _localctx.Password = Match(CHAR_STRING);
				}
			}

			State = 4993;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHAR_STRING) {
				{
				State = 4992; _localctx.Integrity_Algoritm = Match(CHAR_STRING);
				}
			}

			State = 4999;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,639,Context) ) {
			case 1:
				{
				State = 4996;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 4995; Match(NO);
					}
				}

				State = 4998; Match(SALT);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inline_ref_constraintContext : ParserRuleContext {
		public ITerminalNode SCOPE() { return GetToken(PlSqlParser.SCOPE, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Table_fullnameContext table_fullname() {
			return GetRuleContext<Table_fullnameContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public References_clauseContext references_clause() {
			return GetRuleContext<References_clauseContext>(0);
		}
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Constraint_stateContext constraint_state() {
			return GetRuleContext<Constraint_stateContext>(0);
		}
		public Inline_ref_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inline_ref_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInline_ref_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Inline_ref_constraintContext inline_ref_constraint() {
		Inline_ref_constraintContext _localctx = new Inline_ref_constraintContext(Context, State);
		EnterRule(_localctx, 534, RULE_inline_ref_constraint);
		int _la;
		try {
			State = 5014;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SCOPE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5001; Match(SCOPE);
				State = 5002; Match(IS);
				State = 5003; table_fullname();
				}
				break;
			case WITH:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5004; Match(WITH);
				State = 5005; Match(ROWID);
				}
				break;
			case CONSTRAINT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5006; Match(CONSTRAINT);
				State = 5008;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 5007; constraint_name();
					}
				}

				State = 5010; references_clause();
				State = 5012;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (DEFERRABLE - 143)) | (1L << (DISABLE - 143)) | (1L << (ENABLE - 143)) | (1L << (EXCEPTIONS - 143)))) != 0) || _la==INITIALLY || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (NORELY - 387)) | (1L << (NOT - 387)) | (1L << (NOVALIDATE - 387)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
					{
					State = 5011; constraint_state();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Out_of_line_ref_constraintContext : ParserRuleContext {
		public ITerminalNode SCOPE() { return GetToken(PlSqlParser.SCOPE, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Table_fullnameContext table_fullname() {
			return GetRuleContext<Table_fullnameContext>(0);
		}
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public ITerminalNode FOREIGN() { return GetToken(PlSqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public References_clauseContext references_clause() {
			return GetRuleContext<References_clauseContext>(0);
		}
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Constraint_stateContext constraint_state() {
			return GetRuleContext<Constraint_stateContext>(0);
		}
		public Out_of_line_ref_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_out_of_line_ref_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOut_of_line_ref_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Out_of_line_ref_constraintContext out_of_line_ref_constraint() {
		Out_of_line_ref_constraintContext _localctx = new Out_of_line_ref_constraintContext(Context, State);
		EnterRule(_localctx, 536, RULE_out_of_line_ref_constraint);
		int _la;
		try {
			State = 5042;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SCOPE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5016; Match(SCOPE);
				State = 5017; Match(FOR);
				State = 5018; Match(LEFT_PAREN);
				State = 5019; column_name();
				State = 5020; Match(RIGHT_PAREN);
				State = 5021; Match(IS);
				State = 5022; table_fullname();
				}
				break;
			case REF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5024; Match(REF);
				State = 5025; Match(LEFT_PAREN);
				State = 5026; column_name();
				State = 5027; Match(RIGHT_PAREN);
				State = 5028; Match(WITH);
				State = 5029; Match(ROWID);
				}
				break;
			case CONSTRAINT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5031; Match(CONSTRAINT);
				State = 5033;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 5032; constraint_name();
					}
				}

				State = 5035; Match(FOREIGN);
				State = 5036; Match(KEY);
				State = 5037; paren_column_list();
				State = 5038; references_clause();
				State = 5040;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (DEFERRABLE - 143)) | (1L << (DISABLE - 143)) | (1L << (ENABLE - 143)) | (1L << (EXCEPTIONS - 143)))) != 0) || _la==INITIALLY || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (NORELY - 387)) | (1L << (NOT - 387)) | (1L << (NOVALIDATE - 387)))) != 0) || _la==RELY || _la==USING || _la==VALIDATE) {
					{
					State = 5039; constraint_state();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Size_clauseContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode REGULAR_ID() { return GetToken(PlSqlParser.REGULAR_ID, 0); }
		public Size_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_size_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSize_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Size_clauseContext size_clause() {
		Size_clauseContext _localctx = new Size_clauseContext(Context, State);
		EnterRule(_localctx, 538, RULE_size_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5044; Match(UNSIGNED_INTEGER);
			State = 5046;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,646,Context) ) {
			case 1:
				{
				State = 5045; Match(REGULAR_ID);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_tableContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode SEMICOLON() { return GetToken(PlSqlParser.SEMICOLON, 0); }
		public Drop_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_tableContext drop_table() {
		Drop_tableContext _localctx = new Drop_tableContext(Context, State);
		EnterRule(_localctx, 540, RULE_drop_table);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5048; Match(DROP);
			State = 5049; Match(TABLE);
			State = 5050; tableview_name();
			State = 5051; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Comment_on_columnContext : ParserRuleContext {
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode COLUMN() { return GetToken(PlSqlParser.COLUMN, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode PERIOD() { return GetToken(PlSqlParser.PERIOD, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public Comment_on_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment_on_column; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment_on_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Comment_on_columnContext comment_on_column() {
		Comment_on_columnContext _localctx = new Comment_on_columnContext(Context, State);
		EnterRule(_localctx, 542, RULE_comment_on_column);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5053; Match(COMMENT);
			State = 5054; Match(ON);
			State = 5055; Match(COLUMN);
			State = 5056; tableview_name();
			State = 5057; Match(PERIOD);
			State = 5058; column_name();
			State = 5059; Match(IS);
			State = 5060; @string();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_synonymContext : ParserRuleContext {
		public Schema_nameContext Schema_synonym;
		public Schema_nameContext objectSchema;
		public Schema_object_nameContext objectName;
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode SYNONYM() { return GetToken(PlSqlParser.SYNONYM, 0); }
		public Synonym_nameContext synonym_name() {
			return GetRuleContext<Synonym_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Schema_object_nameContext schema_object_name() {
			return GetRuleContext<Schema_object_nameContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode PUBLIC() { return GetToken(PlSqlParser.PUBLIC, 0); }
		public ITerminalNode[] PERIOD() { return GetTokens(PlSqlParser.PERIOD); }
		public ITerminalNode PERIOD(int i) {
			return GetToken(PlSqlParser.PERIOD, i);
		}
		public ITerminalNode AT_SIGN() { return GetToken(PlSqlParser.AT_SIGN, 0); }
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public ITerminalNode EDITIONABLE() { return GetToken(PlSqlParser.EDITIONABLE, 0); }
		public ITerminalNode NONEDITIONABLE() { return GetToken(PlSqlParser.NONEDITIONABLE, 0); }
		public Schema_nameContext[] schema_name() {
			return GetRuleContexts<Schema_nameContext>();
		}
		public Schema_nameContext schema_name(int i) {
			return GetRuleContext<Schema_nameContext>(i);
		}
		public Create_synonymContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_synonym; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_synonym(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_synonymContext create_synonym() {
		Create_synonymContext _localctx = new Create_synonymContext(Context, State);
		EnterRule(_localctx, 544, RULE_create_synonym);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5062; Match(CREATE);
			State = 5065;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 5063; Match(OR);
				State = 5064; Match(REPLACE);
				}
			}

			State = 5068;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EDITIONABLE || _la==NONEDITIONABLE) {
				{
				State = 5067;
				_la = TokenStream.LA(1);
				if ( !(_la==EDITIONABLE || _la==NONEDITIONABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5071;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PUBLIC) {
				{
				State = 5070; Match(PUBLIC);
				}
			}

			State = 5073; Match(SYNONYM);
			State = 5077;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,650,Context) ) {
			case 1:
				{
				State = 5074; _localctx.Schema_synonym = schema_name();
				State = 5075; Match(PERIOD);
				}
				break;
			}
			State = 5079; synonym_name();
			State = 5080; Match(FOR);
			State = 5084;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,651,Context) ) {
			case 1:
				{
				State = 5081; _localctx.objectSchema = schema_name();
				State = 5082; Match(PERIOD);
				}
				break;
			}
			State = 5086; _localctx.objectName = schema_object_name();
			State = 5089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 5087; Match(AT_SIGN);
				State = 5088; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Comment_on_tableContext : ParserRuleContext {
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public Comment_on_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment_on_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment_on_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Comment_on_tableContext comment_on_table() {
		Comment_on_tableContext _localctx = new Comment_on_tableContext(Context, State);
		EnterRule(_localctx, 546, RULE_comment_on_table);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5091; Match(COMMENT);
			State = 5092; Match(ON);
			State = 5093; Match(TABLE);
			State = 5094; tableview_name();
			State = 5095; Match(IS);
			State = 5096; @string();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_tableContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Add_constraintContext add_constraint() {
			return GetRuleContext<Add_constraintContext>(0);
		}
		public Drop_constraintContext drop_constraint() {
			return GetRuleContext<Drop_constraintContext>(0);
		}
		public Enable_constraintContext enable_constraint() {
			return GetRuleContext<Enable_constraintContext>(0);
		}
		public Disable_constraintContext disable_constraint() {
			return GetRuleContext<Disable_constraintContext>(0);
		}
		public Alter_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_tableContext alter_table() {
		Alter_tableContext _localctx = new Alter_tableContext(Context, State);
		EnterRule(_localctx, 548, RULE_alter_table);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5098; Match(ALTER);
			State = 5099; Match(TABLE);
			State = 5100; tableview_name();
			State = 5105;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
				{
				State = 5101; add_constraint();
				}
				break;
			case DROP:
				{
				State = 5102; drop_constraint();
				}
				break;
			case ENABLE:
				{
				State = 5103; enable_constraint();
				}
				break;
			case DISABLE:
				{
				State = 5104; disable_constraint();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_constraintContext : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public Primary_key_clauseContext primary_key_clause() {
			return GetRuleContext<Primary_key_clauseContext>(0);
		}
		public Foreign_key_clauseContext foreign_key_clause() {
			return GetRuleContext<Foreign_key_clauseContext>(0);
		}
		public Unique_key_clauseContext unique_key_clause() {
			return GetRuleContext<Unique_key_clauseContext>(0);
		}
		public Check_constraintContext check_constraint() {
			return GetRuleContext<Check_constraintContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Add_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_constraintContext add_constraint() {
		Add_constraintContext _localctx = new Add_constraintContext(Context, State);
		EnterRule(_localctx, 550, RULE_add_constraint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5107; Match(ADD);
			State = 5110;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT) {
				{
				State = 5108; Match(CONSTRAINT);
				State = 5109; constraint_name();
				}
			}

			State = 5116;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIMARY:
				{
				State = 5112; primary_key_clause();
				}
				break;
			case FOREIGN:
				{
				State = 5113; foreign_key_clause();
				}
				break;
			case UNIQUE:
				{
				State = 5114; unique_key_clause();
				}
				break;
			case CHECK:
				{
				State = 5115; check_constraint();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Check_constraintContext : ParserRuleContext {
		public ITerminalNode CHECK() { return GetToken(PlSqlParser.CHECK, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public Check_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_check_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCheck_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Check_constraintContext check_constraint() {
		Check_constraintContext _localctx = new Check_constraintContext(Context, State);
		EnterRule(_localctx, 552, RULE_check_constraint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5118; Match(CHECK);
			State = 5119; Match(LEFT_PAREN);
			State = 5120; condition();
			State = 5121; Match(RIGHT_PAREN);
			State = 5123;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,656,Context) ) {
			case 1:
				{
				State = 5122; Match(DISABLE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_constraintContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Drop_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_constraintContext drop_constraint() {
		Drop_constraintContext _localctx = new Drop_constraintContext(Context, State);
		EnterRule(_localctx, 554, RULE_drop_constraint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5125; Match(DROP);
			State = 5126; Match(CONSTRAINT);
			State = 5127; constraint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Enable_constraintContext : ParserRuleContext {
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Enable_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enable_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnable_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Enable_constraintContext enable_constraint() {
		Enable_constraintContext _localctx = new Enable_constraintContext(Context, State);
		EnterRule(_localctx, 556, RULE_enable_constraint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5129; Match(ENABLE);
			State = 5130; Match(CONSTRAINT);
			State = 5131; constraint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Disable_constraintContext : ParserRuleContext {
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Disable_constraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_disable_constraint; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDisable_constraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Disable_constraintContext disable_constraint() {
		Disable_constraintContext _localctx = new Disable_constraintContext(Context, State);
		EnterRule(_localctx, 558, RULE_disable_constraint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5133; Match(DISABLE);
			State = 5134; Match(CONSTRAINT);
			State = 5135; constraint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Foreign_key_clauseContext : ParserRuleContext {
		public ITerminalNode FOREIGN() { return GetToken(PlSqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public References_clauseContext references_clause() {
			return GetRuleContext<References_clauseContext>(0);
		}
		public Foreign_key_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreign_key_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeign_key_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Foreign_key_clauseContext foreign_key_clause() {
		Foreign_key_clauseContext _localctx = new Foreign_key_clauseContext(Context, State);
		EnterRule(_localctx, 560, RULE_foreign_key_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5137; Match(FOREIGN);
			State = 5138; Match(KEY);
			State = 5139; paren_column_list();
			State = 5140; references_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class References_clauseContext : ParserRuleContext {
		public ITerminalNode REFERENCES() { return GetToken(PlSqlParser.REFERENCES, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public References_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_references_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferences_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public References_clauseContext references_clause() {
		References_clauseContext _localctx = new References_clauseContext(Context, State);
		EnterRule(_localctx, 562, RULE_references_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5142; Match(REFERENCES);
			State = 5143; tableview_name();
			State = 5144; paren_column_list();
			State = 5152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 5145; Match(ON);
				State = 5146; Match(DELETE);
				State = 5150;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CASCADE:
					{
					State = 5147; Match(CASCADE);
					}
					break;
				case SET:
					{
					State = 5148; Match(SET);
					State = 5149; Match(NULL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unique_key_clauseContext : ParserRuleContext {
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Unique_key_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unique_key_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnique_key_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unique_key_clauseContext unique_key_clause() {
		Unique_key_clauseContext _localctx = new Unique_key_clauseContext(Context, State);
		EnterRule(_localctx, 564, RULE_unique_key_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5154; Match(UNIQUE);
			State = 5155; paren_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Primary_key_clauseContext : ParserRuleContext {
		public ITerminalNode PRIMARY() { return GetToken(PlSqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Primary_key_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primary_key_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimary_key_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Primary_key_clauseContext primary_key_clause() {
		Primary_key_clauseContext _localctx = new Primary_key_clauseContext(Context, State);
		EnterRule(_localctx, 566, RULE_primary_key_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5157; Match(PRIMARY);
			State = 5158; Match(KEY);
			State = 5159; paren_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Anonymous_blockContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(PlSqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode SEMICOLON() { return GetToken(PlSqlParser.SEMICOLON, 0); }
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Seq_of_declare_specsContext seq_of_declare_specs() {
			return GetRuleContext<Seq_of_declare_specsContext>(0);
		}
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public Exception_handlerContext[] exception_handler() {
			return GetRuleContexts<Exception_handlerContext>();
		}
		public Exception_handlerContext exception_handler(int i) {
			return GetRuleContext<Exception_handlerContext>(i);
		}
		public Anonymous_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anonymous_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnonymous_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Anonymous_blockContext anonymous_block() {
		Anonymous_blockContext _localctx = new Anonymous_blockContext(Context, State);
		EnterRule(_localctx, 568, RULE_anonymous_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5163;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DECLARE) {
				{
				State = 5161; Match(DECLARE);
				State = 5162; seq_of_declare_specs();
				}
			}

			State = 5165; Match(BEGIN);
			State = 5166; seq_of_statements();
			State = 5173;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTION) {
				{
				State = 5167; Match(EXCEPTION);
				State = 5169;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5168; exception_handler();
					}
					}
					State = 5171;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				}
			}

			State = 5175; Match(END);
			State = 5176; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Invoker_rights_clauseContext : ParserRuleContext {
		public ITerminalNode AUTHID() { return GetToken(PlSqlParser.AUTHID, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(PlSqlParser.CURRENT_USER, 0); }
		public ITerminalNode DEFINER() { return GetToken(PlSqlParser.DEFINER, 0); }
		public Invoker_rights_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invoker_rights_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInvoker_rights_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Invoker_rights_clauseContext invoker_rights_clause() {
		Invoker_rights_clauseContext _localctx = new Invoker_rights_clauseContext(Context, State);
		EnterRule(_localctx, 570, RULE_invoker_rights_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5178; Match(AUTHID);
			State = 5179;
			_la = TokenStream.LA(1);
			if ( !(_la==CURRENT_USER || _la==DEFINER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compiler_parameters_clauseContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Compiler_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compiler_parameters_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompiler_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compiler_parameters_clauseContext compiler_parameters_clause() {
		Compiler_parameters_clauseContext _localctx = new Compiler_parameters_clauseContext(Context, State);
		EnterRule(_localctx, 572, RULE_compiler_parameters_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5181; identifier();
			State = 5182; Match(EQUALS_OP);
			State = 5183; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Call_specContext : ParserRuleContext {
		public ITerminalNode LANGUAGE() { return GetToken(PlSqlParser.LANGUAGE, 0); }
		public Java_specContext java_spec() {
			return GetRuleContext<Java_specContext>(0);
		}
		public C_specContext c_spec() {
			return GetRuleContext<C_specContext>(0);
		}
		public Call_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_call_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCall_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Call_specContext call_spec() {
		Call_specContext _localctx = new Call_specContext(Context, State);
		EnterRule(_localctx, 574, RULE_call_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5185; Match(LANGUAGE);
			State = 5188;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case JAVA:
				{
				State = 5186; java_spec();
				}
				break;
			case C_LETTER:
				{
				State = 5187; c_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Java_specContext : ParserRuleContext {
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Java_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_java_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJava_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Java_specContext java_spec() {
		Java_specContext _localctx = new Java_specContext(Context, State);
		EnterRule(_localctx, 576, RULE_java_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5190; Match(JAVA);
			State = 5191; Match(NAME);
			State = 5192; Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_specContext : ParserRuleContext {
		public ITerminalNode C_LETTER() { return GetToken(PlSqlParser.C_LETTER, 0); }
		public ITerminalNode LIBRARY() { return GetToken(PlSqlParser.LIBRARY, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public C_agent_in_clauseContext c_agent_in_clause() {
			return GetRuleContext<C_agent_in_clauseContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode CONTEXT() { return GetToken(PlSqlParser.CONTEXT, 0); }
		public C_parameters_clauseContext c_parameters_clause() {
			return GetRuleContext<C_parameters_clauseContext>(0);
		}
		public C_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_specContext c_spec() {
		C_specContext _localctx = new C_specContext(Context, State);
		EnterRule(_localctx, 578, RULE_c_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5194; Match(C_LETTER);
			State = 5197;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NAME) {
				{
				State = 5195; Match(NAME);
				State = 5196; Match(CHAR_STRING);
				}
			}

			State = 5199; Match(LIBRARY);
			State = 5200; identifier();
			State = 5202;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AGENT) {
				{
				State = 5201; c_agent_in_clause();
				}
			}

			State = 5206;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 5204; Match(WITH);
				State = 5205; Match(CONTEXT);
				}
			}

			State = 5209;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARAMETERS) {
				{
				State = 5208; c_parameters_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_agent_in_clauseContext : ParserRuleContext {
		public ITerminalNode AGENT() { return GetToken(PlSqlParser.AGENT, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public C_agent_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_agent_in_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_agent_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_agent_in_clauseContext c_agent_in_clause() {
		C_agent_in_clauseContext _localctx = new C_agent_in_clauseContext(Context, State);
		EnterRule(_localctx, 580, RULE_c_agent_in_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5211; Match(AGENT);
			State = 5212; Match(IN);
			State = 5213; Match(LEFT_PAREN);
			State = 5214; expressions();
			State = 5215; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_parameters_clauseContext : ParserRuleContext {
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public C_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_parameters_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_parameters_clauseContext c_parameters_clause() {
		C_parameters_clauseContext _localctx = new C_parameters_clauseContext(Context, State);
		EnterRule(_localctx, 582, RULE_c_parameters_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5217; Match(PARAMETERS);
			State = 5218; Match(LEFT_PAREN);
			State = 5223;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case VARIABLE_SESSION:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 5219; expressions();
				}
				break;
			case PERIOD:
				{
				State = 5220; Match(PERIOD);
				State = 5221; Match(PERIOD);
				State = 5222; Match(PERIOD);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5225; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode[] IN() { return GetTokens(PlSqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(PlSqlParser.IN, i);
		}
		public ITerminalNode[] OUT() { return GetTokens(PlSqlParser.OUT); }
		public ITerminalNode OUT(int i) {
			return GetToken(PlSqlParser.OUT, i);
		}
		public ITerminalNode[] INOUT() { return GetTokens(PlSqlParser.INOUT); }
		public ITerminalNode INOUT(int i) {
			return GetToken(PlSqlParser.INOUT, i);
		}
		public ITerminalNode[] NOCOPY() { return GetTokens(PlSqlParser.NOCOPY); }
		public ITerminalNode NOCOPY(int i) {
			return GetToken(PlSqlParser.NOCOPY, i);
		}
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(Context, State);
		EnterRule(_localctx, 584, RULE_parameter);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5227; parameter_name();
			State = 5231;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,668,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 5228;
					_la = TokenStream.LA(1);
					if ( !(_la==IN || _la==INOUT || _la==NOCOPY || _la==OUT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					} 
				}
				State = 5233;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,668,Context);
			}
			State = 5235;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,669,Context) ) {
			case 1:
				{
				State = 5234; type_spec();
				}
				break;
			}
			State = 5238;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 5237; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Default_value_partContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASSIGN_OP() { return GetToken(PlSqlParser.ASSIGN_OP, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Default_value_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_default_value_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefault_value_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Default_value_partContext default_value_part() {
		Default_value_partContext _localctx = new Default_value_partContext(Context, State);
		EnterRule(_localctx, 586, RULE_default_value_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5240;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5241; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seq_of_declare_specsContext : ParserRuleContext {
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Seq_of_declare_specsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seq_of_declare_specs; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeq_of_declare_specs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seq_of_declare_specsContext seq_of_declare_specs() {
		Seq_of_declare_specsContext _localctx = new Seq_of_declare_specsContext(Context, State);
		EnterRule(_localctx, 588, RULE_seq_of_declare_specs);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5244;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 5243; declare_spec();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5246;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,671,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_specContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Procedure_bodyContext procedure_body() {
			return GetRuleContext<Procedure_bodyContext>(0);
		}
		public Function_bodyContext function_body() {
			return GetRuleContext<Function_bodyContext>(0);
		}
		public Declare_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declare_specContext declare_spec() {
		Declare_specContext _localctx = new Declare_specContext(Context, State);
		EnterRule(_localctx, 590, RULE_declare_spec);
		try {
			State = 5258;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,672,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5248; variable_declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5249; subtype_declaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5250; cursor_declaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5251; exception_declaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5252; pragma_declaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5253; type_declaration();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5254; procedure_spec();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5255; function_spec();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5256; procedure_body();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5257; function_body();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_declarationContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CONSTANT() { return GetToken(PlSqlParser.CONSTANT, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Variable_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Variable_declarationContext variable_declaration() {
		Variable_declarationContext _localctx = new Variable_declarationContext(Context, State);
		EnterRule(_localctx, 592, RULE_variable_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5260; identifier();
			State = 5262;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,673,Context) ) {
			case 1:
				{
				State = 5261; Match(CONSTANT);
				}
				break;
			}
			State = 5264; type_spec();
			State = 5267;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5265; Match(NOT);
				State = 5266; Match(NULL);
				}
			}

			State = 5270;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 5269; default_value_part();
				}
			}

			State = 5272; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subtype_declarationContext : ParserRuleContext {
		public ITerminalNode SUBTYPE() { return GetToken(PlSqlParser.SUBTYPE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Subtype_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subtype_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubtype_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subtype_declarationContext subtype_declaration() {
		Subtype_declarationContext _localctx = new Subtype_declarationContext(Context, State);
		EnterRule(_localctx, 594, RULE_subtype_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5274; Match(SUBTYPE);
			State = 5275; identifier();
			State = 5276; Match(IS);
			State = 5277; type_spec();
			State = 5283;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RANGE) {
				{
				State = 5278; Match(RANGE);
				State = 5279; expression();
				State = 5280; Match(DOUBLE_PERIOD);
				State = 5281; expression();
				}
			}

			State = 5287;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5285; Match(NOT);
				State = 5286; Match(NULL);
				}
			}

			State = 5289; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_declarationContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Parameter_specContext[] parameter_spec() {
			return GetRuleContexts<Parameter_specContext>();
		}
		public Parameter_specContext parameter_spec(int i) {
			return GetRuleContext<Parameter_specContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Cursor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_declarationContext cursor_declaration() {
		Cursor_declarationContext _localctx = new Cursor_declarationContext(Context, State);
		EnterRule(_localctx, 596, RULE_cursor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5291; Match(CURSOR);
			State = 5292; identifier();
			State = 5304;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 5293; Match(LEFT_PAREN);
				State = 5298;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5295;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 5294; Match(COMMA);
						}
					}

					State = 5297; parameter_spec();
					}
					}
					State = 5300;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				State = 5302; Match(RIGHT_PAREN);
				}
			}

			State = 5308;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 5306; Match(RETURN);
				State = 5307; type_spec();
				}
			}

			State = 5312;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IS) {
				{
				State = 5310; Match(IS);
				State = 5311; select_statement();
				}
			}

			State = 5314; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_specContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Parameter_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_specContext parameter_spec() {
		Parameter_specContext _localctx = new Parameter_specContext(Context, State);
		EnterRule(_localctx, 598, RULE_parameter_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5316; parameter_name();
			State = 5321;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,684,Context) ) {
			case 1:
				{
				State = 5318;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IN) {
					{
					State = 5317; Match(IN);
					}
				}

				State = 5320; type_spec();
				}
				break;
			}
			State = 5324;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 5323; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_declarationContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public Exception_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_declarationContext exception_declaration() {
		Exception_declarationContext _localctx = new Exception_declarationContext(Context, State);
		EnterRule(_localctx, 600, RULE_exception_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5326; identifier();
			State = 5327; Match(EXCEPTION);
			State = 5328; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_declarationContext : ParserRuleContext {
		public IdentifierContext id1;
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(PlSqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(PlSqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(PlSqlParser.EXCEPTION_INIT, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Numeric_negativeContext numeric_negative() {
			return GetRuleContext<Numeric_negativeContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode INLINE() { return GetToken(PlSqlParser.INLINE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(PlSqlParser.RESTRICT_REFERENCES, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Pragma_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_declarationContext pragma_declaration() {
		Pragma_declarationContext _localctx = new Pragma_declarationContext(Context, State);
		EnterRule(_localctx, 602, RULE_pragma_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5330; Match(PRAGMA);
			State = 5361;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SERIALLY_REUSABLE:
				{
				State = 5331; Match(SERIALLY_REUSABLE);
				}
				break;
			case AUTONOMOUS_TRANSACTION:
				{
				State = 5332; Match(AUTONOMOUS_TRANSACTION);
				}
				break;
			case EXCEPTION_INIT:
				{
				State = 5333; Match(EXCEPTION_INIT);
				State = 5334; Match(LEFT_PAREN);
				State = 5335; exception_name();
				State = 5336; Match(COMMA);
				State = 5337; numeric_negative();
				State = 5338; Match(RIGHT_PAREN);
				}
				break;
			case INLINE:
				{
				State = 5340; Match(INLINE);
				State = 5341; Match(LEFT_PAREN);
				State = 5342; _localctx.id1 = identifier();
				State = 5343; Match(COMMA);
				State = 5344; expression();
				State = 5345; Match(RIGHT_PAREN);
				}
				break;
			case RESTRICT_REFERENCES:
				{
				State = 5347; Match(RESTRICT_REFERENCES);
				State = 5348; Match(LEFT_PAREN);
				State = 5351;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 5349; identifier();
					}
					break;
				case DEFAULT:
					{
					State = 5350; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5355;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5353; Match(COMMA);
					State = 5354; identifier();
					}
					}
					State = 5357;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMMA );
				State = 5359; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5363; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_declarationContext : ParserRuleContext {
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Table_type_defContext table_type_def() {
			return GetRuleContext<Table_type_defContext>(0);
		}
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public Record_type_defContext record_type_def() {
			return GetRuleContext<Record_type_defContext>(0);
		}
		public Ref_cursor_type_defContext ref_cursor_type_def() {
			return GetRuleContext<Ref_cursor_type_defContext>(0);
		}
		public Type_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_declarationContext type_declaration() {
		Type_declarationContext _localctx = new Type_declarationContext(Context, State);
		EnterRule(_localctx, 604, RULE_type_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5365; Match(TYPE);
			State = 5366; identifier();
			State = 5367; Match(IS);
			State = 5372;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TABLE:
				{
				State = 5368; table_type_def();
				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 5369; varray_type_def();
				}
				break;
			case RECORD:
				{
				State = 5370; record_type_def();
				}
				break;
			case REF:
				{
				State = 5371; ref_cursor_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5374; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ref_cursor_type_defContext : ParserRuleContext {
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Ref_cursor_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ref_cursor_type_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRef_cursor_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ref_cursor_type_defContext ref_cursor_type_def() {
		Ref_cursor_type_defContext _localctx = new Ref_cursor_type_defContext(Context, State);
		EnterRule(_localctx, 606, RULE_ref_cursor_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5376; Match(REF);
			State = 5377; Match(CURSOR);
			State = 5380;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 5378; Match(RETURN);
				State = 5379; type_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_type_defContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Table_indexed_by_partContext table_indexed_by_part() {
			return GetRuleContext<Table_indexed_by_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Table_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_type_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_type_defContext table_type_def() {
		Table_type_defContext _localctx = new Table_type_defContext(Context, State);
		EnterRule(_localctx, 608, RULE_table_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5382; Match(TABLE);
			State = 5383; Match(OF);
			State = 5384; type_spec();
			State = 5386;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEXED || _la==INDEX) {
				{
				State = 5385; table_indexed_by_part();
				}
			}

			State = 5390;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5388; Match(NOT);
				State = 5389; Match(NULL);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_indexed_by_partContext : ParserRuleContext {
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode INDEXED() { return GetToken(PlSqlParser.INDEXED, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public Table_indexed_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_indexed_by_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_indexed_by_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_indexed_by_partContext table_indexed_by_part() {
		Table_indexed_by_partContext _localctx = new Table_indexed_by_partContext(Context, State);
		EnterRule(_localctx, 610, RULE_table_indexed_by_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5392;
			_la = TokenStream.LA(1);
			if ( !(_la==INDEXED || _la==INDEX) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5393; Match(BY);
			State = 5394; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_type_defContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode VARRAY() { return GetToken(PlSqlParser.VARRAY, 0); }
		public ITerminalNode VARYING() { return GetToken(PlSqlParser.VARYING, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlSqlParser.ARRAY, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Varray_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_type_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarray_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Varray_type_defContext varray_type_def() {
		Varray_type_defContext _localctx = new Varray_type_defContext(Context, State);
		EnterRule(_localctx, 612, RULE_varray_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5399;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VARRAY:
				{
				State = 5396; Match(VARRAY);
				}
				break;
			case VARYING:
				{
				State = 5397; Match(VARYING);
				State = 5398; Match(ARRAY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5401; Match(LEFT_PAREN);
			State = 5402; expression();
			State = 5403; Match(RIGHT_PAREN);
			State = 5404; Match(OF);
			State = 5405; type_spec();
			State = 5408;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,694,Context) ) {
			case 1:
				{
				State = 5406; Match(NOT);
				State = 5407; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_type_defContext : ParserRuleContext {
		public ITerminalNode RECORD() { return GetToken(PlSqlParser.RECORD, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Field_specContext[] field_spec() {
			return GetRuleContexts<Field_specContext>();
		}
		public Field_specContext field_spec(int i) {
			return GetRuleContext<Field_specContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Record_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_type_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_type_defContext record_type_def() {
		Record_type_defContext _localctx = new Record_type_defContext(Context, State);
		EnterRule(_localctx, 614, RULE_record_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5410; Match(RECORD);
			State = 5411; Match(LEFT_PAREN);
			State = 5416;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5413;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 5412; Match(COMMA);
					}
				}

				State = 5415; field_spec();
				}
				}
				State = 5418;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 5420; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_specContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Field_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitField_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Field_specContext field_spec() {
		Field_specContext _localctx = new Field_specContext(Context, State);
		EnterRule(_localctx, 616, RULE_field_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5422; column_name();
			State = 5424;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,697,Context) ) {
			case 1:
				{
				State = 5423; type_spec();
				}
				break;
			}
			State = 5428;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5426; Match(NOT);
				State = 5427; Match(NULL);
				}
			}

			State = 5431;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 5430; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seq_of_statementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public Label_declarationContext[] label_declaration() {
			return GetRuleContexts<Label_declarationContext>();
		}
		public Label_declarationContext label_declaration(int i) {
			return GetRuleContext<Label_declarationContext>(i);
		}
		public ITerminalNode[] Eof() { return GetTokens(PlSqlParser.Eof); }
		public ITerminalNode Eof(int i) {
			return GetToken(PlSqlParser.Eof, i);
		}
		public Seq_of_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seq_of_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeq_of_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seq_of_statementsContext seq_of_statements() {
		Seq_of_statementsContext _localctx = new Seq_of_statementsContext(Context, State);
		EnterRule(_localctx, 618, RULE_seq_of_statements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5437;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 5437;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,700,Context) ) {
					case 1:
						{
						State = 5433; statement();
						State = 5434;
						_la = TokenStream.LA(1);
						if ( !(_la==Eof || _la==SEMICOLON) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case 2:
						{
						State = 5436; label_declaration();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5439;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,701,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_declarationContext : ParserRuleContext {
		public IToken ltp1;
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Label_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Label_declarationContext label_declaration() {
		Label_declarationContext _localctx = new Label_declarationContext(Context, State);
		EnterRule(_localctx, 620, RULE_label_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5441; _localctx.ltp1 = Match(LESS_THAN_OP);
			State = 5442; Match(LESS_THAN_OP);
			State = 5443; label_name();
			State = 5444; Match(GREATER_THAN_OP);
			State = 5445; Match(GREATER_THAN_OP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public Swallow_to_semiContext swallow_to_semi() {
			return GetRuleContext<Swallow_to_semiContext>(0);
		}
		public ITerminalNode TRUNCATE() { return GetToken(PlSqlParser.TRUNCATE, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public Assignment_statementContext assignment_statement() {
			return GetRuleContext<Assignment_statementContext>(0);
		}
		public Continue_statementContext continue_statement() {
			return GetRuleContext<Continue_statementContext>(0);
		}
		public Exit_statementContext exit_statement() {
			return GetRuleContext<Exit_statementContext>(0);
		}
		public Goto_statementContext goto_statement() {
			return GetRuleContext<Goto_statementContext>(0);
		}
		public If_statementContext if_statement() {
			return GetRuleContext<If_statementContext>(0);
		}
		public Loop_statementContext loop_statement() {
			return GetRuleContext<Loop_statementContext>(0);
		}
		public Forall_statementContext forall_statement() {
			return GetRuleContext<Forall_statementContext>(0);
		}
		public Null_statementContext null_statement() {
			return GetRuleContext<Null_statementContext>(0);
		}
		public Raise_statementContext raise_statement() {
			return GetRuleContext<Raise_statementContext>(0);
		}
		public Return_statementContext return_statement() {
			return GetRuleContext<Return_statementContext>(0);
		}
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Pipe_row_statementContext pipe_row_statement() {
			return GetRuleContext<Pipe_row_statementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 622, RULE_statement);
		try {
			State = 5467;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,702,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5447; Match(CREATE);
				State = 5448; swallow_to_semi();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5449; Match(TRUNCATE);
				State = 5450; swallow_to_semi();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5451; body();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5452; block();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5453; assignment_statement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5454; continue_statement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5455; exit_statement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5456; goto_statement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5457; if_statement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5458; loop_statement();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5459; forall_statement();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5460; null_statement();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5461; raise_statement();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5462; return_statement();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 5463; case_statement();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 5464; sql_statement();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 5465; function_call();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 5466; pipe_row_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Swallow_to_semiContext : ParserRuleContext {
		public Swallow_to_semiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_swallow_to_semi; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwallow_to_semi(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Swallow_to_semiContext swallow_to_semi() {
		Swallow_to_semiContext _localctx = new Swallow_to_semiContext(Context, State);
		EnterRule(_localctx, 624, RULE_swallow_to_semi);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5470;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5469;
				_la = TokenStream.LA(1);
				if ( _la <= 0 || (_la==SEMICOLON) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				State = 5472;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCESS) | (1L << ACCOUNT) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTER) | (1L << ADVANCED) | (1L << ADVISOR) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ALLOW) | (1L << ALTER) | (1L << ALWAYS) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ANYSCHEMA) | (1L << ARCHIVAL) | (1L << ARCHIVE) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHENTICATED) | (1L << AUTHENTICATION) | (1L << AUTHID) | (1L << AUTOALLOCATE) | (1L << AUTO) | (1L << AUTOEXTEND) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BACKUP) | (1L << BASIC) | (1L << BASICFILE) | (1L << BATCH) | (1L << BECOME) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BIGFILE) | (1L << BINARY) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BLOCKSIZE) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BUFFER_POOL) | (1L << BUILD) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << CACHE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CAPACITY - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CERTIFICATE - 64)) | (1L << (CHANGE - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHECK - 64)) | (1L << (CHR - 64)) | (1L << (CHUNK - 64)) | (1L << (CLASS - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (CLUSTERING - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMN - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (COMPRESS - 64)) | (1L << (COMPUTE - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONNECT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTAINER - 64)) | (1L << (CONTAINER_DATA - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CREATION - 64)) | (1L << (CRITICAL - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURRVAL - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATAFILE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (DAYS - 128)) | (1L << (DBA_RECYCLEBIN - 128)) | (1L << (DB_ROLE_CHANGE - 128)) | (1L << (DBTIMEZONE - 128)) | (1L << (DDL - 128)) | (1L << (DEBUG - 128)) | (1L << (DEC - 128)) | (1L << (DECIMAL - 128)) | (1L << (DECLARE - 128)) | (1L << (DECOMPOSE - 128)) | (1L << (DECREMENT - 128)) | (1L << (DECRYPT - 128)) | (1L << (DEDUPLICATE - 128)) | (1L << (DEFAULT - 128)) | (1L << (DEFAULTS - 128)) | (1L << (DEFERRABLE - 128)) | (1L << (DEFERRED - 128)) | (1L << (DEFINER - 128)) | (1L << (DELEGATE - 128)) | (1L << (DELETE - 128)) | (1L << (DEPTH - 128)) | (1L << (DESC - 128)) | (1L << (DETERMINISTIC - 128)) | (1L << (DICTIONARY - 128)) | (1L << (DIMENSION - 128)) | (1L << (DIRECTORY - 128)) | (1L << (DISABLE - 128)) | (1L << (DISALLOW - 128)) | (1L << (DISASSOCIATE - 128)) | (1L << (DISTINCT - 128)) | (1L << (DISTINGUISHED - 128)) | (1L << (DISTRIBUTE - 128)) | (1L << (DML - 128)) | (1L << (DOCUMENT - 128)) | (1L << (DOUBLE - 128)) | (1L << (DROP - 128)) | (1L << (DSINTERVAL_UNCONSTRAINED - 128)) | (1L << (DUPLICATE - 128)) | (1L << (EACH - 128)) | (1L << (EDITIONABLE - 128)) | (1L << (EDITION - 128)) | (1L << (EDITIONING - 128)) | (1L << (EDITIONS - 128)) | (1L << (ELEMENT - 128)) | (1L << (ELSE - 128)) | (1L << (ELSIF - 128)) | (1L << (EMPTY - 128)) | (1L << (ENABLE - 128)) | (1L << (ENCODING - 128)) | (1L << (ENCRYPT - 128)) | (1L << (ENCRYPTION - 128)) | (1L << (END - 128)) | (1L << (ENTERPRISE - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERR - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EVALNAME - 128)) | (1L << (EVALUATION - 128)) | (1L << (EXCEPT - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (EXCLUSIVE - 192)) | (1L << (EXECUTE - 192)) | (1L << (EXEMPT - 192)) | (1L << (EXISTS - 192)) | (1L << (EXIT - 192)) | (1L << (EXPIRE - 192)) | (1L << (EXPLAIN - 192)) | (1L << (EXTENT - 192)) | (1L << (EXTERNAL - 192)) | (1L << (EXTERNALLY - 192)) | (1L << (EXTRACT - 192)) | (1L << (FAILURE - 192)) | (1L << (FALSE - 192)) | (1L << (FETCH - 192)) | (1L << (FILESYSTEM_LIKE_LOGGING - 192)) | (1L << (FINAL - 192)) | (1L << (FIRST - 192)) | (1L << (FIRST_VALUE - 192)) | (1L << (FLASHBACK - 192)) | (1L << (FLASH_CACHE - 192)) | (1L << (FLOAT - 192)) | (1L << (FOLDER - 192)) | (1L << (FOLLOWING - 192)) | (1L << (FOLLOWS - 192)) | (1L << (FORALL - 192)) | (1L << (FORCE - 192)) | (1L << (FOREIGN - 192)) | (1L << (FOR - 192)) | (1L << (FREELIST - 192)) | (1L << (FREELISTS - 192)) | (1L << (FREEPOOLS - 192)) | (1L << (FROM - 192)) | (1L << (FULL - 192)) | (1L << (FUNCTION - 192)) | (1L << (GENERATED - 192)) | (1L << (GLOBAL - 192)) | (1L << (GLOBALLY - 192)) | (1L << (GOTO - 192)) | (1L << (GRANT - 192)) | (1L << (GROUP - 192)) | (1L << (GROUPING - 192)) | (1L << (GROUPS - 192)) | (1L << (GUARANTEE - 192)) | (1L << (HASH - 192)) | (1L << (HAVING - 192)) | (1L << (HEAP - 192)) | (1L << (HIDE - 192)) | (1L << (HIERARCHY - 192)) | (1L << (HIGH - 192)) | (1L << (HOUR - 192)) | (1L << (IDENTIFIED - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (IDENTITY - 192)) | (1L << (ID - 192)) | (1L << (IF - 192)) | (1L << (IGNORE - 192)) | (1L << (ILM - 192)) | (1L << (IMMEDIATE - 192)) | (1L << (INCLUDE - 192)) | (1L << (INCLUDING - 192)) | (1L << (INCREMENT - 192)) | (1L << (INDENT - 192)) | (1L << (INDEXED - 192)) | (1L << (INDEX - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (INDEXING - 256)) | (1L << (INDEXTYPE - 256)) | (1L << (INDICATOR - 256)) | (1L << (INDICES - 256)) | (1L << (INFINITE - 256)) | (1L << (INHERIT - 256)) | (1L << (IN - 256)) | (1L << (INITIAL - 256)) | (1L << (INITIALLY - 256)) | (1L << (INITRANS - 256)) | (1L << (INLINE - 256)) | (1L << (INMEMORY - 256)) | (1L << (INNER - 256)) | (1L << (INOUT - 256)) | (1L << (INSERT - 256)) | (1L << (INSTANTIABLE - 256)) | (1L << (INSTEAD - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERSECT - 256)) | (1L << (INTERVAL - 256)) | (1L << (INTERVLEAVED - 256)) | (1L << (INT - 256)) | (1L << (INTO - 256)) | (1L << (INVALIDATE - 256)) | (1L << (INVISIBLE - 256)) | (1L << (IS - 256)) | (1L << (ISOLATION - 256)) | (1L << (ITERATE - 256)) | (1L << (JAVA - 256)) | (1L << (JOB - 256)) | (1L << (JOIN - 256)) | (1L << (KEEP_DUPLICATES - 256)) | (1L << (KEEP - 256)) | (1L << (KEY - 256)) | (1L << (LANGUAGE - 256)) | (1L << (LAST - 256)) | (1L << (LAST_VALUE - 256)) | (1L << (LEADING - 256)) | (1L << (LEFT - 256)) | (1L << (LESS - 256)) | (1L << (LEVEL - 256)) | (1L << (LEVELS - 256)) | (1L << (LIBRARY - 256)) | (1L << (LIKE2 - 256)) | (1L << (LIKE4 - 256)) | (1L << (LIKEC - 256)) | (1L << (LIKE - 256)) | (1L << (LIMIT - 256)) | (1L << (LINEAR - 256)) | (1L << (LINK - 256)) | (1L << (LIST - 256)) | (1L << (LOAD - 256)) | (1L << (LOB - 256)) | (1L << (LOBS - 256)) | (1L << (LOCAL - 256)) | (1L << (LOCATION - 256)) | (1L << (LOCATOR - 256)) | (1L << (LOCKED - 256)) | (1L << (LOCKING - 256)) | (1L << (LOCK - 256)) | (1L << (LOGGING - 256)) | (1L << (LOG - 256)) | (1L << (LOGMINING - 256)) | (1L << (LOGOFF - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (LOGON - 320)) | (1L << (LONG - 320)) | (1L << (LOOP - 320)) | (1L << (LOW - 320)) | (1L << (MAIN - 320)) | (1L << (MANAGE - 320)) | (1L << (MANAGEMENT - 320)) | (1L << (MANUAL - 320)) | (1L << (MAP - 320)) | (1L << (MAPPING - 320)) | (1L << (MATCHED - 320)) | (1L << (MATERIALIZED - 320)) | (1L << (MAXSIZE - 320)) | (1L << (MAXTRANS - 320)) | (1L << (MAXVALUE - 320)) | (1L << (MEASURE - 320)) | (1L << (MEASURES - 320)) | (1L << (MEDIUM - 320)) | (1L << (MEMBER - 320)) | (1L << (MEMCOMPRESS - 320)) | (1L << (MERGE - 320)) | (1L << (MINEXTENTS - 320)) | (1L << (NEXTVAL - 320)) | (1L << (MINIMUM - 320)) | (1L << (MINING - 320)) | (1L << (MINUS - 320)) | (1L << (MINUTE - 320)) | (1L << (MINVALUE - 320)) | (1L << (MLSLABEL - 320)) | (1L << (MODEL - 320)) | (1L << (MODE - 320)) | (1L << (MODIFICATION - 320)) | (1L << (MODIFY - 320)) | (1L << (MONTH - 320)) | (1L << (MONTHS - 320)) | (1L << (MOVEMENT - 320)) | (1L << (MULTISET - 320)) | (1L << (NAME - 320)) | (1L << (NAN - 320)) | (1L << (NATURAL - 320)) | (1L << (NATURALN - 320)) | (1L << (NAV - 320)) | (1L << (NCHAR_CS - 320)) | (1L << (NCHAR - 320)) | (1L << (NCLOB - 320)) | (1L << (NESTED - 320)) | (1L << (NEW - 320)) | (1L << (NEXT - 320)) | (1L << (NOAUDIT - 320)) | (1L << (NOCACHE - 320)) | (1L << (NOCOMPRESS - 320)) | (1L << (NOCOPY - 320)) | (1L << (NOCYCLE - 320)) | (1L << (NOEDITIONABLE - 320)) | (1L << (NOENTITYESCAPING - 320)) | (1L << (NOGUARANTEE - 320)) | (1L << (NOKEEP - 320)) | (1L << (NOLOGGING - 320)) | (1L << (NOMAPPING - 320)) | (1L << (NOMAXVALUE - 320)) | (1L << (NOMINVALUE - 320)) | (1L << (NONEDITIONABLE - 320)) | (1L << (NONE - 320)) | (1L << (NO - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (NONSCHEMA - 384)) | (1L << (NOORDER - 384)) | (1L << (NOPARALLEL - 384)) | (1L << (NORELY - 384)) | (1L << (NOROWDEPENDENCIES - 384)) | (1L << (NOSCHEMACHECK - 384)) | (1L << (NOSORT - 384)) | (1L << (NOTIFICATION - 384)) | (1L << (NOT - 384)) | (1L << (NOVALIDATE - 384)) | (1L << (NOWAIT - 384)) | (1L << (NULL - 384)) | (1L << (NULLS - 384)) | (1L << (NUMBER - 384)) | (1L << (NUMERIC - 384)) | (1L << (NVARCHAR2 - 384)) | (1L << (OBJECT - 384)) | (1L << (OFFLINE - 384)) | (1L << (OFF - 384)) | (1L << (OF - 384)) | (1L << (OID - 384)) | (1L << (OLD - 384)) | (1L << (OLTP - 384)) | (1L << (ONLINE - 384)) | (1L << (ONLY - 384)) | (1L << (ON - 384)) | (1L << (OPEN - 384)) | (1L << (OPERATOR - 384)) | (1L << (OPTIMAL - 384)) | (1L << (OPTION - 384)) | (1L << (ORADATA - 384)) | (1L << (ORDER - 384)) | (1L << (ORDINALITY - 384)) | (1L << (ORGANIZATION - 384)) | (1L << (OR - 384)) | (1L << (OSERROR - 384)) | (1L << (OUTER - 384)) | (1L << (OUTLINE - 384)) | (1L << (OUT - 384)) | (1L << (OVERFLOW - 384)) | (1L << (OVER - 384)) | (1L << (OVERRIDING - 384)) | (1L << (PACKAGE - 384)) | (1L << (PARALLEL_ENABLE - 384)) | (1L << (PARALLEL - 384)) | (1L << (PARAMETERS - 384)) | (1L << (PARENT - 384)) | (1L << (PARTIAL - 384)) | (1L << (PARTITION - 384)) | (1L << (PARTITIONS - 384)) | (1L << (PASSING - 384)) | (1L << (PASSWORD - 384)) | (1L << (PATH - 384)) | (1L << (PCTFREE - 384)) | (1L << (PCTINCREASE - 384)) | (1L << (PCTTHRESHOLD - 384)) | (1L << (PCTUSED - 384)) | (1L << (PCTVERSION - 384)) | (1L << (PERCENT_FOUND - 384)) | (1L << (PERCENT_ISOPEN - 384)) | (1L << (PERCENT_NOTFOUND - 384)) | (1L << (PERCENT_ROWCOUNT - 384)) | (1L << (PERCENT_ROWTYPE - 384)) | (1L << (PERCENT_TYPE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (PIPELINED - 448)) | (1L << (PIPE - 448)) | (1L << (PIVOT - 448)) | (1L << (PLAN - 448)) | (1L << (PLS_INTEGER - 448)) | (1L << (PLUGGABLE - 448)) | (1L << (POLICY - 448)) | (1L << (POSITIVEN - 448)) | (1L << (POSITIVE - 448)) | (1L << (PRAGMA - 448)) | (1L << (PRECEDING - 448)) | (1L << (PRECISION - 448)) | (1L << (PRESENT - 448)) | (1L << (PRESERVE - 448)) | (1L << (PRIMARY - 448)) | (1L << (PRIORITY - 448)) | (1L << (PRIOR - 448)) | (1L << (PRIVILEGE - 448)) | (1L << (PRIVILEGES - 448)) | (1L << (PROCEDURE - 448)) | (1L << (PROCESS - 448)) | (1L << (PROFILE - 448)) | (1L << (PROGRAM - 448)) | (1L << (PUBLIC - 448)) | (1L << (PURGE - 448)) | (1L << (QUERY - 448)) | (1L << (QUOTA - 448)) | (1L << (RAISE - 448)) | (1L << (RANGE - 448)) | (1L << (RAW - 448)) | (1L << (READ - 448)) | (1L << (READS - 448)) | (1L << (REAL - 448)) | (1L << (RECORD - 448)) | (1L << (RECYCLE - 448)) | (1L << (REDACTION - 448)) | (1L << (REFERENCE - 448)) | (1L << (REFERENCES - 448)) | (1L << (REFERENCING - 448)) | (1L << (REF - 448)) | (1L << (REFRESH - 448)) | (1L << (REJECT - 448)) | (1L << (RELATIONAL - 448)) | (1L << (RELIES_ON - 448)) | (1L << (RELY - 448)) | (1L << (REMOVE - 448)) | (1L << (RENAME - 448)) | (1L << (REPLACE - 448)) | (1L << (REQUIRED - 448)) | (1L << (RESOURCE - 448)) | (1L << (RESPECT - 448)) | (1L << (RESTRICTED - 448)) | (1L << (RESTRICT_REFERENCES - 448)) | (1L << (RESULT_CACHE - 448)) | (1L << (RESULT - 448)) | (1L << (RESUMABLE - 448)) | (1L << (RETENTION - 448)) | (1L << (RETURNING - 448)) | (1L << (RETURN - 448)) | (1L << (REUSE - 448)) | (1L << (REVERSE - 448)) | (1L << (REVOKE - 448)) | (1L << (REWRITE - 448)) | (1L << (RIGHT - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (ROLE - 512)) | (1L << (ROLES - 512)) | (1L << (ROLLBACK - 512)) | (1L << (ROLLUP - 512)) | (1L << (ROWDEPENDENCIES - 512)) | (1L << (ROWID - 512)) | (1L << (ROWNUM - 512)) | (1L << (ROW - 512)) | (1L << (ROWS - 512)) | (1L << (RULES - 512)) | (1L << (SALT - 512)) | (1L << (SAMPLE - 512)) | (1L << (SAVEPOINT - 512)) | (1L << (SAVE - 512)) | (1L << (SCHEDULER - 512)) | (1L << (SCHEMACHECK - 512)) | (1L << (SCHEMA - 512)) | (1L << (SCN - 512)) | (1L << (SCOPE - 512)) | (1L << (SEARCH - 512)) | (1L << (SECOND - 512)) | (1L << (SECUREFILE - 512)) | (1L << (SEED - 512)) | (1L << (SEGMENT - 512)) | (1L << (SELECT - 512)) | (1L << (SELF - 512)) | (1L << (SEQUENCE - 512)) | (1L << (SEQUENTIAL - 512)) | (1L << (SERIALIZABLE - 512)) | (1L << (SERIALLY_REUSABLE - 512)) | (1L << (SERVERERROR - 512)) | (1L << (SESSION - 512)) | (1L << (SESSIONTIMEZONE - 512)) | (1L << (SET - 512)) | (1L << (SETS - 512)) | (1L << (SETTINGS - 512)) | (1L << (SHARE - 512)) | (1L << (SHARP - 512)) | (1L << (SHOW - 512)) | (1L << (SHUTDOWN - 512)) | (1L << (SIBLINGS - 512)) | (1L << (SIGNTYPE - 512)) | (1L << (SIMPLE_INTEGER - 512)) | (1L << (SINGLE - 512)) | (1L << (SIZE - 512)) | (1L << (SKIP_ - 512)) | (1L << (SMALLFILE - 512)) | (1L << (SMALLINT - 512)) | (1L << (SNAPSHOT - 512)) | (1L << (SOME - 512)) | (1L << (SORT - 512)) | (1L << (SOURCE - 512)) | (1L << (SPACE_KEYWORD - 512)) | (1L << (SPECIFICATION - 512)) | (1L << (SQLDATA - 512)) | (1L << (SQLERROR - 512)) | (1L << (SQL - 512)) | (1L << (STANDALONE - 512)) | (1L << (START - 512)) | (1L << (STARTUP - 512)) | (1L << (STATEMENT_ID - 512)) | (1L << (STATEMENT - 512)) | (1L << (STATIC - 512)) | (1L << (STATISTICS - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (STORAGE - 576)) | (1L << (STORE - 576)) | (1L << (STRING - 576)) | (1L << (SUBMULTISET - 576)) | (1L << (SUBPARTITIONS - 576)) | (1L << (SUBPARTITION - 576)) | (1L << (SUBSTITUTABLE - 576)) | (1L << (SUBTYPE - 576)) | (1L << (SUCCESS - 576)) | (1L << (SUPPLEMENTAL - 576)) | (1L << (SUSPEND - 576)) | (1L << (SYNONYM - 576)) | (1L << (SYSBACKUP - 576)) | (1L << (SYSDATE - 576)) | (1L << (SYSDBA - 576)) | (1L << (SYSDG - 576)) | (1L << (SYSGUID - 576)) | (1L << (SYSKM - 576)) | (1L << (SYSOPER - 576)) | (1L << (SYSTEM - 576)) | (1L << (TABLESPACE - 576)) | (1L << (TABLES - 576)) | (1L << (TABLE - 576)) | (1L << (TEMPFILE - 576)) | (1L << (TEMPLATE - 576)) | (1L << (TEMPORARY - 576)) | (1L << (THAN - 576)) | (1L << (THEN - 576)) | (1L << (THE - 576)) | (1L << (THROUGH - 576)) | (1L << (TIER - 576)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 576)) | (1L << (TIMESTAMP - 576)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 576)) | (1L << (TIMESTAMP_UNCONSTRAINED - 576)) | (1L << (TIME - 576)) | (1L << (TIMEZONE_ABBR - 576)) | (1L << (TIMEZONE_HOUR - 576)) | (1L << (TIMEZONE_MINUTE - 576)) | (1L << (TIMEZONE_REGION - 576)) | (1L << (TO_NCLOB - 576)) | (1L << (TO_NUMBER - 576)) | (1L << (TO_SINGLE_BYTE - 576)) | (1L << (TO_TIMESTAMP_TZ - 576)) | (1L << (TO - 576)) | (1L << (TO_YMINTERVAL - 576)) | (1L << (TRAILING - 576)) | (1L << (TRANSACTION - 576)) | (1L << (TRANSLATE - 576)) | (1L << (TRANSLATION - 576)) | (1L << (TREAT - 576)) | (1L << (TRIGGER - 576)) | (1L << (TRUE - 576)) | (1L << (TRUNCATE - 576)) | (1L << (TRUNC - 576)) | (1L << (TUNING - 576)) | (1L << (TYPE - 576)) | (1L << (UNBOUNDED - 576)) | (1L << (UNDER - 576)) | (1L << (UNDO - 576)) | (1L << (UNIFORM - 576)) | (1L << (UNION - 576)) | (1L << (UNIQUE - 576)) | (1L << (UNLIMITED - 576)))) != 0) || ((((_la - 640)) & ~0x3f) == 0 && ((1L << (_la - 640)) & ((1L << (UNLOCK - 640)) | (1L << (UNPIVOT - 640)) | (1L << (UNTIL - 640)) | (1L << (UNUSABLE - 640)) | (1L << (UPDATED - 640)) | (1L << (UPDATE - 640)) | (1L << (UPSERT - 640)) | (1L << (UROWID - 640)) | (1L << (USABLE - 640)) | (1L << (USERS - 640)) | (1L << (USER - 640)) | (1L << (USE - 640)) | (1L << (USING - 640)) | (1L << (VALIDATE - 640)) | (1L << (VALUES - 640)) | (1L << (VALUE - 640)) | (1L << (VARCHAR2 - 640)) | (1L << (VARCHAR - 640)) | (1L << (VARIABLE - 640)) | (1L << (VARRAYS - 640)) | (1L << (VARRAY - 640)) | (1L << (VARYING - 640)) | (1L << (VERSIONS - 640)) | (1L << (VERSION - 640)) | (1L << (VIEW - 640)) | (1L << (VIRTUAL - 640)) | (1L << (VISIBLE - 640)) | (1L << (WAIT - 640)) | (1L << (WARNING - 640)) | (1L << (WELLFORMED - 640)) | (1L << (WHENEVER - 640)) | (1L << (WHEN - 640)) | (1L << (WHERE - 640)) | (1L << (WHILE - 640)) | (1L << (WITHIN - 640)) | (1L << (WITHOUT - 640)) | (1L << (WITH - 640)) | (1L << (WORK - 640)) | (1L << (WRITE - 640)) | (1L << (XMLAGG - 640)) | (1L << (XMLATTRIBUTES - 640)) | (1L << (XMLCAST - 640)) | (1L << (XMLCOLATTVAL - 640)) | (1L << (XMLELEMENT - 640)) | (1L << (XMLEXISTS - 640)) | (1L << (XMLFOREST - 640)) | (1L << (XMLNAMESPACES - 640)) | (1L << (XMLPARSE - 640)) | (1L << (XMLPI - 640)) | (1L << (XMLQUERY - 640)) | (1L << (XMLROOT - 640)) | (1L << (XMLSCHEMA - 640)) | (1L << (XMLSERIALIZE - 640)) | (1L << (XMLTABLE - 640)) | (1L << (XMLTYPE - 640)) | (1L << (XML - 640)) | (1L << (YEARS - 640)) | (1L << (YEAR - 640)) | (1L << (YES - 640)) | (1L << (YMINTERVAL_UNCONSTRAINED - 640)) | (1L << (ZONEMAP - 640)) | (1L << (ZONE - 640)) | (1L << (PREDICTION - 640)) | (1L << (PREDICTION_BOUNDS - 640)))) != 0) || ((((_la - 704)) & ~0x3f) == 0 && ((1L << (_la - 704)) & ((1L << (PREDICTION_COST - 704)) | (1L << (PREDICTION_DETAILS - 704)) | (1L << (PREDICTION_PROBABILITY - 704)) | (1L << (PREDICTION_SET - 704)) | (1L << (CUME_DIST - 704)) | (1L << (DENSE_RANK - 704)) | (1L << (LISTAGG - 704)) | (1L << (PERCENT_RANK - 704)) | (1L << (PERCENTILE_CONT - 704)) | (1L << (PERCENTILE_DISC - 704)) | (1L << (RANK - 704)) | (1L << (AVG - 704)) | (1L << (CORR - 704)) | (1L << (COVAR_ - 704)) | (1L << (DECODE - 704)) | (1L << (LAG - 704)) | (1L << (LEAD - 704)) | (1L << (MAX - 704)) | (1L << (MEDIAN - 704)) | (1L << (MIN - 704)) | (1L << (NTILE - 704)) | (1L << (NVL - 704)) | (1L << (RATIO_TO_REPORT - 704)) | (1L << (REGR_ - 704)) | (1L << (ROUND - 704)) | (1L << (ROW_NUMBER - 704)) | (1L << (SUBSTR - 704)) | (1L << (TO_CHAR - 704)) | (1L << (TRIM - 704)) | (1L << (SUM - 704)) | (1L << (STDDEV - 704)) | (1L << (VAR_ - 704)) | (1L << (VARIANCE - 704)) | (1L << (LEAST - 704)) | (1L << (GREATEST - 704)) | (1L << (TO_DATE - 704)) | (1L << (VARIABLE_SESSION - 704)) | (1L << (NATIONAL_CHAR_STRING_LIT - 704)) | (1L << (BIT_STRING_LIT - 704)) | (1L << (HEX_STRING_LIT - 704)) | (1L << (DOUBLE_PERIOD - 704)) | (1L << (PERIOD - 704)) | (1L << (UNSIGNED_INTEGER - 704)) | (1L << (APPROXIMATE_NUM_LIT - 704)) | (1L << (CHAR_STRING - 704)) | (1L << (DELIMITED_ID - 704)) | (1L << (PERCENT - 704)) | (1L << (AMPERSAND - 704)) | (1L << (LEFT_PAREN - 704)) | (1L << (RIGHT_PAREN - 704)) | (1L << (DOUBLE_ASTERISK - 704)) | (1L << (ASTERISK - 704)) | (1L << (PLUS_SIGN - 704)) | (1L << (MINUS_SIGN - 704)) | (1L << (COMMA - 704)) | (1L << (SOLIDUS - 704)) | (1L << (AT_SIGN - 704)) | (1L << (ASSIGN_OP - 704)) | (1L << (BINDVAR - 704)) | (1L << (NOT_EQUAL_OP - 704)) | (1L << (CARRET_OPERATOR_PART - 704)) | (1L << (TILDE_OPERATOR_PART - 704)) | (1L << (EXCLAMATION_OPERATOR_PART - 704)) | (1L << (GREATER_THAN_OP - 704)))) != 0) || ((((_la - 768)) & ~0x3f) == 0 && ((1L << (_la - 768)) & ((1L << (LESS_THAN_OP - 768)) | (1L << (COLON - 768)) | (1L << (BAR - 768)) | (1L << (EQUALS_OP - 768)) | (1L << (LEFT_BRACKET - 768)) | (1L << (RIGHT_BRACKET - 768)) | (1L << (BIND_VAR - 768)) | (1L << (INTRODUCER - 768)) | (1L << (SPACES - 768)) | (1L << (SINGLE_LINE_COMMENT - 768)) | (1L << (MULTI_LINE_COMMENT - 768)) | (1L << (PROMPT - 768)) | (1L << (START_CMD - 768)) | (1L << (REGULAR_ID - 768)) | (1L << (ZV - 768)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assignment_statementContext : ParserRuleContext {
		public ITerminalNode ASSIGN_OP() { return GetToken(PlSqlParser.ASSIGN_OP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Assignment_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assignment_statementContext assignment_statement() {
		Assignment_statementContext _localctx = new Assignment_statementContext(Context, State);
		EnterRule(_localctx, 626, RULE_assignment_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5476;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 5474; general_element();
				}
				break;
			case BINDVAR:
			case COLON:
				{
				State = 5475; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5478; Match(ASSIGN_OP);
			State = 5479; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Continue_statementContext : ParserRuleContext {
		public ITerminalNode CONTINUE() { return GetToken(PlSqlParser.CONTINUE, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Continue_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continue_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinue_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Continue_statementContext continue_statement() {
		Continue_statementContext _localctx = new Continue_statementContext(Context, State);
		EnterRule(_localctx, 628, RULE_continue_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5481; Match(CONTINUE);
			State = 5483;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 5482; label_name();
				}
			}

			State = 5487;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 5485; Match(WHEN);
				State = 5486; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exit_statementContext : ParserRuleContext {
		public ITerminalNode EXIT() { return GetToken(PlSqlParser.EXIT, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Exit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exit_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exit_statementContext exit_statement() {
		Exit_statementContext _localctx = new Exit_statementContext(Context, State);
		EnterRule(_localctx, 630, RULE_exit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5489; Match(EXIT);
			State = 5491;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 5490; label_name();
				}
			}

			State = 5495;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHEN) {
				{
				State = 5493; Match(WHEN);
				State = 5494; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Goto_statementContext : ParserRuleContext {
		public ITerminalNode GOTO() { return GetToken(PlSqlParser.GOTO, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Goto_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_goto_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGoto_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Goto_statementContext goto_statement() {
		Goto_statementContext _localctx = new Goto_statementContext(Context, State);
		EnterRule(_localctx, 632, RULE_goto_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5497; Match(GOTO);
			State = 5498; label_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_statementContext : ParserRuleContext {
		public ITerminalNode[] IF() { return GetTokens(PlSqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(PlSqlParser.IF, i);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Elsif_partContext[] elsif_part() {
			return GetRuleContexts<Elsif_partContext>();
		}
		public Elsif_partContext elsif_part(int i) {
			return GetRuleContext<Elsif_partContext>(i);
		}
		public Else_partContext else_part() {
			return GetRuleContext<Else_partContext>(0);
		}
		public If_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_statementContext if_statement() {
		If_statementContext _localctx = new If_statementContext(Context, State);
		EnterRule(_localctx, 634, RULE_if_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5500; Match(IF);
			State = 5501; condition();
			State = 5502; Match(THEN);
			State = 5503; seq_of_statements();
			State = 5507;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ELSIF) {
				{
				{
				State = 5504; elsif_part();
				}
				}
				State = 5509;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5511;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 5510; else_part();
				}
			}

			State = 5513; Match(END);
			State = 5514; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Elsif_partContext : ParserRuleContext {
		public ITerminalNode ELSIF() { return GetToken(PlSqlParser.ELSIF, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Elsif_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsif_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsif_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Elsif_partContext elsif_part() {
		Elsif_partContext _localctx = new Elsif_partContext(Context, State);
		EnterRule(_localctx, 636, RULE_elsif_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5516; Match(ELSIF);
			State = 5517; condition();
			State = 5518; Match(THEN);
			State = 5519; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElse_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Else_partContext else_part() {
		Else_partContext _localctx = new Else_partContext(Context, State);
		EnterRule(_localctx, 638, RULE_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5521; Match(ELSE);
			State = 5522; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_statementContext : ParserRuleContext {
		public ITerminalNode[] LOOP() { return GetTokens(PlSqlParser.LOOP); }
		public ITerminalNode LOOP(int i) {
			return GetToken(PlSqlParser.LOOP, i);
		}
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Label_declarationContext label_declaration() {
			return GetRuleContext<Label_declarationContext>(0);
		}
		public ITerminalNode WHILE() { return GetToken(PlSqlParser.WHILE, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Cursor_loop_paramContext cursor_loop_param() {
			return GetRuleContext<Cursor_loop_paramContext>(0);
		}
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Loop_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_statementContext loop_statement() {
		Loop_statementContext _localctx = new Loop_statementContext(Context, State);
		EnterRule(_localctx, 640, RULE_loop_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5525;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESS_THAN_OP) {
				{
				State = 5524; label_declaration();
				}
			}

			State = 5531;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WHILE:
				{
				State = 5527; Match(WHILE);
				State = 5528; condition();
				}
				break;
			case FOR:
				{
				State = 5529; Match(FOR);
				State = 5530; cursor_loop_param();
				}
				break;
			case LOOP:
				break;
			default:
				break;
			}
			State = 5533; Match(LOOP);
			State = 5534; seq_of_statements();
			State = 5535; Match(END);
			State = 5536; Match(LOOP);
			State = 5538;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 5537; label_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_loop_paramContext : ParserRuleContext {
		public IToken range_separator;
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode REVERSE() { return GetToken(PlSqlParser.REVERSE, 0); }
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Cursor_loop_paramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_loop_param; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_loop_param(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_loop_paramContext cursor_loop_param() {
		Cursor_loop_paramContext _localctx = new Cursor_loop_paramContext(Context, State);
		EnterRule(_localctx, 642, RULE_cursor_loop_param);
		int _la;
		try {
			State = 5565;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,718,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5540; index_name();
				State = 5541; Match(IN);
				State = 5543;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,714,Context) ) {
				case 1:
					{
					State = 5542; Match(REVERSE);
					}
					break;
				}
				State = 5545; lower_bound();
				State = 5546; _localctx.range_separator = Match(DOUBLE_PERIOD);
				State = 5547; upper_bound();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5549; record_name();
				State = 5550; Match(IN);
				State = 5563;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 5551; cursor_name();
					State = 5557;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==LEFT_PAREN) {
						{
						State = 5552; Match(LEFT_PAREN);
						State = 5554;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
							{
							State = 5553; expressions();
							}
						}

						State = 5556; Match(RIGHT_PAREN);
						}
					}

					}
					break;
				case LEFT_PAREN:
					{
					State = 5559; Match(LEFT_PAREN);
					State = 5560; select_statement();
					State = 5561; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Forall_statementContext : ParserRuleContext {
		public ITerminalNode FORALL() { return GetToken(PlSqlParser.FORALL, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Bounds_clauseContext bounds_clause() {
			return GetRuleContext<Bounds_clauseContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public ITerminalNode SAVE() { return GetToken(PlSqlParser.SAVE, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public Forall_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forall_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForall_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Forall_statementContext forall_statement() {
		Forall_statementContext _localctx = new Forall_statementContext(Context, State);
		EnterRule(_localctx, 644, RULE_forall_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5567; Match(FORALL);
			State = 5568; index_name();
			State = 5569; Match(IN);
			State = 5570; bounds_clause();
			State = 5571; sql_statement();
			State = 5574;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SAVE) {
				{
				State = 5572; Match(SAVE);
				State = 5573; Match(EXCEPTIONS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bounds_clauseContext : ParserRuleContext {
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode INDICES() { return GetToken(PlSqlParser.INDICES, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public Between_boundContext between_bound() {
			return GetRuleContext<Between_boundContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public Bounds_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bounds_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBounds_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bounds_clauseContext bounds_clause() {
		Bounds_clauseContext _localctx = new Bounds_clauseContext(Context, State);
		EnterRule(_localctx, 646, RULE_bounds_clause);
		int _la;
		try {
			State = 5589;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,721,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5576; lower_bound();
				State = 5577; Match(DOUBLE_PERIOD);
				State = 5578; upper_bound();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5580; Match(INDICES);
				State = 5581; Match(OF);
				State = 5582; collection_name();
				State = 5584;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BETWEEN) {
					{
					State = 5583; between_bound();
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5586; Match(VALUES);
				State = 5587; Match(OF);
				State = 5588; index_name();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_boundContext : ParserRuleContext {
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public Between_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_bound; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetween_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Between_boundContext between_bound() {
		Between_boundContext _localctx = new Between_boundContext(Context, State);
		EnterRule(_localctx, 648, RULE_between_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5591; Match(BETWEEN);
			State = 5592; lower_bound();
			State = 5593; Match(AND);
			State = 5594; upper_bound();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lower_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Lower_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lower_bound; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLower_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lower_boundContext lower_bound() {
		Lower_boundContext _localctx = new Lower_boundContext(Context, State);
		EnterRule(_localctx, 650, RULE_lower_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5596; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Upper_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Upper_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_upper_bound; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpper_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Upper_boundContext upper_bound() {
		Upper_boundContext _localctx = new Upper_boundContext(Context, State);
		EnterRule(_localctx, 652, RULE_upper_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5598; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Null_statementContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Null_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_null_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNull_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Null_statementContext null_statement() {
		Null_statementContext _localctx = new Null_statementContext(Context, State);
		EnterRule(_localctx, 654, RULE_null_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5600; Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Raise_statementContext : ParserRuleContext {
		public ITerminalNode RAISE() { return GetToken(PlSqlParser.RAISE, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public Raise_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raise_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRaise_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Raise_statementContext raise_statement() {
		Raise_statementContext _localctx = new Raise_statementContext(Context, State);
		EnterRule(_localctx, 656, RULE_raise_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5602; Match(RAISE);
			State = 5604;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 5603; exception_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_statementContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Return_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_statementContext return_statement() {
		Return_statementContext _localctx = new Return_statementContext(Context, State);
		EnterRule(_localctx, 658, RULE_return_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5606; Match(RETURN);
			State = 5608;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 5607; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_callContext : ParserRuleContext {
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public ITerminalNode CALL() { return GetToken(PlSqlParser.CALL, 0); }
		public Function_argumentsContext function_arguments() {
			return GetRuleContext<Function_argumentsContext>(0);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_call; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_callContext function_call() {
		Function_callContext _localctx = new Function_callContext(Context, State);
		EnterRule(_localctx, 660, RULE_function_call);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5611;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,724,Context) ) {
			case 1:
				{
				State = 5610; Match(CALL);
				}
				break;
			}
			State = 5613; routine_name();
			State = 5615;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,725,Context) ) {
			case 1:
				{
				State = 5614; function_arguments();
				}
				break;
			}
			State = 5618;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,726,Context) ) {
			case 1:
				{
				State = 5617; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pipe_row_statementContext : ParserRuleContext {
		public ITerminalNode PIPE() { return GetToken(PlSqlParser.PIPE, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Pipe_row_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipe_row_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPipe_row_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pipe_row_statementContext pipe_row_statement() {
		Pipe_row_statementContext _localctx = new Pipe_row_statementContext(Context, State);
		EnterRule(_localctx, 662, RULE_pipe_row_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5620; Match(PIPE);
			State = 5621; Match(ROW);
			State = 5622; Match(LEFT_PAREN);
			State = 5623; expression();
			State = 5624; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BodyContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(PlSqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Exception_handlerContext[] exception_handler() {
			return GetRuleContexts<Exception_handlerContext>();
		}
		public Exception_handlerContext exception_handler(int i) {
			return GetRuleContext<Exception_handlerContext>(i);
		}
		public BodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BodyContext body() {
		BodyContext _localctx = new BodyContext(Context, State);
		EnterRule(_localctx, 664, RULE_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5626; Match(BEGIN);
			State = 5627; seq_of_statements();
			State = 5634;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCEPTION) {
				{
				State = 5628; Match(EXCEPTION);
				State = 5630;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5629; exception_handler();
					}
					}
					State = 5632;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				}
			}

			State = 5636; Match(END);
			State = 5638;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,729,Context) ) {
			case 1:
				{
				State = 5637; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_handlerContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public Exception_nameContext[] exception_name() {
			return GetRuleContexts<Exception_nameContext>();
		}
		public Exception_nameContext exception_name(int i) {
			return GetRuleContext<Exception_nameContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public Exception_handlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_handler; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_handler(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_handlerContext exception_handler() {
		Exception_handlerContext _localctx = new Exception_handlerContext(Context, State);
		EnterRule(_localctx, 666, RULE_exception_handler);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5640; Match(WHEN);
			State = 5641; exception_name();
			State = 5646;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 5642; Match(OR);
				State = 5643; exception_name();
				}
				}
				State = 5648;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5649; Match(THEN);
			State = 5650; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_blockContext : ParserRuleContext {
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_blockContext trigger_block() {
		Trigger_blockContext _localctx = new Trigger_blockContext(Context, State);
		EnterRule(_localctx, 668, RULE_trigger_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5660;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECLARE - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 5653;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DECLARE) {
					{
					State = 5652; Match(DECLARE);
					}
				}

				State = 5656;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5655; declare_spec();
					}
					}
					State = 5658;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				}
			}

			State = 5662; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 670, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5665;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DECLARE) {
				{
				State = 5664; Match(DECLARE);
				}
			}

			State = 5668;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5667; declare_spec();
				}
				}
				State = 5670;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROCEDURE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 5672; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_statementContext : ParserRuleContext {
		public Execute_immediateContext execute_immediate() {
			return GetRuleContext<Execute_immediateContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
			return GetRuleContext<Cursor_manipulation_statementsContext>(0);
		}
		public Transaction_control_statementsContext transaction_control_statements() {
			return GetRuleContext<Transaction_control_statementsContext>(0);
		}
		public Sql_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_statementContext sql_statement() {
		Sql_statementContext _localctx = new Sql_statementContext(Context, State);
		EnterRule(_localctx, 672, RULE_sql_statement);
		try {
			State = 5678;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXECUTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5674; execute_immediate();
				}
				break;
			case DELETE:
			case INSERT:
			case LOCK:
			case MERGE:
			case SELECT:
			case UPDATE:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5675; data_manipulation_language_statements();
				}
				break;
			case CLOSE:
			case FETCH:
			case OPEN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5676; cursor_manipulation_statements();
				}
				break;
			case COMMIT:
			case ROLLBACK:
			case SAVEPOINT:
			case SET:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5677; transaction_control_statements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Execute_immediateContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Dynamic_returning_clauseContext dynamic_returning_clause() {
			return GetRuleContext<Dynamic_returning_clauseContext>(0);
		}
		public Execute_immediateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_execute_immediate; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecute_immediate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Execute_immediateContext execute_immediate() {
		Execute_immediateContext _localctx = new Execute_immediateContext(Context, State);
		EnterRule(_localctx, 674, RULE_execute_immediate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5680; Match(EXECUTE);
			State = 5681; Match(IMMEDIATE);
			State = 5682; expression();
			State = 5692;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BULK:
			case INTO:
				{
				State = 5683; into_clause();
				State = 5685;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 5684; using_clause();
					}
				}

				}
				break;
			case USING:
				{
				State = 5687; using_clause();
				State = 5689;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RETURNING || _la==RETURN) {
					{
					State = 5688; dynamic_returning_clause();
					}
				}

				}
				break;
			case RETURNING:
			case RETURN:
				{
				State = 5691; dynamic_returning_clause();
				}
				break;
			case Eof:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dynamic_returning_clauseContext : ParserRuleContext {
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Dynamic_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamic_returning_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamic_returning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dynamic_returning_clauseContext dynamic_returning_clause() {
		Dynamic_returning_clauseContext _localctx = new Dynamic_returning_clauseContext(Context, State);
		EnterRule(_localctx, 676, RULE_dynamic_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5694;
			_la = TokenStream.LA(1);
			if ( !(_la==RETURNING || _la==RETURN) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5695; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_manipulation_language_statementsContext : ParserRuleContext {
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public Lock_table_statementContext lock_table_statement() {
			return GetRuleContext<Lock_table_statementContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Data_manipulation_language_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_manipulation_language_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitData_manipulation_language_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
		Data_manipulation_language_statementsContext _localctx = new Data_manipulation_language_statementsContext(Context, State);
		EnterRule(_localctx, 678, RULE_data_manipulation_language_statements);
		try {
			State = 5703;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MERGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5697; merge_statement();
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5698; lock_table_statement();
				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5699; select_statement();
				}
				break;
			case UPDATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5700; update_statement();
				}
				break;
			case DELETE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5701; delete_statement();
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5702; insert_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_manipulation_statementsContext : ParserRuleContext {
		public Close_statementContext close_statement() {
			return GetRuleContext<Close_statementContext>(0);
		}
		public Open_statementContext open_statement() {
			return GetRuleContext<Open_statementContext>(0);
		}
		public Fetch_statementContext fetch_statement() {
			return GetRuleContext<Fetch_statementContext>(0);
		}
		public Open_for_statementContext open_for_statement() {
			return GetRuleContext<Open_for_statementContext>(0);
		}
		public Cursor_manipulation_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_manipulation_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_manipulation_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
		Cursor_manipulation_statementsContext _localctx = new Cursor_manipulation_statementsContext(Context, State);
		EnterRule(_localctx, 680, RULE_cursor_manipulation_statements);
		try {
			State = 5709;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,741,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5705; close_statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5706; open_statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5707; fetch_statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5708; open_for_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Close_statementContext : ParserRuleContext {
		public ITerminalNode CLOSE() { return GetToken(PlSqlParser.CLOSE, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Close_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_close_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClose_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Close_statementContext close_statement() {
		Close_statementContext _localctx = new Close_statementContext(Context, State);
		EnterRule(_localctx, 682, RULE_close_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5711; Match(CLOSE);
			State = 5712; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(PlSqlParser.OPEN, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Open_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpen_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Open_statementContext open_statement() {
		Open_statementContext _localctx = new Open_statementContext(Context, State);
		EnterRule(_localctx, 684, RULE_open_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5714; Match(OPEN);
			State = 5715; cursor_name();
			State = 5721;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 5716; Match(LEFT_PAREN);
				State = 5718;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 5717; expressions();
					}
				}

				State = 5720; Match(RIGHT_PAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Fetch_statementContext : ParserRuleContext {
		public IToken it1;
		public ITerminalNode FETCH() { return GetToken(PlSqlParser.FETCH, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode BULK() { return GetToken(PlSqlParser.BULK, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Variable_nameContext[] variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Fetch_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetch_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFetch_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Fetch_statementContext fetch_statement() {
		Fetch_statementContext _localctx = new Fetch_statementContext(Context, State);
		EnterRule(_localctx, 686, RULE_fetch_statement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5723; Match(FETCH);
			State = 5724; cursor_name();
			State = 5745;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 5725; _localctx.it1 = Match(INTO);
				State = 5730;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 5727;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 5726; Match(COMMA);
							}
						}

						State = 5729; variable_name();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5732;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,745,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case BULK:
				{
				State = 5734; Match(BULK);
				State = 5735; Match(COLLECT);
				State = 5736; Match(INTO);
				State = 5741;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 5738;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 5737; Match(COMMA);
							}
						}

						State = 5740; variable_name();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5743;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,747,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_for_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(PlSqlParser.OPEN, 0); }
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Open_for_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_for_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpen_for_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Open_for_statementContext open_for_statement() {
		Open_for_statementContext _localctx = new Open_for_statementContext(Context, State);
		EnterRule(_localctx, 688, RULE_open_for_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5747; Match(OPEN);
			State = 5748; variable_name();
			State = 5749; Match(FOR);
			State = 5752;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,749,Context) ) {
			case 1:
				{
				State = 5750; select_statement();
				}
				break;
			case 2:
				{
				State = 5751; expression();
				}
				break;
			}
			State = 5755;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 5754; using_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Transaction_control_statementsContext : ParserRuleContext {
		public Set_transaction_commandContext set_transaction_command() {
			return GetRuleContext<Set_transaction_commandContext>(0);
		}
		public Set_constraint_commandContext set_constraint_command() {
			return GetRuleContext<Set_constraint_commandContext>(0);
		}
		public Commit_statementContext commit_statement() {
			return GetRuleContext<Commit_statementContext>(0);
		}
		public Rollback_statementContext rollback_statement() {
			return GetRuleContext<Rollback_statementContext>(0);
		}
		public Savepoint_statementContext savepoint_statement() {
			return GetRuleContext<Savepoint_statementContext>(0);
		}
		public Transaction_control_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transaction_control_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransaction_control_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Transaction_control_statementsContext transaction_control_statements() {
		Transaction_control_statementsContext _localctx = new Transaction_control_statementsContext(Context, State);
		EnterRule(_localctx, 690, RULE_transaction_control_statements);
		try {
			State = 5762;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,751,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5757; set_transaction_command();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5758; set_constraint_command();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5759; commit_statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5760; rollback_statement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5761; savepoint_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_transaction_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlSqlParser.TRANSACTION, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode ISOLATION() { return GetToken(PlSqlParser.ISOLATION, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlSqlParser.LEVEL, 0); }
		public ITerminalNode USE() { return GetToken(PlSqlParser.USE, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public Rollback_segment_nameContext rollback_segment_name() {
			return GetRuleContext<Rollback_segment_nameContext>(0);
		}
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(PlSqlParser.SERIALIZABLE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(PlSqlParser.COMMITTED, 0); }
		public Set_transaction_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_transaction_command; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_transaction_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_transaction_commandContext set_transaction_command() {
		Set_transaction_commandContext _localctx = new Set_transaction_commandContext(Context, State);
		EnterRule(_localctx, 692, RULE_set_transaction_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5764; Match(SET);
			State = 5765; Match(TRANSACTION);
			State = 5779;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,753,Context) ) {
			case 1:
				{
				State = 5766; Match(READ);
				State = 5767;
				_la = TokenStream.LA(1);
				if ( !(_la==ONLY || _la==WRITE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				{
				State = 5768; Match(ISOLATION);
				State = 5769; Match(LEVEL);
				State = 5773;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case SERIALIZABLE:
					{
					State = 5770; Match(SERIALIZABLE);
					}
					break;
				case READ:
					{
					State = 5771; Match(READ);
					State = 5772; Match(COMMITTED);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				{
				State = 5775; Match(USE);
				State = 5776; Match(ROLLBACK);
				State = 5777; Match(SEGMENT);
				State = 5778; rollback_segment_name();
				}
				break;
			}
			State = 5783;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,754,Context) ) {
			case 1:
				{
				State = 5781; Match(NAME);
				State = 5782; @string();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_constraint_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(PlSqlParser.CONSTRAINTS, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode DEFERRED() { return GetToken(PlSqlParser.DEFERRED, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Constraint_nameContext[] constraint_name() {
			return GetRuleContexts<Constraint_nameContext>();
		}
		public Constraint_nameContext constraint_name(int i) {
			return GetRuleContext<Constraint_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Set_constraint_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_constraint_command; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_constraint_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_constraint_commandContext set_constraint_command() {
		Set_constraint_commandContext _localctx = new Set_constraint_commandContext(Context, State);
		EnterRule(_localctx, 694, RULE_set_constraint_command);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5785; Match(SET);
			State = 5786;
			_la = TokenStream.LA(1);
			if ( !(_la==CONSTRAINT || _la==CONSTRAINTS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5796;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				{
				State = 5787; Match(ALL);
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case COMMA:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 5792;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 5789;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 5788; Match(COMMA);
							}
						}

						State = 5791; constraint_name();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5794;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,756,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5798;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Commit_statementContext : ParserRuleContext {
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode WORK() { return GetToken(PlSqlParser.WORK, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Write_clauseContext write_clause() {
			return GetRuleContext<Write_clauseContext>(0);
		}
		public ITerminalNode CORRUPT_XID() { return GetToken(PlSqlParser.CORRUPT_XID, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(PlSqlParser.CORRUPT_XID_ALL, 0); }
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Commit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commit_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Commit_statementContext commit_statement() {
		Commit_statementContext _localctx = new Commit_statementContext(Context, State);
		EnterRule(_localctx, 696, RULE_commit_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5800; Match(COMMIT);
			State = 5802;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,758,Context) ) {
			case 1:
				{
				State = 5801; Match(WORK);
				}
				break;
			}
			State = 5817;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,761,Context) ) {
			case 1:
				{
				State = 5804; Match(COMMENT);
				State = 5805; expression();
				}
				break;
			case 2:
				{
				State = 5806; Match(FORCE);
				State = 5815;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,760,Context) ) {
				case 1:
					{
					State = 5807; Match(CORRUPT_XID);
					State = 5808; expression();
					}
					break;
				case 2:
					{
					State = 5809; Match(CORRUPT_XID_ALL);
					}
					break;
				case 3:
					{
					State = 5810; expression();
					State = 5813;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,759,Context) ) {
					case 1:
						{
						State = 5811; Match(COMMA);
						State = 5812; expression();
						}
						break;
					}
					}
					break;
				}
				}
				break;
			}
			State = 5820;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,762,Context) ) {
			case 1:
				{
				State = 5819; write_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Write_clauseContext : ParserRuleContext {
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode BATCH() { return GetToken(PlSqlParser.BATCH, 0); }
		public Write_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_write_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWrite_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Write_clauseContext write_clause() {
		Write_clauseContext _localctx = new Write_clauseContext(Context, State);
		EnterRule(_localctx, 698, RULE_write_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5822; Match(WRITE);
			State = 5824;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,763,Context) ) {
			case 1:
				{
				State = 5823;
				_la = TokenStream.LA(1);
				if ( !(_la==NOWAIT || _la==WAIT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 5827;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,764,Context) ) {
			case 1:
				{
				State = 5826;
				_la = TokenStream.LA(1);
				if ( !(_la==BATCH || _la==IMMEDIATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_statementContext : ParserRuleContext {
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode WORK() { return GetToken(PlSqlParser.WORK, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public ITerminalNode SAVEPOINT() { return GetToken(PlSqlParser.SAVEPOINT, 0); }
		public Rollback_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollback_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_statementContext rollback_statement() {
		Rollback_statementContext _localctx = new Rollback_statementContext(Context, State);
		EnterRule(_localctx, 700, RULE_rollback_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5829; Match(ROLLBACK);
			State = 5831;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,765,Context) ) {
			case 1:
				{
				State = 5830; Match(WORK);
				}
				break;
			}
			State = 5840;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,767,Context) ) {
			case 1:
				{
				State = 5833; Match(TO);
				State = 5835;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,766,Context) ) {
				case 1:
					{
					State = 5834; Match(SAVEPOINT);
					}
					break;
				}
				State = 5837; savepoint_name();
				}
				break;
			case 2:
				{
				State = 5838; Match(FORCE);
				State = 5839; @string();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_statementContext : ParserRuleContext {
		public ITerminalNode SAVEPOINT() { return GetToken(PlSqlParser.SAVEPOINT, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public Savepoint_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepoint_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_statementContext savepoint_statement() {
		Savepoint_statementContext _localctx = new Savepoint_statementContext(Context, State);
		EnterRule(_localctx, 702, RULE_savepoint_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5842; Match(SAVEPOINT);
			State = 5843; savepoint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_statementContext : ParserRuleContext {
		public ITerminalNode EXPLAIN() { return GetToken(PlSqlParser.EXPLAIN, 0); }
		public ITerminalNode PLAN() { return GetToken(PlSqlParser.PLAN, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(PlSqlParser.STATEMENT_ID, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Explain_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplain_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Explain_statementContext explain_statement() {
		Explain_statementContext _localctx = new Explain_statementContext(Context, State);
		EnterRule(_localctx, 704, RULE_explain_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5845; Match(EXPLAIN);
			State = 5846; Match(PLAN);
			State = 5851;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SET) {
				{
				State = 5847; Match(SET);
				State = 5848; Match(STATEMENT_ID);
				State = 5849; Match(EQUALS_OP);
				State = 5850; @string();
				}
			}

			State = 5855;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 5853; Match(INTO);
				State = 5854; tableview_name();
				}
			}

			State = 5857; Match(FOR);
			State = 5863;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 5858; select_statement();
				}
				break;
			case UPDATE:
				{
				State = 5859; update_statement();
				}
				break;
			case DELETE:
				{
				State = 5860; delete_statement();
				}
				break;
			case INSERT:
				{
				State = 5861; insert_statement();
				}
				break;
			case MERGE:
				{
				State = 5862; merge_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_statementContext : ParserRuleContext {
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Subquery_factoring_clauseContext subquery_factoring_clause() {
			return GetRuleContext<Subquery_factoring_clauseContext>(0);
		}
		public For_update_clauseContext[] for_update_clause() {
			return GetRuleContexts<For_update_clauseContext>();
		}
		public For_update_clauseContext for_update_clause(int i) {
			return GetRuleContext<For_update_clauseContext>(i);
		}
		public Order_by_clauseContext[] order_by_clause() {
			return GetRuleContexts<Order_by_clauseContext>();
		}
		public Order_by_clauseContext order_by_clause(int i) {
			return GetRuleContext<Order_by_clauseContext>(i);
		}
		public Select_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_statementContext select_statement() {
		Select_statementContext _localctx = new Select_statementContext(Context, State);
		EnterRule(_localctx, 706, RULE_select_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5866;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 5865; subquery_factoring_clause();
				}
			}

			State = 5868; subquery();
			State = 5873;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FOR || _la==ORDER) {
				{
				State = 5871;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FOR:
					{
					State = 5869; for_update_clause();
					}
					break;
				case ORDER:
					{
					State = 5870; order_by_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 5875;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_factoring_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public Factoring_elementContext[] factoring_element() {
			return GetRuleContexts<Factoring_elementContext>();
		}
		public Factoring_elementContext factoring_element(int i) {
			return GetRuleContext<Factoring_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Subquery_factoring_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_factoring_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_factoring_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_factoring_clauseContext subquery_factoring_clause() {
		Subquery_factoring_clauseContext _localctx = new Subquery_factoring_clauseContext(Context, State);
		EnterRule(_localctx, 708, RULE_subquery_factoring_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5876; Match(WITH);
			State = 5881;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5878;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 5877; Match(COMMA);
					}
				}

				State = 5880; factoring_element();
				}
				}
				State = 5883;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Factoring_elementContext : ParserRuleContext {
		public Query_nameContext query_name() {
			return GetRuleContext<Query_nameContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Search_clauseContext search_clause() {
			return GetRuleContext<Search_clauseContext>(0);
		}
		public Cycle_clauseContext cycle_clause() {
			return GetRuleContext<Cycle_clauseContext>(0);
		}
		public Factoring_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factoring_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFactoring_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Factoring_elementContext factoring_element() {
		Factoring_elementContext _localctx = new Factoring_elementContext(Context, State);
		EnterRule(_localctx, 710, RULE_factoring_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5885; query_name();
			State = 5887;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 5886; paren_column_list();
				}
			}

			State = 5889; Match(AS);
			State = 5890; Match(LEFT_PAREN);
			State = 5891; subquery();
			State = 5893;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 5892; order_by_clause();
				}
			}

			State = 5895; Match(RIGHT_PAREN);
			State = 5897;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEARCH) {
				{
				State = 5896; search_clause();
				}
			}

			State = 5900;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,779,Context) ) {
			case 1:
				{
				State = 5899; cycle_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Search_clauseContext : ParserRuleContext {
		public ITerminalNode SEARCH() { return GetToken(PlSqlParser.SEARCH, 0); }
		public ITerminalNode[] FIRST() { return GetTokens(PlSqlParser.FIRST); }
		public ITerminalNode FIRST(int i) {
			return GetToken(PlSqlParser.FIRST, i);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode DEPTH() { return GetToken(PlSqlParser.DEPTH, 0); }
		public ITerminalNode BREADTH() { return GetToken(PlSqlParser.BREADTH, 0); }
		public ITerminalNode[] ASC() { return GetTokens(PlSqlParser.ASC); }
		public ITerminalNode ASC(int i) {
			return GetToken(PlSqlParser.ASC, i);
		}
		public ITerminalNode[] DESC() { return GetTokens(PlSqlParser.DESC); }
		public ITerminalNode DESC(int i) {
			return GetToken(PlSqlParser.DESC, i);
		}
		public ITerminalNode[] NULLS() { return GetTokens(PlSqlParser.NULLS); }
		public ITerminalNode NULLS(int i) {
			return GetToken(PlSqlParser.NULLS, i);
		}
		public ITerminalNode[] LAST() { return GetTokens(PlSqlParser.LAST); }
		public ITerminalNode LAST(int i) {
			return GetToken(PlSqlParser.LAST, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Search_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_search_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearch_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Search_clauseContext search_clause() {
		Search_clauseContext _localctx = new Search_clauseContext(Context, State);
		EnterRule(_localctx, 712, RULE_search_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5902; Match(SEARCH);
			State = 5903;
			_la = TokenStream.LA(1);
			if ( !(_la==BREADTH || _la==DEPTH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5904; Match(FIRST);
			State = 5905; Match(BY);
			State = 5906; column_name();
			State = 5908;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC) {
				{
				State = 5907; Match(ASC);
				}
			}

			State = 5911;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DESC) {
				{
				State = 5910; Match(DESC);
				}
			}

			State = 5915;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,782,Context) ) {
			case 1:
				{
				State = 5913; Match(NULLS);
				State = 5914; Match(FIRST);
				}
				break;
			}
			State = 5919;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NULLS) {
				{
				State = 5917; Match(NULLS);
				State = 5918; Match(LAST);
				}
			}

			State = 5939;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5921; Match(COMMA);
				State = 5922; column_name();
				State = 5924;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ASC) {
					{
					State = 5923; Match(ASC);
					}
				}

				State = 5927;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DESC) {
					{
					State = 5926; Match(DESC);
					}
				}

				State = 5931;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,786,Context) ) {
				case 1:
					{
					State = 5929; Match(NULLS);
					State = 5930; Match(FIRST);
					}
					break;
				}
				State = 5935;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NULLS) {
					{
					State = 5933; Match(NULLS);
					State = 5934; Match(LAST);
					}
				}

				}
				}
				State = 5941;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5942; Match(SET);
			State = 5943; column_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cycle_clauseContext : ParserRuleContext {
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public Column_listContext column_list() {
			return GetRuleContext<Column_listContext>(0);
		}
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Cycle_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cycle_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCycle_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cycle_clauseContext cycle_clause() {
		Cycle_clauseContext _localctx = new Cycle_clauseContext(Context, State);
		EnterRule(_localctx, 714, RULE_cycle_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5945; Match(CYCLE);
			State = 5946; column_list();
			State = 5947; Match(SET);
			State = 5948; column_name();
			State = 5949; Match(TO);
			State = 5950; expression();
			State = 5951; Match(DEFAULT);
			State = 5952; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_basic_elementsContext : ParserRuleContext {
		public Query_blockContext query_block() {
			return GetRuleContext<Query_blockContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Subquery_basic_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_basic_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_basic_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_basic_elementsContext subquery_basic_elements() {
		Subquery_basic_elementsContext _localctx = new Subquery_basic_elementsContext(Context, State);
		EnterRule(_localctx, 716, RULE_subquery_basic_elements);
		try {
			State = 5959;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5954; query_block();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5955; Match(LEFT_PAREN);
				State = 5956; subquery();
				State = 5957; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_operation_partContext : ParserRuleContext {
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public ITerminalNode UNION() { return GetToken(PlSqlParser.UNION, 0); }
		public ITerminalNode INTERSECT() { return GetToken(PlSqlParser.INTERSECT, 0); }
		public ITerminalNode MINUS() { return GetToken(PlSqlParser.MINUS, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Subquery_operation_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_operation_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_operation_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_operation_partContext subquery_operation_part() {
		Subquery_operation_partContext _localctx = new Subquery_operation_partContext(Context, State);
		EnterRule(_localctx, 718, RULE_subquery_operation_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5967;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNION:
				{
				State = 5961; Match(UNION);
				State = 5963;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL) {
					{
					State = 5962; Match(ALL);
					}
				}

				}
				break;
			case INTERSECT:
				{
				State = 5965; Match(INTERSECT);
				}
				break;
			case MINUS:
				{
				State = 5966; Match(MINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5969; subquery_basic_elements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_blockContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(PlSqlParser.SELECT, 0); }
		public From_clauseContext from_clause() {
			return GetRuleContext<From_clauseContext>(0);
		}
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Hierarchical_query_clauseContext hierarchical_query_clause() {
			return GetRuleContext<Hierarchical_query_clauseContext>(0);
		}
		public Group_by_clauseContext group_by_clause() {
			return GetRuleContext<Group_by_clauseContext>(0);
		}
		public Model_clauseContext model_clause() {
			return GetRuleContext<Model_clauseContext>(0);
		}
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Selected_elementContext[] selected_element() {
			return GetRuleContexts<Selected_elementContext>();
		}
		public Selected_elementContext selected_element(int i) {
			return GetRuleContext<Selected_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Query_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_blockContext query_block() {
		Query_blockContext _localctx = new Query_blockContext(Context, State);
		EnterRule(_localctx, 720, RULE_query_block);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5971; Match(SELECT);
			State = 5973;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,792,Context) ) {
			case 1:
				{
				State = 5972;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 5984;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASTERISK:
				{
				State = 5975; Match(ASTERISK);
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case VARIABLE_SESSION:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case COMMA:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 5980;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 5977;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 5976; Match(COMMA);
							}
						}

						State = 5979; selected_element();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5982;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,794,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5987;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BULK || _la==INTO) {
				{
				State = 5986; into_clause();
				}
			}

			State = 5989; from_clause();
			State = 5991;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,797,Context) ) {
			case 1:
				{
				State = 5990; where_clause();
				}
				break;
			}
			State = 5994;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,798,Context) ) {
			case 1:
				{
				State = 5993; hierarchical_query_clause();
				}
				break;
			}
			State = 5997;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,799,Context) ) {
			case 1:
				{
				State = 5996; group_by_clause();
				}
				break;
			}
			State = 6000;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,800,Context) ) {
			case 1:
				{
				State = 5999; model_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Selected_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelected_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selected_elementContext selected_element() {
		Selected_elementContext _localctx = new Selected_elementContext(Context, State);
		EnterRule(_localctx, 722, RULE_selected_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6002; select_list_elements();
			State = 6004;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,801,Context) ) {
			case 1:
				{
				State = 6003; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class From_clauseContext : ParserRuleContext {
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public Table_ref_listContext table_ref_list() {
			return GetRuleContext<Table_ref_listContext>(0);
		}
		public From_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrom_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public From_clauseContext from_clause() {
		From_clauseContext _localctx = new From_clauseContext(Context, State);
		EnterRule(_localctx, 724, RULE_from_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6006; Match(FROM);
			State = 6007; table_ref_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_list_elementsContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public Select_list_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_list_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_list_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_list_elementsContext select_list_elements() {
		Select_list_elementsContext _localctx = new Select_list_elementsContext(Context, State);
		EnterRule(_localctx, 726, RULE_select_list_elements);
		try {
			State = 6019;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,803,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6009; tableview_name();
				State = 6010; Match(PERIOD);
				State = 6011; Match(ASTERISK);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6016;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,802,Context) ) {
				case 1:
					{
					State = 6013; regular_id();
					State = 6014; Match(PERIOD);
					}
					break;
				}
				State = 6018; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_listContext : ParserRuleContext {
		public Table_refContext[] table_ref() {
			return GetRuleContexts<Table_refContext>();
		}
		public Table_refContext table_ref(int i) {
			return GetRuleContext<Table_refContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Table_ref_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_listContext table_ref_list() {
		Table_ref_listContext _localctx = new Table_ref_listContext(Context, State);
		EnterRule(_localctx, 728, RULE_table_ref_list);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6025;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 6022;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 6021; Match(COMMA);
						}
					}

					State = 6024; table_ref();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 6027;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,805,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_refContext : ParserRuleContext {
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Join_clauseContext[] join_clause() {
			return GetRuleContexts<Join_clauseContext>();
		}
		public Join_clauseContext join_clause(int i) {
			return GetRuleContext<Join_clauseContext>(i);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_refContext table_ref() {
		Table_refContext _localctx = new Table_refContext(Context, State);
		EnterRule(_localctx, 730, RULE_table_ref);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6029; table_ref_aux();
			State = 6033;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,806,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 6030; join_clause();
					}
					} 
				}
				State = 6035;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,806,Context);
			}
			State = 6038;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,807,Context) ) {
			case 1:
				{
				State = 6036; pivot_clause();
				}
				break;
			case 2:
				{
				State = 6037; unpivot_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_auxContext : ParserRuleContext {
		public Table_ref_aux_internalContext table_ref_aux_internal() {
			return GetRuleContext<Table_ref_aux_internalContext>(0);
		}
		public Flashback_query_clauseContext[] flashback_query_clause() {
			return GetRuleContexts<Flashback_query_clauseContext>();
		}
		public Flashback_query_clauseContext flashback_query_clause(int i) {
			return GetRuleContext<Flashback_query_clauseContext>(i);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Table_ref_auxContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_aux; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_auxContext table_ref_aux() {
		Table_ref_auxContext _localctx = new Table_ref_auxContext(Context, State);
		EnterRule(_localctx, 732, RULE_table_ref_aux);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6040; table_ref_aux_internal();
			State = 6044;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,808,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 6041; flashback_query_clause();
					}
					} 
				}
				State = 6046;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,808,Context);
			}
			State = 6048;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,809,Context) ) {
			case 1:
				{
				State = 6047; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_aux_internalContext : ParserRuleContext {
		public Table_ref_aux_internalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_aux_internal; } }
	 
		public Table_ref_aux_internalContext() { }
		public virtual void CopyFrom(Table_ref_aux_internalContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Table_ref_aux_internal_threeContext : Table_ref_aux_internalContext {
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Table_ref_aux_internal_threeContext(Table_ref_aux_internalContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux_internal_three(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Table_ref_aux_internal_oneContext : Table_ref_aux_internalContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_ref_aux_internal_oneContext(Table_ref_aux_internalContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux_internal_one(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Table_ref_aux_internal_twoContext : Table_ref_aux_internalContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Table_refContext table_ref() {
			return GetRuleContext<Table_refContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_ref_aux_internal_twoContext(Table_ref_aux_internalContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux_internal_two(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_aux_internalContext table_ref_aux_internal() {
		Table_ref_aux_internalContext _localctx = new Table_ref_aux_internalContext(Context, State);
		EnterRule(_localctx, 734, RULE_table_ref_aux_internal);
		int _la;
		try {
			State = 6073;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,813,Context) ) {
			case 1:
				_localctx = new Table_ref_aux_internal_oneContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 6050; dml_table_expression_clause();
				State = 6053;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,810,Context) ) {
				case 1:
					{
					State = 6051; pivot_clause();
					}
					break;
				case 2:
					{
					State = 6052; unpivot_clause();
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new Table_ref_aux_internal_twoContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 6055; Match(LEFT_PAREN);
				State = 6056; table_ref();
				State = 6060;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INTERSECT || _la==MINUS || _la==UNION) {
					{
					{
					State = 6057; subquery_operation_part();
					}
					}
					State = 6062;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 6063; Match(RIGHT_PAREN);
				State = 6066;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,812,Context) ) {
				case 1:
					{
					State = 6064; pivot_clause();
					}
					break;
				case 2:
					{
					State = 6065; unpivot_clause();
					}
					break;
				}
				}
				break;
			case 3:
				_localctx = new Table_ref_aux_internal_threeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 6068; Match(ONLY);
				State = 6069; Match(LEFT_PAREN);
				State = 6070; dml_table_expression_clause();
				State = 6071; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_clauseContext : ParserRuleContext {
		public ITerminalNode JOIN() { return GetToken(PlSqlParser.JOIN, 0); }
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Query_partition_clauseContext[] query_partition_clause() {
			return GetRuleContexts<Query_partition_clauseContext>();
		}
		public Query_partition_clauseContext query_partition_clause(int i) {
			return GetRuleContext<Query_partition_clauseContext>(i);
		}
		public ITerminalNode INNER() { return GetToken(PlSqlParser.INNER, 0); }
		public Outer_join_typeContext outer_join_type() {
			return GetRuleContext<Outer_join_typeContext>(0);
		}
		public Join_on_partContext[] join_on_part() {
			return GetRuleContexts<Join_on_partContext>();
		}
		public Join_on_partContext join_on_part(int i) {
			return GetRuleContext<Join_on_partContext>(i);
		}
		public Join_using_partContext[] join_using_part() {
			return GetRuleContexts<Join_using_partContext>();
		}
		public Join_using_partContext join_using_part(int i) {
			return GetRuleContext<Join_using_partContext>(i);
		}
		public ITerminalNode CROSS() { return GetToken(PlSqlParser.CROSS, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlSqlParser.NATURAL, 0); }
		public Join_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_clauseContext join_clause() {
		Join_clauseContext _localctx = new Join_clauseContext(Context, State);
		EnterRule(_localctx, 736, RULE_join_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6076;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 6075; query_partition_clause();
				}
			}

			State = 6079;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CROSS || _la==NATURAL) {
				{
				State = 6078;
				_la = TokenStream.LA(1);
				if ( !(_la==CROSS || _la==NATURAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6083;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INNER:
				{
				State = 6081; Match(INNER);
				}
				break;
			case FULL:
			case LEFT:
			case RIGHT:
				{
				State = 6082; outer_join_type();
				}
				break;
			case JOIN:
				break;
			default:
				break;
			}
			State = 6085; Match(JOIN);
			State = 6086; table_ref_aux();
			State = 6088;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,817,Context) ) {
			case 1:
				{
				State = 6087; query_partition_clause();
				}
				break;
			}
			State = 6094;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,819,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 6092;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ON:
						{
						State = 6090; join_on_part();
						}
						break;
					case USING:
						{
						State = 6091; join_using_part();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 6096;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,819,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_on_partContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Join_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_on_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_on_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_on_partContext join_on_part() {
		Join_on_partContext _localctx = new Join_on_partContext(Context, State);
		EnterRule(_localctx, 738, RULE_join_on_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6097; Match(ON);
			State = 6098; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_using_partContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Join_using_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_using_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_using_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_using_partContext join_using_part() {
		Join_using_partContext _localctx = new Join_using_partContext(Context, State);
		EnterRule(_localctx, 740, RULE_join_using_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6100; Match(USING);
			State = 6101; paren_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_typeContext : ParserRuleContext {
		public ITerminalNode FULL() { return GetToken(PlSqlParser.FULL, 0); }
		public ITerminalNode LEFT() { return GetToken(PlSqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(PlSqlParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(PlSqlParser.OUTER, 0); }
		public Outer_join_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuter_join_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_typeContext outer_join_type() {
		Outer_join_typeContext _localctx = new Outer_join_typeContext(Context, State);
		EnterRule(_localctx, 742, RULE_outer_join_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6103;
			_la = TokenStream.LA(1);
			if ( !(_la==FULL || _la==LEFT || _la==RIGHT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6105;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OUTER) {
				{
				State = 6104; Match(OUTER);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_partition_clauseContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Query_partition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_partition_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_partition_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_partition_clauseContext query_partition_clause() {
		Query_partition_clauseContext _localctx = new Query_partition_clauseContext(Context, State);
		EnterRule(_localctx, 744, RULE_query_partition_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6107; Match(PARTITION);
			State = 6108; Match(BY);
			State = 6116;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,822,Context) ) {
			case 1:
				{
				{
				State = 6109; Match(LEFT_PAREN);
				State = 6112;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,821,Context) ) {
				case 1:
					{
					State = 6110; subquery();
					}
					break;
				case 2:
					{
					State = 6111; expressions();
					}
					break;
				}
				State = 6114; Match(RIGHT_PAREN);
				}
				}
				break;
			case 2:
				{
				State = 6115; expressions();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_query_clauseContext : ParserRuleContext {
		public ITerminalNode VERSIONS() { return GetToken(PlSqlParser.VERSIONS, 0); }
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode SCN() { return GetToken(PlSqlParser.SCN, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(PlSqlParser.SNAPSHOT, 0); }
		public Flashback_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_query_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlashback_query_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_query_clauseContext flashback_query_clause() {
		Flashback_query_clauseContext _localctx = new Flashback_query_clauseContext(Context, State);
		EnterRule(_localctx, 746, RULE_flashback_query_clause);
		int _la;
		try {
			State = 6126;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VERSIONS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6118; Match(VERSIONS);
				State = 6119; Match(BETWEEN);
				State = 6120;
				_la = TokenStream.LA(1);
				if ( !(_la==SCN || _la==TIMESTAMP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6121; expression();
				}
				break;
			case AS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6122; Match(AS);
				State = 6123; Match(OF);
				State = 6124;
				_la = TokenStream.LA(1);
				if ( !(_la==SCN || _la==SNAPSHOT || _la==TIMESTAMP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6125; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_clauseContext : ParserRuleContext {
		public ITerminalNode PIVOT() { return GetToken(PlSqlParser.PIVOT, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public Pivot_in_clauseContext pivot_in_clause() {
			return GetRuleContext<Pivot_in_clauseContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode XML() { return GetToken(PlSqlParser.XML, 0); }
		public Pivot_elementContext[] pivot_element() {
			return GetRuleContexts<Pivot_elementContext>();
		}
		public Pivot_elementContext pivot_element(int i) {
			return GetRuleContext<Pivot_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Pivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_clauseContext pivot_clause() {
		Pivot_clauseContext _localctx = new Pivot_clauseContext(Context, State);
		EnterRule(_localctx, 748, RULE_pivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6128; Match(PIVOT);
			State = 6130;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==XML) {
				{
				State = 6129; Match(XML);
				}
			}

			State = 6132; Match(LEFT_PAREN);
			State = 6137;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6134;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 6133; Match(COMMA);
					}
				}

				State = 6136; pivot_element();
				}
				}
				State = 6139;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 6141; pivot_for_clause();
			State = 6142; pivot_in_clause();
			State = 6143; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_elementContext : ParserRuleContext {
		public Aggregate_function_nameContext aggregate_function_name() {
			return GetRuleContext<Aggregate_function_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_elementContext pivot_element() {
		Pivot_elementContext _localctx = new Pivot_elementContext(Context, State);
		EnterRule(_localctx, 750, RULE_pivot_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6145; aggregate_function_name();
			State = 6146; Match(LEFT_PAREN);
			State = 6147; expression();
			State = 6148; Match(RIGHT_PAREN);
			State = 6150;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,827,Context) ) {
			case 1:
				{
				State = 6149; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_for_clauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Pivot_for_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_for_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_for_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_for_clauseContext pivot_for_clause() {
		Pivot_for_clauseContext _localctx = new Pivot_for_clauseContext(Context, State);
		EnterRule(_localctx, 752, RULE_pivot_for_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6152; Match(FOR);
			State = 6155;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 6153; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 6154; paren_column_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clauseContext : ParserRuleContext {
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode[] ANY() { return GetTokens(PlSqlParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(PlSqlParser.ANY, i);
		}
		public Pivot_in_clause_elementContext[] pivot_in_clause_element() {
			return GetRuleContexts<Pivot_in_clause_elementContext>();
		}
		public Pivot_in_clause_elementContext pivot_in_clause_element(int i) {
			return GetRuleContext<Pivot_in_clause_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Pivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clauseContext pivot_in_clause() {
		Pivot_in_clauseContext _localctx = new Pivot_in_clauseContext(Context, State);
		EnterRule(_localctx, 754, RULE_pivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6157; Match(IN);
			State = 6158; Match(LEFT_PAREN);
			State = 6176;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,833,Context) ) {
			case 1:
				{
				State = 6159; subquery();
				}
				break;
			case 2:
				{
				State = 6164;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 6161;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 6160; Match(COMMA);
						}
					}

					State = 6163; Match(ANY);
					}
					}
					State = 6166;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==ANY || _la==COMMA );
				}
				break;
			case 3:
				{
				State = 6172;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 6169;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 6168; Match(COMMA);
						}
					}

					State = 6171; pivot_in_clause_element();
					}
					}
					State = 6174;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				}
				break;
			}
			State = 6178; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementContext : ParserRuleContext {
		public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
			return GetRuleContext<Pivot_in_clause_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_in_clause_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementContext pivot_in_clause_element() {
		Pivot_in_clause_elementContext _localctx = new Pivot_in_clause_elementContext(Context, State);
		EnterRule(_localctx, 756, RULE_pivot_in_clause_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6180; pivot_in_clause_elements();
			State = 6182;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,834,Context) ) {
			case 1:
				{
				State = 6181; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementsContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Pivot_in_clause_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
		Pivot_in_clause_elementsContext _localctx = new Pivot_in_clause_elementsContext(Context, State);
		EnterRule(_localctx, 758, RULE_pivot_in_clause_elements);
		int _la;
		try {
			State = 6190;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,836,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6184; expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6185; Match(LEFT_PAREN);
				State = 6187;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 6186; expressions();
					}
				}

				State = 6189; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_clauseContext : ParserRuleContext {
		public ITerminalNode UNPIVOT() { return GetToken(PlSqlParser.UNPIVOT, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public Unpivot_in_clauseContext unpivot_in_clause() {
			return GetRuleContext<Unpivot_in_clauseContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode INCLUDE() { return GetToken(PlSqlParser.INCLUDE, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(PlSqlParser.EXCLUDE, 0); }
		public Unpivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_clauseContext unpivot_clause() {
		Unpivot_clauseContext _localctx = new Unpivot_clauseContext(Context, State);
		EnterRule(_localctx, 760, RULE_unpivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6192; Match(UNPIVOT);
			State = 6195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCLUDE || _la==INCLUDE) {
				{
				State = 6193;
				_la = TokenStream.LA(1);
				if ( !(_la==EXCLUDE || _la==INCLUDE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6194; Match(NULLS);
				}
			}

			State = 6197; Match(LEFT_PAREN);
			State = 6200;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 6198; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 6199; paren_column_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6202; pivot_for_clause();
			State = 6203; unpivot_in_clause();
			State = 6204; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_clauseContext : ParserRuleContext {
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Unpivot_in_elementsContext[] unpivot_in_elements() {
			return GetRuleContexts<Unpivot_in_elementsContext>();
		}
		public Unpivot_in_elementsContext unpivot_in_elements(int i) {
			return GetRuleContext<Unpivot_in_elementsContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Unpivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_clauseContext unpivot_in_clause() {
		Unpivot_in_clauseContext _localctx = new Unpivot_in_clauseContext(Context, State);
		EnterRule(_localctx, 762, RULE_unpivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6206; Match(IN);
			State = 6207; Match(LEFT_PAREN);
			State = 6212;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6209;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 6208; Match(COMMA);
					}
				}

				State = 6211; unpivot_in_elements();
				}
				}
				State = 6214;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 6216; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_elementsContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Unpivot_in_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_in_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_elementsContext unpivot_in_elements() {
		Unpivot_in_elementsContext _localctx = new Unpivot_in_elementsContext(Context, State);
		EnterRule(_localctx, 764, RULE_unpivot_in_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6220;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 6218; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 6219; paren_column_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6237;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 6222; Match(AS);
				State = 6235;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATE:
				case DBTIMEZONE:
				case DEFAULT:
				case FALSE:
				case INTERVAL:
				case MAXVALUE:
				case MINVALUE:
				case NULL:
				case SESSIONTIMEZONE:
				case TIMESTAMP:
				case TRUE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case PLUS_SIGN:
					{
					State = 6223; constant();
					}
					break;
				case LEFT_PAREN:
					{
					State = 6224; Match(LEFT_PAREN);
					State = 6229;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 6226;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 6225; Match(COMMA);
							}
						}

						State = 6228; constant();
						}
						}
						State = 6231;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( ((((_la - 126)) & ~0x3f) == 0 && ((1L << (_la - 126)) & ((1L << (DATE - 126)) | (1L << (DBTIMEZONE - 126)) | (1L << (DEFAULT - 126)))) != 0) || _la==FALSE || _la==INTERVAL || _la==MAXVALUE || _la==MINVALUE || _la==NULL || _la==SESSIONTIMEZONE || _la==TIMESTAMP || _la==TRUE || ((((_la - 741)) & ~0x3f) == 0 && ((1L << (_la - 741)) & ((1L << (NATIONAL_CHAR_STRING_LIT - 741)) | (1L << (UNSIGNED_INTEGER - 741)) | (1L << (APPROXIMATE_NUM_LIT - 741)) | (1L << (CHAR_STRING - 741)) | (1L << (PLUS_SIGN - 741)) | (1L << (COMMA - 741)))) != 0) );
					State = 6233; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hierarchical_query_clauseContext : ParserRuleContext {
		public ITerminalNode CONNECT() { return GetToken(PlSqlParser.CONNECT, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public Start_partContext start_part() {
			return GetRuleContext<Start_partContext>(0);
		}
		public Hierarchical_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hierarchical_query_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHierarchical_query_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hierarchical_query_clauseContext hierarchical_query_clause() {
		Hierarchical_query_clauseContext _localctx = new Hierarchical_query_clauseContext(Context, State);
		EnterRule(_localctx, 766, RULE_hierarchical_query_clause);
		try {
			State = 6256;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONNECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6239; Match(CONNECT);
				State = 6240; Match(BY);
				State = 6242;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,846,Context) ) {
				case 1:
					{
					State = 6241; Match(NOCYCLE);
					}
					break;
				}
				State = 6244; condition();
				State = 6246;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,847,Context) ) {
				case 1:
					{
					State = 6245; start_part();
					}
					break;
				}
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6248; start_part();
				State = 6249; Match(CONNECT);
				State = 6250; Match(BY);
				State = 6252;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,848,Context) ) {
				case 1:
					{
					State = 6251; Match(NOCYCLE);
					}
					break;
				}
				State = 6254; condition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Start_partContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Start_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Start_partContext start_part() {
		Start_partContext _localctx = new Start_partContext(Context, State);
		EnterRule(_localctx, 768, RULE_start_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6258; Match(START);
			State = 6259; Match(WITH);
			State = 6260; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_clauseContext : ParserRuleContext {
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Group_by_elementsContext[] group_by_elements() {
			return GetRuleContexts<Group_by_elementsContext>();
		}
		public Group_by_elementsContext group_by_elements(int i) {
			return GetRuleContext<Group_by_elementsContext>(i);
		}
		public Having_clauseContext having_clause() {
			return GetRuleContext<Having_clauseContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Group_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_clauseContext group_by_clause() {
		Group_by_clauseContext _localctx = new Group_by_clauseContext(Context, State);
		EnterRule(_localctx, 770, RULE_group_by_clause);
		int _la;
		try {
			int _alt;
			State = 6288;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GROUP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6262; Match(GROUP);
				State = 6263; Match(BY);
				State = 6268;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 6265;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 6264; Match(COMMA);
							}
						}

						State = 6267; group_by_elements();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 6270;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,851,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 6273;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,852,Context) ) {
				case 1:
					{
					State = 6272; having_clause();
					}
					break;
				}
				}
				break;
			case HAVING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6275; having_clause();
				State = 6286;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,855,Context) ) {
				case 1:
					{
					State = 6276; Match(GROUP);
					State = 6277; Match(BY);
					State = 6282;
					ErrorHandler.Sync(this);
					_alt = 1;
					do {
						switch (_alt) {
						case 1:
							{
							{
							State = 6279;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==COMMA) {
								{
								State = 6278; Match(COMMA);
								}
							}

							State = 6281; group_by_elements();
							}
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 6284;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,854,Context);
					} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_elementsContext : ParserRuleContext {
		public Grouping_sets_clauseContext grouping_sets_clause() {
			return GetRuleContext<Grouping_sets_clauseContext>(0);
		}
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Group_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_by_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_elementsContext group_by_elements() {
		Group_by_elementsContext _localctx = new Group_by_elementsContext(Context, State);
		EnterRule(_localctx, 772, RULE_group_by_elements);
		try {
			State = 6293;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,857,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6290; grouping_sets_clause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6291; rollup_cube_clause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6292; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollup_cube_clauseContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode ROLLUP() { return GetToken(PlSqlParser.ROLLUP, 0); }
		public ITerminalNode CUBE() { return GetToken(PlSqlParser.CUBE, 0); }
		public Grouping_sets_elementsContext[] grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Rollup_cube_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollup_cube_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollup_cube_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollup_cube_clauseContext rollup_cube_clause() {
		Rollup_cube_clauseContext _localctx = new Rollup_cube_clauseContext(Context, State);
		EnterRule(_localctx, 774, RULE_rollup_cube_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6295;
			_la = TokenStream.LA(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6296; Match(LEFT_PAREN);
			State = 6301;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6298;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 6297; Match(COMMA);
					}
				}

				State = 6300; grouping_sets_elements();
				}
				}
				State = 6303;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 6305; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_clauseContext : ParserRuleContext {
		public ITerminalNode GROUPING() { return GetToken(PlSqlParser.GROUPING, 0); }
		public ITerminalNode SETS() { return GetToken(PlSqlParser.SETS, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Grouping_sets_elementsContext[] grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Grouping_sets_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_sets_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_clauseContext grouping_sets_clause() {
		Grouping_sets_clauseContext _localctx = new Grouping_sets_clauseContext(Context, State);
		EnterRule(_localctx, 776, RULE_grouping_sets_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6307; Match(GROUPING);
			State = 6308; Match(SETS);
			State = 6309; Match(LEFT_PAREN);
			State = 6314;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6311;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 6310; Match(COMMA);
					}
				}

				State = 6313; grouping_sets_elements();
				}
				}
				State = 6316;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 6318; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_elementsContext : ParserRuleContext {
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Grouping_sets_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_sets_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_elementsContext grouping_sets_elements() {
		Grouping_sets_elementsContext _localctx = new Grouping_sets_elementsContext(Context, State);
		EnterRule(_localctx, 778, RULE_grouping_sets_elements);
		int _la;
		try {
			State = 6327;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,863,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6320; rollup_cube_clause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6321; Match(LEFT_PAREN);
				State = 6323;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 6322; expressions();
					}
				}

				State = 6325; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6326; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Having_clauseContext : ParserRuleContext {
		public ITerminalNode HAVING() { return GetToken(PlSqlParser.HAVING, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Having_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_having_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHaving_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Having_clauseContext having_clause() {
		Having_clauseContext _localctx = new Having_clauseContext(Context, State);
		EnterRule(_localctx, 780, RULE_having_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6329; Match(HAVING);
			State = 6330; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_clauseContext : ParserRuleContext {
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public Main_modelContext main_model() {
			return GetRuleContext<Main_modelContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Return_rows_clauseContext return_rows_clause() {
			return GetRuleContext<Return_rows_clauseContext>(0);
		}
		public Reference_modelContext[] reference_model() {
			return GetRuleContexts<Reference_modelContext>();
		}
		public Reference_modelContext reference_model(int i) {
			return GetRuleContext<Reference_modelContext>(i);
		}
		public Model_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_clauseContext model_clause() {
		Model_clauseContext _localctx = new Model_clauseContext(Context, State);
		EnterRule(_localctx, 782, RULE_model_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6332; Match(MODEL);
			State = 6336;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 6333; cell_reference_options();
				}
				}
				State = 6338;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6340;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURN) {
				{
				State = 6339; return_rows_clause();
				}
			}

			State = 6345;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==REFERENCE) {
				{
				{
				State = 6342; reference_model();
				}
				}
				State = 6347;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6348; main_model();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_reference_optionsContext : ParserRuleContext {
		public ITerminalNode NAV() { return GetToken(PlSqlParser.NAV, 0); }
		public ITerminalNode IGNORE() { return GetToken(PlSqlParser.IGNORE, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode SINGLE() { return GetToken(PlSqlParser.SINGLE, 0); }
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public Cell_reference_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_reference_options; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCell_reference_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cell_reference_optionsContext cell_reference_options() {
		Cell_reference_optionsContext _localctx = new Cell_reference_optionsContext(Context, State);
		EnterRule(_localctx, 784, RULE_cell_reference_options);
		int _la;
		try {
			State = 6358;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IGNORE:
			case KEEP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6350;
				_la = TokenStream.LA(1);
				if ( !(_la==IGNORE || _la==KEEP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6351; Match(NAV);
				}
				break;
			case UNIQUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6352; Match(UNIQUE);
				State = 6356;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DIMENSION:
					{
					State = 6353; Match(DIMENSION);
					}
					break;
				case SINGLE:
					{
					State = 6354; Match(SINGLE);
					State = 6355; Match(REFERENCE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_rows_clauseContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public ITerminalNode UPDATED() { return GetToken(PlSqlParser.UPDATED, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Return_rows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_rows_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_rows_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_rows_clauseContext return_rows_clause() {
		Return_rows_clauseContext _localctx = new Return_rows_clauseContext(Context, State);
		EnterRule(_localctx, 786, RULE_return_rows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6360; Match(RETURN);
			State = 6361;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==UPDATED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6362; Match(ROWS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_modelContext : ParserRuleContext {
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public Reference_model_nameContext reference_model_name() {
			return GetRuleContext<Reference_model_nameContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Reference_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_model(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_modelContext reference_model() {
		Reference_modelContext _localctx = new Reference_modelContext(Context, State);
		EnterRule(_localctx, 788, RULE_reference_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6364; Match(REFERENCE);
			State = 6365; reference_model_name();
			State = 6366; Match(ON);
			State = 6367; Match(LEFT_PAREN);
			State = 6368; subquery();
			State = 6369; Match(RIGHT_PAREN);
			State = 6370; model_column_clauses();
			State = 6374;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 6371; cell_reference_options();
				}
				}
				State = 6376;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_modelContext : ParserRuleContext {
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Model_rules_clauseContext model_rules_clause() {
			return GetRuleContext<Model_rules_clauseContext>(0);
		}
		public ITerminalNode MAIN() { return GetToken(PlSqlParser.MAIN, 0); }
		public Main_model_nameContext main_model_name() {
			return GetRuleContext<Main_model_nameContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Main_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain_model(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Main_modelContext main_model() {
		Main_modelContext _localctx = new Main_modelContext(Context, State);
		EnterRule(_localctx, 790, RULE_main_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6379;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MAIN) {
				{
				State = 6377; Match(MAIN);
				State = 6378; main_model_name();
				}
			}

			State = 6381; model_column_clauses();
			State = 6385;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 6382; cell_reference_options();
				}
				}
				State = 6387;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6388; model_rules_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_clausesContext : ParserRuleContext {
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Model_column_listContext[] model_column_list() {
			return GetRuleContexts<Model_column_listContext>();
		}
		public Model_column_listContext model_column_list(int i) {
			return GetRuleContext<Model_column_listContext>(i);
		}
		public ITerminalNode MEASURES() { return GetToken(PlSqlParser.MEASURES, 0); }
		public Model_column_partition_partContext model_column_partition_part() {
			return GetRuleContext<Model_column_partition_partContext>(0);
		}
		public Model_column_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_clauses; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_clausesContext model_column_clauses() {
		Model_column_clausesContext _localctx = new Model_column_clausesContext(Context, State);
		EnterRule(_localctx, 792, RULE_model_column_clauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6391;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 6390; model_column_partition_part();
				}
			}

			State = 6393; Match(DIMENSION);
			State = 6394; Match(BY);
			State = 6395; model_column_list();
			State = 6396; Match(MEASURES);
			State = 6397; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_partition_partContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Model_column_listContext model_column_list() {
			return GetRuleContext<Model_column_listContext>(0);
		}
		public Model_column_partition_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_partition_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_partition_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_partition_partContext model_column_partition_part() {
		Model_column_partition_partContext _localctx = new Model_column_partition_partContext(Context, State);
		EnterRule(_localctx, 794, RULE_model_column_partition_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6399; Match(PARTITION);
			State = 6400; Match(BY);
			State = 6401; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_listContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Model_columnContext[] model_column() {
			return GetRuleContexts<Model_columnContext>();
		}
		public Model_columnContext model_column(int i) {
			return GetRuleContext<Model_columnContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Model_column_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_listContext model_column_list() {
		Model_column_listContext _localctx = new Model_column_listContext(Context, State);
		EnterRule(_localctx, 796, RULE_model_column_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6403; Match(LEFT_PAREN);
			State = 6408;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6405;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 6404; Match(COMMA);
					}
				}

				State = 6407; model_column();
				}
				}
				State = 6410;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELECT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 6412; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_columnContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Query_blockContext query_block() {
			return GetRuleContext<Query_blockContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Model_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_columnContext model_column() {
		Model_columnContext _localctx = new Model_columnContext(Context, State);
		EnterRule(_localctx, 798, RULE_model_column);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6416;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case VARIABLE_SESSION:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 6414; expression();
				}
				break;
			case SELECT:
				{
				State = 6415; query_block();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6419;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,876,Context) ) {
			case 1:
				{
				State = 6418; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_clauseContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Model_rules_partContext model_rules_part() {
			return GetRuleContext<Model_rules_partContext>(0);
		}
		public Model_rules_elementContext[] model_rules_element() {
			return GetRuleContexts<Model_rules_elementContext>();
		}
		public Model_rules_elementContext model_rules_element(int i) {
			return GetRuleContext<Model_rules_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Model_rules_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_clauseContext model_rules_clause() {
		Model_rules_clauseContext _localctx = new Model_rules_clauseContext(Context, State);
		EnterRule(_localctx, 800, RULE_model_rules_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6422;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RULES) {
				{
				State = 6421; model_rules_part();
				}
			}

			State = 6424; Match(LEFT_PAREN);
			State = 6431;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPDATE - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 6426;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 6425; Match(COMMA);
					}
				}

				State = 6428; model_rules_element();
				}
				}
				State = 6433;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6434; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_partContext : ParserRuleContext {
		public ITerminalNode RULES() { return GetToken(PlSqlParser.RULES, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode UPSERT() { return GetToken(PlSqlParser.UPSERT, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Model_iterate_clauseContext model_iterate_clause() {
			return GetRuleContext<Model_iterate_clauseContext>(0);
		}
		public ITerminalNode AUTOMATIC() { return GetToken(PlSqlParser.AUTOMATIC, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(PlSqlParser.SEQUENTIAL, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Model_rules_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_partContext model_rules_part() {
		Model_rules_partContext _localctx = new Model_rules_partContext(Context, State);
		EnterRule(_localctx, 802, RULE_model_rules_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6436; Match(RULES);
			State = 6442;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UPDATE:
				{
				State = 6437; Match(UPDATE);
				}
				break;
			case UPSERT:
				{
				State = 6438; Match(UPSERT);
				State = 6440;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL) {
					{
					State = 6439; Match(ALL);
					}
				}

				}
				break;
			case AUTOMATIC:
			case ITERATE:
			case SEQUENTIAL:
			case LEFT_PAREN:
				break;
			default:
				break;
			}
			State = 6446;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTOMATIC || _la==SEQUENTIAL) {
				{
				State = 6444;
				_la = TokenStream.LA(1);
				if ( !(_la==AUTOMATIC || _la==SEQUENTIAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6445; Match(ORDER);
				}
			}

			State = 6449;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ITERATE) {
				{
				State = 6448; model_iterate_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_elementContext : ParserRuleContext {
		public Cell_assignmentContext cell_assignment() {
			return GetRuleContext<Cell_assignmentContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode UPSERT() { return GetToken(PlSqlParser.UPSERT, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Model_rules_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_elementContext model_rules_element() {
		Model_rules_elementContext _localctx = new Model_rules_elementContext(Context, State);
		EnterRule(_localctx, 804, RULE_model_rules_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6456;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,885,Context) ) {
			case 1:
				{
				State = 6451; Match(UPDATE);
				}
				break;
			case 2:
				{
				State = 6452; Match(UPSERT);
				State = 6454;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,884,Context) ) {
				case 1:
					{
					State = 6453; Match(ALL);
					}
					break;
				}
				}
				break;
			}
			State = 6458; cell_assignment();
			State = 6460;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 6459; order_by_clause();
				}
			}

			State = 6462; Match(EQUALS_OP);
			State = 6463; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_assignmentContext : ParserRuleContext {
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public Cell_assignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_assignment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCell_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cell_assignmentContext cell_assignment() {
		Cell_assignmentContext _localctx = new Cell_assignmentContext(Context, State);
		EnterRule(_localctx, 806, RULE_cell_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6465; model_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_iterate_clauseContext : ParserRuleContext {
		public ITerminalNode ITERATE() { return GetToken(PlSqlParser.ITERATE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Until_partContext until_part() {
			return GetRuleContext<Until_partContext>(0);
		}
		public Model_iterate_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_iterate_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_iterate_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_iterate_clauseContext model_iterate_clause() {
		Model_iterate_clauseContext _localctx = new Model_iterate_clauseContext(Context, State);
		EnterRule(_localctx, 808, RULE_model_iterate_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6467; Match(ITERATE);
			State = 6468; Match(LEFT_PAREN);
			State = 6469; expression();
			State = 6470; Match(RIGHT_PAREN);
			State = 6472;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNTIL) {
				{
				State = 6471; until_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Until_partContext : ParserRuleContext {
		public ITerminalNode UNTIL() { return GetToken(PlSqlParser.UNTIL, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Until_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_until_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntil_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Until_partContext until_part() {
		Until_partContext _localctx = new Until_partContext(Context, State);
		EnterRule(_localctx, 810, RULE_until_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6474; Match(UNTIL);
			State = 6475; Match(LEFT_PAREN);
			State = 6476; condition();
			State = 6477; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_clauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode SIBLINGS() { return GetToken(PlSqlParser.SIBLINGS, 0); }
		public Order_by_elementsContext[] order_by_elements() {
			return GetRuleContexts<Order_by_elementsContext>();
		}
		public Order_by_elementsContext order_by_elements(int i) {
			return GetRuleContext<Order_by_elementsContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Order_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_clauseContext order_by_clause() {
		Order_by_clauseContext _localctx = new Order_by_clauseContext(Context, State);
		EnterRule(_localctx, 812, RULE_order_by_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6479; Match(ORDER);
			State = 6481;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SIBLINGS) {
				{
				State = 6480; Match(SIBLINGS);
				}
			}

			State = 6483; Match(BY);
			State = 6488;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 6485;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 6484; Match(COMMA);
						}
					}

					State = 6487; order_by_elements();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 6490;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,890,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_elementsContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode ASC() { return GetToken(PlSqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(PlSqlParser.DESC, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public Order_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_by_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_elementsContext order_by_elements() {
		Order_by_elementsContext _localctx = new Order_by_elementsContext(Context, State);
		EnterRule(_localctx, 814, RULE_order_by_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6492; expression();
			State = 6494;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 6493;
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6498;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,892,Context) ) {
			case 1:
				{
				State = 6496; Match(NULLS);
				State = 6497;
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST || _la==LAST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_clauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public For_update_of_partContext for_update_of_part() {
			return GetRuleContext<For_update_of_partContext>(0);
		}
		public For_update_optionsContext for_update_options() {
			return GetRuleContext<For_update_optionsContext>(0);
		}
		public For_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_clauseContext for_update_clause() {
		For_update_clauseContext _localctx = new For_update_clauseContext(Context, State);
		EnterRule(_localctx, 816, RULE_for_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6500; Match(FOR);
			State = 6501; Match(UPDATE);
			State = 6503;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OF) {
				{
				State = 6502; for_update_of_part();
				}
			}

			State = 6506;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,894,Context) ) {
			case 1:
				{
				State = 6505; for_update_options();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_of_partContext : ParserRuleContext {
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Column_listContext column_list() {
			return GetRuleContext<Column_listContext>(0);
		}
		public For_update_of_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_of_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_of_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_of_partContext for_update_of_part() {
		For_update_of_partContext _localctx = new For_update_of_partContext(Context, State);
		EnterRule(_localctx, 818, RULE_for_update_of_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6508; Match(OF);
			State = 6509; column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_optionsContext : ParserRuleContext {
		public ITerminalNode SKIP_() { return GetToken(PlSqlParser.SKIP_, 0); }
		public ITerminalNode LOCKED() { return GetToken(PlSqlParser.LOCKED, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public For_update_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_options; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_optionsContext for_update_options() {
		For_update_optionsContext _localctx = new For_update_optionsContext(Context, State);
		EnterRule(_localctx, 820, RULE_for_update_options);
		try {
			State = 6516;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SKIP_:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6511; Match(SKIP_);
				State = 6512; Match(LOCKED);
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6513; Match(NOWAIT);
				}
				break;
			case WAIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6514; Match(WAIT);
				State = 6515; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_statementContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Update_set_clauseContext update_set_clause() {
			return GetRuleContext<Update_set_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Update_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_statementContext update_statement() {
		Update_statementContext _localctx = new Update_statementContext(Context, State);
		EnterRule(_localctx, 822, RULE_update_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6518; Match(UPDATE);
			State = 6519; general_table_ref();
			State = 6520; update_set_clause();
			State = 6522;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6521; where_clause();
				}
			}

			State = 6525;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,897,Context) ) {
			case 1:
				{
				State = 6524; static_returning_clause();
				}
				break;
			}
			State = 6528;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,898,Context) ) {
			case 1:
				{
				State = 6527; error_logging_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_set_clauseContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Column_based_update_set_clauseContext[] column_based_update_set_clause() {
			return GetRuleContexts<Column_based_update_set_clauseContext>();
		}
		public Column_based_update_set_clauseContext column_based_update_set_clause(int i) {
			return GetRuleContext<Column_based_update_set_clauseContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_set_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_set_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_set_clauseContext update_set_clause() {
		Update_set_clauseContext _localctx = new Update_set_clauseContext(Context, State);
		EnterRule(_localctx, 824, RULE_update_set_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6530; Match(SET);
			State = 6546;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,901,Context) ) {
			case 1:
				{
				State = 6535;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 6532;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 6531; Match(COMMA);
							}
						}

						State = 6534; column_based_update_set_clause();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 6537;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,900,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 2:
				{
				State = 6539; Match(VALUE);
				State = 6540; Match(LEFT_PAREN);
				State = 6541; identifier();
				State = 6542; Match(RIGHT_PAREN);
				State = 6543; Match(EQUALS_OP);
				State = 6544; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_based_update_set_clauseContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Column_based_update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_based_update_set_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_based_update_set_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_based_update_set_clauseContext column_based_update_set_clause() {
		Column_based_update_set_clauseContext _localctx = new Column_based_update_set_clauseContext(Context, State);
		EnterRule(_localctx, 826, RULE_column_based_update_set_clause);
		try {
			State = 6556;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6548; column_name();
				State = 6549; Match(EQUALS_OP);
				State = 6550; expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6552; paren_column_list();
				State = 6553; Match(EQUALS_OP);
				State = 6554; subquery();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Delete_statementContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Delete_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delete_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDelete_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Delete_statementContext delete_statement() {
		Delete_statementContext _localctx = new Delete_statementContext(Context, State);
		EnterRule(_localctx, 828, RULE_delete_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6558; Match(DELETE);
			State = 6560;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 6559; Match(FROM);
				}
			}

			State = 6562; general_table_ref();
			State = 6564;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6563; where_clause();
				}
			}

			State = 6567;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,905,Context) ) {
			case 1:
				{
				State = 6566; static_returning_clause();
				}
				break;
			}
			State = 6570;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,906,Context) ) {
			case 1:
				{
				State = 6569; error_logging_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_statementContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public Single_table_insertContext single_table_insert() {
			return GetRuleContext<Single_table_insertContext>(0);
		}
		public Multi_table_insertContext multi_table_insert() {
			return GetRuleContext<Multi_table_insertContext>(0);
		}
		public Insert_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_statementContext insert_statement() {
		Insert_statementContext _localctx = new Insert_statementContext(Context, State);
		EnterRule(_localctx, 830, RULE_insert_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6572; Match(INSERT);
			State = 6575;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INTO:
				{
				State = 6573; single_table_insert();
				}
				break;
			case ALL:
			case FIRST:
			case WHEN:
				{
				State = 6574; multi_table_insert();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_table_insertContext : ParserRuleContext {
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Single_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_table_insert; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingle_table_insert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Single_table_insertContext single_table_insert() {
		Single_table_insertContext _localctx = new Single_table_insertContext(Context, State);
		EnterRule(_localctx, 832, RULE_single_table_insert);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6577; insert_into_clause();
			State = 6583;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUES:
				{
				State = 6578; values_clause();
				State = 6580;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,908,Context) ) {
				case 1:
					{
					State = 6579; static_returning_clause();
					}
					break;
				}
				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 6582; select_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6586;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,910,Context) ) {
			case 1:
				{
				State = 6585; error_logging_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_insertContext : ParserRuleContext {
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Conditional_insert_clauseContext conditional_insert_clause() {
			return GetRuleContext<Conditional_insert_clauseContext>(0);
		}
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Multi_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_insert; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_table_insert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_insertContext multi_table_insert() {
		Multi_table_insertContext _localctx = new Multi_table_insertContext(Context, State);
		EnterRule(_localctx, 834, RULE_multi_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6595;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,912,Context) ) {
			case 1:
				{
				State = 6588; Match(ALL);
				State = 6590;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 6589; multi_table_element();
					}
					}
					State = 6592;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==INTO );
				}
				break;
			case 2:
				{
				State = 6594; conditional_insert_clause();
				}
				break;
			}
			State = 6597; select_statement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_elementContext : ParserRuleContext {
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Multi_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_table_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_elementContext multi_table_element() {
		Multi_table_elementContext _localctx = new Multi_table_elementContext(Context, State);
		EnterRule(_localctx, 836, RULE_multi_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6599; insert_into_clause();
			State = 6601;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VALUES) {
				{
				State = 6600; values_clause();
				}
			}

			State = 6604;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOG) {
				{
				State = 6603; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_clauseContext : ParserRuleContext {
		public Conditional_insert_when_partContext[] conditional_insert_when_part() {
			return GetRuleContexts<Conditional_insert_when_partContext>();
		}
		public Conditional_insert_when_partContext conditional_insert_when_part(int i) {
			return GetRuleContext<Conditional_insert_when_partContext>(i);
		}
		public Conditional_insert_else_partContext conditional_insert_else_part() {
			return GetRuleContext<Conditional_insert_else_partContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public Conditional_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_clauseContext conditional_insert_clause() {
		Conditional_insert_clauseContext _localctx = new Conditional_insert_clauseContext(Context, State);
		EnterRule(_localctx, 838, RULE_conditional_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6607;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==FIRST) {
				{
				State = 6606;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==FIRST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 6610;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6609; conditional_insert_when_part();
				}
				}
				State = 6612;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 6615;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 6614; conditional_insert_else_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_when_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_when_partContext conditional_insert_when_part() {
		Conditional_insert_when_partContext _localctx = new Conditional_insert_when_partContext(Context, State);
		EnterRule(_localctx, 840, RULE_conditional_insert_when_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6617; Match(WHEN);
			State = 6618; condition();
			State = 6619; Match(THEN);
			State = 6621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6620; multi_table_element();
				}
				}
				State = 6623;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_else_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_else_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_else_partContext conditional_insert_else_part() {
		Conditional_insert_else_partContext _localctx = new Conditional_insert_else_partContext(Context, State);
		EnterRule(_localctx, 842, RULE_conditional_insert_else_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6625; Match(ELSE);
			State = 6627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 6626; multi_table_element();
				}
				}
				State = 6629;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_into_clauseContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public Insert_into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_into_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_into_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_into_clauseContext insert_into_clause() {
		Insert_into_clauseContext _localctx = new Insert_into_clauseContext(Context, State);
		EnterRule(_localctx, 844, RULE_insert_into_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6631; Match(INTO);
			State = 6632; general_table_ref();
			State = 6634;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,920,Context) ) {
			case 1:
				{
				State = 6633; paren_column_list();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Values_clauseContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Values_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_values_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValues_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Values_clauseContext values_clause() {
		Values_clauseContext _localctx = new Values_clauseContext(Context, State);
		EnterRule(_localctx, 846, RULE_values_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6636; Match(VALUES);
			State = 6637; Match(LEFT_PAREN);
			State = 6639;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 6638; expressions();
				}
			}

			State = 6641; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_statementContext : ParserRuleContext {
		public ITerminalNode MERGE() { return GetToken(PlSqlParser.MERGE, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Selected_tableviewContext selected_tableview() {
			return GetRuleContext<Selected_tableviewContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Merge_update_clauseContext merge_update_clause() {
			return GetRuleContext<Merge_update_clauseContext>(0);
		}
		public Merge_insert_clauseContext merge_insert_clause() {
			return GetRuleContext<Merge_insert_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Merge_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_statementContext merge_statement() {
		Merge_statementContext _localctx = new Merge_statementContext(Context, State);
		EnterRule(_localctx, 848, RULE_merge_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6643; Match(MERGE);
			State = 6644; Match(INTO);
			State = 6645; tableview_name();
			State = 6647;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 6646; table_alias();
				}
			}

			State = 6649; Match(USING);
			State = 6650; selected_tableview();
			State = 6651; Match(ON);
			State = 6652; Match(LEFT_PAREN);
			State = 6653; condition();
			State = 6654; Match(RIGHT_PAREN);
			State = 6663;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,925,Context) ) {
			case 1:
				{
				State = 6655; merge_update_clause();
				State = 6657;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6656; merge_insert_clause();
					}
				}

				}
				break;
			case 2:
				{
				State = 6659; merge_insert_clause();
				State = 6661;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHEN) {
					{
					State = 6660; merge_update_clause();
					}
				}

				}
				break;
			}
			State = 6666;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,926,Context) ) {
			case 1:
				{
				State = 6665; error_logging_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ITerminalNode MATCHED() { return GetToken(PlSqlParser.MATCHED, 0); }
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public Merge_elementContext[] merge_element() {
			return GetRuleContexts<Merge_elementContext>();
		}
		public Merge_elementContext merge_element(int i) {
			return GetRuleContext<Merge_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext merge_update_delete_part() {
			return GetRuleContext<Merge_update_delete_partContext>(0);
		}
		public Merge_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_update_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_clauseContext merge_update_clause() {
		Merge_update_clauseContext _localctx = new Merge_update_clauseContext(Context, State);
		EnterRule(_localctx, 850, RULE_merge_update_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6668; Match(WHEN);
			State = 6669; Match(MATCHED);
			State = 6670; Match(THEN);
			State = 6671; Match(UPDATE);
			State = 6672; Match(SET);
			State = 6673; merge_element();
			State = 6678;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,927,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 6674; Match(COMMA);
					State = 6675; merge_element();
					}
					} 
				}
				State = 6680;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,927,Context);
			}
			State = 6682;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6681; where_clause();
				}
			}

			State = 6685;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,929,Context) ) {
			case 1:
				{
				State = 6684; merge_update_delete_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_elementContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Merge_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_elementContext merge_element() {
		Merge_elementContext _localctx = new Merge_elementContext(Context, State);
		EnterRule(_localctx, 852, RULE_merge_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6687; column_name();
			State = 6688; Match(EQUALS_OP);
			State = 6689; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_delete_partContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_delete_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_update_delete_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_delete_partContext merge_update_delete_part() {
		Merge_update_delete_partContext _localctx = new Merge_update_delete_partContext(Context, State);
		EnterRule(_localctx, 854, RULE_merge_update_delete_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6691; Match(DELETE);
			State = 6692; where_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_insert_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode MATCHED() { return GetToken(PlSqlParser.MATCHED, 0); }
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_insert_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_insert_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_insert_clauseContext merge_insert_clause() {
		Merge_insert_clauseContext _localctx = new Merge_insert_clauseContext(Context, State);
		EnterRule(_localctx, 856, RULE_merge_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6694; Match(WHEN);
			State = 6695; Match(NOT);
			State = 6696; Match(MATCHED);
			State = 6697; Match(THEN);
			State = 6698; Match(INSERT);
			State = 6700;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 6699; paren_column_list();
				}
			}

			State = 6702; Match(VALUES);
			State = 6703; Match(LEFT_PAREN);
			State = 6705;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 6704; expressions();
				}
			}

			State = 6707; Match(RIGHT_PAREN);
			State = 6709;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 6708; where_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_tableviewContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Selected_tableviewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_tableview; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelected_tableview(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selected_tableviewContext selected_tableview() {
		Selected_tableviewContext _localctx = new Selected_tableviewContext(Context, State);
		EnterRule(_localctx, 858, RULE_selected_tableview);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6716;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 6711; tableview_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 6712; Match(LEFT_PAREN);
				State = 6713; select_statement();
				State = 6714; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 6719;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 6718; table_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_statementContext : ParserRuleContext {
		public ITerminalNode LOCK() { return GetToken(PlSqlParser.LOCK, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Lock_table_elementContext[] lock_table_element() {
			return GetRuleContexts<Lock_table_elementContext>();
		}
		public Lock_table_elementContext lock_table_element(int i) {
			return GetRuleContext<Lock_table_elementContext>(i);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Lock_modeContext lock_mode() {
			return GetRuleContext<Lock_modeContext>(0);
		}
		public ITerminalNode MODE() { return GetToken(PlSqlParser.MODE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Wait_nowait_partContext wait_nowait_part() {
			return GetRuleContext<Wait_nowait_partContext>(0);
		}
		public Lock_table_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_statementContext lock_table_statement() {
		Lock_table_statementContext _localctx = new Lock_table_statementContext(Context, State);
		EnterRule(_localctx, 860, RULE_lock_table_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6721; Match(LOCK);
			State = 6722; Match(TABLE);
			State = 6723; lock_table_element();
			State = 6728;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6724; Match(COMMA);
				State = 6725; lock_table_element();
				}
				}
				State = 6730;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 6731; Match(IN);
			State = 6732; lock_mode();
			State = 6733; Match(MODE);
			State = 6735;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,936,Context) ) {
			case 1:
				{
				State = 6734; wait_nowait_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Wait_nowait_partContext : ParserRuleContext {
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public Wait_nowait_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_wait_nowait_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWait_nowait_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Wait_nowait_partContext wait_nowait_part() {
		Wait_nowait_partContext _localctx = new Wait_nowait_partContext(Context, State);
		EnterRule(_localctx, 862, RULE_wait_nowait_part);
		try {
			State = 6740;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6737; Match(WAIT);
				State = 6738; expression();
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6739; Match(NOWAIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_elementContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Lock_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_elementContext lock_table_element() {
		Lock_table_elementContext _localctx = new Lock_table_elementContext(Context, State);
		EnterRule(_localctx, 864, RULE_lock_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6742; tableview_name();
			State = 6744;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION || _la==SUBPARTITION) {
				{
				State = 6743; partition_extension_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_modeContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode SHARE() { return GetToken(PlSqlParser.SHARE, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(PlSqlParser.EXCLUSIVE, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public Lock_modeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_mode; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_mode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_modeContext lock_mode() {
		Lock_modeContext _localctx = new Lock_modeContext(Context, State);
		EnterRule(_localctx, 866, RULE_lock_mode);
		int _la;
		try {
			State = 6758;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,940,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6746; Match(ROW);
				State = 6747; Match(SHARE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6748; Match(ROW);
				State = 6749; Match(EXCLUSIVE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6750; Match(SHARE);
				State = 6752;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UPDATE) {
					{
					State = 6751; Match(UPDATE);
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6754; Match(SHARE);
				State = 6755; Match(ROW);
				State = 6756; Match(EXCLUSIVE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6757; Match(EXCLUSIVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_table_refContext : ParserRuleContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public General_table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_table_ref; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_table_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_table_refContext general_table_ref() {
		General_table_refContext _localctx = new General_table_refContext(Context, State);
		EnterRule(_localctx, 868, RULE_general_table_ref);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6766;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,941,Context) ) {
			case 1:
				{
				State = 6760; dml_table_expression_clause();
				}
				break;
			case 2:
				{
				State = 6761; Match(ONLY);
				State = 6762; Match(LEFT_PAREN);
				State = 6763; dml_table_expression_clause();
				State = 6764; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 6769;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,942,Context) ) {
			case 1:
				{
				State = 6768; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Static_returning_clauseContext : ParserRuleContext {
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Static_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_static_returning_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatic_returning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Static_returning_clauseContext static_returning_clause() {
		Static_returning_clauseContext _localctx = new Static_returning_clauseContext(Context, State);
		EnterRule(_localctx, 870, RULE_static_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6771;
			_la = TokenStream.LA(1);
			if ( !(_la==RETURNING || _la==RETURN) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6772; expressions();
			State = 6773; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_clauseContext : ParserRuleContext {
		public ITerminalNode LOG() { return GetToken(PlSqlParser.LOG, 0); }
		public ITerminalNode ERRORS() { return GetToken(PlSqlParser.ERRORS, 0); }
		public Error_logging_into_partContext error_logging_into_part() {
			return GetRuleContext<Error_logging_into_partContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Error_logging_reject_partContext error_logging_reject_part() {
			return GetRuleContext<Error_logging_reject_partContext>(0);
		}
		public Error_logging_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_clauseContext error_logging_clause() {
		Error_logging_clauseContext _localctx = new Error_logging_clauseContext(Context, State);
		EnterRule(_localctx, 872, RULE_error_logging_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6775; Match(LOG);
			State = 6776; Match(ERRORS);
			State = 6778;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,943,Context) ) {
			case 1:
				{
				State = 6777; error_logging_into_part();
				}
				break;
			}
			State = 6781;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,944,Context) ) {
			case 1:
				{
				State = 6780; expression();
				}
				break;
			}
			State = 6784;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,945,Context) ) {
			case 1:
				{
				State = 6783; error_logging_reject_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_into_partContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Error_logging_into_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_into_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_into_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_into_partContext error_logging_into_part() {
		Error_logging_into_partContext _localctx = new Error_logging_into_partContext(Context, State);
		EnterRule(_localctx, 874, RULE_error_logging_into_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6786; Match(INTO);
			State = 6787; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_reject_partContext : ParserRuleContext {
		public ITerminalNode REJECT() { return GetToken(PlSqlParser.REJECT, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Error_logging_reject_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_reject_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_reject_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_reject_partContext error_logging_reject_part() {
		Error_logging_reject_partContext _localctx = new Error_logging_reject_partContext(Context, State);
		EnterRule(_localctx, 876, RULE_error_logging_reject_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6789; Match(REJECT);
			State = 6790; Match(LIMIT);
			State = 6793;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,946,Context) ) {
			case 1:
				{
				State = 6791; Match(UNLIMITED);
				}
				break;
			case 2:
				{
				State = 6792; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_table_expression_clauseContext : ParserRuleContext {
		public Table_collection_expressionContext table_collection_expression() {
			return GetRuleContext<Table_collection_expressionContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Subquery_restriction_clauseContext subquery_restriction_clause() {
			return GetRuleContext<Subquery_restriction_clauseContext>(0);
		}
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Sample_clauseContext sample_clause() {
			return GetRuleContext<Sample_clauseContext>(0);
		}
		public Dml_table_expression_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_table_expression_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_table_expression_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_table_expression_clauseContext dml_table_expression_clause() {
		Dml_table_expression_clauseContext _localctx = new Dml_table_expression_clauseContext(Context, State);
		EnterRule(_localctx, 878, RULE_dml_table_expression_clause);
		int _la;
		try {
			State = 6807;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TABLE:
			case THE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6795; table_collection_expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6796; Match(LEFT_PAREN);
				State = 6797; select_statement();
				State = 6799;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 6798; subquery_restriction_clause();
					}
				}

				State = 6801; Match(RIGHT_PAREN);
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6803; tableview_name();
				State = 6805;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,948,Context) ) {
				case 1:
					{
					State = 6804; sample_clause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_collection_expressionContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode THE() { return GetToken(PlSqlParser.THE, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode PLUS_SIGN() { return GetToken(PlSqlParser.PLUS_SIGN, 0); }
		public Table_collection_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_collection_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_collection_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_collection_expressionContext table_collection_expression() {
		Table_collection_expressionContext _localctx = new Table_collection_expressionContext(Context, State);
		EnterRule(_localctx, 880, RULE_table_collection_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6809;
			_la = TokenStream.LA(1);
			if ( !(_la==TABLE || _la==THE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 6822;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,951,Context) ) {
			case 1:
				{
				State = 6810; Match(LEFT_PAREN);
				State = 6811; subquery();
				State = 6812; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				{
				State = 6814; Match(LEFT_PAREN);
				State = 6815; expression();
				State = 6816; Match(RIGHT_PAREN);
				State = 6820;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,950,Context) ) {
				case 1:
					{
					State = 6817; Match(LEFT_PAREN);
					State = 6818; Match(PLUS_SIGN);
					State = 6819; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_restriction_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode CHECK() { return GetToken(PlSqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(PlSqlParser.OPTION, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Subquery_restriction_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_restriction_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_restriction_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_restriction_clauseContext subquery_restriction_clause() {
		Subquery_restriction_clauseContext _localctx = new Subquery_restriction_clauseContext(Context, State);
		EnterRule(_localctx, 882, RULE_subquery_restriction_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6824; Match(WITH);
			State = 6833;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case READ:
				{
				State = 6825; Match(READ);
				State = 6826; Match(ONLY);
				}
				break;
			case CHECK:
				{
				State = 6827; Match(CHECK);
				State = 6828; Match(OPTION);
				State = 6831;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 6829; Match(CONSTRAINT);
					State = 6830; constraint_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sample_clauseContext : ParserRuleContext {
		public ITerminalNode SAMPLE() { return GetToken(PlSqlParser.SAMPLE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode BLOCK() { return GetToken(PlSqlParser.BLOCK, 0); }
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public Seed_partContext seed_part() {
			return GetRuleContext<Seed_partContext>(0);
		}
		public Sample_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sample_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSample_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sample_clauseContext sample_clause() {
		Sample_clauseContext _localctx = new Sample_clauseContext(Context, State);
		EnterRule(_localctx, 884, RULE_sample_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6835; Match(SAMPLE);
			State = 6837;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BLOCK) {
				{
				State = 6836; Match(BLOCK);
				}
			}

			State = 6839; Match(LEFT_PAREN);
			State = 6840; expression();
			State = 6843;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 6841; Match(COMMA);
				State = 6842; expression();
				}
			}

			State = 6845; Match(RIGHT_PAREN);
			State = 6847;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,956,Context) ) {
			case 1:
				{
				State = 6846; seed_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seed_partContext : ParserRuleContext {
		public ITerminalNode SEED() { return GetToken(PlSqlParser.SEED, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Seed_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seed_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeed_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seed_partContext seed_part() {
		Seed_partContext _localctx = new Seed_partContext(Context, State);
		EnterRule(_localctx, 886, RULE_seed_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6849; Match(SEED);
			State = 6850; Match(LEFT_PAREN);
			State = 6851; expression();
			State = 6852; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(Context, State);
		EnterRule(_localctx, 888, RULE_condition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6854; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ExpressionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionsContext expressions() {
		ExpressionsContext _localctx = new ExpressionsContext(Context, State);
		EnterRule(_localctx, 890, RULE_expressions);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6856; expression();
			State = 6861;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,957,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 6857; Match(COMMA);
					State = 6858; expression();
					}
					} 
				}
				State = 6863;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,957,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public Cursor_expressionContext cursor_expression() {
			return GetRuleContext<Cursor_expressionContext>(0);
		}
		public Logical_expressionContext logical_expression() {
			return GetRuleContext<Logical_expressionContext>(0);
		}
		public ITerminalNode VARIABLE_SESSION() { return GetToken(PlSqlParser.VARIABLE_SESSION, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 892, RULE_expression);
		try {
			State = 6867;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,958,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6864; cursor_expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6865; logical_expression(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6866; Match(VARIABLE_SESSION);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_expressionContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Cursor_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_expressionContext cursor_expression() {
		Cursor_expressionContext _localctx = new Cursor_expressionContext(Context, State);
		EnterRule(_localctx, 894, RULE_cursor_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6869; Match(CURSOR);
			State = 6870; Match(LEFT_PAREN);
			State = 6871; subquery();
			State = 6872; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Logical_expressionContext : ParserRuleContext {
		public Type_specContext type_spec1;
		public Multiset_expressionContext multiset_expression() {
			return GetRuleContext<Multiset_expressionContext>(0);
		}
		public ITerminalNode[] IS() { return GetTokens(PlSqlParser.IS); }
		public ITerminalNode IS(int i) {
			return GetToken(PlSqlParser.IS, i);
		}
		public ITerminalNode[] NULL() { return GetTokens(PlSqlParser.NULL); }
		public ITerminalNode NULL(int i) {
			return GetToken(PlSqlParser.NULL, i);
		}
		public ITerminalNode[] NAN() { return GetTokens(PlSqlParser.NAN); }
		public ITerminalNode NAN(int i) {
			return GetToken(PlSqlParser.NAN, i);
		}
		public ITerminalNode[] PRESENT() { return GetTokens(PlSqlParser.PRESENT); }
		public ITerminalNode PRESENT(int i) {
			return GetToken(PlSqlParser.PRESENT, i);
		}
		public ITerminalNode[] INFINITE() { return GetTokens(PlSqlParser.INFINITE); }
		public ITerminalNode INFINITE(int i) {
			return GetToken(PlSqlParser.INFINITE, i);
		}
		public ITerminalNode[] A_LETTER() { return GetTokens(PlSqlParser.A_LETTER); }
		public ITerminalNode A_LETTER(int i) {
			return GetToken(PlSqlParser.A_LETTER, i);
		}
		public ITerminalNode[] SET() { return GetTokens(PlSqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(PlSqlParser.SET, i);
		}
		public ITerminalNode[] EMPTY() { return GetTokens(PlSqlParser.EMPTY); }
		public ITerminalNode EMPTY(int i) {
			return GetToken(PlSqlParser.EMPTY, i);
		}
		public ITerminalNode[] OF() { return GetTokens(PlSqlParser.OF); }
		public ITerminalNode OF(int i) {
			return GetToken(PlSqlParser.OF, i);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode[] NOT() { return GetTokens(PlSqlParser.NOT); }
		public ITerminalNode NOT(int i) {
			return GetToken(PlSqlParser.NOT, i);
		}
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode[] TYPE() { return GetTokens(PlSqlParser.TYPE); }
		public ITerminalNode TYPE(int i) {
			return GetToken(PlSqlParser.TYPE, i);
		}
		public ITerminalNode[] ONLY() { return GetTokens(PlSqlParser.ONLY); }
		public ITerminalNode ONLY(int i) {
			return GetToken(PlSqlParser.ONLY, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Logical_expressionContext[] logical_expression() {
			return GetRuleContexts<Logical_expressionContext>();
		}
		public Logical_expressionContext logical_expression(int i) {
			return GetRuleContext<Logical_expressionContext>(i);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public Logical_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logical_expressionContext logical_expression() {
		return logical_expression(0);
	}

	private Logical_expressionContext logical_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Logical_expressionContext _localctx = new Logical_expressionContext(Context, _parentState);
		Logical_expressionContext _prevctx = _localctx;
		int _startState = 896;
		EnterRecursionRule(_localctx, 896, RULE_logical_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6914;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 6875; multiset_expression();
				State = 6909;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,964,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 6876; Match(IS);
						State = 6878;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6877; Match(NOT);
							}
						}

						State = 6905;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case NULL:
							{
							State = 6880; Match(NULL);
							}
							break;
						case NAN:
							{
							State = 6881; Match(NAN);
							}
							break;
						case PRESENT:
							{
							State = 6882; Match(PRESENT);
							}
							break;
						case INFINITE:
							{
							State = 6883; Match(INFINITE);
							}
							break;
						case A_LETTER:
							{
							State = 6884; Match(A_LETTER);
							State = 6885; Match(SET);
							}
							break;
						case EMPTY:
							{
							State = 6886; Match(EMPTY);
							}
							break;
						case OF:
							{
							State = 6887; Match(OF);
							State = 6889;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==TYPE) {
								{
								State = 6888; Match(TYPE);
								}
							}

							State = 6891; Match(LEFT_PAREN);
							State = 6893;
							ErrorHandler.Sync(this);
							switch ( Interpreter.AdaptivePredict(TokenStream,961,Context) ) {
							case 1:
								{
								State = 6892; Match(ONLY);
								}
								break;
							}
							State = 6895; _localctx.type_spec1 = type_spec();
							State = 6900;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							while (_la==COMMA) {
								{
								{
								State = 6896; Match(COMMA);
								State = 6897; type_spec();
								}
								}
								State = 6902;
								ErrorHandler.Sync(this);
								_la = TokenStream.LA(1);
							}
							State = 6903; Match(RIGHT_PAREN);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						} 
					}
					State = 6911;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,964,Context);
				}
				}
				break;
			case NOT:
				{
				State = 6912; Match(NOT);
				State = 6913; logical_expression(3);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6924;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,967,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 6922;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,966,Context) ) {
					case 1:
						{
						_localctx = new Logical_expressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_logical_expression);
						State = 6916;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 6917; Match(AND);
						State = 6918; logical_expression(3);
						}
						break;
					case 2:
						{
						_localctx = new Logical_expressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_logical_expression);
						State = 6919;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 6920; Match(OR);
						State = 6921; logical_expression(2);
						}
						break;
					}
					} 
				}
				State = 6926;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,967,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Multiset_expressionContext : ParserRuleContext {
		public IToken multiset_type;
		public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(PlSqlParser.SUBMULTISET, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Multiset_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiset_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_expressionContext multiset_expression() {
		Multiset_expressionContext _localctx = new Multiset_expressionContext(Context, State);
		EnterRule(_localctx, 898, RULE_multiset_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6927; relational_expression(0);
			State = 6933;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,969,Context) ) {
			case 1:
				{
				State = 6928;
				_localctx.multiset_type = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MEMBER || _la==SUBMULTISET) ) {
					_localctx.multiset_type = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6930;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OF) {
					{
					State = 6929; Match(OF);
					}
				}

				State = 6932; concatenation(0);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_expressionContext : ParserRuleContext {
		public Relational_operatorContext op;
		public Compound_expressionContext compound_expression() {
			return GetRuleContext<Compound_expressionContext>(0);
		}
		public Relational_expressionContext[] relational_expression() {
			return GetRuleContexts<Relational_expressionContext>();
		}
		public Relational_expressionContext relational_expression(int i) {
			return GetRuleContext<Relational_expressionContext>(i);
		}
		public Relational_operatorContext relational_operator() {
			return GetRuleContext<Relational_operatorContext>(0);
		}
		public Relational_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_expressionContext relational_expression() {
		return relational_expression(0);
	}

	private Relational_expressionContext relational_expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Relational_expressionContext _localctx = new Relational_expressionContext(Context, _parentState);
		Relational_expressionContext _prevctx = _localctx;
		int _startState = 900;
		EnterRecursionRule(_localctx, 900, RULE_relational_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 6936; compound_expression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6944;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,970,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Relational_expressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_relational_expression);
					State = 6938;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 6939; _localctx.op = relational_operator();
					State = 6940; relational_expression(3);
					}
					} 
				}
				State = 6946;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,970,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Simple_expressionContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode PERIOD() { return GetToken(PlSqlParser.PERIOD, 0); }
		public Query_nameContext query_name() {
			return GetRuleContext<Query_nameContext>(0);
		}
		public Id_expressionsContext id_expressions() {
			return GetRuleContext<Id_expressionsContext>(0);
		}
		public ITerminalNode ROWNUM() { return GetToken(PlSqlParser.ROWNUM, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public ITerminalNode CURRVAL() { return GetToken(PlSqlParser.CURRVAL, 0); }
		public ITerminalNode NEXTVAL() { return GetToken(PlSqlParser.NEXTVAL, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Simple_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_expressionContext simple_expression() {
		Simple_expressionContext _localctx = new Simple_expressionContext(Context, State);
		EnterRule(_localctx, 902, RULE_simple_expression);
		int _la;
		try {
			State = 6967;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,974,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6953;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,972,Context) ) {
				case 1:
					{
					State = 6949;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,971,Context) ) {
					case 1:
						{
						State = 6947; query_name();
						}
						break;
					case 2:
						{
						State = 6948; id_expressions();
						}
						break;
					}
					State = 6951; Match(PERIOD);
					}
					break;
				}
				State = 6957;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,973,Context) ) {
				case 1:
					{
					State = 6955; column_name();
					}
					break;
				case 2:
					{
					State = 6956; Match(ROWID);
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6959; Match(ROWNUM);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6960; @string();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6961; numeric();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6962; sequence_name();
				State = 6963; Match(PERIOD);
				State = 6964;
				_la = TokenStream.LA(1);
				if ( !(_la==CURRVAL || _la==NEXTVAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 6966; Match(NULL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_expressionContext : ParserRuleContext {
		public ConcatenationContext concatenation1;
		public IToken like_type;
		public ConcatenationContext concatenation2;
		public ConcatenationContext concatenation3;
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public In_elementsContext in_elements() {
			return GetRuleContext<In_elementsContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public Between_elementsContext between_elements() {
			return GetRuleContext<Between_elementsContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode LIKE() { return GetToken(PlSqlParser.LIKE, 0); }
		public ITerminalNode LIKEC() { return GetToken(PlSqlParser.LIKEC, 0); }
		public ITerminalNode LIKE2() { return GetToken(PlSqlParser.LIKE2, 0); }
		public ITerminalNode LIKE4() { return GetToken(PlSqlParser.LIKE4, 0); }
		public ITerminalNode ESCAPE() { return GetToken(PlSqlParser.ESCAPE, 0); }
		public Compound_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_expressionContext compound_expression() {
		Compound_expressionContext _localctx = new Compound_expressionContext(Context, State);
		EnterRule(_localctx, 904, RULE_compound_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6969; _localctx.concatenation1 = concatenation(0);
			State = 6985;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,978,Context) ) {
			case 1:
				{
				State = 6971;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 6970; Match(NOT);
					}
				}

				State = 6983;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IN:
					{
					State = 6973; Match(IN);
					State = 6974; in_elements();
					}
					break;
				case BETWEEN:
					{
					State = 6975; Match(BETWEEN);
					State = 6976; between_elements();
					}
					break;
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIKE:
					{
					State = 6977;
					_localctx.like_type = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(((((_la - 299)) & ~0x3f) == 0 && ((1L << (_la - 299)) & ((1L << (LIKE2 - 299)) | (1L << (LIKE4 - 299)) | (1L << (LIKEC - 299)) | (1L << (LIKE - 299)))) != 0)) ) {
						_localctx.like_type = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 6978; _localctx.concatenation2 = concatenation(0);
					State = 6981;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,976,Context) ) {
					case 1:
						{
						State = 6979; Match(ESCAPE);
						State = 6980; _localctx.concatenation3 = concatenation(0);
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConcatenationContext : ParserRuleContext {
		public IToken op;
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public Interval_expressionContext interval_expression() {
			return GetRuleContext<Interval_expressionContext>(0);
		}
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public ITerminalNode SOLIDUS() { return GetToken(PlSqlParser.SOLIDUS, 0); }
		public ITerminalNode PLUS_SIGN() { return GetToken(PlSqlParser.PLUS_SIGN, 0); }
		public ITerminalNode MINUS_SIGN() { return GetToken(PlSqlParser.MINUS_SIGN, 0); }
		public ITerminalNode[] BAR() { return GetTokens(PlSqlParser.BAR); }
		public ITerminalNode BAR(int i) {
			return GetToken(PlSqlParser.BAR, i);
		}
		public ConcatenationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConcatenationContext concatenation() {
		return concatenation(0);
	}

	private ConcatenationContext concatenation(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ConcatenationContext _localctx = new ConcatenationContext(Context, _parentState);
		ConcatenationContext _prevctx = _localctx;
		int _startState = 906;
		EnterRecursionRule(_localctx, 906, RULE_concatenation, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 6988; model_expression();
			State = 6997;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,980,Context) ) {
			case 1:
				{
				State = 6989; Match(AT);
				State = 6994;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LOCAL:
					{
					State = 6990; Match(LOCAL);
					}
					break;
				case TIME:
					{
					State = 6991; Match(TIME);
					State = 6992; Match(ZONE);
					State = 6993; concatenation(0);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				{
				State = 6996; interval_expression();
				}
				break;
			}
			}
			Context.Stop = TokenStream.LT(-1);
			State = 7011;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,982,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 7009;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,981,Context) ) {
					case 1:
						{
						_localctx = new ConcatenationContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_concatenation);
						State = 6999;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 7000;
						_localctx.op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ASTERISK || _la==SOLIDUS) ) {
							_localctx.op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 7001; concatenation(4);
						}
						break;
					case 2:
						{
						_localctx = new ConcatenationContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_concatenation);
						State = 7002;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 7003;
						_localctx.op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==PLUS_SIGN || _la==MINUS_SIGN) ) {
							_localctx.op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 7004; concatenation(3);
						}
						break;
					case 3:
						{
						_localctx = new ConcatenationContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_concatenation);
						State = 7005;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 7006; Match(BAR);
						State = 7007; Match(BAR);
						State = 7008; concatenation(2);
						}
						break;
					}
					} 
				}
				State = 7013;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,982,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Relational_operatorContext : ParserRuleContext {
		public ITerminalNode NOT_EQUAL_OP() { return GetToken(PlSqlParser.NOT_EQUAL_OP, 0); }
		public Relational_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_operator; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_operatorContext relational_operator() {
		Relational_operatorContext _localctx = new Relational_operatorContext(Context, State);
		EnterRule(_localctx, 908, RULE_relational_operator);
		int _la;
		try {
			State = 7028;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,985,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7014; Match(EQUALS_OP);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7022;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NOT_EQUAL_OP:
					{
					State = 7015; Match(NOT_EQUAL_OP);
					}
					break;
				case LESS_THAN_OP:
					{
					State = 7016; Match(LESS_THAN_OP);
					State = 7017; Match(GREATER_THAN_OP);
					}
					break;
				case EXCLAMATION_OPERATOR_PART:
					{
					State = 7018; Match(EXCLAMATION_OPERATOR_PART);
					State = 7019; Match(EQUALS_OP);
					}
					break;
				case CARRET_OPERATOR_PART:
					{
					State = 7020; Match(CARRET_OPERATOR_PART);
					State = 7021; Match(EQUALS_OP);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7024;
				_la = TokenStream.LA(1);
				if ( !(_la==GREATER_THAN_OP || _la==LESS_THAN_OP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7026;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUALS_OP) {
					{
					State = 7025; Match(EQUALS_OP);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Model_expression_elementContext model_expression_element() {
			return GetRuleContext<Model_expression_elementContext>(0);
		}
		public Model_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_expressionContext model_expression() {
		Model_expressionContext _localctx = new Model_expressionContext(Context, State);
		EnterRule(_localctx, 910, RULE_model_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7030; unary_expression();
			State = 7035;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,986,Context) ) {
			case 1:
				{
				State = 7031; Match(LEFT_BRACKET);
				State = 7032; model_expression_element();
				State = 7033; Match(RIGHT_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class In_elementsContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public In_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_in_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIn_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public In_elementsContext in_elements() {
		In_elementsContext _localctx = new In_elementsContext(Context, State);
		EnterRule(_localctx, 912, RULE_in_elements);
		int _la;
		try {
			State = 7055;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,988,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7037; Match(LEFT_PAREN);
				State = 7038; subquery();
				State = 7039; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7041; Match(LEFT_PAREN);
				State = 7042; concatenation(0);
				State = 7047;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 7043; Match(COMMA);
					State = 7044; concatenation(0);
					}
					}
					State = 7049;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 7050; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7052; constant();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7053; bind_variable();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7054; general_element();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_elementsContext : ParserRuleContext {
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public Between_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetween_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Between_elementsContext between_elements() {
		Between_elementsContext _localctx = new Between_elementsContext(Context, State);
		EnterRule(_localctx, 914, RULE_between_elements);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7057; concatenation(0);
			State = 7058; Match(AND);
			State = 7059; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Interval_expressionContext : ParserRuleContext {
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public Interval_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interval_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterval_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Interval_expressionContext interval_expression() {
		Interval_expressionContext _localctx = new Interval_expressionContext(Context, State);
		EnterRule(_localctx, 916, RULE_interval_expression);
		int _la;
		try {
			State = 7085;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DAY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7061; Match(DAY);
				State = 7066;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 7062; Match(LEFT_PAREN);
					State = 7063; concatenation(0);
					State = 7064; Match(RIGHT_PAREN);
					}
				}

				State = 7068; Match(TO);
				State = 7069; Match(SECOND);
				State = 7074;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,990,Context) ) {
				case 1:
					{
					State = 7070; Match(LEFT_PAREN);
					State = 7071; concatenation(0);
					State = 7072; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7076; Match(YEAR);
				State = 7081;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 7077; Match(LEFT_PAREN);
					State = 7078; concatenation(0);
					State = 7079; Match(RIGHT_PAREN);
					}
				}

				State = 7083; Match(TO);
				State = 7084; Match(MONTH);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expression_elementContext : ParserRuleContext {
		public ITerminalNode[] ANY() { return GetTokens(PlSqlParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(PlSqlParser.ANY, i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Single_column_for_loopContext[] single_column_for_loop() {
			return GetRuleContexts<Single_column_for_loopContext>();
		}
		public Single_column_for_loopContext single_column_for_loop(int i) {
			return GetRuleContext<Single_column_for_loopContext>(i);
		}
		public Multi_column_for_loopContext multi_column_for_loop() {
			return GetRuleContext<Multi_column_for_loopContext>(0);
		}
		public Model_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_expression_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_expression_elementContext model_expression_element() {
		Model_expression_elementContext _localctx = new Model_expression_elementContext(Context, State);
		EnterRule(_localctx, 918, RULE_model_expression_element);
		int _la;
		try {
			State = 7110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,997,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7089;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,993,Context) ) {
				case 1:
					{
					State = 7087; Match(ANY);
					}
					break;
				case 2:
					{
					State = 7088; expression();
					}
					break;
				}
				State = 7098;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 7091; Match(COMMA);
					State = 7094;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,994,Context) ) {
					case 1:
						{
						State = 7092; Match(ANY);
						}
						break;
					case 2:
						{
						State = 7093; expression();
						}
						break;
					}
					}
					}
					State = 7100;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7101; single_column_for_loop();
				State = 7106;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 7102; Match(COMMA);
					State = 7103; single_column_for_loop();
					}
					}
					State = 7108;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7109; multi_column_for_loop();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_column_for_loopContext : ParserRuleContext {
		public ExpressionContext fromExpr;
		public ExpressionContext toExpr;
		public IToken action_type;
		public ExpressionContext action_expr;
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode DECREMENT() { return GetToken(PlSqlParser.DECREMENT, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode LIKE() { return GetToken(PlSqlParser.LIKE, 0); }
		public Single_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_column_for_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingle_column_for_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Single_column_for_loopContext single_column_for_loop() {
		Single_column_for_loopContext _localctx = new Single_column_for_loopContext(Context, State);
		EnterRule(_localctx, 920, RULE_single_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7112; Match(FOR);
			State = 7113; column_name();
			State = 7131;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IN:
				{
				State = 7114; Match(IN);
				State = 7115; Match(LEFT_PAREN);
				State = 7117;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 7116; expressions();
					}
				}

				State = 7119; Match(RIGHT_PAREN);
				}
				break;
			case FROM:
			case LIKE:
				{
				State = 7122;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE) {
					{
					State = 7120; Match(LIKE);
					State = 7121; expression();
					}
				}

				State = 7124; Match(FROM);
				State = 7125; _localctx.fromExpr = expression();
				State = 7126; Match(TO);
				State = 7127; _localctx.toExpr = expression();
				State = 7128;
				_localctx.action_type = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DECREMENT || _la==INCREMENT) ) {
					_localctx.action_type = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7129; _localctx.action_expr = expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_column_for_loopContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Paren_column_listContext paren_column_list() {
			return GetRuleContext<Paren_column_listContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Multi_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_column_for_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_column_for_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_column_for_loopContext multi_column_for_loop() {
		Multi_column_for_loopContext _localctx = new Multi_column_for_loopContext(Context, State);
		EnterRule(_localctx, 922, RULE_multi_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7133; Match(FOR);
			State = 7134; paren_column_list();
			State = 7135; Match(IN);
			State = 7136; Match(LEFT_PAREN);
			State = 7143;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1002,Context) ) {
			case 1:
				{
				State = 7137; subquery();
				}
				break;
			case 2:
				{
				State = 7138; Match(LEFT_PAREN);
				State = 7140;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 7139; expressions();
					}
				}

				State = 7142; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 7145; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public ITerminalNode MINUS_SIGN() { return GetToken(PlSqlParser.MINUS_SIGN, 0); }
		public ITerminalNode PLUS_SIGN() { return GetToken(PlSqlParser.PLUS_SIGN, 0); }
		public ITerminalNode PRIOR() { return GetToken(PlSqlParser.PRIOR, 0); }
		public ITerminalNode CONNECT_BY_ROOT() { return GetToken(PlSqlParser.CONNECT_BY_ROOT, 0); }
		public Standard_functionContext standard_function() {
			return GetRuleContext<Standard_functionContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(PlSqlParser.NEW, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Quantified_expressionContext quantified_expression() {
			return GetRuleContext<Quantified_expressionContext>(0);
		}
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public Unary_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_expressionContext unary_expression() {
		Unary_expressionContext _localctx = new Unary_expressionContext(Context, State);
		EnterRule(_localctx, 924, RULE_unary_expression);
		int _la;
		try {
			State = 7163;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1003,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7147;
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS_SIGN || _la==MINUS_SIGN) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7148; unary_expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7149; Match(PRIOR);
				State = 7150; unary_expression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7151; Match(CONNECT_BY_ROOT);
				State = 7152; unary_expression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7153; standard_function();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7154; Match(NEW);
				State = 7155; unary_expression();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7156; Match(DISTINCT);
				State = 7157; unary_expression();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7158; Match(ALL);
				State = 7159; unary_expression();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7160; case_statement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 7161; quantified_expression();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 7162; atom();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_statementContext : ParserRuleContext {
		public Searched_case_statementContext searched_case_statement() {
			return GetRuleContext<Searched_case_statementContext>(0);
		}
		public Simple_case_statementContext simple_case_statement() {
			return GetRuleContext<Simple_case_statementContext>(0);
		}
		public Case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_statementContext case_statement() {
		Case_statementContext _localctx = new Case_statementContext(Context, State);
		EnterRule(_localctx, 926, RULE_case_statement);
		try {
			State = 7167;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1004,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7165; searched_case_statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7166; simple_case_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode[] CASE() { return GetTokens(PlSqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(PlSqlParser.CASE, i);
		}
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public Simple_case_when_partContext[] simple_case_when_part() {
			return GetRuleContexts<Simple_case_when_partContext>();
		}
		public Simple_case_when_partContext simple_case_when_part(int i) {
			return GetRuleContext<Simple_case_when_partContext>(i);
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public Simple_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_case_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_statementContext simple_case_statement() {
		Simple_case_statementContext _localctx = new Simple_case_statementContext(Context, State);
		EnterRule(_localctx, 928, RULE_simple_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7170;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 7169; label_name();
				}
			}

			State = 7172; _localctx.ck1 = Match(CASE);
			State = 7173; expression();
			State = 7175;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7174; simple_case_when_part();
				}
				}
				State = 7177;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 7180;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 7179; case_else_part();
				}
			}

			State = 7182; Match(END);
			State = 7184;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1008,Context) ) {
			case 1:
				{
				State = 7183; Match(CASE);
				}
				break;
			}
			State = 7187;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1009,Context) ) {
			case 1:
				{
				State = 7186; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Simple_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_when_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_case_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_when_partContext simple_case_when_part() {
		Simple_case_when_partContext _localctx = new Simple_case_when_partContext(Context, State);
		EnterRule(_localctx, 930, RULE_simple_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7189; Match(WHEN);
			State = 7190; expression();
			State = 7191; Match(THEN);
			State = 7194;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1010,Context) ) {
			case 1:
				{
				State = 7192; seq_of_statements();
				}
				break;
			case 2:
				{
				State = 7193; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode[] CASE() { return GetTokens(PlSqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(PlSqlParser.CASE, i);
		}
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public Searched_case_when_partContext[] searched_case_when_part() {
			return GetRuleContexts<Searched_case_when_partContext>();
		}
		public Searched_case_when_partContext searched_case_when_part(int i) {
			return GetRuleContext<Searched_case_when_partContext>(i);
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public Searched_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearched_case_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_statementContext searched_case_statement() {
		Searched_case_statementContext _localctx = new Searched_case_statementContext(Context, State);
		EnterRule(_localctx, 932, RULE_searched_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7197;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==REGULAR_ID) {
				{
				State = 7196; label_name();
				}
			}

			State = 7199; _localctx.ck1 = Match(CASE);
			State = 7201;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7200; searched_case_when_part();
				}
				}
				State = 7203;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 7206;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 7205; case_else_part();
				}
			}

			State = 7208; Match(END);
			State = 7210;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1014,Context) ) {
			case 1:
				{
				State = 7209; Match(CASE);
				}
				break;
			}
			State = 7213;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1015,Context) ) {
			case 1:
				{
				State = 7212; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Searched_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_when_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearched_case_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_when_partContext searched_case_when_part() {
		Searched_case_when_partContext _localctx = new Searched_case_when_partContext(Context, State);
		EnterRule(_localctx, 934, RULE_searched_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7215; Match(WHEN);
			State = 7216; expression();
			State = 7217; Match(THEN);
			State = 7220;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1016,Context) ) {
			case 1:
				{
				State = 7218; seq_of_statements();
				}
				break;
			case 2:
				{
				State = 7219; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Case_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_else_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_else_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_else_partContext case_else_part() {
		Case_else_partContext _localctx = new Case_else_partContext(Context, State);
		EnterRule(_localctx, 936, RULE_case_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7222; Match(ELSE);
			State = 7225;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1017,Context) ) {
			case 1:
				{
				State = 7223; seq_of_statements();
				}
				break;
			case 2:
				{
				State = 7224; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public Outer_join_signContext outer_join_sign() {
			return GetRuleContext<Outer_join_signContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 938, RULE_atom);
		try {
			int _alt;
			State = 7246;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1019,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7227; table_element();
				State = 7228; outer_join_sign();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7230; bind_variable();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7231; constant();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7232; general_element();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7233; Match(LEFT_PAREN);
				State = 7234; subquery();
				State = 7235; Match(RIGHT_PAREN);
				State = 7239;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1018,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 7236; subquery_operation_part();
						}
						} 
					}
					State = 7241;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,1018,Context);
				}
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7242; Match(LEFT_PAREN);
				State = 7243; expressions();
				State = 7244; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quantified_expressionContext : ParserRuleContext {
		public ITerminalNode SOME() { return GetToken(PlSqlParser.SOME, 0); }
		public ITerminalNode EXISTS() { return GetToken(PlSqlParser.EXISTS, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode ANY() { return GetToken(PlSqlParser.ANY, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Quantified_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantified_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantified_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quantified_expressionContext quantified_expression() {
		Quantified_expressionContext _localctx = new Quantified_expressionContext(Context, State);
		EnterRule(_localctx, 940, RULE_quantified_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7248;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==ANY || _la==EXISTS || _la==SOME) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7257;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1020,Context) ) {
			case 1:
				{
				State = 7249; Match(LEFT_PAREN);
				State = 7250; subquery();
				State = 7251; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				{
				State = 7253; Match(LEFT_PAREN);
				State = 7254; expression();
				State = 7255; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_functionContext : ParserRuleContext {
		public String_functionContext string_function() {
			return GetRuleContext<String_functionContext>(0);
		}
		public Numeric_function_wrapperContext numeric_function_wrapper() {
			return GetRuleContext<Numeric_function_wrapperContext>(0);
		}
		public Other_functionContext other_function() {
			return GetRuleContext<Other_functionContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Standard_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStandard_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Standard_functionContext standard_function() {
		Standard_functionContext _localctx = new Standard_functionContext(Context, State);
		EnterRule(_localctx, 942, RULE_standard_function);
		try {
			int _alt;
			State = 7275;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1023,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7259; string_function();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7260; numeric_function_wrapper();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7261; other_function();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7262; id_expression();
				State = 7263; Match(LEFT_PAREN);
				State = 7264; expression();
				State = 7269;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1021,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 7265; Match(COMMA);
						State = 7266; expression();
						}
						} 
					}
					State = 7271;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,1021,Context);
				}
				State = 7273;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1022,Context) ) {
				case 1:
					{
					State = 7272; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_functionContext : ParserRuleContext {
		public StringContext string1;
		public StringContext string2;
		public ITerminalNode SUBSTR() { return GetToken(PlSqlParser.SUBSTR, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode TO_CHAR() { return GetToken(PlSqlParser.TO_CHAR, 0); }
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public Standard_functionContext standard_function() {
			return GetRuleContext<Standard_functionContext>(0);
		}
		public StringContext[] @string() {
			return GetRuleContexts<StringContext>();
		}
		public StringContext @string(int i) {
			return GetRuleContext<StringContext>(i);
		}
		public ITerminalNode DECODE() { return GetToken(PlSqlParser.DECODE, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode CHR() { return GetToken(PlSqlParser.CHR, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(PlSqlParser.NCHAR_CS, 0); }
		public ITerminalNode TRIM() { return GetToken(PlSqlParser.TRIM, 0); }
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode LEADING() { return GetToken(PlSqlParser.LEADING, 0); }
		public ITerminalNode TRAILING() { return GetToken(PlSqlParser.TRAILING, 0); }
		public ITerminalNode BOTH() { return GetToken(PlSqlParser.BOTH, 0); }
		public String_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_functionContext string_function() {
		String_functionContext _localctx = new String_functionContext(Context, State);
		EnterRule(_localctx, 944, RULE_string_function);
		int _la;
		try {
			State = 7331;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUBSTR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7277; Match(SUBSTR);
				State = 7278; Match(LEFT_PAREN);
				State = 7279; expression();
				State = 7280; Match(COMMA);
				State = 7281; expression();
				State = 7284;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7282; Match(COMMA);
					State = 7283; expression();
					}
				}

				State = 7286; Match(RIGHT_PAREN);
				}
				break;
			case TO_CHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7288; Match(TO_CHAR);
				State = 7289; Match(LEFT_PAREN);
				State = 7293;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1025,Context) ) {
				case 1:
					{
					State = 7290; table_element();
					}
					break;
				case 2:
					{
					State = 7291; standard_function();
					}
					break;
				case 3:
					{
					State = 7292; expression();
					}
					break;
				}
				State = 7297;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1026,Context) ) {
				case 1:
					{
					State = 7295; Match(COMMA);
					State = 7296; _localctx.string1 = @string();
					}
					break;
				}
				State = 7301;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7299; Match(COMMA);
					State = 7300; _localctx.string2 = @string();
					}
				}

				State = 7303; Match(RIGHT_PAREN);
				}
				break;
			case DECODE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7305; Match(DECODE);
				State = 7306; Match(LEFT_PAREN);
				State = 7307; expressions();
				State = 7308; Match(RIGHT_PAREN);
				}
				break;
			case CHR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7310; Match(CHR);
				State = 7311; Match(LEFT_PAREN);
				State = 7312; concatenation(0);
				State = 7313; Match(USING);
				State = 7314; Match(NCHAR_CS);
				State = 7315; Match(RIGHT_PAREN);
				}
				break;
			case TRIM:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7317; Match(TRIM);
				State = 7318; Match(LEFT_PAREN);
				State = 7326;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1030,Context) ) {
				case 1:
					{
					State = 7320;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==BOTH || _la==LEADING || _la==TRAILING) {
						{
						State = 7319;
						_la = TokenStream.LA(1);
						if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 7323;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) {
						{
						State = 7322; _localctx.string1 = @string();
						}
					}

					State = 7325; Match(FROM);
					}
					break;
				}
				State = 7328; concatenation(0);
				State = 7329; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_function_wrapperContext : ParserRuleContext {
		public Numeric_functionContext numeric_function() {
			return GetRuleContext<Numeric_functionContext>(0);
		}
		public Single_column_for_loopContext single_column_for_loop() {
			return GetRuleContext<Single_column_for_loopContext>(0);
		}
		public Multi_column_for_loopContext multi_column_for_loop() {
			return GetRuleContext<Multi_column_for_loopContext>(0);
		}
		public Numeric_function_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_function_wrapper; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_function_wrapper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_function_wrapperContext numeric_function_wrapper() {
		Numeric_function_wrapperContext _localctx = new Numeric_function_wrapperContext(Context, State);
		EnterRule(_localctx, 946, RULE_numeric_function_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7333; numeric_function();
			State = 7336;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1032,Context) ) {
			case 1:
				{
				State = 7334; single_column_for_loop();
				}
				break;
			case 2:
				{
				State = 7335; multi_column_for_loop();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_functionContext : ParserRuleContext {
		public ITerminalNode SUM() { return GetToken(PlSqlParser.SUM, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode ROUND() { return GetToken(PlSqlParser.ROUND, 0); }
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode AVG() { return GetToken(PlSqlParser.AVG, 0); }
		public ITerminalNode MAX() { return GetToken(PlSqlParser.MAX, 0); }
		public ITerminalNode LEAST() { return GetToken(PlSqlParser.LEAST, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode GREATEST() { return GetToken(PlSqlParser.GREATEST, 0); }
		public Numeric_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_functionContext numeric_function() {
		Numeric_functionContext _localctx = new Numeric_functionContext(Context, State);
		EnterRule(_localctx, 948, RULE_numeric_function);
		int _la;
		try {
			State = 7396;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUM:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7338; Match(SUM);
				State = 7339; Match(LEFT_PAREN);
				State = 7341;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1033,Context) ) {
				case 1:
					{
					State = 7340;
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 7343; expression();
				State = 7344; Match(RIGHT_PAREN);
				}
				break;
			case COUNT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7346; Match(COUNT);
				State = 7347; Match(LEFT_PAREN);
				State = 7355;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ASTERISK:
					{
					State = 7348; Match(ASTERISK);
					}
					break;
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ALL:
				case ANALYZE:
				case ANY:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COALESCE:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIOR:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUE:
				case TRUNCATE:
				case TRUNC:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNIQUE:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case DECODE:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case NVL:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROUND:
				case ROW_NUMBER:
				case SUBSTR:
				case TO_CHAR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case LEAST:
				case GREATEST:
				case TO_DATE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case RIGHT_PAREN:
				case PLUS_SIGN:
				case MINUS_SIGN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 7353;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNIQUE - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 7350;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,1034,Context) ) {
						case 1:
							{
							State = 7349;
							_la = TokenStream.LA(1);
							if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
							ErrorHandler.RecoverInline(this);
							}
							else {
								ErrorHandler.ReportMatch(this);
							    Consume();
							}
							}
							break;
						}
						State = 7352; concatenation(0);
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 7357; Match(RIGHT_PAREN);
				State = 7359;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1037,Context) ) {
				case 1:
					{
					State = 7358; over_clause();
					}
					break;
				}
				}
				break;
			case ROUND:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7361; Match(ROUND);
				State = 7362; Match(LEFT_PAREN);
				State = 7363; expression();
				State = 7366;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7364; Match(COMMA);
					State = 7365; Match(UNSIGNED_INTEGER);
					}
				}

				State = 7368; Match(RIGHT_PAREN);
				}
				break;
			case AVG:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7370; Match(AVG);
				State = 7371; Match(LEFT_PAREN);
				State = 7373;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1039,Context) ) {
				case 1:
					{
					State = 7372;
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 7375; expression();
				State = 7376; Match(RIGHT_PAREN);
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7378; Match(MAX);
				State = 7379; Match(LEFT_PAREN);
				State = 7381;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1040,Context) ) {
				case 1:
					{
					State = 7380;
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 7383; expression();
				State = 7384; Match(RIGHT_PAREN);
				}
				break;
			case LEAST:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7386; Match(LEAST);
				State = 7387; Match(LEFT_PAREN);
				State = 7388; expressions();
				State = 7389; Match(RIGHT_PAREN);
				}
				break;
			case GREATEST:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7391; Match(GREATEST);
				State = 7392; Match(LEFT_PAREN);
				State = 7393; expressions();
				State = 7394; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class To_dateContext : ParserRuleContext {
		public StringContext string1;
		public ITerminalNode TO_DATE() { return GetToken(PlSqlParser.TO_DATE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public To_dateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_to_date; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTo_date(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public To_dateContext to_date() {
		To_dateContext _localctx = new To_dateContext(Context, State);
		EnterRule(_localctx, 950, RULE_to_date);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7398; Match(TO_DATE);
			State = 7399; Match(LEFT_PAREN);
			State = 7400; expression();
			State = 7403;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 7401; Match(COMMA);
				State = 7402; _localctx.string1 = @string();
				}
			}

			State = 7405; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Other_functionContext : ParserRuleContext {
		public Over_clause_keywordContext over_clause_keyword() {
			return GetRuleContext<Over_clause_keywordContext>(0);
		}
		public Function_argument_analyticContext function_argument_analytic() {
			return GetRuleContext<Function_argument_analyticContext>(0);
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public Function_argument_modelingContext function_argument_modeling() {
			return GetRuleContext<Function_argument_modelingContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public ITerminalNode NVL() { return GetToken(PlSqlParser.NVL, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public To_dateContext to_date() {
			return GetRuleContext<To_dateContext>(0);
		}
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CAST() { return GetToken(PlSqlParser.CAST, 0); }
		public ITerminalNode XMLCAST() { return GetToken(PlSqlParser.XMLCAST, 0); }
		public ITerminalNode MULTISET() { return GetToken(PlSqlParser.MULTISET, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode COALESCE() { return GetToken(PlSqlParser.COALESCE, 0); }
		public Logical_expressionContext[] logical_expression() {
			return GetRuleContexts<Logical_expressionContext>();
		}
		public Logical_expressionContext logical_expression(int i) {
			return GetRuleContext<Logical_expressionContext>(i);
		}
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public Collect_order_by_partContext collect_order_by_part() {
			return GetRuleContext<Collect_order_by_partContext>(0);
		}
		public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
			return GetRuleContext<Within_or_over_clause_keywordContext>(0);
		}
		public Function_argumentsContext function_arguments() {
			return GetRuleContext<Function_argumentsContext>(0);
		}
		public Within_or_over_partContext[] within_or_over_part() {
			return GetRuleContexts<Within_or_over_partContext>();
		}
		public Within_or_over_partContext within_or_over_part(int i) {
			return GetRuleContext<Within_or_over_partContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode PERCENT_ISOPEN() { return GetToken(PlSqlParser.PERCENT_ISOPEN, 0); }
		public ITerminalNode PERCENT_FOUND() { return GetToken(PlSqlParser.PERCENT_FOUND, 0); }
		public ITerminalNode PERCENT_NOTFOUND() { return GetToken(PlSqlParser.PERCENT_NOTFOUND, 0); }
		public ITerminalNode PERCENT_ROWCOUNT() { return GetToken(PlSqlParser.PERCENT_ROWCOUNT, 0); }
		public ITerminalNode DECOMPOSE() { return GetToken(PlSqlParser.DECOMPOSE, 0); }
		public ITerminalNode CANONICAL() { return GetToken(PlSqlParser.CANONICAL, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(PlSqlParser.COMPATIBILITY, 0); }
		public ITerminalNode EXTRACT() { return GetToken(PlSqlParser.EXTRACT, 0); }
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(PlSqlParser.FIRST_VALUE, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(PlSqlParser.LAST_VALUE, 0); }
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
			return GetRuleContext<Respect_or_ignore_nullsContext>(0);
		}
		public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
			return GetRuleContext<Standard_prediction_function_keywordContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Cost_matrix_clauseContext cost_matrix_clause() {
			return GetRuleContext<Cost_matrix_clauseContext>(0);
		}
		public ITerminalNode TRANSLATE() { return GetToken(PlSqlParser.TRANSLATE, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(PlSqlParser.CHAR_CS, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(PlSqlParser.NCHAR_CS, 0); }
		public StringContext[] @string() {
			return GetRuleContexts<StringContext>();
		}
		public StringContext @string(int i) {
			return GetRuleContext<StringContext>(i);
		}
		public ITerminalNode TREAT() { return GetToken(PlSqlParser.TREAT, 0); }
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode XMLAGG() { return GetToken(PlSqlParser.XMLAGG, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public ITerminalNode XMLCOLATTVAL() { return GetToken(PlSqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(PlSqlParser.XMLFOREST, 0); }
		public Xml_multiuse_expression_elementContext[] xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode XMLELEMENT() { return GetToken(PlSqlParser.XMLELEMENT, 0); }
		public Xml_attributes_clauseContext xml_attributes_clause() {
			return GetRuleContext<Xml_attributes_clauseContext>(0);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(PlSqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(PlSqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode EVALNAME() { return GetToken(PlSqlParser.EVALNAME, 0); }
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public ITerminalNode XMLEXISTS() { return GetToken(PlSqlParser.XMLEXISTS, 0); }
		public Xml_passing_clauseContext xml_passing_clause() {
			return GetRuleContext<Xml_passing_clauseContext>(0);
		}
		public ITerminalNode XMLPARSE() { return GetToken(PlSqlParser.XMLPARSE, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlSqlParser.DOCUMENT, 0); }
		public ITerminalNode CONTENT() { return GetToken(PlSqlParser.CONTENT, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(PlSqlParser.WELLFORMED, 0); }
		public ITerminalNode XMLPI() { return GetToken(PlSqlParser.XMLPI, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode XMLQUERY() { return GetToken(PlSqlParser.XMLQUERY, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode EMPTY() { return GetToken(PlSqlParser.EMPTY, 0); }
		public ITerminalNode XMLROOT() { return GetToken(PlSqlParser.XMLROOT, 0); }
		public Xmlroot_param_version_partContext xmlroot_param_version_part() {
			return GetRuleContext<Xmlroot_param_version_partContext>(0);
		}
		public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
			return GetRuleContext<Xmlroot_param_standalone_partContext>(0);
		}
		public ITerminalNode XMLSERIALIZE() { return GetToken(PlSqlParser.XMLSERIALIZE, 0); }
		public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
			return GetRuleContext<Xmlserialize_param_enconding_partContext>(0);
		}
		public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
			return GetRuleContext<Xmlserialize_param_version_partContext>(0);
		}
		public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
			return GetRuleContext<Xmlserialize_param_ident_partContext>(0);
		}
		public ITerminalNode DEFAULTS() { return GetToken(PlSqlParser.DEFAULTS, 0); }
		public ITerminalNode HIDE() { return GetToken(PlSqlParser.HIDE, 0); }
		public ITerminalNode SHOW() { return GetToken(PlSqlParser.SHOW, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(PlSqlParser.XMLTABLE, 0); }
		public Xml_namespaces_clauseContext xml_namespaces_clause() {
			return GetRuleContext<Xml_namespaces_clauseContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(PlSqlParser.COLUMNS, 0); }
		public Xml_table_columnContext[] xml_table_column() {
			return GetRuleContexts<Xml_table_columnContext>();
		}
		public Xml_table_columnContext xml_table_column(int i) {
			return GetRuleContext<Xml_table_columnContext>(i);
		}
		public ITerminalNode TRUNC() { return GetToken(PlSqlParser.TRUNC, 0); }
		public Other_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_other_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOther_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Other_functionContext other_function() {
		Other_functionContext _localctx = new Other_functionContext(Context, State);
		EnterRule(_localctx, 952, RULE_other_function);
		int _la;
		try {
			int _alt;
			State = 7737;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1095,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7407; over_clause_keyword();
				State = 7408; function_argument_analytic();
				State = 7410;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1043,Context) ) {
				case 1:
					{
					State = 7409; over_clause();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7412; regular_id();
				State = 7413; function_argument_modeling();
				State = 7415;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1044,Context) ) {
				case 1:
					{
					State = 7414; using_clause();
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7417; Match(NVL);
				State = 7418; Match(LEFT_PAREN);
				State = 7419; expression();
				State = 7420; Match(COMMA);
				State = 7421; expression();
				State = 7422; Match(RIGHT_PAREN);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7424; to_date();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7425; Match(COUNT);
				State = 7426; Match(LEFT_PAREN);
				State = 7432;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ASTERISK:
					{
					State = 7427; Match(ASTERISK);
					}
					break;
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ALL:
				case ANALYZE:
				case ANY:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COALESCE:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIOR:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUE:
				case TRUNCATE:
				case TRUNC:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNIQUE:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case DECODE:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case NVL:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROUND:
				case ROW_NUMBER:
				case SUBSTR:
				case TO_CHAR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case LEAST:
				case GREATEST:
				case TO_DATE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case PLUS_SIGN:
				case MINUS_SIGN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 7429;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,1045,Context) ) {
					case 1:
						{
						State = 7428;
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					}
					State = 7431; concatenation(0);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 7434; Match(RIGHT_PAREN);
				State = 7436;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1047,Context) ) {
				case 1:
					{
					State = 7435; over_clause();
					}
					break;
				}
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7438;
				_la = TokenStream.LA(1);
				if ( !(_la==CAST || _la==XMLCAST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7439; Match(LEFT_PAREN);
				State = 7446;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1048,Context) ) {
				case 1:
					{
					State = 7440; Match(MULTISET);
					State = 7441; Match(LEFT_PAREN);
					State = 7442; subquery();
					State = 7443; Match(RIGHT_PAREN);
					}
					break;
				case 2:
					{
					State = 7445; concatenation(0);
					}
					break;
				}
				State = 7448; Match(AS);
				State = 7449; type_spec();
				State = 7450; Match(RIGHT_PAREN);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7452; Match(COALESCE);
				State = 7453; Match(LEFT_PAREN);
				State = 7454; logical_expression(0);
				State = 7459;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 7455; Match(COMMA);
					State = 7456; logical_expression(0);
					}
					}
					State = 7461;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 7462; Match(RIGHT_PAREN);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7464; Match(COLLECT);
				State = 7465; Match(LEFT_PAREN);
				State = 7467;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1050,Context) ) {
				case 1:
					{
					State = 7466;
					_la = TokenStream.LA(1);
					if ( !(_la==DISTINCT || _la==UNIQUE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 7469; concatenation(0);
				State = 7471;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 7470; collect_order_by_part();
					}
				}

				State = 7473; Match(RIGHT_PAREN);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 7475; within_or_over_clause_keyword();
				{
				State = 7476; function_arguments();
				State = 7478;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==KEEP) {
					{
					State = 7477; keep_clause();
					}
				}

				}
				State = 7481;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 7480; within_or_over_part();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 7483;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,1053,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 7485; cursor_name();
				State = 7486;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 442)) & ~0x3f) == 0 && ((1L << (_la - 442)) & ((1L << (PERCENT_FOUND - 442)) | (1L << (PERCENT_ISOPEN - 442)) | (1L << (PERCENT_NOTFOUND - 442)) | (1L << (PERCENT_ROWCOUNT - 442)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 7488; Match(DECOMPOSE);
				State = 7489; Match(LEFT_PAREN);
				State = 7490; concatenation(0);
				State = 7492;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CANONICAL || _la==COMPATIBILITY) {
					{
					State = 7491;
					_la = TokenStream.LA(1);
					if ( !(_la==CANONICAL || _la==COMPATIBILITY) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 7494; Match(RIGHT_PAREN);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 7496; Match(EXTRACT);
				State = 7497; Match(LEFT_PAREN);
				State = 7498; regular_id();
				State = 7499; Match(FROM);
				State = 7500; concatenation(0);
				State = 7501; Match(RIGHT_PAREN);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 7503;
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST_VALUE || _la==LAST_VALUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7504; function_argument_analytic();
				State = 7506;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 7505; respect_or_ignore_nulls();
					}
				}

				State = 7508; over_clause();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 7510; standard_prediction_function_keyword();
				State = 7511; Match(LEFT_PAREN);
				State = 7512; expressions();
				State = 7514;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COST) {
					{
					State = 7513; cost_matrix_clause();
					}
				}

				State = 7517;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 7516; using_clause();
					}
				}

				State = 7519; Match(RIGHT_PAREN);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 7521; Match(TRANSLATE);
				State = 7522; Match(LEFT_PAREN);
				State = 7523; expression();
				State = 7526;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 7524; Match(USING);
					State = 7525;
					_la = TokenStream.LA(1);
					if ( !(_la==CHAR_CS || _la==NCHAR_CS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 7532;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 7528; Match(COMMA);
					State = 7529; expression();
					}
					}
					State = 7534;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 7535; Match(RIGHT_PAREN);
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 7537; Match(TRANSLATE);
				State = 7538; Match(LEFT_PAREN);
				State = 7539; expression();
				State = 7540; Match(COMMA);
				State = 7541; @string();
				State = 7542; Match(COMMA);
				State = 7543; @string();
				State = 7544; Match(RIGHT_PAREN);
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 7546; Match(TREAT);
				State = 7547; Match(LEFT_PAREN);
				State = 7548; expression();
				State = 7549; Match(AS);
				State = 7551;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1060,Context) ) {
				case 1:
					{
					State = 7550; Match(REF);
					}
					break;
				}
				State = 7553; type_spec();
				State = 7554; Match(RIGHT_PAREN);
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 7556; Match(XMLAGG);
				State = 7557; Match(LEFT_PAREN);
				State = 7558; expression();
				State = 7560;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 7559; order_by_clause();
					}
				}

				State = 7562; Match(RIGHT_PAREN);
				State = 7565;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1062,Context) ) {
				case 1:
					{
					State = 7563; Match(PERIOD);
					State = 7564; general_element_part();
					}
					break;
				}
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 7567;
				_la = TokenStream.LA(1);
				if ( !(_la==XMLCOLATTVAL || _la==XMLFOREST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7568; Match(LEFT_PAREN);
				State = 7573;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 7570;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 7569; Match(COMMA);
						}
					}

					State = 7572; xml_multiuse_expression_element();
					}
					}
					State = 7575;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				State = 7577; Match(RIGHT_PAREN);
				State = 7580;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1065,Context) ) {
				case 1:
					{
					State = 7578; Match(PERIOD);
					State = 7579; general_element_part();
					}
					break;
				}
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 7582; Match(XMLELEMENT);
				State = 7583; Match(LEFT_PAREN);
				State = 7585;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1066,Context) ) {
				case 1:
					{
					State = 7584;
					_la = TokenStream.LA(1);
					if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 7588;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1067,Context) ) {
				case 1:
					{
					State = 7587;
					_la = TokenStream.LA(1);
					if ( !(_la==EVALNAME || _la==NAME) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 7590; expression();
				State = 7593;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1068,Context) ) {
				case 1:
					{
					State = 7591; Match(COMMA);
					State = 7592; xml_attributes_clause();
					}
					break;
				}
				State = 7602;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 7595; Match(COMMA);
					State = 7596; expression();
					State = 7598;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 7597; column_alias();
						}
					}

					}
					}
					State = 7604;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 7605; Match(RIGHT_PAREN);
				State = 7608;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1071,Context) ) {
				case 1:
					{
					State = 7606; Match(PERIOD);
					State = 7607; general_element_part();
					}
					break;
				}
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 7610; Match(XMLEXISTS);
				State = 7611; Match(LEFT_PAREN);
				State = 7612; expression();
				State = 7614;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PASSING) {
					{
					State = 7613; xml_passing_clause();
					}
				}

				State = 7616; Match(RIGHT_PAREN);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 7618; Match(XMLPARSE);
				State = 7619; Match(LEFT_PAREN);
				State = 7620;
				_la = TokenStream.LA(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7621; concatenation(0);
				State = 7623;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WELLFORMED) {
					{
					State = 7622; Match(WELLFORMED);
					}
				}

				State = 7625; Match(RIGHT_PAREN);
				State = 7628;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1074,Context) ) {
				case 1:
					{
					State = 7626; Match(PERIOD);
					State = 7627; general_element_part();
					}
					break;
				}
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 7630; Match(XMLPI);
				State = 7631; Match(LEFT_PAREN);
				State = 7636;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NAME:
					{
					State = 7632; Match(NAME);
					State = 7633; identifier();
					}
					break;
				case EVALNAME:
					{
					State = 7634; Match(EVALNAME);
					State = 7635; concatenation(0);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 7640;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7638; Match(COMMA);
					State = 7639; concatenation(0);
					}
				}

				State = 7642; Match(RIGHT_PAREN);
				State = 7645;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1077,Context) ) {
				case 1:
					{
					State = 7643; Match(PERIOD);
					State = 7644; general_element_part();
					}
					break;
				}
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 7647; Match(XMLQUERY);
				State = 7648; Match(LEFT_PAREN);
				State = 7649; concatenation(0);
				State = 7651;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PASSING) {
					{
					State = 7650; xml_passing_clause();
					}
				}

				State = 7653; Match(RETURNING);
				State = 7654; Match(CONTENT);
				State = 7658;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NULL) {
					{
					State = 7655; Match(NULL);
					State = 7656; Match(ON);
					State = 7657; Match(EMPTY);
					}
				}

				State = 7660; Match(RIGHT_PAREN);
				State = 7663;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1080,Context) ) {
				case 1:
					{
					State = 7661; Match(PERIOD);
					State = 7662; general_element_part();
					}
					break;
				}
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 7665; Match(XMLROOT);
				State = 7666; Match(LEFT_PAREN);
				State = 7667; concatenation(0);
				State = 7670;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1081,Context) ) {
				case 1:
					{
					State = 7668; Match(COMMA);
					State = 7669; xmlroot_param_version_part();
					}
					break;
				}
				State = 7674;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7672; Match(COMMA);
					State = 7673; xmlroot_param_standalone_part();
					}
				}

				State = 7676; Match(RIGHT_PAREN);
				State = 7679;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1083,Context) ) {
				case 1:
					{
					State = 7677; Match(PERIOD);
					State = 7678; general_element_part();
					}
					break;
				}
				}
				break;
			case 26:
				EnterOuterAlt(_localctx, 26);
				{
				State = 7681; Match(XMLSERIALIZE);
				State = 7682; Match(LEFT_PAREN);
				State = 7683;
				_la = TokenStream.LA(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7684; concatenation(0);
				State = 7687;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 7685; Match(AS);
					State = 7686; type_spec();
					}
				}

				State = 7690;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ENCODING) {
					{
					State = 7689; xmlserialize_param_enconding_part();
					}
				}

				State = 7693;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VERSION) {
					{
					State = 7692; xmlserialize_param_version_part();
					}
				}

				State = 7696;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDENT || _la==NO) {
					{
					State = 7695; xmlserialize_param_ident_part();
					}
				}

				State = 7700;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==HIDE || _la==SHOW) {
					{
					State = 7698;
					_la = TokenStream.LA(1);
					if ( !(_la==HIDE || _la==SHOW) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 7699; Match(DEFAULTS);
					}
				}

				State = 7702; Match(RIGHT_PAREN);
				State = 7705;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1089,Context) ) {
				case 1:
					{
					State = 7703; Match(PERIOD);
					State = 7704; general_element_part();
					}
					break;
				}
				}
				break;
			case 27:
				EnterOuterAlt(_localctx, 27);
				{
				State = 7707; Match(XMLTABLE);
				State = 7708; Match(LEFT_PAREN);
				State = 7710;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1090,Context) ) {
				case 1:
					{
					State = 7709; xml_namespaces_clause();
					}
					break;
				}
				State = 7712; concatenation(0);
				State = 7714;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PASSING) {
					{
					State = 7713; xml_passing_clause();
					}
				}

				State = 7721;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMNS) {
					{
					State = 7716; Match(COLUMNS);
					State = 7717; xml_table_column();
					{
					State = 7718; Match(COMMA);
					State = 7719; xml_table_column();
					}
					}
				}

				State = 7723; Match(RIGHT_PAREN);
				State = 7726;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1093,Context) ) {
				case 1:
					{
					State = 7724; Match(PERIOD);
					State = 7725; general_element_part();
					}
					break;
				}
				}
				break;
			case 28:
				EnterOuterAlt(_localctx, 28);
				{
				State = 7728; Match(TRUNC);
				State = 7729; Match(LEFT_PAREN);
				State = 7730; expression();
				State = 7733;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7731; Match(COMMA);
					State = 7732; @string();
					}
				}

				State = 7735; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode AVG() { return GetToken(PlSqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(PlSqlParser.CORR, 0); }
		public ITerminalNode LAG() { return GetToken(PlSqlParser.LAG, 0); }
		public ITerminalNode LEAD() { return GetToken(PlSqlParser.LEAD, 0); }
		public ITerminalNode MAX() { return GetToken(PlSqlParser.MAX, 0); }
		public ITerminalNode MEDIAN() { return GetToken(PlSqlParser.MEDIAN, 0); }
		public ITerminalNode MIN() { return GetToken(PlSqlParser.MIN, 0); }
		public ITerminalNode NTILE() { return GetToken(PlSqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(PlSqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(PlSqlParser.ROW_NUMBER, 0); }
		public ITerminalNode SUM() { return GetToken(PlSqlParser.SUM, 0); }
		public ITerminalNode VARIANCE() { return GetToken(PlSqlParser.VARIANCE, 0); }
		public ITerminalNode REGR_() { return GetToken(PlSqlParser.REGR_, 0); }
		public ITerminalNode STDDEV() { return GetToken(PlSqlParser.STDDEV, 0); }
		public ITerminalNode VAR_() { return GetToken(PlSqlParser.VAR_, 0); }
		public ITerminalNode COVAR_() { return GetToken(PlSqlParser.COVAR_, 0); }
		public Over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause_keyword; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOver_clause_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Over_clause_keywordContext over_clause_keyword() {
		Over_clause_keywordContext _localctx = new Over_clause_keywordContext(Context, State);
		EnterRule(_localctx, 954, RULE_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7739;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 715)) & ~0x3f) == 0 && ((1L << (_la - 715)) & ((1L << (AVG - 715)) | (1L << (CORR - 715)) | (1L << (COVAR_ - 715)) | (1L << (LAG - 715)) | (1L << (LEAD - 715)) | (1L << (MAX - 715)) | (1L << (MEDIAN - 715)) | (1L << (MIN - 715)) | (1L << (NTILE - 715)) | (1L << (RATIO_TO_REPORT - 715)) | (1L << (REGR_ - 715)) | (1L << (ROW_NUMBER - 715)) | (1L << (SUM - 715)) | (1L << (STDDEV - 715)) | (1L << (VAR_ - 715)) | (1L << (VARIANCE - 715)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode CUME_DIST() { return GetToken(PlSqlParser.CUME_DIST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(PlSqlParser.DENSE_RANK, 0); }
		public ITerminalNode LISTAGG() { return GetToken(PlSqlParser.LISTAGG, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(PlSqlParser.PERCENT_RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(PlSqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(PlSqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode RANK() { return GetToken(PlSqlParser.RANK, 0); }
		public Within_or_over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_clause_keyword; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithin_or_over_clause_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
		Within_or_over_clause_keywordContext _localctx = new Within_or_over_clause_keywordContext(Context, State);
		EnterRule(_localctx, 956, RULE_within_or_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7741;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 708)) & ~0x3f) == 0 && ((1L << (_la - 708)) & ((1L << (CUME_DIST - 708)) | (1L << (DENSE_RANK - 708)) | (1L << (LISTAGG - 708)) | (1L << (PERCENT_RANK - 708)) | (1L << (PERCENTILE_CONT - 708)) | (1L << (PERCENTILE_DISC - 708)) | (1L << (RANK - 708)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_prediction_function_keywordContext : ParserRuleContext {
		public ITerminalNode PREDICTION() { return GetToken(PlSqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(PlSqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(PlSqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(PlSqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(PlSqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(PlSqlParser.PREDICTION_SET, 0); }
		public Standard_prediction_function_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_prediction_function_keyword; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStandard_prediction_function_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
		Standard_prediction_function_keywordContext _localctx = new Standard_prediction_function_keywordContext(Context, State);
		EnterRule(_localctx, 958, RULE_standard_prediction_function_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7743;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 702)) & ~0x3f) == 0 && ((1L << (_la - 702)) & ((1L << (PREDICTION - 702)) | (1L << (PREDICTION_BOUNDS - 702)) | (1L << (PREDICTION_COST - 702)) | (1L << (PREDICTION_DETAILS - 702)) | (1L << (PREDICTION_PROBABILITY - 702)) | (1L << (PREDICTION_SET - 702)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clauseContext : ParserRuleContext {
		public ITerminalNode OVER() { return GetToken(PlSqlParser.OVER, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Query_partition_clauseContext query_partition_clause() {
			return GetRuleContext<Query_partition_clauseContext>(0);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Windowing_clauseContext windowing_clause() {
			return GetRuleContext<Windowing_clauseContext>(0);
		}
		public Over_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOver_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Over_clauseContext over_clause() {
		Over_clauseContext _localctx = new Over_clauseContext(Context, State);
		EnterRule(_localctx, 960, RULE_over_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7745; Match(OVER);
			State = 7746; Match(LEFT_PAREN);
			State = 7748;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 7747; query_partition_clause();
				}
			}

			State = 7754;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 7750; order_by_clause();
				State = 7752;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RANGE || _la==ROWS) {
					{
					State = 7751; windowing_clause();
					}
				}

				}
			}

			State = 7756; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_clauseContext : ParserRuleContext {
		public Windowing_typeContext windowing_type() {
			return GetRuleContext<Windowing_typeContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public Windowing_elementsContext[] windowing_elements() {
			return GetRuleContexts<Windowing_elementsContext>();
		}
		public Windowing_elementsContext windowing_elements(int i) {
			return GetRuleContext<Windowing_elementsContext>(i);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public Windowing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_clauseContext windowing_clause() {
		Windowing_clauseContext _localctx = new Windowing_clauseContext(Context, State);
		EnterRule(_localctx, 962, RULE_windowing_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7758; windowing_type();
			State = 7765;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BETWEEN:
				{
				State = 7759; Match(BETWEEN);
				State = 7760; windowing_elements();
				State = 7761; Match(AND);
				State = 7762; windowing_elements();
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 7764; windowing_elements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_typeContext : ParserRuleContext {
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public Windowing_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_typeContext windowing_type() {
		Windowing_typeContext _localctx = new Windowing_typeContext(Context, State);
		EnterRule(_localctx, 964, RULE_windowing_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7767;
			_la = TokenStream.LA(1);
			if ( !(_la==RANGE || _la==ROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_elementsContext : ParserRuleContext {
		public ITerminalNode UNBOUNDED() { return GetToken(PlSqlParser.UNBOUNDED, 0); }
		public ITerminalNode PRECEDING() { return GetToken(PlSqlParser.PRECEDING, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode FOLLOWING() { return GetToken(PlSqlParser.FOLLOWING, 0); }
		public Windowing_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_elementsContext windowing_elements() {
		Windowing_elementsContext _localctx = new Windowing_elementsContext(Context, State);
		EnterRule(_localctx, 966, RULE_windowing_elements);
		int _la;
		try {
			State = 7776;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1100,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7769; Match(UNBOUNDED);
				State = 7770; Match(PRECEDING);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7771; Match(CURRENT);
				State = 7772; Match(ROW);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7773; concatenation(0);
				State = 7774;
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_clauseContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public Using_elementContext[] using_element() {
			return GetRuleContexts<Using_elementContext>();
		}
		public Using_elementContext using_element(int i) {
			return GetRuleContext<Using_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Using_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_clauseContext using_clause() {
		Using_clauseContext _localctx = new Using_clauseContext(Context, State);
		EnterRule(_localctx, 968, RULE_using_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 7778; Match(USING);
			State = 7788;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASTERISK:
				{
				State = 7779; Match(ASTERISK);
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case IN:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case VARIABLE_SESSION:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case COMMA:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 7784;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 7781;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 7780; Match(COMMA);
							}
						}

						State = 7783; using_element();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 7786;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,1102,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Using_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_elementContext using_element() {
		Using_elementContext _localctx = new Using_elementContext(Context, State);
		EnterRule(_localctx, 970, RULE_using_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7795;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1105,Context) ) {
			case 1:
				{
				State = 7790; Match(IN);
				State = 7792;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1104,Context) ) {
				case 1:
					{
					State = 7791; Match(OUT);
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 7794; Match(OUT);
				}
				break;
			}
			State = 7797; select_list_elements();
			State = 7799;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1106,Context) ) {
			case 1:
				{
				State = 7798; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collect_order_by_partContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Collect_order_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collect_order_by_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollect_order_by_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collect_order_by_partContext collect_order_by_part() {
		Collect_order_by_partContext _localctx = new Collect_order_by_partContext(Context, State);
		EnterRule(_localctx, 972, RULE_collect_order_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7801; Match(ORDER);
			State = 7802; Match(BY);
			State = 7803; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_partContext : ParserRuleContext {
		public ITerminalNode WITHIN() { return GetToken(PlSqlParser.WITHIN, 0); }
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Within_or_over_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithin_or_over_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_partContext within_or_over_part() {
		Within_or_over_partContext _localctx = new Within_or_over_partContext(Context, State);
		EnterRule(_localctx, 974, RULE_within_or_over_part);
		try {
			State = 7812;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITHIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7805; Match(WITHIN);
				State = 7806; Match(GROUP);
				State = 7807; Match(LEFT_PAREN);
				State = 7808; order_by_clause();
				State = 7809; Match(RIGHT_PAREN);
				}
				break;
			case OVER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7811; over_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_matrix_clauseContext : ParserRuleContext {
		public ITerminalNode COST() { return GetToken(PlSqlParser.COST, 0); }
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public Cost_class_nameContext[] cost_class_name() {
			return GetRuleContexts<Cost_class_nameContext>();
		}
		public Cost_class_nameContext cost_class_name(int i) {
			return GetRuleContext<Cost_class_nameContext>(i);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Cost_matrix_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_matrix_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCost_matrix_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cost_matrix_clauseContext cost_matrix_clause() {
		Cost_matrix_clauseContext _localctx = new Cost_matrix_clauseContext(Context, State);
		EnterRule(_localctx, 976, RULE_cost_matrix_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7814; Match(COST);
			State = 7836;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MODEL:
				{
				State = 7815; Match(MODEL);
				State = 7817;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AUTO) {
					{
					State = 7816; Match(AUTO);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				State = 7819; Match(LEFT_PAREN);
				State = 7824;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 7821;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 7820; Match(COMMA);
						}
					}

					State = 7823; cost_class_name();
					}
					}
					State = 7826;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				State = 7828; Match(RIGHT_PAREN);
				State = 7829; Match(VALUES);
				State = 7830; Match(LEFT_PAREN);
				State = 7832;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 7831; expressions();
					}
				}

				State = 7834; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_passing_clauseContext : ParserRuleContext {
		public ITerminalNode PASSING() { return GetToken(PlSqlParser.PASSING, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Xml_passing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_passing_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_passing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_passing_clauseContext xml_passing_clause() {
		Xml_passing_clauseContext _localctx = new Xml_passing_clauseContext(Context, State);
		EnterRule(_localctx, 978, RULE_xml_passing_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7838; Match(PASSING);
			State = 7841;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 7839; Match(BY);
				State = 7840; Match(VALUE);
				}
			}

			State = 7843; expression();
			State = 7845;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 7844; column_alias();
				}
			}

			{
			State = 7847; Match(COMMA);
			State = 7848; expression();
			State = 7850;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1115,Context) ) {
			case 1:
				{
				State = 7849; column_alias();
				}
				break;
			}
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_attributes_clauseContext : ParserRuleContext {
		public ITerminalNode XMLATTRIBUTES() { return GetToken(PlSqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Xml_multiuse_expression_elementContext[] xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(PlSqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(PlSqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(PlSqlParser.SCHEMACHECK, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(PlSqlParser.NOSCHEMACHECK, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Xml_attributes_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_attributes_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_attributes_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_attributes_clauseContext xml_attributes_clause() {
		Xml_attributes_clauseContext _localctx = new Xml_attributes_clauseContext(Context, State);
		EnterRule(_localctx, 980, RULE_xml_attributes_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7852; Match(XMLATTRIBUTES);
			State = 7853; Match(LEFT_PAREN);
			State = 7855;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1116,Context) ) {
			case 1:
				{
				State = 7854;
				_la = TokenStream.LA(1);
				if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 7858;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1117,Context) ) {
			case 1:
				{
				State = 7857;
				_la = TokenStream.LA(1);
				if ( !(_la==NOSCHEMACHECK || _la==SCHEMACHECK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 7864;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7861;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 7860; Match(COMMA);
					}
				}

				State = 7863; xml_multiuse_expression_element();
				}
				}
				State = 7866;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 7868; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_namespaces_clauseContext : ParserRuleContext {
		public ITerminalNode XMLNAMESPACES() { return GetToken(PlSqlParser.XMLNAMESPACES, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_namespaces_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_namespaces_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_namespaces_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_namespaces_clauseContext xml_namespaces_clause() {
		Xml_namespaces_clauseContext _localctx = new Xml_namespaces_clauseContext(Context, State);
		EnterRule(_localctx, 982, RULE_xml_namespaces_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7870; Match(XMLNAMESPACES);
			State = 7871; Match(LEFT_PAREN);
			State = 7875;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1120,Context) ) {
			case 1:
				{
				State = 7872; concatenation(0);
				State = 7873; column_alias();
				}
				break;
			}
			State = 7883;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 7877; Match(COMMA);
				State = 7878; concatenation(0);
				State = 7879; column_alias();
				}
				}
				State = 7885;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 7887;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 7886; xml_general_default_part();
				}
			}

			State = 7889; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_table_columnContext : ParserRuleContext {
		public Xml_column_nameContext xml_column_name() {
			return GetRuleContext<Xml_column_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlSqlParser.ORDINALITY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode PATH() { return GetToken(PlSqlParser.PATH, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_table_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table_column; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_table_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_table_columnContext xml_table_column() {
		Xml_table_columnContext _localctx = new Xml_table_columnContext(Context, State);
		EnterRule(_localctx, 984, RULE_xml_table_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7891; xml_column_name();
			State = 7902;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				{
				State = 7892; Match(FOR);
				State = 7893; Match(ORDINALITY);
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case REGULAR_ID:
				{
				State = 7894; type_spec();
				State = 7897;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH) {
					{
					State = 7895; Match(PATH);
					State = 7896; concatenation(0);
					}
				}

				State = 7900;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 7899; xml_general_default_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_general_default_partContext : ParserRuleContext {
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xml_general_default_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_general_default_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_general_default_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_general_default_partContext xml_general_default_part() {
		Xml_general_default_partContext _localctx = new Xml_general_default_partContext(Context, State);
		EnterRule(_localctx, 986, RULE_xml_general_default_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7904; Match(DEFAULT);
			State = 7905; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_multiuse_expression_elementContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode EVALNAME() { return GetToken(PlSqlParser.EVALNAME, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xml_multiuse_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_multiuse_expression_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_multiuse_expression_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_multiuse_expression_elementContext xml_multiuse_expression_element() {
		Xml_multiuse_expression_elementContext _localctx = new Xml_multiuse_expression_elementContext(Context, State);
		EnterRule(_localctx, 988, RULE_xml_multiuse_expression_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7907; expression();
			State = 7914;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 7908; Match(AS);
				State = 7912;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1126,Context) ) {
				case 1:
					{
					State = 7909; id_expression();
					}
					break;
				case 2:
					{
					State = 7910; Match(EVALNAME);
					State = 7911; concatenation(0);
					}
					break;
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(PlSqlParser.VERSION, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Xmlroot_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_version_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlroot_param_version_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_version_partContext xmlroot_param_version_part() {
		Xmlroot_param_version_partContext _localctx = new Xmlroot_param_version_partContext(Context, State);
		EnterRule(_localctx, 990, RULE_xmlroot_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7916; Match(VERSION);
			State = 7920;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1128,Context) ) {
			case 1:
				{
				State = 7917; Match(NO);
				State = 7918; Match(VALUE);
				}
				break;
			case 2:
				{
				State = 7919; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_standalone_partContext : ParserRuleContext {
		public ITerminalNode STANDALONE() { return GetToken(PlSqlParser.STANDALONE, 0); }
		public ITerminalNode YES() { return GetToken(PlSqlParser.YES, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public Xmlroot_param_standalone_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_standalone_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlroot_param_standalone_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
		Xmlroot_param_standalone_partContext _localctx = new Xmlroot_param_standalone_partContext(Context, State);
		EnterRule(_localctx, 992, RULE_xmlroot_param_standalone_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7922; Match(STANDALONE);
			State = 7928;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case YES:
				{
				State = 7923; Match(YES);
				}
				break;
			case NO:
				{
				State = 7924; Match(NO);
				State = 7926;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUE) {
					{
					State = 7925; Match(VALUE);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_enconding_partContext : ParserRuleContext {
		public ITerminalNode ENCODING() { return GetToken(PlSqlParser.ENCODING, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xmlserialize_param_enconding_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_enconding_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_enconding_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
		Xmlserialize_param_enconding_partContext _localctx = new Xmlserialize_param_enconding_partContext(Context, State);
		EnterRule(_localctx, 994, RULE_xmlserialize_param_enconding_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7930; Match(ENCODING);
			State = 7931; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(PlSqlParser.VERSION, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xmlserialize_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_version_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_version_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
		Xmlserialize_param_version_partContext _localctx = new Xmlserialize_param_version_partContext(Context, State);
		EnterRule(_localctx, 996, RULE_xmlserialize_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7933; Match(VERSION);
			State = 7934; concatenation(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_ident_partContext : ParserRuleContext {
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode INDENT() { return GetToken(PlSqlParser.INDENT, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xmlserialize_param_ident_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_ident_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_ident_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
		Xmlserialize_param_ident_partContext _localctx = new Xmlserialize_param_ident_partContext(Context, State);
		EnterRule(_localctx, 998, RULE_xmlserialize_param_ident_part);
		int _la;
		try {
			State = 7944;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7936; Match(NO);
				State = 7937; Match(INDENT);
				}
				break;
			case INDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7938; Match(INDENT);
				State = 7942;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SIZE) {
					{
					State = 7939; Match(SIZE);
					State = 7940; Match(EQUALS_OP);
					State = 7941; concatenation(0);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_plus_commandContext : ParserRuleContext {
		public ITerminalNode EXIT() { return GetToken(PlSqlParser.EXIT, 0); }
		public ITerminalNode PROMPT() { return GetToken(PlSqlParser.PROMPT, 0); }
		public ITerminalNode SHOW() { return GetToken(PlSqlParser.SHOW, 0); }
		public ITerminalNode ERR() { return GetToken(PlSqlParser.ERR, 0); }
		public ITerminalNode ERRORS() { return GetToken(PlSqlParser.ERRORS, 0); }
		public ITerminalNode START_CMD() { return GetToken(PlSqlParser.START_CMD, 0); }
		public Sqlplus_whenever_commandContext sqlplus_whenever_command() {
			return GetRuleContext<Sqlplus_whenever_commandContext>(0);
		}
		public Sqlplus_set_commandContext sqlplus_set_command() {
			return GetRuleContext<Sqlplus_set_commandContext>(0);
		}
		public Sqlplus_execute_commandContext sqlplus_execute_command() {
			return GetRuleContext<Sqlplus_execute_commandContext>(0);
		}
		public Sql_plus_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_plus_command; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_plus_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_plus_commandContext sql_plus_command() {
		Sql_plus_commandContext _localctx = new Sql_plus_commandContext(Context, State);
		EnterRule(_localctx, 1000, RULE_sql_plus_command);
		int _la;
		try {
			State = 7955;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SOLIDUS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7946; Match(SOLIDUS);
				}
				break;
			case EXIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7947; Match(EXIT);
				}
				break;
			case PROMPT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 7948; Match(PROMPT);
				}
				break;
			case SHOW:
				EnterOuterAlt(_localctx, 4);
				{
				State = 7949; Match(SHOW);
				State = 7950;
				_la = TokenStream.LA(1);
				if ( !(_la==ERR || _la==ERRORS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case START_CMD:
				EnterOuterAlt(_localctx, 5);
				{
				State = 7951; Match(START_CMD);
				}
				break;
			case WHENEVER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 7952; sqlplus_whenever_command();
				}
				break;
			case SET:
				EnterOuterAlt(_localctx, 7);
				{
				State = 7953; sqlplus_set_command();
				}
				break;
			case EXECUTE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 7954; sqlplus_execute_command();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlplus_execute_commandContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Sqlplus_execute_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlplus_execute_command; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlplus_execute_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlplus_execute_commandContext sqlplus_execute_command() {
		Sqlplus_execute_commandContext _localctx = new Sqlplus_execute_commandContext(Context, State);
		EnterRule(_localctx, 1002, RULE_sqlplus_execute_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7957; Match(EXECUTE);
			State = 7958; function_call();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlplus_whenever_commandContext : ParserRuleContext {
		public ITerminalNode WHENEVER() { return GetToken(PlSqlParser.WHENEVER, 0); }
		public ITerminalNode SQLERROR() { return GetToken(PlSqlParser.SQLERROR, 0); }
		public ITerminalNode OSERROR() { return GetToken(PlSqlParser.OSERROR, 0); }
		public ITerminalNode EXIT() { return GetToken(PlSqlParser.EXIT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(PlSqlParser.CONTINUE, 0); }
		public ITerminalNode SUCCESS() { return GetToken(PlSqlParser.SUCCESS, 0); }
		public ITerminalNode FAILURE() { return GetToken(PlSqlParser.FAILURE, 0); }
		public ITerminalNode WARNING() { return GetToken(PlSqlParser.WARNING, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public Sqlplus_whenever_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlplus_whenever_command; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlplus_whenever_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlplus_whenever_commandContext sqlplus_whenever_command() {
		Sqlplus_whenever_commandContext _localctx = new Sqlplus_whenever_commandContext(Context, State);
		EnterRule(_localctx, 1004, RULE_sqlplus_whenever_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7960; Match(WHENEVER);
			State = 7961;
			_la = TokenStream.LA(1);
			if ( !(_la==OSERROR || _la==SQLERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 7967;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXIT:
				{
				State = 7962; Match(EXIT);
				State = 7963;
				_la = TokenStream.LA(1);
				if ( !(_la==FAILURE || _la==SUCCESS || _la==WARNING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 7964;
				_la = TokenStream.LA(1);
				if ( !(_la==COMMIT || _la==ROLLBACK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case CONTINUE:
				{
				State = 7965; Match(CONTINUE);
				State = 7966;
				_la = TokenStream.LA(1);
				if ( !(_la==COMMIT || _la==NONE || _la==ROLLBACK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argumentsContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Function_argumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_arguments; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_arguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argumentsContext function_arguments() {
		Function_argumentsContext _localctx = new Function_argumentsContext(Context, State);
		EnterRule(_localctx, 1006, RULE_function_arguments);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7969; Match(LEFT_PAREN);
			State = 7970; arguments();
			State = 7971; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 1008, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7974;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 7973; argument();
				}
			}

			State = 7978;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 7976; Match(COMMA);
				State = 7977; argument();
				}
				}
				State = 7980;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public ITerminalNode BIND_VAR() { return GetToken(PlSqlParser.BIND_VAR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 1010, RULE_argument);
		try {
			State = 7987;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1137,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 7982; regular_id();
				State = 7983; Match(BIND_VAR);
				State = 7984; expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 7986; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlplus_set_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public Regular_idContext[] regular_id() {
			return GetRuleContexts<Regular_idContext>();
		}
		public Regular_idContext regular_id(int i) {
			return GetRuleContext<Regular_idContext>(i);
		}
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode OFF() { return GetToken(PlSqlParser.OFF, 0); }
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public Sqlplus_set_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlplus_set_command; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlplus_set_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlplus_set_commandContext sqlplus_set_command() {
		Sqlplus_set_commandContext _localctx = new Sqlplus_set_commandContext(Context, State);
		EnterRule(_localctx, 1012, RULE_sqlplus_set_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7989; Match(SET);
			State = 7990; regular_id();
			State = 7996;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1138,Context) ) {
			case 1:
				{
				State = 7991; Match(CHAR_STRING);
				}
				break;
			case 2:
				{
				State = 7992; Match(ON);
				}
				break;
			case 3:
				{
				State = 7993; Match(OFF);
				}
				break;
			case 4:
				{
				State = 7994; numeric();
				}
				break;
			case 5:
				{
				State = 7995; regular_id();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_extension_clauseContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public Partition_extension_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_extension_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_extension_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_extension_clauseContext partition_extension_clause() {
		Partition_extension_clauseContext _localctx = new Partition_extension_clauseContext(Context, State);
		EnterRule(_localctx, 1014, RULE_partition_extension_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7998;
			_la = TokenStream.LA(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 8000;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 7999; Match(FOR);
				}
			}

			State = 8002; Match(LEFT_PAREN);
			State = 8004;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 8003; expressions();
				}
			}

			State = 8006; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_aliasContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Column_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_alias; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_alias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_aliasContext column_alias() {
		Column_aliasContext _localctx = new Column_aliasContext(Context, State);
		EnterRule(_localctx, 1016, RULE_column_alias);
		int _la;
		try {
			State = 8016;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1143,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8009;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 8008; Match(AS);
					}
				}

				State = 8013;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 8011; identifier();
					}
					break;
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 8012; @string();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8015; Match(AS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_aliasContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public Table_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_alias; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_alias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_aliasContext table_alias() {
		Table_aliasContext _localctx = new Table_aliasContext(Context, State);
		EnterRule(_localctx, 1018, RULE_table_alias);
		try {
			State = 8020;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8018; identifier();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8019; @string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Where_clauseContext : ParserRuleContext {
		public ITerminalNode WHERE() { return GetToken(PlSqlParser.WHERE, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Where_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_where_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhere_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Where_clauseContext where_clause() {
		Where_clauseContext _localctx = new Where_clauseContext(Context, State);
		EnterRule(_localctx, 1020, RULE_where_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8022; Match(WHERE);
			State = 8027;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT:
				{
				State = 8023; Match(CURRENT);
				State = 8024; Match(OF);
				State = 8025; cursor_name();
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIOR:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TRUNC:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case LEAST:
			case GREATEST:
			case TO_DATE:
			case VARIABLE_SESSION:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 8026; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Into_clauseContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public ITerminalNode BULK() { return GetToken(PlSqlParser.BULK, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public Variable_nameContext[] variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_into_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInto_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Into_clauseContext into_clause() {
		Into_clauseContext _localctx = new Into_clauseContext(Context, State);
		EnterRule(_localctx, 1022, RULE_into_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 8031;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BULK) {
				{
				State = 8029; Match(BULK);
				State = 8030; Match(COLLECT);
				}
			}

			State = 8033; Match(INTO);
			State = 8038;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 8035;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 8034; Match(COMMA);
						}
					}

					State = 8037; variable_name();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 8040;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1148,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_column_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public Xml_column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_column_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_column_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_column_nameContext xml_column_name() {
		Xml_column_nameContext _localctx = new Xml_column_nameContext(Context, State);
		EnterRule(_localctx, 1024, RULE_xml_column_name);
		try {
			State = 8044;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8042; identifier();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8043; @string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_nameContext : ParserRuleContext {
		public IdentifiersContext identifiers() {
			return GetRuleContext<IdentifiersContext>(0);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Routine_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutine_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Routine_nameContext routine_name() {
		Routine_nameContext _localctx = new Routine_nameContext(Context, State);
		EnterRule(_localctx, 1026, RULE_routine_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8046; identifiers();
			State = 8049;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 8047; Match(AT_SIGN);
				State = 8048; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndextypeContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public IndextypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indextype; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndextype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndextypeContext indextype() {
		IndextypeContext _localctx = new IndextypeContext(Context, State);
		EnterRule(_localctx, 1028, RULE_indextype);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8051; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grantee_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Identified_byContext identified_by() {
			return GetRuleContext<Identified_byContext>(0);
		}
		public Grantee_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantee_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrantee_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grantee_nameContext grantee_name() {
		Grantee_nameContext _localctx = new Grantee_nameContext(Context, State);
		EnterRule(_localctx, 1030, RULE_grantee_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8053; id_expression();
			State = 8055;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENTIFIED) {
				{
				State = 8054; identified_by();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Role_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode CONNECT() { return GetToken(PlSqlParser.CONNECT, 0); }
		public Role_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_role_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRole_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Role_nameContext role_name() {
		Role_nameContext _localctx = new Role_nameContext(Context, State);
		EnterRule(_localctx, 1032, RULE_role_name);
		try {
			State = 8059;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8057; id_expression();
				}
				break;
			case CONNECT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8058; Match(CONNECT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constraint_nameContext : ParserRuleContext {
		public IdentifiersContext identifiers() {
			return GetRuleContext<IdentifiersContext>(0);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Constraint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraint_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraint_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constraint_nameContext constraint_name() {
		Constraint_nameContext _localctx = new Constraint_nameContext(Context, State);
		EnterRule(_localctx, 1034, RULE_constraint_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8061; identifiers();
			State = 8064;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT_SIGN) {
				{
				State = 8062; Match(AT_SIGN);
				State = 8063; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Variable_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Variable_nameContext variable_name() {
		Variable_nameContext _localctx = new Variable_nameContext(Context, State);
		EnterRule(_localctx, 1036, RULE_variable_name);
		int _la;
		try {
			State = 8076;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8068;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTRODUCER) {
					{
					State = 8066; Match(INTRODUCER);
					State = 8067; char_set_name();
					}
				}

				State = 8070; id_expression();
				State = 8073;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PERIOD) {
					{
					State = 8071; Match(PERIOD);
					State = 8072; id_expression();
					}
				}

				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8075; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_nameContext : ParserRuleContext {
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Cursor_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_nameContext cursor_name() {
		Cursor_nameContext _localctx = new Cursor_nameContext(Context, State);
		EnterRule(_localctx, 1038, RULE_cursor_name);
		try {
			State = 8080;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8078; general_element();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8079; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Record_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_nameContext record_name() {
		Record_nameContext _localctx = new Record_nameContext(Context, State);
		EnterRule(_localctx, 1040, RULE_record_name);
		try {
			State = 8084;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8082; identifier();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8083; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Link_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Link_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_link_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLink_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Link_nameContext link_name() {
		Link_nameContext _localctx = new Link_nameContext(Context, State);
		EnterRule(_localctx, 1042, RULE_link_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8086; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tableview_nameContext : ParserRuleContext {
		public Table_fullnameContext table_fullname() {
			return GetRuleContext<Table_fullnameContext>(0);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Tableview_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableview_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableview_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tableview_nameContext tableview_name() {
		Tableview_nameContext _localctx = new Tableview_nameContext(Context, State);
		EnterRule(_localctx, 1044, RULE_tableview_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8088; table_fullname();
			State = 8092;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1159,Context) ) {
			case 1:
				{
				State = 8089; Match(AT_SIGN);
				State = 8090; link_name();
				}
				break;
			case 2:
				{
				State = 8091; partition_extension_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Element_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_nameContext element_name() {
		Element_nameContext _localctx = new Element_nameContext(Context, State);
		EnterRule(_localctx, 1046, RULE_element_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8094; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_archive_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Flashback_archive_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_archive_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlashback_archive_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_archive_nameContext flashback_archive_name() {
		Flashback_archive_nameContext _localctx = new Flashback_archive_nameContext(Context, State);
		EnterRule(_localctx, 1048, RULE_flashback_archive_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8096; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Zonemap_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Zonemap_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_zonemap_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitZonemap_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Zonemap_nameContext zonemap_name() {
		Zonemap_nameContext _localctx = new Zonemap_nameContext(Context, State);
		EnterRule(_localctx, 1050, RULE_zonemap_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8098; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subpartition_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Subpartition_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartition_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubpartition_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subpartition_nameContext subpartition_name() {
		Subpartition_nameContext _localctx = new Subpartition_nameContext(Context, State);
		EnterRule(_localctx, 1052, RULE_subpartition_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8100; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_item_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Lob_item_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_item_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_item_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_item_nameContext lob_item_name() {
		Lob_item_nameContext _localctx = new Lob_item_nameContext(Context, State);
		EnterRule(_localctx, 1054, RULE_lob_item_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8102; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dir_object_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Dir_object_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dir_object_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDir_object_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dir_object_nameContext dir_object_name() {
		Dir_object_nameContext _localctx = new Dir_object_nameContext(Context, State);
		EnterRule(_localctx, 1056, RULE_dir_object_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8104; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class User_object_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public User_object_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_user_object_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUser_object_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public User_object_nameContext user_object_name() {
		User_object_nameContext _localctx = new User_object_nameContext(Context, State);
		EnterRule(_localctx, 1058, RULE_user_object_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8106; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tablespace_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Tablespace_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespace_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablespace_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tablespace_nameContext tablespace_name() {
		Tablespace_nameContext _localctx = new Tablespace_nameContext(Context, State);
		EnterRule(_localctx, 1060, RULE_tablespace_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8108; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Label_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Label_nameContext label_name() {
		Label_nameContext _localctx = new Label_nameContext(Context, State);
		EnterRule(_localctx, 1062, RULE_label_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8110; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Partition_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_nameContext partition_name() {
		Partition_nameContext _localctx = new Partition_nameContext(Context, State);
		EnterRule(_localctx, 1064, RULE_partition_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8112; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_object_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Schema_object_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_object_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSchema_object_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Schema_object_nameContext schema_object_name() {
		Schema_object_nameContext _localctx = new Schema_object_nameContext(Context, State);
		EnterRule(_localctx, 1066, RULE_schema_object_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8114; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lob_segnameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Lob_segnameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lob_segname; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLob_segname(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lob_segnameContext lob_segname() {
		Lob_segnameContext _localctx = new Lob_segnameContext(Context, State);
		EnterRule(_localctx, 1068, RULE_lob_segname);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8116; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ilm_policy_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Ilm_policy_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ilm_policy_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIlm_policy_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ilm_policy_nameContext ilm_policy_name() {
		Ilm_policy_nameContext _localctx = new Ilm_policy_nameContext(Context, State);
		EnterRule(_localctx, 1070, RULE_ilm_policy_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8118; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Directory_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Directory_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directory_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectory_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Directory_nameContext directory_name() {
		Directory_nameContext _localctx = new Directory_nameContext(Context, State);
		EnterRule(_localctx, 1072, RULE_directory_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8120; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Full_identifierContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Full_identifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_full_identifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFull_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Full_identifierContext full_identifier() {
		Full_identifierContext _localctx = new Full_identifierContext(Context, State);
		EnterRule(_localctx, 1074, RULE_full_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8122; identifier();
			State = 8125;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1160,Context) ) {
			case 1:
				{
				State = 8123; Match(PERIOD);
				State = 8124; id_expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Implementation_type_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Implementation_type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implementation_type_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImplementation_type_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Implementation_type_nameContext implementation_type_name() {
		Implementation_type_nameContext _localctx = new Implementation_type_nameContext(Context, State);
		EnterRule(_localctx, 1076, RULE_implementation_type_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8127; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Container_tableview_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Container_tableview_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_container_tableview_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContainer_tableview_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Container_tableview_nameContext container_tableview_name() {
		Container_tableview_nameContext _localctx = new Container_tableview_nameContext(Context, State);
		EnterRule(_localctx, 1078, RULE_container_tableview_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8129; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_nameContext function_name() {
		Function_nameContext _localctx = new Function_nameContext(Context, State);
		EnterRule(_localctx, 1080, RULE_function_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8131; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Procedure_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_nameContext procedure_name() {
		Procedure_nameContext _localctx = new Procedure_nameContext(Context, State);
		EnterRule(_localctx, 1082, RULE_procedure_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8133; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Trigger_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_nameContext trigger_name() {
		Trigger_nameContext _localctx = new Trigger_nameContext(Context, State);
		EnterRule(_localctx, 1084, RULE_trigger_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8135; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Collection_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollection_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collection_nameContext collection_name() {
		Collection_nameContext _localctx = new Collection_nameContext(Context, State);
		EnterRule(_localctx, 1086, RULE_collection_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8137; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_nameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Index_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_nameContext index_name() {
		Index_nameContext _localctx = new Index_nameContext(Context, State);
		EnterRule(_localctx, 1088, RULE_index_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8139; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_fullnameContext : ParserRuleContext {
		public Full_identifierContext full_identifier() {
			return GetRuleContext<Full_identifierContext>(0);
		}
		public Table_fullnameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_fullname; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_fullname(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_fullnameContext table_fullname() {
		Table_fullnameContext _localctx = new Table_fullnameContext(Context, State);
		EnterRule(_localctx, 1090, RULE_table_fullname);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8141; full_identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grant_object_nameContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode USER() { return GetToken(PlSqlParser.USER, 0); }
		public User_object_nameContext[] user_object_name() {
			return GetRuleContexts<User_object_nameContext>();
		}
		public User_object_nameContext user_object_name(int i) {
			return GetRuleContext<User_object_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public ITerminalNode DIRECTORY() { return GetToken(PlSqlParser.DIRECTORY, 0); }
		public Dir_object_nameContext dir_object_name() {
			return GetRuleContext<Dir_object_nameContext>(0);
		}
		public ITerminalNode EDITION() { return GetToken(PlSqlParser.EDITION, 0); }
		public Schema_object_nameContext schema_object_name() {
			return GetRuleContext<Schema_object_nameContext>(0);
		}
		public ITerminalNode MINING() { return GetToken(PlSqlParser.MINING, 0); }
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode SOURCE() { return GetToken(PlSqlParser.SOURCE, 0); }
		public ITerminalNode RESOURCE() { return GetToken(PlSqlParser.RESOURCE, 0); }
		public ITerminalNode SQL() { return GetToken(PlSqlParser.SQL, 0); }
		public ITerminalNode TRANSLATION() { return GetToken(PlSqlParser.TRANSLATION, 0); }
		public ITerminalNode PROFILE() { return GetToken(PlSqlParser.PROFILE, 0); }
		public Grant_object_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grant_object_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrant_object_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grant_object_nameContext grant_object_name() {
		Grant_object_nameContext _localctx = new Grant_object_nameContext(Context, State);
		EnterRule(_localctx, 1092, RULE_grant_object_name);
		int _la;
		try {
			State = 8167;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1163,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8143; tableview_name();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8144; Match(USER);
				State = 8149;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 8146;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 8145; Match(COMMA);
						}
					}

					State = 8148; user_object_name();
					}
					}
					State = 8151;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (COMMA - 711)))) != 0) || _la==REGULAR_ID );
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 8153; Match(DIRECTORY);
				State = 8154; dir_object_name();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 8155; Match(EDITION);
				State = 8156; schema_object_name();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 8157; Match(MINING);
				State = 8158; Match(MODEL);
				State = 8159; schema_object_name();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 8160; Match(JAVA);
				State = 8161;
				_la = TokenStream.LA(1);
				if ( !(_la==RESOURCE || _la==SOURCE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8162; schema_object_name();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 8163; Match(SQL);
				State = 8164; Match(TRANSLATION);
				State = 8165; Match(PROFILE);
				State = 8166; schema_object_name();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_listContext : ParserRuleContext {
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Column_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_listContext column_list() {
		Column_listContext _localctx = new Column_listContext(Context, State);
		EnterRule(_localctx, 1094, RULE_column_list);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 8173;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 8170;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 8169; Match(COMMA);
						}
					}

					State = 8172; column_name();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 8175;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1165,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Paren_column_listContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Column_listContext column_list() {
			return GetRuleContext<Column_listContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Paren_column_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paren_column_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParen_column_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Paren_column_listContext paren_column_list() {
		Paren_column_listContext _localctx = new Paren_column_listContext(Context, State);
		EnterRule(_localctx, 1096, RULE_paren_column_list);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8177; Match(LEFT_PAREN);
			State = 8178; column_list();
			State = 8179; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Keep_clauseContext : ParserRuleContext {
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(PlSqlParser.DENSE_RANK, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Keep_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keep_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeep_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Keep_clauseContext keep_clause() {
		Keep_clauseContext _localctx = new Keep_clauseContext(Context, State);
		EnterRule(_localctx, 1098, RULE_keep_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8181; Match(KEEP);
			State = 8182; Match(LEFT_PAREN);
			State = 8183; Match(DENSE_RANK);
			State = 8184;
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 8185; order_by_clause();
			State = 8186; Match(RIGHT_PAREN);
			State = 8188;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1166,Context) ) {
			case 1:
				{
				State = 8187; over_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_analyticContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Respect_or_ignore_nullsContext[] respect_or_ignore_nulls() {
			return GetRuleContexts<Respect_or_ignore_nullsContext>();
		}
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls(int i) {
			return GetRuleContext<Respect_or_ignore_nullsContext>(i);
		}
		public Function_argument_analyticContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_analytic; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument_analytic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_analyticContext function_argument_analytic() {
		Function_argument_analyticContext _localctx = new Function_argument_analyticContext(Context, State);
		EnterRule(_localctx, 1100, RULE_function_argument_analytic);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8190; Match(LEFT_PAREN);
			State = 8200;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 8192;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 8191; Match(COMMA);
					}
				}

				State = 8194; argument();
				State = 8196;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1168,Context) ) {
				case 1:
					{
					State = 8195; respect_or_ignore_nulls();
					}
					break;
				}
				}
				}
				State = 8202;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 8203; Match(RIGHT_PAREN);
			State = 8205;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1170,Context) ) {
			case 1:
				{
				State = 8204; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_modelingContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode ASTERISK() { return GetToken(PlSqlParser.ASTERISK, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlSqlParser.COMMA, i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public NumericContext[] numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode[] NULL() { return GetTokens(PlSqlParser.NULL); }
		public ITerminalNode NULL(int i) {
			return GetToken(PlSqlParser.NULL, i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Function_argument_modelingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_modeling; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument_modeling(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_modelingContext function_argument_modeling() {
		Function_argument_modelingContext _localctx = new Function_argument_modelingContext(Context, State);
		EnterRule(_localctx, 1102, RULE_function_argument_modeling);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8207; Match(LEFT_PAREN);
			State = 8208; column_name();
			State = 8221;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 8209; Match(COMMA);
				State = 8212;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case PLUS_SIGN:
					{
					State = 8210; numeric();
					}
					break;
				case NULL:
					{
					State = 8211; Match(NULL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 8219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 8214; Match(COMMA);
					State = 8217;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case UNSIGNED_INTEGER:
					case APPROXIMATE_NUM_LIT:
					case PLUS_SIGN:
						{
						State = 8215; numeric();
						}
						break;
					case NULL:
						{
						State = 8216; Match(NULL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				}
			}

			State = 8223; Match(USING);
			State = 8240;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1178,Context) ) {
			case 1:
				{
				State = 8224; tableview_name();
				State = 8225; Match(PERIOD);
				State = 8226; Match(ASTERISK);
				}
				break;
			case 2:
				{
				State = 8228; Match(ASTERISK);
				}
				break;
			case 3:
				{
				State = 8236;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 8230;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 8229; Match(COMMA);
						}
					}

					State = 8232; expression();
					State = 8234;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,1176,Context) ) {
					case 1:
						{
						State = 8233; column_alias();
						}
						break;
					}
					}
					}
					State = 8238;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CASE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COALESCE - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DISTINCT - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (EXISTS - 195)) | (1L << (EXIT - 195)) | (1L << (EXPLAIN - 195)) | (1L << (EXTERNAL - 195)) | (1L << (EXTRACT - 195)) | (1L << (FAILURE - 195)) | (1L << (FALSE - 195)) | (1L << (FINAL - 195)) | (1L << (FIRST - 195)) | (1L << (FIRST_VALUE - 195)) | (1L << (FLOAT - 195)) | (1L << (FOLLOWING - 195)) | (1L << (FOLLOWS - 195)) | (1L << (FORALL - 195)) | (1L << (FORCE - 195)) | (1L << (FULL - 195)) | (1L << (FUNCTION - 195)) | (1L << (GROUPING - 195)) | (1L << (HASH - 195)) | (1L << (HIDE - 195)) | (1L << (HOUR - 195)) | (1L << (ID - 195)) | (1L << (IGNORE - 195)) | (1L << (IMMEDIATE - 195)) | (1L << (INCLUDE - 195)) | (1L << (INCLUDING - 195)) | (1L << (INCREMENT - 195)) | (1L << (INDENT - 195)) | (1L << (INDEXED - 195)) | (1L << (INDICATOR - 195)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (INDICES - 259)) | (1L << (INFINITE - 259)) | (1L << (INLINE - 259)) | (1L << (INNER - 259)) | (1L << (INOUT - 259)) | (1L << (INSTANTIABLE - 259)) | (1L << (INSTEAD - 259)) | (1L << (INTEGER - 259)) | (1L << (INTERVAL - 259)) | (1L << (INT - 259)) | (1L << (INVALIDATE - 259)) | (1L << (ISOLATION - 259)) | (1L << (ITERATE - 259)) | (1L << (JAVA - 259)) | (1L << (JOIN - 259)) | (1L << (KEEP - 259)) | (1L << (KEY - 259)) | (1L << (LANGUAGE - 259)) | (1L << (LAST - 259)) | (1L << (LAST_VALUE - 259)) | (1L << (LEADING - 259)) | (1L << (LEFT - 259)) | (1L << (LEVEL - 259)) | (1L << (LIBRARY - 259)) | (1L << (LIKE2 - 259)) | (1L << (LIKE4 - 259)) | (1L << (LIKEC - 259)) | (1L << (LIMIT - 259)) | (1L << (LINK - 259)) | (1L << (LIST - 259)) | (1L << (LOCAL - 259)) | (1L << (LOCKED - 259)) | (1L << (LOG - 259)) | (1L << (LOGOFF - 259)) | (1L << (LOGON - 259)) | (1L << (LONG - 259)) | (1L << (LOOP - 259)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NOT - 389)) | (1L << (NULL - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIOR - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUE - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TRUNC - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (DECODE - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (NVL - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROUND - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TO_CHAR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)) | (1L << (LEAST - 711)) | (1L << (GREATEST - 711)) | (1L << (TO_DATE - 711)) | (1L << (VARIABLE_SESSION - 711)) | (1L << (NATIONAL_CHAR_STRING_LIT - 711)) | (1L << (UNSIGNED_INTEGER - 711)) | (1L << (APPROXIMATE_NUM_LIT - 711)) | (1L << (CHAR_STRING - 711)) | (1L << (DELIMITED_ID - 711)) | (1L << (LEFT_PAREN - 711)) | (1L << (PLUS_SIGN - 711)) | (1L << (MINUS_SIGN - 711)) | (1L << (COMMA - 711)) | (1L << (BINDVAR - 711)) | (1L << (COLON - 711)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				}
				break;
			}
			State = 8242; Match(RIGHT_PAREN);
			State = 8244;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1179,Context) ) {
			case 1:
				{
				State = 8243; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Respect_or_ignore_nullsContext : ParserRuleContext {
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode RESPECT() { return GetToken(PlSqlParser.RESPECT, 0); }
		public ITerminalNode IGNORE() { return GetToken(PlSqlParser.IGNORE, 0); }
		public Respect_or_ignore_nullsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_respect_or_ignore_nulls; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRespect_or_ignore_nulls(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
		Respect_or_ignore_nullsContext _localctx = new Respect_or_ignore_nullsContext(Context, State);
		EnterRule(_localctx, 1104, RULE_respect_or_ignore_nulls);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8246;
			_la = TokenStream.LA(1);
			if ( !(_la==IGNORE || _la==RESPECT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 8247; Match(NULLS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_specContext : ParserRuleContext {
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode PERCENT_ROWTYPE() { return GetToken(PlSqlParser.PERCENT_ROWTYPE, 0); }
		public ITerminalNode PERCENT_TYPE() { return GetToken(PlSqlParser.PERCENT_TYPE, 0); }
		public Type_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_spec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_specContext type_spec() {
		Type_specContext _localctx = new Type_specContext(Context, State);
		EnterRule(_localctx, 1106, RULE_type_spec);
		int _la;
		try {
			State = 8257;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1182,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8249; datatype();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8251;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1180,Context) ) {
				case 1:
					{
					State = 8250; Match(REF);
					}
					break;
				}
				State = 8253; type_name();
				State = 8255;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) {
					{
					State = 8254;
					_la = TokenStream.LA(1);
					if ( !(_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatatypeContext : ParserRuleContext {
		public Native_datatype_elementContext native_datatype_element() {
			return GetRuleContext<Native_datatype_elementContext>(0);
		}
		public Precision_partContext precision_part() {
			return GetRuleContext<Precision_partContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ITerminalNode CHARACTER() { return GetToken(PlSqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public DatatypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datatype; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatatype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatatypeContext datatype() {
		DatatypeContext _localctx = new DatatypeContext(Context, State);
		EnterRule(_localctx, 1108, RULE_datatype);
		int _la;
		try {
			State = 8290;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BOOLEAN:
			case CHARACTER:
			case CHAR:
			case CLOB:
			case DATE:
			case DAY:
			case DEC:
			case DECIMAL:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case FLOAT:
			case HOUR:
			case INTEGER:
			case INT:
			case LONG:
			case MINUTE:
			case MLSLABEL:
			case MONTH:
			case NATURAL:
			case NATURALN:
			case NCHAR:
			case NCLOB:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case RAW:
			case REAL:
			case ROWID:
			case SECOND:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SMALLINT:
			case STRING:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case UROWID:
			case VARCHAR2:
			case VARCHAR:
			case YEAR:
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8259; native_datatype_element();
				State = 8261;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1183,Context) ) {
				case 1:
					{
					State = 8260; precision_part();
					}
					break;
				}
				State = 8272;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1185,Context) ) {
				case 1:
					{
					State = 8263; Match(WITH);
					State = 8265;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==LOCAL) {
						{
						State = 8264; Match(LOCAL);
						}
					}

					State = 8267; Match(TIME);
					State = 8268; Match(ZONE);
					}
					break;
				case 2:
					{
					State = 8269; Match(CHARACTER);
					State = 8270; Match(SET);
					State = 8271; char_set_name();
					}
					break;
				}
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8274; Match(INTERVAL);
				State = 8275;
				_la = TokenStream.LA(1);
				if ( !(_la==DAY || _la==YEAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8280;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 8276; Match(LEFT_PAREN);
					State = 8277; expression();
					State = 8278; Match(RIGHT_PAREN);
					}
				}

				State = 8282; Match(TO);
				State = 8283;
				_la = TokenStream.LA(1);
				if ( !(_la==MONTH || _la==SECOND) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8288;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1187,Context) ) {
				case 1:
					{
					State = 8284; Match(LEFT_PAREN);
					State = 8285; expression();
					State = 8286; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Precision_partContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public NumericContext[] numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public ITerminalNode CHAR() { return GetToken(PlSqlParser.CHAR, 0); }
		public ITerminalNode BYTE() { return GetToken(PlSqlParser.BYTE, 0); }
		public Precision_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precision_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecision_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Precision_partContext precision_part() {
		Precision_partContext _localctx = new Precision_partContext(Context, State);
		EnterRule(_localctx, 1110, RULE_precision_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8292; Match(LEFT_PAREN);
			State = 8293; numeric();
			State = 8296;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 8294; Match(COMMA);
				State = 8295; numeric();
				}
			}

			State = 8299;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BYTE || _la==CHAR) {
				{
				State = 8298;
				_la = TokenStream.LA(1);
				if ( !(_la==BYTE || _la==CHAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 8301; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Native_datatype_elementContext : ParserRuleContext {
		public ITerminalNode BINARY_INTEGER() { return GetToken(PlSqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(PlSqlParser.PLS_INTEGER, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlSqlParser.NATURAL, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(PlSqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(PlSqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode NATURALN() { return GetToken(PlSqlParser.NATURALN, 0); }
		public ITerminalNode POSITIVE() { return GetToken(PlSqlParser.POSITIVE, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(PlSqlParser.POSITIVEN, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(PlSqlParser.SIGNTYPE, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(PlSqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(PlSqlParser.NVARCHAR2, 0); }
		public ITerminalNode DEC() { return GetToken(PlSqlParser.DEC, 0); }
		public ITerminalNode INTEGER() { return GetToken(PlSqlParser.INTEGER, 0); }
		public ITerminalNode INT() { return GetToken(PlSqlParser.INT, 0); }
		public ITerminalNode NUMERIC() { return GetToken(PlSqlParser.NUMERIC, 0); }
		public ITerminalNode SMALLINT() { return GetToken(PlSqlParser.SMALLINT, 0); }
		public ITerminalNode NUMBER() { return GetToken(PlSqlParser.NUMBER, 0); }
		public ITerminalNode DECIMAL() { return GetToken(PlSqlParser.DECIMAL, 0); }
		public ITerminalNode DOUBLE() { return GetToken(PlSqlParser.DOUBLE, 0); }
		public ITerminalNode PRECISION() { return GetToken(PlSqlParser.PRECISION, 0); }
		public ITerminalNode FLOAT() { return GetToken(PlSqlParser.FLOAT, 0); }
		public ITerminalNode REAL() { return GetToken(PlSqlParser.REAL, 0); }
		public ITerminalNode NCHAR() { return GetToken(PlSqlParser.NCHAR, 0); }
		public ITerminalNode LONG() { return GetToken(PlSqlParser.LONG, 0); }
		public ITerminalNode RAW() { return GetToken(PlSqlParser.RAW, 0); }
		public ITerminalNode CHAR() { return GetToken(PlSqlParser.CHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(PlSqlParser.CHARACTER, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(PlSqlParser.VARCHAR2, 0); }
		public ITerminalNode VARCHAR() { return GetToken(PlSqlParser.VARCHAR, 0); }
		public ITerminalNode STRING() { return GetToken(PlSqlParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(PlSqlParser.BOOLEAN, 0); }
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode UROWID() { return GetToken(PlSqlParser.UROWID, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode HOUR() { return GetToken(PlSqlParser.HOUR, 0); }
		public ITerminalNode MINUTE() { return GetToken(PlSqlParser.MINUTE, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(PlSqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(PlSqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(PlSqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(PlSqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode BFILE() { return GetToken(PlSqlParser.BFILE, 0); }
		public ITerminalNode BLOB() { return GetToken(PlSqlParser.BLOB, 0); }
		public ITerminalNode CLOB() { return GetToken(PlSqlParser.CLOB, 0); }
		public ITerminalNode NCLOB() { return GetToken(PlSqlParser.NCLOB, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(PlSqlParser.MLSLABEL, 0); }
		public Native_datatype_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_native_datatype_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNative_datatype_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Native_datatype_elementContext native_datatype_element() {
		Native_datatype_elementContext _localctx = new Native_datatype_elementContext(Context, State);
		EnterRule(_localctx, 1112, RULE_native_datatype_element);
		try {
			State = 8363;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BINARY_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8303; Match(BINARY_INTEGER);
				}
				break;
			case PLS_INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8304; Match(PLS_INTEGER);
				}
				break;
			case NATURAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 8305; Match(NATURAL);
				}
				break;
			case BINARY_FLOAT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 8306; Match(BINARY_FLOAT);
				}
				break;
			case BINARY_DOUBLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 8307; Match(BINARY_DOUBLE);
				}
				break;
			case NATURALN:
				EnterOuterAlt(_localctx, 6);
				{
				State = 8308; Match(NATURALN);
				}
				break;
			case POSITIVE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 8309; Match(POSITIVE);
				}
				break;
			case POSITIVEN:
				EnterOuterAlt(_localctx, 8);
				{
				State = 8310; Match(POSITIVEN);
				}
				break;
			case SIGNTYPE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 8311; Match(SIGNTYPE);
				}
				break;
			case SIMPLE_INTEGER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 8312; Match(SIMPLE_INTEGER);
				}
				break;
			case NVARCHAR2:
				EnterOuterAlt(_localctx, 11);
				{
				State = 8313; Match(NVARCHAR2);
				}
				break;
			case DEC:
				EnterOuterAlt(_localctx, 12);
				{
				State = 8314; Match(DEC);
				}
				break;
			case INTEGER:
				EnterOuterAlt(_localctx, 13);
				{
				State = 8315; Match(INTEGER);
				}
				break;
			case INT:
				EnterOuterAlt(_localctx, 14);
				{
				State = 8316; Match(INT);
				}
				break;
			case NUMERIC:
				EnterOuterAlt(_localctx, 15);
				{
				State = 8317; Match(NUMERIC);
				}
				break;
			case SMALLINT:
				EnterOuterAlt(_localctx, 16);
				{
				State = 8318; Match(SMALLINT);
				}
				break;
			case NUMBER:
				EnterOuterAlt(_localctx, 17);
				{
				State = 8319; Match(NUMBER);
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 18);
				{
				State = 8320; Match(DECIMAL);
				}
				break;
			case DOUBLE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 8321; Match(DOUBLE);
				State = 8323;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1191,Context) ) {
				case 1:
					{
					State = 8322; Match(PRECISION);
					}
					break;
				}
				}
				break;
			case FLOAT:
				EnterOuterAlt(_localctx, 20);
				{
				State = 8325; Match(FLOAT);
				}
				break;
			case REAL:
				EnterOuterAlt(_localctx, 21);
				{
				State = 8326; Match(REAL);
				}
				break;
			case NCHAR:
				EnterOuterAlt(_localctx, 22);
				{
				State = 8327; Match(NCHAR);
				}
				break;
			case LONG:
				EnterOuterAlt(_localctx, 23);
				{
				State = 8328; Match(LONG);
				State = 8330;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1192,Context) ) {
				case 1:
					{
					State = 8329; Match(RAW);
					}
					break;
				}
				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 24);
				{
				State = 8332; Match(CHAR);
				}
				break;
			case CHARACTER:
				EnterOuterAlt(_localctx, 25);
				{
				State = 8333; Match(CHARACTER);
				}
				break;
			case VARCHAR2:
				EnterOuterAlt(_localctx, 26);
				{
				State = 8334; Match(VARCHAR2);
				}
				break;
			case VARCHAR:
				EnterOuterAlt(_localctx, 27);
				{
				State = 8335; Match(VARCHAR);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 28);
				{
				State = 8336; Match(STRING);
				}
				break;
			case RAW:
				EnterOuterAlt(_localctx, 29);
				{
				State = 8337; Match(RAW);
				}
				break;
			case BOOLEAN:
				EnterOuterAlt(_localctx, 30);
				{
				State = 8338; Match(BOOLEAN);
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 31);
				{
				State = 8339; Match(DATE);
				}
				break;
			case ROWID:
				EnterOuterAlt(_localctx, 32);
				{
				State = 8340; Match(ROWID);
				}
				break;
			case UROWID:
				EnterOuterAlt(_localctx, 33);
				{
				State = 8341; Match(UROWID);
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 34);
				{
				State = 8342; Match(YEAR);
				}
				break;
			case MONTH:
				EnterOuterAlt(_localctx, 35);
				{
				State = 8343; Match(MONTH);
				}
				break;
			case DAY:
				EnterOuterAlt(_localctx, 36);
				{
				State = 8344; Match(DAY);
				}
				break;
			case HOUR:
				EnterOuterAlt(_localctx, 37);
				{
				State = 8345; Match(HOUR);
				}
				break;
			case MINUTE:
				EnterOuterAlt(_localctx, 38);
				{
				State = 8346; Match(MINUTE);
				}
				break;
			case SECOND:
				EnterOuterAlt(_localctx, 39);
				{
				State = 8347; Match(SECOND);
				}
				break;
			case TIMEZONE_HOUR:
				EnterOuterAlt(_localctx, 40);
				{
				State = 8348; Match(TIMEZONE_HOUR);
				}
				break;
			case TIMEZONE_MINUTE:
				EnterOuterAlt(_localctx, 41);
				{
				State = 8349; Match(TIMEZONE_MINUTE);
				}
				break;
			case TIMEZONE_REGION:
				EnterOuterAlt(_localctx, 42);
				{
				State = 8350; Match(TIMEZONE_REGION);
				}
				break;
			case TIMEZONE_ABBR:
				EnterOuterAlt(_localctx, 43);
				{
				State = 8351; Match(TIMEZONE_ABBR);
				}
				break;
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 44);
				{
				State = 8352; Match(TIMESTAMP);
				}
				break;
			case TIMESTAMP_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 45);
				{
				State = 8353; Match(TIMESTAMP_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_TZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 46);
				{
				State = 8354; Match(TIMESTAMP_TZ_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_LTZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 47);
				{
				State = 8355; Match(TIMESTAMP_LTZ_UNCONSTRAINED);
				}
				break;
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 48);
				{
				State = 8356; Match(YMINTERVAL_UNCONSTRAINED);
				}
				break;
			case DSINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 49);
				{
				State = 8357; Match(DSINTERVAL_UNCONSTRAINED);
				}
				break;
			case BFILE:
				EnterOuterAlt(_localctx, 50);
				{
				State = 8358; Match(BFILE);
				}
				break;
			case BLOB:
				EnterOuterAlt(_localctx, 51);
				{
				State = 8359; Match(BLOB);
				}
				break;
			case CLOB:
				EnterOuterAlt(_localctx, 52);
				{
				State = 8360; Match(CLOB);
				}
				break;
			case NCLOB:
				EnterOuterAlt(_localctx, 53);
				{
				State = 8361; Match(NCLOB);
				}
				break;
			case MLSLABEL:
				EnterOuterAlt(_localctx, 54);
				{
				State = 8362; Match(MLSLABEL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bind_variableContext : ParserRuleContext {
		public ITerminalNode[] BINDVAR() { return GetTokens(PlSqlParser.BINDVAR); }
		public ITerminalNode BINDVAR(int i) {
			return GetToken(PlSqlParser.BINDVAR, i);
		}
		public ITerminalNode[] UNSIGNED_INTEGER() { return GetTokens(PlSqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(PlSqlParser.UNSIGNED_INTEGER, i);
		}
		public General_element_partContext[] general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public ITerminalNode INDICATOR() { return GetToken(PlSqlParser.INDICATOR, 0); }
		public Bind_variableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bind_variable; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBind_variable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bind_variableContext bind_variable() {
		Bind_variableContext _localctx = new Bind_variableContext(Context, State);
		EnterRule(_localctx, 1114, RULE_bind_variable);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 8368;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BINDVAR:
				{
				State = 8365; Match(BINDVAR);
				}
				break;
			case COLON:
				{
				State = 8366; Match(COLON);
				State = 8367; Match(UNSIGNED_INTEGER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 8378;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1197,Context) ) {
			case 1:
				{
				State = 8371;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDICATOR) {
					{
					State = 8370; Match(INDICATOR);
					}
				}

				State = 8376;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINDVAR:
					{
					State = 8373; Match(BINDVAR);
					}
					break;
				case COLON:
					{
					State = 8374; Match(COLON);
					State = 8375; Match(UNSIGNED_INTEGER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			State = 8384;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1198,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 8380; Match(PERIOD);
					State = 8381; general_element_part();
					}
					} 
				}
				State = 8386;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1198,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_elementContext : ParserRuleContext {
		public General_element_partContext[] general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public General_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_elementContext general_element() {
		General_elementContext _localctx = new General_elementContext(Context, State);
		EnterRule(_localctx, 1116, RULE_general_element);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 8387; general_element_part();
			State = 8392;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1199,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 8388; Match(PERIOD);
					State = 8389; general_element_part();
					}
					} 
				}
				State = 8394;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1199,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_element_partContext : ParserRuleContext {
		public Id_expressionsContext id_expressions() {
			return GetRuleContext<Id_expressionsContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Function_argumentsContext function_arguments() {
			return GetRuleContext<Function_argumentsContext>(0);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public General_element_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element_part; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_element_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_element_partContext general_element_part() {
		General_element_partContext _localctx = new General_element_partContext(Context, State);
		EnterRule(_localctx, 1118, RULE_general_element_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8397;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTRODUCER) {
				{
				State = 8395; Match(INTRODUCER);
				State = 8396; char_set_name();
				}
			}

			State = 8399; id_expressions();
			State = 8402;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1201,Context) ) {
			case 1:
				{
				State = 8400; Match(AT_SIGN);
				State = 8401; link_name();
				}
				break;
			}
			State = 8405;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1202,Context) ) {
			case 1:
				{
				State = 8404; function_arguments();
				}
				break;
			}
			State = 8408;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1203,Context) ) {
			case 1:
				{
				State = 8407; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_elementContext : ParserRuleContext {
		public Id_expressionsContext id_expressions() {
			return GetRuleContext<Id_expressionsContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_elementContext table_element() {
		Table_elementContext _localctx = new Table_elementContext(Context, State);
		EnterRule(_localctx, 1120, RULE_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8412;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTRODUCER) {
				{
				State = 8410; Match(INTRODUCER);
				State = 8411; char_set_name();
				}
			}

			State = 8414; id_expressions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_privilegeContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(PlSqlParser.PRIVILEGES, 0); }
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public ITerminalNode FLASHBACK() { return GetToken(PlSqlParser.FLASHBACK, 0); }
		public ITerminalNode ARCHIVE() { return GetToken(PlSqlParser.ARCHIVE, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public ITerminalNode INHERIT() { return GetToken(PlSqlParser.INHERIT, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public ITerminalNode MERGE() { return GetToken(PlSqlParser.MERGE, 0); }
		public ITerminalNode VIEW() { return GetToken(PlSqlParser.VIEW, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode REFRESH() { return GetToken(PlSqlParser.REFRESH, 0); }
		public ITerminalNode QUERY() { return GetToken(PlSqlParser.QUERY, 0); }
		public ITerminalNode REWRITE() { return GetToken(PlSqlParser.REWRITE, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode REFERENCES() { return GetToken(PlSqlParser.REFERENCES, 0); }
		public ITerminalNode SELECT() { return GetToken(PlSqlParser.SELECT, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(PlSqlParser.TRANSLATE, 0); }
		public ITerminalNode SQL() { return GetToken(PlSqlParser.SQL, 0); }
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode USE() { return GetToken(PlSqlParser.USE, 0); }
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public Object_privilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_privilege; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_privilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_privilegeContext object_privilege() {
		Object_privilegeContext _localctx = new Object_privilegeContext(Context, State);
		EnterRule(_localctx, 1122, RULE_object_privilege);
		int _la;
		try {
			State = 8449;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1206,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8416; Match(ALL);
				State = 8418;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIVILEGES) {
					{
					State = 8417; Match(PRIVILEGES);
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8420; Match(ALTER);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 8421; Match(DEBUG);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 8422; Match(DELETE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 8423; Match(EXECUTE);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 8424; Match(FLASHBACK);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 8425; Match(FLASHBACK);
				State = 8426; Match(ARCHIVE);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 8427; Match(INDEX);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 8428; Match(INHERIT);
				State = 8429; Match(PRIVILEGES);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 8430; Match(INSERT);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 8431; Match(KEEP);
				State = 8432; Match(SEQUENCE);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 8433; Match(MERGE);
				State = 8434; Match(VIEW);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 8435; Match(ON);
				State = 8436; Match(COMMIT);
				State = 8437; Match(REFRESH);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 8438; Match(QUERY);
				State = 8439; Match(REWRITE);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 8440; Match(READ);
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 8441; Match(REFERENCES);
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 8442; Match(SELECT);
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 8443; Match(TRANSLATE);
				State = 8444; Match(SQL);
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 8445; Match(UNDER);
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 8446; Match(UPDATE);
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 8447; Match(USE);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 8448; Match(WRITE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class System_privilegeContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(PlSqlParser.PRIVILEGES, 0); }
		public ITerminalNode ADVISOR() { return GetToken(PlSqlParser.ADVISOR, 0); }
		public ITerminalNode ADMINISTER() { return GetToken(PlSqlParser.ADMINISTER, 0); }
		public ITerminalNode SQL() { return GetToken(PlSqlParser.SQL, 0); }
		public ITerminalNode TUNING() { return GetToken(PlSqlParser.TUNING, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode ANY() { return GetToken(PlSqlParser.ANY, 0); }
		public ITerminalNode PROFILE() { return GetToken(PlSqlParser.PROFILE, 0); }
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode MANAGEMENT() { return GetToken(PlSqlParser.MANAGEMENT, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public ITerminalNode CLUSTER() { return GetToken(PlSqlParser.CLUSTER, 0); }
		public ITerminalNode CONTEXT() { return GetToken(PlSqlParser.CONTEXT, 0); }
		public ITerminalNode EXEMPT() { return GetToken(PlSqlParser.EXEMPT, 0); }
		public ITerminalNode REDACTION() { return GetToken(PlSqlParser.REDACTION, 0); }
		public ITerminalNode POLICY() { return GetToken(PlSqlParser.POLICY, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode LINK() { return GetToken(PlSqlParser.LINK, 0); }
		public ITerminalNode PUBLIC() { return GetToken(PlSqlParser.PUBLIC, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public ITerminalNode CONNECT() { return GetToken(PlSqlParser.CONNECT, 0); }
		public ITerminalNode SESSION() { return GetToken(PlSqlParser.SESSION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlSqlParser.ANALYZE, 0); }
		public ITerminalNode DICTIONARY() { return GetToken(PlSqlParser.DICTIONARY, 0); }
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(PlSqlParser.DIRECTORY, 0); }
		public ITerminalNode EDITION() { return GetToken(PlSqlParser.EDITION, 0); }
		public ITerminalNode FLASHBACK() { return GetToken(PlSqlParser.FLASHBACK, 0); }
		public ITerminalNode ARCHIVE() { return GetToken(PlSqlParser.ARCHIVE, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public ITerminalNode INDEXTYPE() { return GetToken(PlSqlParser.INDEXTYPE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public ITerminalNode JOB() { return GetToken(PlSqlParser.JOB, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode CLASS() { return GetToken(PlSqlParser.CLASS, 0); }
		public ITerminalNode PROGRAM() { return GetToken(PlSqlParser.PROGRAM, 0); }
		public ITerminalNode MANAGE() { return GetToken(PlSqlParser.MANAGE, 0); }
		public ITerminalNode SCHEDULER() { return GetToken(PlSqlParser.SCHEDULER, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public ITerminalNode LIBRARY() { return GetToken(PlSqlParser.LIBRARY, 0); }
		public ITerminalNode LOGMINING() { return GetToken(PlSqlParser.LOGMINING, 0); }
		public ITerminalNode MATERIALIZED() { return GetToken(PlSqlParser.MATERIALIZED, 0); }
		public ITerminalNode VIEW() { return GetToken(PlSqlParser.VIEW, 0); }
		public ITerminalNode QUERY() { return GetToken(PlSqlParser.QUERY, 0); }
		public ITerminalNode REWRITE() { return GetToken(PlSqlParser.REWRITE, 0); }
		public ITerminalNode GLOBAL() { return GetToken(PlSqlParser.GLOBAL, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode REFRESH() { return GetToken(PlSqlParser.REFRESH, 0); }
		public ITerminalNode MINING() { return GetToken(PlSqlParser.MINING, 0); }
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public ITerminalNode SELECT() { return GetToken(PlSqlParser.SELECT, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode CUBE() { return GetToken(PlSqlParser.CUBE, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode MEASURE() { return GetToken(PlSqlParser.MEASURE, 0); }
		public ITerminalNode FOLDER() { return GetToken(PlSqlParser.FOLDER, 0); }
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode BUILD() { return GetToken(PlSqlParser.BUILD, 0); }
		public ITerminalNode PROCESS() { return GetToken(PlSqlParser.PROCESS, 0); }
		public ITerminalNode OPERATOR() { return GetToken(PlSqlParser.OPERATOR, 0); }
		public ITerminalNode OUTLINE() { return GetToken(PlSqlParser.OUTLINE, 0); }
		public ITerminalNode PLUGGABLE() { return GetToken(PlSqlParser.PLUGGABLE, 0); }
		public ITerminalNode CONTAINER() { return GetToken(PlSqlParser.CONTAINER, 0); }
		public ITerminalNode ROLE() { return GetToken(PlSqlParser.ROLE, 0); }
		public ITerminalNode GRANT() { return GetToken(PlSqlParser.GRANT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public ITerminalNode RESTRICTED() { return GetToken(PlSqlParser.RESTRICTED, 0); }
		public ITerminalNode RESOURCE() { return GetToken(PlSqlParser.RESOURCE, 0); }
		public ITerminalNode COST() { return GetToken(PlSqlParser.COST, 0); }
		public ITerminalNode TRANSLATION() { return GetToken(PlSqlParser.TRANSLATION, 0); }
		public ITerminalNode USE() { return GetToken(PlSqlParser.USE, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(PlSqlParser.TRANSLATE, 0); }
		public ITerminalNode SYNONYM() { return GetToken(PlSqlParser.SYNONYM, 0); }
		public ITerminalNode BACKUP() { return GetToken(PlSqlParser.BACKUP, 0); }
		public ITerminalNode LOCK() { return GetToken(PlSqlParser.LOCK, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(PlSqlParser.TABLESPACE, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public ITerminalNode USER() { return GetToken(PlSqlParser.USER, 0); }
		public ITerminalNode MERGE() { return GetToken(PlSqlParser.MERGE, 0); }
		public ITerminalNode AUDIT() { return GetToken(PlSqlParser.AUDIT, 0); }
		public ITerminalNode BECOME() { return GetToken(PlSqlParser.BECOME, 0); }
		public ITerminalNode CHANGE() { return GetToken(PlSqlParser.CHANGE, 0); }
		public ITerminalNode NOTIFICATION() { return GetToken(PlSqlParser.NOTIFICATION, 0); }
		public ITerminalNode ACCESS() { return GetToken(PlSqlParser.ACCESS, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlSqlParser.TRANSACTION, 0); }
		public ITerminalNode PRIVILEGE() { return GetToken(PlSqlParser.PRIVILEGE, 0); }
		public ITerminalNode INHERIT() { return GetToken(PlSqlParser.INHERIT, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode SYSGUID() { return GetToken(PlSqlParser.SYSGUID, 0); }
		public ITerminalNode PURGE() { return GetToken(PlSqlParser.PURGE, 0); }
		public ITerminalNode DBA_RECYCLEBIN() { return GetToken(PlSqlParser.DBA_RECYCLEBIN, 0); }
		public ITerminalNode RESUMABLE() { return GetToken(PlSqlParser.RESUMABLE, 0); }
		public ITerminalNode SYSBACKUP() { return GetToken(PlSqlParser.SYSBACKUP, 0); }
		public ITerminalNode SYSDBA() { return GetToken(PlSqlParser.SYSDBA, 0); }
		public ITerminalNode SYSDG() { return GetToken(PlSqlParser.SYSDG, 0); }
		public ITerminalNode SYSKM() { return GetToken(PlSqlParser.SYSKM, 0); }
		public ITerminalNode SYSOPER() { return GetToken(PlSqlParser.SYSOPER, 0); }
		public System_privilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_system_privilege; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSystem_privilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public System_privilegeContext system_privilege() {
		System_privilegeContext _localctx = new System_privilegeContext(Context, State);
		EnterRule(_localctx, 1124, RULE_system_privilege);
		int _la;
		try {
			State = 8777;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1233,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8451; Match(ALL);
				State = 8452; Match(PRIVILEGES);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8453; Match(ADVISOR);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 8454; Match(ADMINISTER);
				State = 8456;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8455; Match(ANY);
					}
				}

				State = 8458; Match(SQL);
				State = 8459; Match(TUNING);
				State = 8460; Match(SET);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 8461;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8462; Match(ANY);
				State = 8463; Match(SQL);
				State = 8464; Match(PROFILE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 8465; Match(ADMINISTER);
				State = 8466; Match(SQL);
				State = 8467; Match(MANAGEMENT);
				State = 8468; Match(OBJECT);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 8469; Match(CREATE);
				State = 8471;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8470; Match(ANY);
					}
				}

				State = 8473; Match(CLUSTER);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 8474;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8475; Match(ANY);
				State = 8476; Match(CLUSTER);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 8477;
				_la = TokenStream.LA(1);
				if ( !(_la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8478; Match(ANY);
				State = 8479; Match(CONTEXT);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 8480; Match(EXEMPT);
				State = 8481; Match(REDACTION);
				State = 8482; Match(POLICY);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 8483; Match(ALTER);
				State = 8484; Match(DATABASE);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 8485;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8487;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PUBLIC) {
					{
					State = 8486; Match(PUBLIC);
					}
				}

				State = 8489; Match(DATABASE);
				State = 8490; Match(LINK);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 8491; Match(DROP);
				State = 8492; Match(PUBLIC);
				State = 8493; Match(DATABASE);
				State = 8494; Match(LINK);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 8495; Match(DEBUG);
				State = 8496; Match(CONNECT);
				State = 8497; Match(SESSION);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 8498; Match(DEBUG);
				State = 8499; Match(ANY);
				State = 8500; Match(PROCEDURE);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 8501; Match(ANALYZE);
				State = 8502; Match(ANY);
				State = 8503; Match(DICTIONARY);
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 8504; Match(CREATE);
				State = 8506;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8505; Match(ANY);
					}
				}

				State = 8508; Match(DIMENSION);
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 8509;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8510; Match(ANY);
				State = 8511; Match(DIMENSION);
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 8512;
				_la = TokenStream.LA(1);
				if ( !(_la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8513; Match(ANY);
				State = 8514; Match(DIRECTORY);
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 8515;
				_la = TokenStream.LA(1);
				if ( !(_la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8516; Match(ANY);
				State = 8517; Match(EDITION);
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 8518; Match(FLASHBACK);
				State = 8523;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ARCHIVE:
					{
					State = 8519; Match(ARCHIVE);
					State = 8520; Match(ADMINISTER);
					}
					break;
				case ANY:
					{
					State = 8521; Match(ANY);
					State = 8522; Match(TABLE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 8525;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8526; Match(ANY);
				State = 8527; Match(INDEX);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 8528; Match(CREATE);
				State = 8530;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8529; Match(ANY);
					}
				}

				State = 8532; Match(INDEXTYPE);
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 8533;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==EXECUTE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8534; Match(ANY);
				State = 8535; Match(INDEXTYPE);
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 8536; Match(CREATE);
				State = 8538;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY || _la==EXTERNAL) {
					{
					State = 8537;
					_la = TokenStream.LA(1);
					if ( !(_la==ANY || _la==EXTERNAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 8540; Match(JOB);
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 8541; Match(EXECUTE);
				State = 8542; Match(ANY);
				State = 8543;
				_la = TokenStream.LA(1);
				if ( !(_la==CLASS || _la==PROGRAM) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 26:
				EnterOuterAlt(_localctx, 26);
				{
				State = 8544; Match(MANAGE);
				State = 8545; Match(SCHEDULER);
				}
				break;
			case 27:
				EnterOuterAlt(_localctx, 27);
				{
				State = 8546; Match(ADMINISTER);
				State = 8547; Match(KEY);
				State = 8548; Match(MANAGEMENT);
				}
				break;
			case 28:
				EnterOuterAlt(_localctx, 28);
				{
				State = 8549; Match(CREATE);
				State = 8551;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8550; Match(ANY);
					}
				}

				State = 8553; Match(LIBRARY);
				}
				break;
			case 29:
				EnterOuterAlt(_localctx, 29);
				{
				State = 8554;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==EXECUTE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8555; Match(ANY);
				State = 8556; Match(LIBRARY);
				}
				break;
			case 30:
				EnterOuterAlt(_localctx, 30);
				{
				State = 8557; Match(LOGMINING);
				}
				break;
			case 31:
				EnterOuterAlt(_localctx, 31);
				{
				State = 8558; Match(CREATE);
				State = 8560;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8559; Match(ANY);
					}
				}

				State = 8562; Match(MATERIALIZED);
				State = 8563; Match(VIEW);
				}
				break;
			case 32:
				EnterOuterAlt(_localctx, 32);
				{
				State = 8564;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8565; Match(ANY);
				State = 8566; Match(MATERIALIZED);
				State = 8567; Match(VIEW);
				}
				break;
			case 33:
				EnterOuterAlt(_localctx, 33);
				{
				State = 8569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GLOBAL) {
					{
					State = 8568; Match(GLOBAL);
					}
				}

				State = 8571; Match(QUERY);
				State = 8572; Match(REWRITE);
				}
				break;
			case 34:
				EnterOuterAlt(_localctx, 34);
				{
				State = 8573; Match(ON);
				State = 8574; Match(COMMIT);
				State = 8575; Match(REFRESH);
				}
				break;
			case 35:
				EnterOuterAlt(_localctx, 35);
				{
				State = 8576; Match(CREATE);
				State = 8578;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8577; Match(ANY);
					}
				}

				State = 8580; Match(MINING);
				State = 8581; Match(MODEL);
				}
				break;
			case 36:
				EnterOuterAlt(_localctx, 36);
				{
				State = 8582;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==COMMENT || _la==DROP || _la==SELECT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8583; Match(ANY);
				State = 8584; Match(MINING);
				State = 8585; Match(MODEL);
				}
				break;
			case 37:
				EnterOuterAlt(_localctx, 37);
				{
				State = 8586; Match(CREATE);
				State = 8588;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8587; Match(ANY);
					}
				}

				State = 8590; Match(CUBE);
				}
				break;
			case 38:
				EnterOuterAlt(_localctx, 38);
				{
				State = 8591;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==SELECT || _la==UPDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8592; Match(ANY);
				State = 8593; Match(CUBE);
				}
				break;
			case 39:
				EnterOuterAlt(_localctx, 39);
				{
				State = 8594; Match(CREATE);
				State = 8596;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8595; Match(ANY);
					}
				}

				State = 8598; Match(MEASURE);
				State = 8599; Match(FOLDER);
				}
				break;
			case 40:
				EnterOuterAlt(_localctx, 40);
				{
				State = 8600;
				_la = TokenStream.LA(1);
				if ( !(_la==DELETE || _la==DROP || _la==INSERT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8601; Match(ANY);
				State = 8602; Match(MEASURE);
				State = 8603; Match(FOLDER);
				}
				break;
			case 41:
				EnterOuterAlt(_localctx, 41);
				{
				State = 8604; Match(CREATE);
				State = 8606;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8605; Match(ANY);
					}
				}

				State = 8608; Match(CUBE);
				State = 8609; Match(DIMENSION);
				}
				break;
			case 42:
				EnterOuterAlt(_localctx, 42);
				{
				State = 8610;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DELETE || _la==DROP || _la==INSERT || _la==SELECT || _la==UPDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8611; Match(ANY);
				State = 8612; Match(CUBE);
				State = 8613; Match(DIMENSION);
				}
				break;
			case 43:
				EnterOuterAlt(_localctx, 43);
				{
				State = 8614; Match(CREATE);
				State = 8616;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8615; Match(ANY);
					}
				}

				State = 8618; Match(CUBE);
				State = 8619; Match(BUILD);
				State = 8620; Match(PROCESS);
				}
				break;
			case 44:
				EnterOuterAlt(_localctx, 44);
				{
				State = 8621;
				_la = TokenStream.LA(1);
				if ( !(_la==DROP || _la==UPDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8622; Match(ANY);
				State = 8623; Match(CUBE);
				State = 8624; Match(BUILD);
				State = 8625; Match(PROCESS);
				}
				break;
			case 45:
				EnterOuterAlt(_localctx, 45);
				{
				State = 8626; Match(CREATE);
				State = 8628;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8627; Match(ANY);
					}
				}

				State = 8630; Match(OPERATOR);
				}
				break;
			case 46:
				EnterOuterAlt(_localctx, 46);
				{
				State = 8631;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==EXECUTE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8632; Match(ANY);
				State = 8633; Match(OPERATOR);
				}
				break;
			case 47:
				EnterOuterAlt(_localctx, 47);
				{
				State = 8634;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8635; Match(ANY);
				State = 8636; Match(OUTLINE);
				}
				break;
			case 48:
				EnterOuterAlt(_localctx, 48);
				{
				State = 8637; Match(CREATE);
				State = 8638; Match(PLUGGABLE);
				State = 8639; Match(DATABASE);
				}
				break;
			case 49:
				EnterOuterAlt(_localctx, 49);
				{
				State = 8640; Match(SET);
				State = 8641; Match(CONTAINER);
				}
				break;
			case 50:
				EnterOuterAlt(_localctx, 50);
				{
				State = 8642; Match(CREATE);
				State = 8644;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8643; Match(ANY);
					}
				}

				State = 8646; Match(PROCEDURE);
				}
				break;
			case 51:
				EnterOuterAlt(_localctx, 51);
				{
				State = 8647;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==EXECUTE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8648; Match(ANY);
				State = 8649; Match(PROCEDURE);
				}
				break;
			case 52:
				EnterOuterAlt(_localctx, 52);
				{
				State = 8650;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8651; Match(PROFILE);
				}
				break;
			case 53:
				EnterOuterAlt(_localctx, 53);
				{
				State = 8652; Match(CREATE);
				State = 8653; Match(ROLE);
				}
				break;
			case 54:
				EnterOuterAlt(_localctx, 54);
				{
				State = 8654;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==GRANT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8655; Match(ANY);
				State = 8656; Match(ROLE);
				}
				break;
			case 55:
				EnterOuterAlt(_localctx, 55);
				{
				State = 8657;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8658; Match(ROLLBACK);
				State = 8659; Match(SEGMENT);
				}
				break;
			case 56:
				EnterOuterAlt(_localctx, 56);
				{
				State = 8660; Match(CREATE);
				State = 8662;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8661; Match(ANY);
					}
				}

				State = 8664; Match(SEQUENCE);
				}
				break;
			case 57:
				EnterOuterAlt(_localctx, 57);
				{
				State = 8665;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==SELECT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8666; Match(ANY);
				State = 8667; Match(SEQUENCE);
				}
				break;
			case 58:
				EnterOuterAlt(_localctx, 58);
				{
				State = 8668;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==RESTRICTED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8669; Match(SESSION);
				}
				break;
			case 59:
				EnterOuterAlt(_localctx, 59);
				{
				State = 8670; Match(ALTER);
				State = 8671; Match(RESOURCE);
				State = 8672; Match(COST);
				}
				break;
			case 60:
				EnterOuterAlt(_localctx, 60);
				{
				State = 8673; Match(CREATE);
				State = 8675;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8674; Match(ANY);
					}
				}

				State = 8677; Match(SQL);
				State = 8678; Match(TRANSLATION);
				State = 8679; Match(PROFILE);
				}
				break;
			case 61:
				EnterOuterAlt(_localctx, 61);
				{
				State = 8680;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==USE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8681; Match(ANY);
				State = 8682; Match(SQL);
				State = 8683; Match(TRANSLATION);
				State = 8684; Match(PROFILE);
				}
				break;
			case 62:
				EnterOuterAlt(_localctx, 62);
				{
				State = 8685; Match(TRANSLATE);
				State = 8686; Match(ANY);
				State = 8687; Match(SQL);
				}
				break;
			case 63:
				EnterOuterAlt(_localctx, 63);
				{
				State = 8688; Match(CREATE);
				State = 8690;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8689; Match(ANY);
					}
				}

				State = 8692; Match(SYNONYM);
				}
				break;
			case 64:
				EnterOuterAlt(_localctx, 64);
				{
				State = 8693; Match(DROP);
				State = 8694; Match(ANY);
				State = 8695; Match(SYNONYM);
				}
				break;
			case 65:
				EnterOuterAlt(_localctx, 65);
				{
				State = 8696;
				_la = TokenStream.LA(1);
				if ( !(_la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8697; Match(PUBLIC);
				State = 8698; Match(SYNONYM);
				}
				break;
			case 66:
				EnterOuterAlt(_localctx, 66);
				{
				State = 8699; Match(CREATE);
				State = 8701;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8700; Match(ANY);
					}
				}

				State = 8703; Match(TABLE);
				}
				break;
			case 67:
				EnterOuterAlt(_localctx, 67);
				{
				State = 8704;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==BACKUP || _la==COMMENT || _la==DELETE || _la==DROP || _la==INSERT || _la==LOCK || _la==READ || _la==SELECT || _la==UPDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8705; Match(ANY);
				State = 8706; Match(TABLE);
				}
				break;
			case 68:
				EnterOuterAlt(_localctx, 68);
				{
				State = 8707;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP || _la==MANAGE || _la==UNLIMITED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8708; Match(TABLESPACE);
				}
				break;
			case 69:
				EnterOuterAlt(_localctx, 69);
				{
				State = 8709; Match(CREATE);
				State = 8711;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8710; Match(ANY);
					}
				}

				State = 8713; Match(TRIGGER);
				}
				break;
			case 70:
				EnterOuterAlt(_localctx, 70);
				{
				State = 8714;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8715; Match(ANY);
				State = 8716; Match(TRIGGER);
				}
				break;
			case 71:
				EnterOuterAlt(_localctx, 71);
				{
				State = 8717; Match(ADMINISTER);
				State = 8718; Match(DATABASE);
				State = 8719; Match(TRIGGER);
				}
				break;
			case 72:
				EnterOuterAlt(_localctx, 72);
				{
				State = 8720; Match(CREATE);
				State = 8722;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8721; Match(ANY);
					}
				}

				State = 8724; Match(TYPE);
				}
				break;
			case 73:
				EnterOuterAlt(_localctx, 73);
				{
				State = 8725;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==DROP || _la==EXECUTE || _la==UNDER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8726; Match(ANY);
				State = 8727; Match(TYPE);
				}
				break;
			case 74:
				EnterOuterAlt(_localctx, 74);
				{
				State = 8728;
				_la = TokenStream.LA(1);
				if ( !(_la==ALTER || _la==CREATE || _la==DROP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8729; Match(USER);
				}
				break;
			case 75:
				EnterOuterAlt(_localctx, 75);
				{
				State = 8730; Match(CREATE);
				State = 8732;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8731; Match(ANY);
					}
				}

				State = 8734; Match(VIEW);
				}
				break;
			case 76:
				EnterOuterAlt(_localctx, 76);
				{
				State = 8735;
				_la = TokenStream.LA(1);
				if ( !(_la==DROP || _la==MERGE || _la==UNDER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8736; Match(ANY);
				State = 8737; Match(VIEW);
				}
				break;
			case 77:
				EnterOuterAlt(_localctx, 77);
				{
				State = 8738;
				_la = TokenStream.LA(1);
				if ( !(_la==ANALYZE || _la==AUDIT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8739; Match(ANY);
				}
				break;
			case 78:
				EnterOuterAlt(_localctx, 78);
				{
				State = 8740; Match(BECOME);
				State = 8741; Match(USER);
				}
				break;
			case 79:
				EnterOuterAlt(_localctx, 79);
				{
				State = 8742; Match(CHANGE);
				State = 8743; Match(NOTIFICATION);
				}
				break;
			case 80:
				EnterOuterAlt(_localctx, 80);
				{
				State = 8744; Match(EXEMPT);
				State = 8745; Match(ACCESS);
				State = 8746; Match(POLICY);
				}
				break;
			case 81:
				EnterOuterAlt(_localctx, 81);
				{
				State = 8747; Match(FORCE);
				State = 8749;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANY) {
					{
					State = 8748; Match(ANY);
					}
				}

				State = 8751; Match(TRANSACTION);
				}
				break;
			case 82:
				EnterOuterAlt(_localctx, 82);
				{
				State = 8752; Match(GRANT);
				State = 8753; Match(ANY);
				State = 8755;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OBJECT) {
					{
					State = 8754; Match(OBJECT);
					}
				}

				State = 8757; Match(PRIVILEGE);
				}
				break;
			case 83:
				EnterOuterAlt(_localctx, 83);
				{
				State = 8758; Match(INHERIT);
				State = 8759; Match(ANY);
				State = 8760; Match(PRIVILEGES);
				}
				break;
			case 84:
				EnterOuterAlt(_localctx, 84);
				{
				State = 8761; Match(KEEP);
				State = 8762; Match(DATE);
				State = 8763; Match(TIME);
				}
				break;
			case 85:
				EnterOuterAlt(_localctx, 85);
				{
				State = 8764; Match(KEEP);
				State = 8765; Match(SYSGUID);
				}
				break;
			case 86:
				EnterOuterAlt(_localctx, 86);
				{
				State = 8766; Match(PURGE);
				State = 8767; Match(DBA_RECYCLEBIN);
				}
				break;
			case 87:
				EnterOuterAlt(_localctx, 87);
				{
				State = 8768; Match(RESUMABLE);
				}
				break;
			case 88:
				EnterOuterAlt(_localctx, 88);
				{
				State = 8769; Match(SELECT);
				State = 8770; Match(ANY);
				State = 8771;
				_la = TokenStream.LA(1);
				if ( !(_la==DICTIONARY || _la==TRANSACTION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 89:
				EnterOuterAlt(_localctx, 89);
				{
				State = 8772; Match(SYSBACKUP);
				}
				break;
			case 90:
				EnterOuterAlt(_localctx, 90);
				{
				State = 8773; Match(SYSDBA);
				}
				break;
			case 91:
				EnterOuterAlt(_localctx, 91);
				{
				State = 8774; Match(SYSDG);
				}
				break;
			case 92:
				EnterOuterAlt(_localctx, 92);
				{
				State = 8775; Match(SYSKM);
				}
				break;
			case 93:
				EnterOuterAlt(_localctx, 93);
				{
				State = 8776; Match(SYSOPER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 1126, RULE_literal);
		try {
			State = 8781;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1234,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8779; constant();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8780; function_call();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Literal_datetimeContext : ParserRuleContext {
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Literal_datetimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal_datetime; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral_datetime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Literal_datetimeContext literal_datetime() {
		Literal_datetimeContext _localctx = new Literal_datetimeContext(Context, State);
		EnterRule(_localctx, 1128, RULE_literal_datetime);
		try {
			State = 8786;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8783; Match(DATE);
				State = 8784; @string();
				}
				break;
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8785; function_call();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public StringContext[] @string() {
			return GetRuleContexts<StringContext>();
		}
		public StringContext @string(int i) {
			return GetRuleContext<StringContext>(i);
		}
		public Bind_variableContext[] bind_variable() {
			return GetRuleContexts<Bind_variableContext>();
		}
		public Bind_variableContext bind_variable(int i) {
			return GetRuleContext<Bind_variableContext>(i);
		}
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode[] DAY() { return GetTokens(PlSqlParser.DAY); }
		public ITerminalNode DAY(int i) {
			return GetToken(PlSqlParser.DAY, i);
		}
		public ITerminalNode[] HOUR() { return GetTokens(PlSqlParser.HOUR); }
		public ITerminalNode HOUR(int i) {
			return GetToken(PlSqlParser.HOUR, i);
		}
		public ITerminalNode[] MINUTE() { return GetTokens(PlSqlParser.MINUTE); }
		public ITerminalNode MINUTE(int i) {
			return GetToken(PlSqlParser.MINUTE, i);
		}
		public ITerminalNode[] SECOND() { return GetTokens(PlSqlParser.SECOND); }
		public ITerminalNode SECOND(int i) {
			return GetToken(PlSqlParser.SECOND, i);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode[] UNSIGNED_INTEGER() { return GetTokens(PlSqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(PlSqlParser.UNSIGNED_INTEGER, i);
		}
		public ITerminalNode COMMA() { return GetToken(PlSqlParser.COMMA, 0); }
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode TRUE() { return GetToken(PlSqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(PlSqlParser.FALSE, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(PlSqlParser.DBTIMEZONE, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(PlSqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 1130, RULE_constant);
		int _la;
		try {
			State = 8850;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8788; Match(TIMESTAMP);
				State = 8791;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 8789; @string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 8790; bind_variable();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 8797;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1237,Context) ) {
				case 1:
					{
					State = 8793; Match(AT);
					State = 8794; Match(TIME);
					State = 8795; Match(ZONE);
					State = 8796; @string();
					}
					break;
				}
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8799; Match(INTERVAL);
				State = 8803;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 8800; @string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 8801; bind_variable();
					}
					break;
				case ACCOUNT:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case A_LETTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BUILD:
				case BULK:
				case BYTE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHARACTER:
				case CHAR:
				case CHAR_CS:
				case CHR:
				case C_LETTER:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID_ALL:
				case CORRUPT_XID:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATABASE:
				case DATA:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case ID:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INTEGER:
				case INTERVAL:
				case INT:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case KEY:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LINK:
				case LIST:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINIMUM:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR_CS:
				case NCHAR:
				case NCLOB:
				case NESTED:
				case NEW:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NO:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case OPERATOR:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUTER:
				case OUT:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVEN:
				case POSITIVE:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIORITY:
				case PRIVILEGE:
				case PROGRAM:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REFERENCE:
				case REFERENCING:
				case REF:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT_CACHE:
				case RESULT:
				case RETURNING:
				case RETURN:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROWID:
				case ROW:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVEPOINT:
				case SAVE:
				case SCHEMACHECK:
				case SCHEMA:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SORT:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT_ID:
				case STATEMENT:
				case STATIC:
				case STATISTICS:
				case STORE:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case SYSDATE:
				case TEMPORARY:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIME:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USERS:
				case USER:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR2:
				case VARCHAR:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSIONS:
				case VERSION:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case XMLTYPE:
				case XML:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case SUBSTR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 8802; general_element_part();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 8805;
				_la = TokenStream.LA(1);
				if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==MONTH || _la==SECOND || _la==YEAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 8819;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1242,Context) ) {
				case 1:
					{
					State = 8806; Match(LEFT_PAREN);
					State = 8809;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case UNSIGNED_INTEGER:
						{
						State = 8807; Match(UNSIGNED_INTEGER);
						}
						break;
					case BINDVAR:
					case COLON:
						{
						State = 8808; bind_variable();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 8816;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 8811; Match(COMMA);
						State = 8814;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case UNSIGNED_INTEGER:
							{
							State = 8812; Match(UNSIGNED_INTEGER);
							}
							break;
						case BINDVAR:
						case COLON:
							{
							State = 8813; bind_variable();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
					}

					State = 8818; Match(RIGHT_PAREN);
					}
					break;
				}
				State = 8836;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1246,Context) ) {
				case 1:
					{
					State = 8821; Match(TO);
					State = 8834;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case DAY:
						{
						State = 8822; Match(DAY);
						}
						break;
					case HOUR:
						{
						State = 8823; Match(HOUR);
						}
						break;
					case MINUTE:
						{
						State = 8824; Match(MINUTE);
						}
						break;
					case SECOND:
						{
						State = 8825; Match(SECOND);
						State = 8832;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,1244,Context) ) {
						case 1:
							{
							State = 8826; Match(LEFT_PAREN);
							State = 8829;
							ErrorHandler.Sync(this);
							switch (TokenStream.LA(1)) {
							case UNSIGNED_INTEGER:
								{
								State = 8827; Match(UNSIGNED_INTEGER);
								}
								break;
							case BINDVAR:
							case COLON:
								{
								State = 8828; bind_variable();
								}
								break;
							default:
								throw new NoViableAltException(this);
							}
							State = 8831; Match(RIGHT_PAREN);
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case PLUS_SIGN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 8838; numeric();
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 8839; Match(DATE);
				State = 8840; @string();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 5);
				{
				State = 8841; @string();
				}
				break;
			case NULL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 8842; Match(NULL);
				}
				break;
			case TRUE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 8843; Match(TRUE);
				}
				break;
			case FALSE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 8844; Match(FALSE);
				}
				break;
			case DBTIMEZONE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 8845; Match(DBTIMEZONE);
				}
				break;
			case SESSIONTIMEZONE:
				EnterOuterAlt(_localctx, 10);
				{
				State = 8846; Match(SESSIONTIMEZONE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 8847; Match(MINVALUE);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 8848; Match(MAXVALUE);
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 13);
				{
				State = 8849; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 1132, RULE_identifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8854;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTRODUCER) {
				{
				State = 8852; Match(INTRODUCER);
				State = 8853; char_set_name();
				}
			}

			State = 8856; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Synonym_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Synonym_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_synonym_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSynonym_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Synonym_nameContext synonym_name() {
		Synonym_nameContext _localctx = new Synonym_nameContext(Context, State);
		EnterRule(_localctx, 1134, RULE_synonym_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8858; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Package_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_nameContext package_name() {
		Package_nameContext _localctx = new Package_nameContext(Context, State);
		EnterRule(_localctx, 1136, RULE_package_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8860; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Parameter_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_nameContext parameter_name() {
		Parameter_nameContext _localctx = new Parameter_nameContext(Context, State);
		EnterRule(_localctx, 1138, RULE_parameter_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8862; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_model_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Reference_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_model_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_model_nameContext reference_model_name() {
		Reference_model_nameContext _localctx = new Reference_model_nameContext(Context, State);
		EnterRule(_localctx, 1140, RULE_reference_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8864; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_class_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Cost_class_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_class_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCost_class_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cost_class_nameContext cost_class_name() {
		Cost_class_nameContext _localctx = new Cost_class_nameContext(Context, State);
		EnterRule(_localctx, 1142, RULE_cost_class_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8866; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Attribute_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_nameContext attribute_name() {
		Attribute_nameContext _localctx = new Attribute_nameContext(Context, State);
		EnterRule(_localctx, 1144, RULE_attribute_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8868; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Savepoint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepoint_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_nameContext savepoint_name() {
		Savepoint_nameContext _localctx = new Savepoint_nameContext(Context, State);
		EnterRule(_localctx, 1146, RULE_savepoint_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8870; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_segment_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Rollback_segment_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_segment_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollback_segment_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_segment_nameContext rollback_segment_name() {
		Rollback_segment_nameContext _localctx = new Rollback_segment_nameContext(Context, State);
		EnterRule(_localctx, 1148, RULE_rollback_segment_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8872; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_var_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Table_var_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_var_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_var_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_var_nameContext table_var_name() {
		Table_var_nameContext _localctx = new Table_var_nameContext(Context, State);
		EnterRule(_localctx, 1150, RULE_table_var_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8874; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Schema_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSchema_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Schema_nameContext schema_name() {
		Schema_nameContext _localctx = new Schema_nameContext(Context, State);
		EnterRule(_localctx, 1152, RULE_schema_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8876; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_model_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Main_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain_model_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Main_model_nameContext main_model_name() {
		Main_model_nameContext _localctx = new Main_model_nameContext(Context, State);
		EnterRule(_localctx, 1154, RULE_main_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8878; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Query_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_nameContext query_name() {
		Query_nameContext _localctx = new Query_nameContext(Context, State);
		EnterRule(_localctx, 1156, RULE_query_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8880; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Log_group_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Log_group_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_log_group_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLog_group_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Log_group_nameContext log_group_name() {
		Log_group_nameContext _localctx = new Log_group_nameContext(Context, State);
		EnterRule(_localctx, 1158, RULE_log_group_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8882; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifiersContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public IdentifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifiers; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifiers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifiersContext identifiers() {
		IdentifiersContext _localctx = new IdentifiersContext(Context, State);
		EnterRule(_localctx, 1160, RULE_identifiers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8884; identifier();
			State = 8889;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==PERIOD) {
				{
				{
				State = 8885; Match(PERIOD);
				State = 8886; id_expression();
				}
				}
				State = 8891;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Aggregate_function_nameContext : ParserRuleContext {
		public IdentifiersContext identifiers() {
			return GetRuleContext<IdentifiersContext>(0);
		}
		public Aggregate_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregate_function_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregate_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Aggregate_function_nameContext aggregate_function_name() {
		Aggregate_function_nameContext _localctx = new Aggregate_function_nameContext(Context, State);
		EnterRule(_localctx, 1162, RULE_aggregate_function_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8892; identifiers();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_nameContext : ParserRuleContext {
		public IdentifiersContext identifiers() {
			return GetRuleContext<IdentifiersContext>(0);
		}
		public Exception_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_nameContext exception_name() {
		Exception_nameContext _localctx = new Exception_nameContext(Context, State);
		EnterRule(_localctx, 1164, RULE_exception_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8894; identifiers();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_nameContext : ParserRuleContext {
		public IdentifiersContext identifiers() {
			return GetRuleContext<IdentifiersContext>(0);
		}
		public Column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_nameContext column_name() {
		Column_nameContext _localctx = new Column_nameContext(Context, State);
		EnterRule(_localctx, 1166, RULE_column_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8896; identifiers();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_expressionContext : ParserRuleContext {
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public ITerminalNode DELIMITED_ID() { return GetToken(PlSqlParser.DELIMITED_ID, 0); }
		public Id_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Id_expressionContext id_expression() {
		Id_expressionContext _localctx = new Id_expressionContext(Context, State);
		EnterRule(_localctx, 1168, RULE_id_expression);
		try {
			State = 8900;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCOUNT:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case A_LETTER:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BUILD:
			case BULK:
			case BYTE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHARACTER:
			case CHAR:
			case CHAR_CS:
			case CHR:
			case C_LETTER:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID_ALL:
			case CORRUPT_XID:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATABASE:
			case DATA:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case ID:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INTEGER:
			case INTERVAL:
			case INT:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case KEY:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LINK:
			case LIST:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINIMUM:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR_CS:
			case NCHAR:
			case NCLOB:
			case NESTED:
			case NEW:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NO:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case OPERATOR:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUTER:
			case OUT:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVEN:
			case POSITIVE:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIORITY:
			case PRIVILEGE:
			case PROGRAM:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REFERENCE:
			case REFERENCING:
			case REF:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT_CACHE:
			case RESULT:
			case RETURNING:
			case RETURN:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROWID:
			case ROW:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVEPOINT:
			case SAVE:
			case SCHEMACHECK:
			case SCHEMA:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SORT:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT_ID:
			case STATEMENT:
			case STATIC:
			case STATISTICS:
			case STORE:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case SYSDATE:
			case TEMPORARY:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIME:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USERS:
			case USER:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR2:
			case VARCHAR:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSIONS:
			case VERSION:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case XMLTYPE:
			case XML:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case SUBSTR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8898; regular_id();
				}
				break;
			case DELIMITED_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8899; Match(DELIMITED_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_expressionsContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Id_expressionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_expressions; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId_expressions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Id_expressionsContext id_expressions() {
		Id_expressionsContext _localctx = new Id_expressionsContext(Context, State);
		EnterRule(_localctx, 1170, RULE_id_expressions);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 8902; id_expression();
			State = 8907;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1251,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 8903; Match(PERIOD);
					State = 8904; id_expression();
					}
					} 
				}
				State = 8909;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1251,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_nameContext : ParserRuleContext {
		public Id_expressionsContext id_expressions() {
			return GetRuleContext<Id_expressionsContext>(0);
		}
		public Type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_nameContext type_name() {
		Type_nameContext _localctx = new Type_nameContext(Context, State);
		EnterRule(_localctx, 1172, RULE_type_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8910; id_expressions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_nameContext : ParserRuleContext {
		public Id_expressionsContext id_expressions() {
			return GetRuleContext<Id_expressionsContext>(0);
		}
		public Sequence_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_nameContext sequence_name() {
		Sequence_nameContext _localctx = new Sequence_nameContext(Context, State);
		EnterRule(_localctx, 1174, RULE_sequence_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8912; id_expressions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Char_set_nameContext : ParserRuleContext {
		public Id_expressionsContext id_expressions() {
			return GetRuleContext<Id_expressionsContext>(0);
		}
		public Char_set_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_char_set_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChar_set_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Char_set_nameContext char_set_name() {
		Char_set_nameContext _localctx = new Char_set_nameContext(Context, State);
		EnterRule(_localctx, 1176, RULE_char_set_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8914; id_expressions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_signContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode PLUS_SIGN() { return GetToken(PlSqlParser.PLUS_SIGN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlSqlParser.RIGHT_PAREN, 0); }
		public Outer_join_signContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_sign; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuter_join_sign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_signContext outer_join_sign() {
		Outer_join_signContext _localctx = new Outer_join_signContext(Context, State);
		EnterRule(_localctx, 1178, RULE_outer_join_sign);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8916; Match(LEFT_PAREN);
			State = 8917; Match(PLUS_SIGN);
			State = 8918; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Regular_idContext : ParserRuleContext {
		public ITerminalNode REGULAR_ID() { return GetToken(PlSqlParser.REGULAR_ID, 0); }
		public ITerminalNode A_LETTER() { return GetToken(PlSqlParser.A_LETTER, 0); }
		public ITerminalNode ACCOUNT() { return GetToken(PlSqlParser.ACCOUNT, 0); }
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public ITerminalNode AGENT() { return GetToken(PlSqlParser.AGENT, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(PlSqlParser.AGGREGATE, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlSqlParser.ANALYZE, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlSqlParser.ARRAY, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(PlSqlParser.ASSOCIATE, 0); }
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(PlSqlParser.ATTRIBUTE, 0); }
		public ITerminalNode AUDIT() { return GetToken(PlSqlParser.AUDIT, 0); }
		public ITerminalNode AUTHID() { return GetToken(PlSqlParser.AUTHID, 0); }
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public ITerminalNode AUTOMATIC() { return GetToken(PlSqlParser.AUTOMATIC, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(PlSqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode BATCH() { return GetToken(PlSqlParser.BATCH, 0); }
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode BFILE() { return GetToken(PlSqlParser.BFILE, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(PlSqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(PlSqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode BINARY_INTEGER() { return GetToken(PlSqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode BLOB() { return GetToken(PlSqlParser.BLOB, 0); }
		public ITerminalNode BLOCK() { return GetToken(PlSqlParser.BLOCK, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(PlSqlParser.BOOLEAN, 0); }
		public ITerminalNode BOTH() { return GetToken(PlSqlParser.BOTH, 0); }
		public ITerminalNode BUILD() { return GetToken(PlSqlParser.BUILD, 0); }
		public ITerminalNode BULK() { return GetToken(PlSqlParser.BULK, 0); }
		public ITerminalNode BYTE() { return GetToken(PlSqlParser.BYTE, 0); }
		public ITerminalNode C_LETTER() { return GetToken(PlSqlParser.C_LETTER, 0); }
		public ITerminalNode CALL() { return GetToken(PlSqlParser.CALL, 0); }
		public ITerminalNode CANONICAL() { return GetToken(PlSqlParser.CANONICAL, 0); }
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode CAST() { return GetToken(PlSqlParser.CAST, 0); }
		public ITerminalNode CHAR() { return GetToken(PlSqlParser.CHAR, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(PlSqlParser.CHAR_CS, 0); }
		public ITerminalNode CHARACTER() { return GetToken(PlSqlParser.CHARACTER, 0); }
		public ITerminalNode CHR() { return GetToken(PlSqlParser.CHR, 0); }
		public ITerminalNode CLOB() { return GetToken(PlSqlParser.CLOB, 0); }
		public ITerminalNode CLOSE() { return GetToken(PlSqlParser.CLOSE, 0); }
		public ITerminalNode CLUSTER() { return GetToken(PlSqlParser.CLUSTER, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public ITerminalNode COLUMNS() { return GetToken(PlSqlParser.COLUMNS, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode COMMITTED() { return GetToken(PlSqlParser.COMMITTED, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(PlSqlParser.COMPATIBILITY, 0); }
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode COMPOUND() { return GetToken(PlSqlParser.COMPOUND, 0); }
		public ITerminalNode CONSTANT() { return GetToken(PlSqlParser.CONSTANT, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(PlSqlParser.CONSTRAINTS, 0); }
		public ITerminalNode CONSTRUCTOR() { return GetToken(PlSqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode CONTENT() { return GetToken(PlSqlParser.CONTENT, 0); }
		public ITerminalNode CONTEXT() { return GetToken(PlSqlParser.CONTEXT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(PlSqlParser.CONTINUE, 0); }
		public ITerminalNode CONVERT() { return GetToken(PlSqlParser.CONVERT, 0); }
		public ITerminalNode CORRUPT_XID() { return GetToken(PlSqlParser.CORRUPT_XID, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(PlSqlParser.CORRUPT_XID_ALL, 0); }
		public ITerminalNode COST() { return GetToken(PlSqlParser.COST, 0); }
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public ITerminalNode CROSS() { return GetToken(PlSqlParser.CROSS, 0); }
		public ITerminalNode CUBE() { return GetToken(PlSqlParser.CUBE, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(PlSqlParser.CURRENT_USER, 0); }
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(PlSqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public ITerminalNode DATA() { return GetToken(PlSqlParser.DATA, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(PlSqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(PlSqlParser.DBTIMEZONE, 0); }
		public ITerminalNode DDL() { return GetToken(PlSqlParser.DDL, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public ITerminalNode DEC() { return GetToken(PlSqlParser.DEC, 0); }
		public ITerminalNode DECIMAL() { return GetToken(PlSqlParser.DECIMAL, 0); }
		public ITerminalNode DECOMPOSE() { return GetToken(PlSqlParser.DECOMPOSE, 0); }
		public ITerminalNode DECREMENT() { return GetToken(PlSqlParser.DECREMENT, 0); }
		public ITerminalNode DEFAULTS() { return GetToken(PlSqlParser.DEFAULTS, 0); }
		public ITerminalNode DEFERRED() { return GetToken(PlSqlParser.DEFERRED, 0); }
		public ITerminalNode DEFINER() { return GetToken(PlSqlParser.DEFINER, 0); }
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode DETERMINISTIC() { return GetToken(PlSqlParser.DETERMINISTIC, 0); }
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(PlSqlParser.DISASSOCIATE, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlSqlParser.DOCUMENT, 0); }
		public ITerminalNode DOUBLE() { return GetToken(PlSqlParser.DOUBLE, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode EACH() { return GetToken(PlSqlParser.EACH, 0); }
		public ITerminalNode ELEMENT() { return GetToken(PlSqlParser.ELEMENT, 0); }
		public ITerminalNode EMPTY() { return GetToken(PlSqlParser.EMPTY, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode ENCODING() { return GetToken(PlSqlParser.ENCODING, 0); }
		public ITerminalNode ENTITYESCAPING() { return GetToken(PlSqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode ERR() { return GetToken(PlSqlParser.ERR, 0); }
		public ITerminalNode ERRORS() { return GetToken(PlSqlParser.ERRORS, 0); }
		public ITerminalNode ESCAPE() { return GetToken(PlSqlParser.ESCAPE, 0); }
		public ITerminalNode EVALNAME() { return GetToken(PlSqlParser.EVALNAME, 0); }
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(PlSqlParser.EXCEPTION_INIT, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(PlSqlParser.EXCLUDE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public ITerminalNode EXIT() { return GetToken(PlSqlParser.EXIT, 0); }
		public ITerminalNode EXPLAIN() { return GetToken(PlSqlParser.EXPLAIN, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode EXTRACT() { return GetToken(PlSqlParser.EXTRACT, 0); }
		public ITerminalNode FAILURE() { return GetToken(PlSqlParser.FAILURE, 0); }
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(PlSqlParser.FIRST_VALUE, 0); }
		public ITerminalNode FLOAT() { return GetToken(PlSqlParser.FLOAT, 0); }
		public ITerminalNode FOLLOWING() { return GetToken(PlSqlParser.FOLLOWING, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(PlSqlParser.FOLLOWS, 0); }
		public ITerminalNode FORALL() { return GetToken(PlSqlParser.FORALL, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode FULL() { return GetToken(PlSqlParser.FULL, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public ITerminalNode GROUPING() { return GetToken(PlSqlParser.GROUPING, 0); }
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public ITerminalNode HIDE() { return GetToken(PlSqlParser.HIDE, 0); }
		public ITerminalNode HOUR() { return GetToken(PlSqlParser.HOUR, 0); }
		public ITerminalNode ID() { return GetToken(PlSqlParser.ID, 0); }
		public ITerminalNode IGNORE() { return GetToken(PlSqlParser.IGNORE, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode INCLUDE() { return GetToken(PlSqlParser.INCLUDE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(PlSqlParser.INCLUDING, 0); }
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode INDENT() { return GetToken(PlSqlParser.INDENT, 0); }
		public ITerminalNode INDEXED() { return GetToken(PlSqlParser.INDEXED, 0); }
		public ITerminalNode INDICATOR() { return GetToken(PlSqlParser.INDICATOR, 0); }
		public ITerminalNode INDICES() { return GetToken(PlSqlParser.INDICES, 0); }
		public ITerminalNode INFINITE() { return GetToken(PlSqlParser.INFINITE, 0); }
		public ITerminalNode INLINE() { return GetToken(PlSqlParser.INLINE, 0); }
		public ITerminalNode INNER() { return GetToken(PlSqlParser.INNER, 0); }
		public ITerminalNode INOUT() { return GetToken(PlSqlParser.INOUT, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public ITerminalNode INSTEAD() { return GetToken(PlSqlParser.INSTEAD, 0); }
		public ITerminalNode INT() { return GetToken(PlSqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(PlSqlParser.INTEGER, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode INVALIDATE() { return GetToken(PlSqlParser.INVALIDATE, 0); }
		public ITerminalNode ISOLATION() { return GetToken(PlSqlParser.ISOLATION, 0); }
		public ITerminalNode ITERATE() { return GetToken(PlSqlParser.ITERATE, 0); }
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode JOIN() { return GetToken(PlSqlParser.JOIN, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode KEY() { return GetToken(PlSqlParser.KEY, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(PlSqlParser.LANGUAGE, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(PlSqlParser.LAST_VALUE, 0); }
		public ITerminalNode LEADING() { return GetToken(PlSqlParser.LEADING, 0); }
		public ITerminalNode LEFT() { return GetToken(PlSqlParser.LEFT, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlSqlParser.LEVEL, 0); }
		public ITerminalNode LIBRARY() { return GetToken(PlSqlParser.LIBRARY, 0); }
		public ITerminalNode LIKE2() { return GetToken(PlSqlParser.LIKE2, 0); }
		public ITerminalNode LIKE4() { return GetToken(PlSqlParser.LIKE4, 0); }
		public ITerminalNode LIKEC() { return GetToken(PlSqlParser.LIKEC, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public ITerminalNode LINK() { return GetToken(PlSqlParser.LINK, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode LOCKED() { return GetToken(PlSqlParser.LOCKED, 0); }
		public ITerminalNode LOG() { return GetToken(PlSqlParser.LOG, 0); }
		public ITerminalNode LOGOFF() { return GetToken(PlSqlParser.LOGOFF, 0); }
		public ITerminalNode LOGON() { return GetToken(PlSqlParser.LOGON, 0); }
		public ITerminalNode LONG() { return GetToken(PlSqlParser.LONG, 0); }
		public ITerminalNode LOOP() { return GetToken(PlSqlParser.LOOP, 0); }
		public ITerminalNode MAIN() { return GetToken(PlSqlParser.MAIN, 0); }
		public ITerminalNode MAP() { return GetToken(PlSqlParser.MAP, 0); }
		public ITerminalNode MATCHED() { return GetToken(PlSqlParser.MATCHED, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode MEASURES() { return GetToken(PlSqlParser.MEASURES, 0); }
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode MERGE() { return GetToken(PlSqlParser.MERGE, 0); }
		public ITerminalNode MINIMUM() { return GetToken(PlSqlParser.MINIMUM, 0); }
		public ITerminalNode MINUTE() { return GetToken(PlSqlParser.MINUTE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(PlSqlParser.MLSLABEL, 0); }
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public ITerminalNode MODIFY() { return GetToken(PlSqlParser.MODIFY, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode MULTISET() { return GetToken(PlSqlParser.MULTISET, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode NAN() { return GetToken(PlSqlParser.NAN, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlSqlParser.NATURAL, 0); }
		public ITerminalNode NATURALN() { return GetToken(PlSqlParser.NATURALN, 0); }
		public ITerminalNode NAV() { return GetToken(PlSqlParser.NAV, 0); }
		public ITerminalNode NCHAR() { return GetToken(PlSqlParser.NCHAR, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(PlSqlParser.NCHAR_CS, 0); }
		public ITerminalNode NCLOB() { return GetToken(PlSqlParser.NCLOB, 0); }
		public ITerminalNode NESTED() { return GetToken(PlSqlParser.NESTED, 0); }
		public ITerminalNode NEW() { return GetToken(PlSqlParser.NEW, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(PlSqlParser.NOAUDIT, 0); }
		public ITerminalNode NOCOPY() { return GetToken(PlSqlParser.NOCOPY, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(PlSqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(PlSqlParser.NOSCHEMACHECK, 0); }
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode NUMBER() { return GetToken(PlSqlParser.NUMBER, 0); }
		public ITerminalNode NUMERIC() { return GetToken(PlSqlParser.NUMERIC, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(PlSqlParser.NVARCHAR2, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public ITerminalNode OFF() { return GetToken(PlSqlParser.OFF, 0); }
		public ITerminalNode OID() { return GetToken(PlSqlParser.OID, 0); }
		public ITerminalNode OLD() { return GetToken(PlSqlParser.OLD, 0); }
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode OPEN() { return GetToken(PlSqlParser.OPEN, 0); }
		public ITerminalNode OPERATOR() { return GetToken(PlSqlParser.OPERATOR, 0); }
		public ITerminalNode ORADATA() { return GetToken(PlSqlParser.ORADATA, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlSqlParser.ORDINALITY, 0); }
		public ITerminalNode OSERROR() { return GetToken(PlSqlParser.OSERROR, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public ITerminalNode OUTER() { return GetToken(PlSqlParser.OUTER, 0); }
		public ITerminalNode OVER() { return GetToken(PlSqlParser.OVER, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(PlSqlParser.OVERRIDING, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(PlSqlParser.PARALLEL_ENABLE, 0); }
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public ITerminalNode PARENT() { return GetToken(PlSqlParser.PARENT, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode PASSING() { return GetToken(PlSqlParser.PASSING, 0); }
		public ITerminalNode PASSWORD() { return GetToken(PlSqlParser.PASSWORD, 0); }
		public ITerminalNode PATH() { return GetToken(PlSqlParser.PATH, 0); }
		public ITerminalNode PIPELINED() { return GetToken(PlSqlParser.PIPELINED, 0); }
		public ITerminalNode PLAN() { return GetToken(PlSqlParser.PLAN, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(PlSqlParser.PLS_INTEGER, 0); }
		public ITerminalNode POSITIVE() { return GetToken(PlSqlParser.POSITIVE, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(PlSqlParser.POSITIVEN, 0); }
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public ITerminalNode PRECEDING() { return GetToken(PlSqlParser.PRECEDING, 0); }
		public ITerminalNode PRECISION() { return GetToken(PlSqlParser.PRECISION, 0); }
		public ITerminalNode PRESENT() { return GetToken(PlSqlParser.PRESENT, 0); }
		public ITerminalNode PRIVILEGE() { return GetToken(PlSqlParser.PRIVILEGE, 0); }
		public ITerminalNode PRIORITY() { return GetToken(PlSqlParser.PRIORITY, 0); }
		public ITerminalNode PROGRAM() { return GetToken(PlSqlParser.PROGRAM, 0); }
		public ITerminalNode RAISE() { return GetToken(PlSqlParser.RAISE, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public ITerminalNode RAW() { return GetToken(PlSqlParser.RAW, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode REAL() { return GetToken(PlSqlParser.REAL, 0); }
		public ITerminalNode RECORD() { return GetToken(PlSqlParser.RECORD, 0); }
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public ITerminalNode REFERENCING() { return GetToken(PlSqlParser.REFERENCING, 0); }
		public ITerminalNode REJECT() { return GetToken(PlSqlParser.REJECT, 0); }
		public ITerminalNode RELIES_ON() { return GetToken(PlSqlParser.RELIES_ON, 0); }
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode RESPECT() { return GetToken(PlSqlParser.RESPECT, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(PlSqlParser.RESTRICT_REFERENCES, 0); }
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public ITerminalNode RESULT_CACHE() { return GetToken(PlSqlParser.RESULT_CACHE, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode REVERSE() { return GetToken(PlSqlParser.REVERSE, 0); }
		public ITerminalNode REVOKE() { return GetToken(PlSqlParser.REVOKE, 0); }
		public ITerminalNode RIGHT() { return GetToken(PlSqlParser.RIGHT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode ROLLUP() { return GetToken(PlSqlParser.ROLLUP, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public ITerminalNode RULES() { return GetToken(PlSqlParser.RULES, 0); }
		public ITerminalNode SAMPLE() { return GetToken(PlSqlParser.SAMPLE, 0); }
		public ITerminalNode SAVE() { return GetToken(PlSqlParser.SAVE, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(PlSqlParser.SAVEPOINT, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlSqlParser.SCHEMA, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(PlSqlParser.SCHEMACHECK, 0); }
		public ITerminalNode SCN() { return GetToken(PlSqlParser.SCN, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public ITerminalNode SEED() { return GetToken(PlSqlParser.SEED, 0); }
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode SELF() { return GetToken(PlSqlParser.SELF, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(PlSqlParser.SEQUENTIAL, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(PlSqlParser.SERIALIZABLE, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(PlSqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(PlSqlParser.SERVERERROR, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(PlSqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode SETS() { return GetToken(PlSqlParser.SETS, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public ITerminalNode SHOW() { return GetToken(PlSqlParser.SHOW, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(PlSqlParser.SHUTDOWN, 0); }
		public ITerminalNode SIBLINGS() { return GetToken(PlSqlParser.SIBLINGS, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(PlSqlParser.SIGNTYPE, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(PlSqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode SINGLE() { return GetToken(PlSqlParser.SINGLE, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public ITerminalNode SKIP_() { return GetToken(PlSqlParser.SKIP_, 0); }
		public ITerminalNode SMALLINT() { return GetToken(PlSqlParser.SMALLINT, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(PlSqlParser.SNAPSHOT, 0); }
		public ITerminalNode SOME() { return GetToken(PlSqlParser.SOME, 0); }
		public ITerminalNode SORT() { return GetToken(PlSqlParser.SORT, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(PlSqlParser.SPECIFICATION, 0); }
		public ITerminalNode SQLDATA() { return GetToken(PlSqlParser.SQLDATA, 0); }
		public ITerminalNode SQLERROR() { return GetToken(PlSqlParser.SQLERROR, 0); }
		public ITerminalNode STANDALONE() { return GetToken(PlSqlParser.STANDALONE, 0); }
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode STARTUP() { return GetToken(PlSqlParser.STARTUP, 0); }
		public ITerminalNode STATEMENT() { return GetToken(PlSqlParser.STATEMENT, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(PlSqlParser.STATEMENT_ID, 0); }
		public ITerminalNode STATIC() { return GetToken(PlSqlParser.STATIC, 0); }
		public ITerminalNode STATISTICS() { return GetToken(PlSqlParser.STATISTICS, 0); }
		public ITerminalNode STRING() { return GetToken(PlSqlParser.STRING, 0); }
		public ITerminalNode STORE() { return GetToken(PlSqlParser.STORE, 0); }
		public ITerminalNode SUBSTR() { return GetToken(PlSqlParser.SUBSTR, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(PlSqlParser.SUBMULTISET, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(PlSqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode SUBTYPE() { return GetToken(PlSqlParser.SUBTYPE, 0); }
		public ITerminalNode SUCCESS() { return GetToken(PlSqlParser.SUCCESS, 0); }
		public ITerminalNode SUSPEND() { return GetToken(PlSqlParser.SUSPEND, 0); }
		public ITerminalNode SYSDATE() { return GetToken(PlSqlParser.SYSDATE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(PlSqlParser.TEMPORARY, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(PlSqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(PlSqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(PlSqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(PlSqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode TRAILING() { return GetToken(PlSqlParser.TRAILING, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlSqlParser.TRANSACTION, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(PlSqlParser.TRANSLATE, 0); }
		public ITerminalNode TREAT() { return GetToken(PlSqlParser.TREAT, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode TRIM() { return GetToken(PlSqlParser.TRIM, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(PlSqlParser.TRUNCATE, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public ITerminalNode UNBOUNDED() { return GetToken(PlSqlParser.UNBOUNDED, 0); }
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public ITerminalNode UNTIL() { return GetToken(PlSqlParser.UNTIL, 0); }
		public ITerminalNode UPDATED() { return GetToken(PlSqlParser.UPDATED, 0); }
		public ITerminalNode UPSERT() { return GetToken(PlSqlParser.UPSERT, 0); }
		public ITerminalNode UROWID() { return GetToken(PlSqlParser.UROWID, 0); }
		public ITerminalNode USE() { return GetToken(PlSqlParser.USE, 0); }
		public ITerminalNode USER() { return GetToken(PlSqlParser.USER, 0); }
		public ITerminalNode USERS() { return GetToken(PlSqlParser.USERS, 0); }
		public ITerminalNode VALIDATE() { return GetToken(PlSqlParser.VALIDATE, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public ITerminalNode VARCHAR() { return GetToken(PlSqlParser.VARCHAR, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(PlSqlParser.VARCHAR2, 0); }
		public ITerminalNode VARIABLE() { return GetToken(PlSqlParser.VARIABLE, 0); }
		public ITerminalNode VARRAY() { return GetToken(PlSqlParser.VARRAY, 0); }
		public ITerminalNode VARYING() { return GetToken(PlSqlParser.VARYING, 0); }
		public ITerminalNode VERSION() { return GetToken(PlSqlParser.VERSION, 0); }
		public ITerminalNode VERSIONS() { return GetToken(PlSqlParser.VERSIONS, 0); }
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ITerminalNode WARNING() { return GetToken(PlSqlParser.WARNING, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(PlSqlParser.WELLFORMED, 0); }
		public ITerminalNode WHENEVER() { return GetToken(PlSqlParser.WHENEVER, 0); }
		public ITerminalNode WHILE() { return GetToken(PlSqlParser.WHILE, 0); }
		public ITerminalNode WITHIN() { return GetToken(PlSqlParser.WITHIN, 0); }
		public ITerminalNode WORK() { return GetToken(PlSqlParser.WORK, 0); }
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public ITerminalNode XML() { return GetToken(PlSqlParser.XML, 0); }
		public ITerminalNode XMLAGG() { return GetToken(PlSqlParser.XMLAGG, 0); }
		public ITerminalNode XMLATTRIBUTES() { return GetToken(PlSqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode XMLCAST() { return GetToken(PlSqlParser.XMLCAST, 0); }
		public ITerminalNode XMLCOLATTVAL() { return GetToken(PlSqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(PlSqlParser.XMLELEMENT, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(PlSqlParser.XMLEXISTS, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(PlSqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLNAMESPACES() { return GetToken(PlSqlParser.XMLNAMESPACES, 0); }
		public ITerminalNode XMLPARSE() { return GetToken(PlSqlParser.XMLPARSE, 0); }
		public ITerminalNode XMLPI() { return GetToken(PlSqlParser.XMLPI, 0); }
		public ITerminalNode XMLQUERY() { return GetToken(PlSqlParser.XMLQUERY, 0); }
		public ITerminalNode XMLROOT() { return GetToken(PlSqlParser.XMLROOT, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(PlSqlParser.XMLSERIALIZE, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(PlSqlParser.XMLTABLE, 0); }
		public ITerminalNode XMLTYPE() { return GetToken(PlSqlParser.XMLTYPE, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode YES() { return GetToken(PlSqlParser.YES, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ITerminalNode PREDICTION() { return GetToken(PlSqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(PlSqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(PlSqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(PlSqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(PlSqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(PlSqlParser.PREDICTION_SET, 0); }
		public ITerminalNode CUME_DIST() { return GetToken(PlSqlParser.CUME_DIST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(PlSqlParser.DENSE_RANK, 0); }
		public ITerminalNode LIST() { return GetToken(PlSqlParser.LIST, 0); }
		public ITerminalNode LISTAGG() { return GetToken(PlSqlParser.LISTAGG, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(PlSqlParser.PERCENT_RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(PlSqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(PlSqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode RANK() { return GetToken(PlSqlParser.RANK, 0); }
		public ITerminalNode AVG() { return GetToken(PlSqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(PlSqlParser.CORR, 0); }
		public ITerminalNode LAG() { return GetToken(PlSqlParser.LAG, 0); }
		public ITerminalNode LEAD() { return GetToken(PlSqlParser.LEAD, 0); }
		public ITerminalNode MAX() { return GetToken(PlSqlParser.MAX, 0); }
		public ITerminalNode MEDIAN() { return GetToken(PlSqlParser.MEDIAN, 0); }
		public ITerminalNode MIN() { return GetToken(PlSqlParser.MIN, 0); }
		public ITerminalNode NTILE() { return GetToken(PlSqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(PlSqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(PlSqlParser.ROW_NUMBER, 0); }
		public ITerminalNode SUM() { return GetToken(PlSqlParser.SUM, 0); }
		public ITerminalNode VARIANCE() { return GetToken(PlSqlParser.VARIANCE, 0); }
		public ITerminalNode REGR_() { return GetToken(PlSqlParser.REGR_, 0); }
		public ITerminalNode STDDEV() { return GetToken(PlSqlParser.STDDEV, 0); }
		public ITerminalNode VAR_() { return GetToken(PlSqlParser.VAR_, 0); }
		public ITerminalNode COVAR_() { return GetToken(PlSqlParser.COVAR_, 0); }
		public Regular_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regular_id; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegular_id(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Regular_idContext regular_id() {
		Regular_idContext _localctx = new Regular_idContext(Context, State);
		EnterRule(_localctx, 1180, RULE_regular_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8920;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCOUNT) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << A_LETTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BUILD) | (1L << BULK) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CANONICAL - 64)) | (1L << (CASCADE - 64)) | (1L << (CAST - 64)) | (1L << (CHARACTER - 64)) | (1L << (CHAR - 64)) | (1L << (CHAR_CS - 64)) | (1L << (CHR - 64)) | (1L << (C_LETTER - 64)) | (1L << (CLOB - 64)) | (1L << (CLOSE - 64)) | (1L << (CLUSTER - 64)) | (1L << (COLLECT - 64)) | (1L << (COLUMNS - 64)) | (1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATA - 64)) | (1L << (DAY - 64)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (DB_ROLE_CHANGE - 130)) | (1L << (DBTIMEZONE - 130)) | (1L << (DDL - 130)) | (1L << (DEBUG - 130)) | (1L << (DEC - 130)) | (1L << (DECIMAL - 130)) | (1L << (DECOMPOSE - 130)) | (1L << (DECREMENT - 130)) | (1L << (DEFAULTS - 130)) | (1L << (DEFERRED - 130)) | (1L << (DEFINER - 130)) | (1L << (DELETE - 130)) | (1L << (DETERMINISTIC - 130)) | (1L << (DIMENSION - 130)) | (1L << (DISABLE - 130)) | (1L << (DISASSOCIATE - 130)) | (1L << (DOCUMENT - 130)) | (1L << (DOUBLE - 130)) | (1L << (DSINTERVAL_UNCONSTRAINED - 130)) | (1L << (EACH - 130)) | (1L << (ELEMENT - 130)) | (1L << (EMPTY - 130)) | (1L << (ENABLE - 130)) | (1L << (ENCODING - 130)) | (1L << (ENTITYESCAPING - 130)) | (1L << (ERR - 130)) | (1L << (ERRORS - 130)) | (1L << (ESCAPE - 130)) | (1L << (EVALNAME - 130)) | (1L << (EXCEPTION - 130)) | (1L << (EXCEPTION_INIT - 130)) | (1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (EXIT - 196)) | (1L << (EXPLAIN - 196)) | (1L << (EXTERNAL - 196)) | (1L << (EXTRACT - 196)) | (1L << (FAILURE - 196)) | (1L << (FINAL - 196)) | (1L << (FIRST - 196)) | (1L << (FIRST_VALUE - 196)) | (1L << (FLOAT - 196)) | (1L << (FOLLOWING - 196)) | (1L << (FOLLOWS - 196)) | (1L << (FORALL - 196)) | (1L << (FORCE - 196)) | (1L << (FULL - 196)) | (1L << (FUNCTION - 196)) | (1L << (GROUPING - 196)) | (1L << (HASH - 196)) | (1L << (HIDE - 196)) | (1L << (HOUR - 196)) | (1L << (ID - 196)) | (1L << (IGNORE - 196)) | (1L << (IMMEDIATE - 196)) | (1L << (INCLUDE - 196)) | (1L << (INCLUDING - 196)) | (1L << (INCREMENT - 196)) | (1L << (INDENT - 196)) | (1L << (INDEXED - 196)) | (1L << (INDICATOR - 196)) | (1L << (INDICES - 196)))) != 0) || ((((_la - 260)) & ~0x3f) == 0 && ((1L << (_la - 260)) & ((1L << (INFINITE - 260)) | (1L << (INLINE - 260)) | (1L << (INNER - 260)) | (1L << (INOUT - 260)) | (1L << (INSTANTIABLE - 260)) | (1L << (INSTEAD - 260)) | (1L << (INTEGER - 260)) | (1L << (INTERVAL - 260)) | (1L << (INT - 260)) | (1L << (INVALIDATE - 260)) | (1L << (ISOLATION - 260)) | (1L << (ITERATE - 260)) | (1L << (JAVA - 260)) | (1L << (JOIN - 260)) | (1L << (KEEP - 260)) | (1L << (KEY - 260)) | (1L << (LANGUAGE - 260)) | (1L << (LAST - 260)) | (1L << (LAST_VALUE - 260)) | (1L << (LEADING - 260)) | (1L << (LEFT - 260)) | (1L << (LEVEL - 260)) | (1L << (LIBRARY - 260)) | (1L << (LIKE2 - 260)) | (1L << (LIKE4 - 260)) | (1L << (LIKEC - 260)) | (1L << (LIMIT - 260)) | (1L << (LINK - 260)) | (1L << (LIST - 260)) | (1L << (LOCAL - 260)) | (1L << (LOCKED - 260)) | (1L << (LOG - 260)) | (1L << (LOGOFF - 260)) | (1L << (LOGON - 260)) | (1L << (LONG - 260)) | (1L << (LOOP - 260)))) != 0) || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (MAIN - 324)) | (1L << (MAP - 324)) | (1L << (MATCHED - 324)) | (1L << (MAXVALUE - 324)) | (1L << (MEASURES - 324)) | (1L << (MEMBER - 324)) | (1L << (MERGE - 324)) | (1L << (MINIMUM - 324)) | (1L << (MINUTE - 324)) | (1L << (MINVALUE - 324)) | (1L << (MLSLABEL - 324)) | (1L << (MODEL - 324)) | (1L << (MODIFY - 324)) | (1L << (MONTH - 324)) | (1L << (MULTISET - 324)) | (1L << (NAME - 324)) | (1L << (NAN - 324)) | (1L << (NATURAL - 324)) | (1L << (NATURALN - 324)) | (1L << (NAV - 324)) | (1L << (NCHAR_CS - 324)) | (1L << (NCHAR - 324)) | (1L << (NCLOB - 324)) | (1L << (NESTED - 324)) | (1L << (NEW - 324)) | (1L << (NOAUDIT - 324)) | (1L << (NOCOPY - 324)) | (1L << (NOCYCLE - 324)) | (1L << (NOENTITYESCAPING - 324)) | (1L << (NONE - 324)) | (1L << (NO - 324)))) != 0) || ((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (NOSCHEMACHECK - 389)) | (1L << (NULLS - 389)) | (1L << (NUMBER - 389)) | (1L << (NUMERIC - 389)) | (1L << (NVARCHAR2 - 389)) | (1L << (OBJECT - 389)) | (1L << (OFF - 389)) | (1L << (OID - 389)) | (1L << (OLD - 389)) | (1L << (ONLY - 389)) | (1L << (OPEN - 389)) | (1L << (OPERATOR - 389)) | (1L << (ORADATA - 389)) | (1L << (ORDINALITY - 389)) | (1L << (OSERROR - 389)) | (1L << (OUTER - 389)) | (1L << (OUT - 389)) | (1L << (OVER - 389)) | (1L << (OVERRIDING - 389)) | (1L << (PACKAGE - 389)) | (1L << (PARALLEL_ENABLE - 389)) | (1L << (PARAMETERS - 389)) | (1L << (PARENT - 389)) | (1L << (PARTITION - 389)) | (1L << (PASSING - 389)) | (1L << (PASSWORD - 389)) | (1L << (PATH - 389)) | (1L << (PIPELINED - 389)) | (1L << (PLAN - 389)) | (1L << (PLS_INTEGER - 389)))) != 0) || ((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (POSITIVEN - 455)) | (1L << (POSITIVE - 455)) | (1L << (PRAGMA - 455)) | (1L << (PRECEDING - 455)) | (1L << (PRECISION - 455)) | (1L << (PRESENT - 455)) | (1L << (PRIORITY - 455)) | (1L << (PRIVILEGE - 455)) | (1L << (PROGRAM - 455)) | (1L << (RAISE - 455)) | (1L << (RANGE - 455)) | (1L << (RAW - 455)) | (1L << (READ - 455)) | (1L << (REAL - 455)) | (1L << (RECORD - 455)) | (1L << (REFERENCE - 455)) | (1L << (REFERENCING - 455)) | (1L << (REF - 455)) | (1L << (REJECT - 455)) | (1L << (RELIES_ON - 455)) | (1L << (RENAME - 455)) | (1L << (REPLACE - 455)) | (1L << (RESPECT - 455)) | (1L << (RESTRICT_REFERENCES - 455)) | (1L << (RESULT_CACHE - 455)) | (1L << (RESULT - 455)) | (1L << (RETURNING - 455)) | (1L << (RETURN - 455)) | (1L << (REUSE - 455)) | (1L << (REVERSE - 455)) | (1L << (REVOKE - 455)) | (1L << (RIGHT - 455)) | (1L << (ROLLBACK - 455)) | (1L << (ROLLUP - 455)) | (1L << (ROWID - 455)))) != 0) || ((((_la - 519)) & ~0x3f) == 0 && ((1L << (_la - 519)) & ((1L << (ROW - 519)) | (1L << (ROWS - 519)) | (1L << (RULES - 519)) | (1L << (SAMPLE - 519)) | (1L << (SAVEPOINT - 519)) | (1L << (SAVE - 519)) | (1L << (SCHEMACHECK - 519)) | (1L << (SCHEMA - 519)) | (1L << (SCN - 519)) | (1L << (SECOND - 519)) | (1L << (SEED - 519)) | (1L << (SEGMENT - 519)) | (1L << (SELF - 519)) | (1L << (SEQUENCE - 519)) | (1L << (SEQUENTIAL - 519)) | (1L << (SERIALIZABLE - 519)) | (1L << (SERIALLY_REUSABLE - 519)) | (1L << (SERVERERROR - 519)) | (1L << (SESSIONTIMEZONE - 519)) | (1L << (SET - 519)) | (1L << (SETS - 519)) | (1L << (SETTINGS - 519)) | (1L << (SHOW - 519)) | (1L << (SHUTDOWN - 519)) | (1L << (SIBLINGS - 519)) | (1L << (SIGNTYPE - 519)) | (1L << (SIMPLE_INTEGER - 519)) | (1L << (SINGLE - 519)) | (1L << (SIZE - 519)) | (1L << (SKIP_ - 519)) | (1L << (SMALLINT - 519)) | (1L << (SNAPSHOT - 519)) | (1L << (SOME - 519)) | (1L << (SORT - 519)) | (1L << (SPECIFICATION - 519)) | (1L << (SQLDATA - 519)) | (1L << (SQLERROR - 519)) | (1L << (STANDALONE - 519)) | (1L << (START - 519)) | (1L << (STARTUP - 519)) | (1L << (STATEMENT_ID - 519)) | (1L << (STATEMENT - 519)) | (1L << (STATIC - 519)) | (1L << (STATISTICS - 519)) | (1L << (STORE - 519)) | (1L << (STRING - 519)) | (1L << (SUBMULTISET - 519)) | (1L << (SUBPARTITION - 519)) | (1L << (SUBSTITUTABLE - 519)))) != 0) || ((((_la - 583)) & ~0x3f) == 0 && ((1L << (_la - 583)) & ((1L << (SUBTYPE - 583)) | (1L << (SUCCESS - 583)) | (1L << (SUSPEND - 583)) | (1L << (SYSDATE - 583)) | (1L << (TEMPORARY - 583)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP - 583)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 583)) | (1L << (TIMESTAMP_UNCONSTRAINED - 583)) | (1L << (TIME - 583)) | (1L << (TIMEZONE_ABBR - 583)) | (1L << (TIMEZONE_HOUR - 583)) | (1L << (TIMEZONE_MINUTE - 583)) | (1L << (TIMEZONE_REGION - 583)) | (1L << (TRAILING - 583)) | (1L << (TRANSACTION - 583)) | (1L << (TRANSLATE - 583)) | (1L << (TREAT - 583)) | (1L << (TRIGGER - 583)) | (1L << (TRUNCATE - 583)) | (1L << (TYPE - 583)) | (1L << (UNBOUNDED - 583)) | (1L << (UNDER - 583)) | (1L << (UNLIMITED - 583)) | (1L << (UNTIL - 583)) | (1L << (UPDATED - 583)) | (1L << (UPSERT - 583)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (UROWID - 647)) | (1L << (USERS - 647)) | (1L << (USER - 647)) | (1L << (USE - 647)) | (1L << (VALIDATE - 647)) | (1L << (VALUE - 647)) | (1L << (VARCHAR2 - 647)) | (1L << (VARCHAR - 647)) | (1L << (VARIABLE - 647)) | (1L << (VARRAY - 647)) | (1L << (VARYING - 647)) | (1L << (VERSIONS - 647)) | (1L << (VERSION - 647)) | (1L << (WAIT - 647)) | (1L << (WARNING - 647)) | (1L << (WELLFORMED - 647)) | (1L << (WHENEVER - 647)) | (1L << (WHILE - 647)) | (1L << (WITHIN - 647)) | (1L << (WORK - 647)) | (1L << (WRITE - 647)) | (1L << (XMLAGG - 647)) | (1L << (XMLATTRIBUTES - 647)) | (1L << (XMLCAST - 647)) | (1L << (XMLCOLATTVAL - 647)) | (1L << (XMLELEMENT - 647)) | (1L << (XMLEXISTS - 647)) | (1L << (XMLFOREST - 647)) | (1L << (XMLNAMESPACES - 647)) | (1L << (XMLPARSE - 647)) | (1L << (XMLPI - 647)) | (1L << (XMLQUERY - 647)) | (1L << (XMLROOT - 647)) | (1L << (XMLSERIALIZE - 647)) | (1L << (XMLTABLE - 647)) | (1L << (XMLTYPE - 647)) | (1L << (XML - 647)) | (1L << (YEAR - 647)) | (1L << (YES - 647)) | (1L << (YMINTERVAL_UNCONSTRAINED - 647)) | (1L << (ZONE - 647)) | (1L << (PREDICTION - 647)) | (1L << (PREDICTION_BOUNDS - 647)) | (1L << (PREDICTION_COST - 647)) | (1L << (PREDICTION_DETAILS - 647)) | (1L << (PREDICTION_PROBABILITY - 647)) | (1L << (PREDICTION_SET - 647)) | (1L << (CUME_DIST - 647)) | (1L << (DENSE_RANK - 647)) | (1L << (LISTAGG - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (PERCENT_RANK - 711)) | (1L << (PERCENTILE_CONT - 711)) | (1L << (PERCENTILE_DISC - 711)) | (1L << (RANK - 711)) | (1L << (AVG - 711)) | (1L << (CORR - 711)) | (1L << (COVAR_ - 711)) | (1L << (LAG - 711)) | (1L << (LEAD - 711)) | (1L << (MAX - 711)) | (1L << (MEDIAN - 711)) | (1L << (MIN - 711)) | (1L << (NTILE - 711)) | (1L << (RATIO_TO_REPORT - 711)) | (1L << (REGR_ - 711)) | (1L << (ROW_NUMBER - 711)) | (1L << (SUBSTR - 711)) | (1L << (TRIM - 711)) | (1L << (SUM - 711)) | (1L << (STDDEV - 711)) | (1L << (VAR_ - 711)) | (1L << (VARIANCE - 711)))) != 0) || _la==REGULAR_ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_function_nameContext : ParserRuleContext {
		public ITerminalNode CHR() { return GetToken(PlSqlParser.CHR, 0); }
		public ITerminalNode DECODE() { return GetToken(PlSqlParser.DECODE, 0); }
		public ITerminalNode SUBSTR() { return GetToken(PlSqlParser.SUBSTR, 0); }
		public ITerminalNode TO_CHAR() { return GetToken(PlSqlParser.TO_CHAR, 0); }
		public ITerminalNode TRIM() { return GetToken(PlSqlParser.TRIM, 0); }
		public String_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_function_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_function_nameContext string_function_name() {
		String_function_nameContext _localctx = new String_function_nameContext(Context, State);
		EnterRule(_localctx, 1182, RULE_string_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8922;
			_la = TokenStream.LA(1);
			if ( !(_la==CHR || ((((_la - 718)) & ~0x3f) == 0 && ((1L << (_la - 718)) & ((1L << (DECODE - 718)) | (1L << (SUBSTR - 718)) | (1L << (TO_CHAR - 718)) | (1L << (TRIM - 718)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_function_nameContext : ParserRuleContext {
		public ITerminalNode AVG() { return GetToken(PlSqlParser.AVG, 0); }
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public ITerminalNode NVL() { return GetToken(PlSqlParser.NVL, 0); }
		public ITerminalNode ROUND() { return GetToken(PlSqlParser.ROUND, 0); }
		public ITerminalNode SUM() { return GetToken(PlSqlParser.SUM, 0); }
		public Numeric_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_function_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_function_nameContext numeric_function_name() {
		Numeric_function_nameContext _localctx = new Numeric_function_nameContext(Context, State);
		EnterRule(_localctx, 1184, RULE_numeric_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8924;
			_la = TokenStream.LA(1);
			if ( !(_la==COUNT || ((((_la - 715)) & ~0x3f) == 0 && ((1L << (_la - 715)) & ((1L << (AVG - 715)) | (1L << (NVL - 715)) | (1L << (ROUND - 715)) | (1L << (SUM - 715)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerContext : ParserRuleContext {
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public Numeric_negativeContext numeric_negative() {
			return GetRuleContext<Numeric_negativeContext>(0);
		}
		public IntegerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integer; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInteger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntegerContext integer() {
		IntegerContext _localctx = new IntegerContext(Context, State);
		EnterRule(_localctx, 1186, RULE_integer);
		try {
			State = 8928;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case PLUS_SIGN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8926; numeric();
				}
				break;
			case MINUS_SIGN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8927; numeric_negative();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode PLUS_SIGN() { return GetToken(PlSqlParser.PLUS_SIGN, 0); }
		public ITerminalNode APPROXIMATE_NUM_LIT() { return GetToken(PlSqlParser.APPROXIMATE_NUM_LIT, 0); }
		public NumericContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericContext numeric() {
		NumericContext _localctx = new NumericContext(Context, State);
		EnterRule(_localctx, 1188, RULE_numeric);
		int _la;
		try {
			State = 8935;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNSIGNED_INTEGER:
			case PLUS_SIGN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 8931;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PLUS_SIGN) {
					{
					State = 8930; Match(PLUS_SIGN);
					}
				}

				State = 8933; Match(UNSIGNED_INTEGER);
				}
				break;
			case APPROXIMATE_NUM_LIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 8934; Match(APPROXIMATE_NUM_LIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_negativeContext : ParserRuleContext {
		public ITerminalNode MINUS_SIGN() { return GetToken(PlSqlParser.MINUS_SIGN, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public Numeric_negativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_negative; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_negative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_negativeContext numeric_negative() {
		Numeric_negativeContext _localctx = new Numeric_negativeContext(Context, State);
		EnterRule(_localctx, 1190, RULE_numeric_negative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8937; Match(MINUS_SIGN);
			State = 8938; Match(UNSIGNED_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public ITerminalNode NATIONAL_CHAR_STRING_LIT() { return GetToken(PlSqlParser.NATIONAL_CHAR_STRING_LIT, 0); }
		public StringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlParserVisitor<TResult> typedVisitor = visitor as IPlSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringContext @string() {
		StringContext _localctx = new StringContext(Context, State);
		EnterRule(_localctx, 1192, RULE_string);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 8940;
			_la = TokenStream.LA(1);
			if ( !(_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 448: return logical_expression_sempred((Logical_expressionContext)_localctx, predIndex);
		case 450: return relational_expression_sempred((Relational_expressionContext)_localctx, predIndex);
		case 453: return concatenation_sempred((ConcatenationContext)_localctx, predIndex);
		}
		return true;
	}
	private bool logical_expression_sempred(Logical_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool relational_expression_sempred(Relational_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 2);
		}
		return true;
	}
	private bool concatenation_sempred(ConcatenationContext _localctx, int predIndex) {
		switch (predIndex) {
		case 3: return Precpred(Context, 3);
		case 4: return Precpred(Context, 2);
		case 5: return Precpred(Context, 1);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x311', '\x22F1', '\x4', '\x2', '\t', '\x2', '\x4', 
		'\x3', '\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', 
		'\x4', '\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', 
		'\b', '\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', 
		'\v', '\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', 
		'\t', '\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x4', ':', '\t', ':', '\x4', ';', '\t', ';', '\x4', '<', '\t', '<', '\x4', 
		'=', '\t', '=', '\x4', '>', '\t', '>', '\x4', '?', '\t', '?', '\x4', '@', 
		'\t', '@', '\x4', '\x41', '\t', '\x41', '\x4', '\x42', '\t', '\x42', '\x4', 
		'\x43', '\t', '\x43', '\x4', '\x44', '\t', '\x44', '\x4', '\x45', '\t', 
		'\x45', '\x4', '\x46', '\t', '\x46', '\x4', 'G', '\t', 'G', '\x4', 'H', 
		'\t', 'H', '\x4', 'I', '\t', 'I', '\x4', 'J', '\t', 'J', '\x4', 'K', '\t', 
		'K', '\x4', 'L', '\t', 'L', '\x4', 'M', '\t', 'M', '\x4', 'N', '\t', 'N', 
		'\x4', 'O', '\t', 'O', '\x4', 'P', '\t', 'P', '\x4', 'Q', '\t', 'Q', '\x4', 
		'R', '\t', 'R', '\x4', 'S', '\t', 'S', '\x4', 'T', '\t', 'T', '\x4', 'U', 
		'\t', 'U', '\x4', 'V', '\t', 'V', '\x4', 'W', '\t', 'W', '\x4', 'X', '\t', 
		'X', '\x4', 'Y', '\t', 'Y', '\x4', 'Z', '\t', 'Z', '\x4', '[', '\t', '[', 
		'\x4', '\\', '\t', '\\', '\x4', ']', '\t', ']', '\x4', '^', '\t', '^', 
		'\x4', '_', '\t', '_', '\x4', '`', '\t', '`', '\x4', '\x61', '\t', '\x61', 
		'\x4', '\x62', '\t', '\x62', '\x4', '\x63', '\t', '\x63', '\x4', '\x64', 
		'\t', '\x64', '\x4', '\x65', '\t', '\x65', '\x4', '\x66', '\t', '\x66', 
		'\x4', 'g', '\t', 'g', '\x4', 'h', '\t', 'h', '\x4', 'i', '\t', 'i', '\x4', 
		'j', '\t', 'j', '\x4', 'k', '\t', 'k', '\x4', 'l', '\t', 'l', '\x4', 'm', 
		'\t', 'm', '\x4', 'n', '\t', 'n', '\x4', 'o', '\t', 'o', '\x4', 'p', '\t', 
		'p', '\x4', 'q', '\t', 'q', '\x4', 'r', '\t', 'r', '\x4', 's', '\t', 's', 
		'\x4', 't', '\t', 't', '\x4', 'u', '\t', 'u', '\x4', 'v', '\t', 'v', '\x4', 
		'w', '\t', 'w', '\x4', 'x', '\t', 'x', '\x4', 'y', '\t', 'y', '\x4', 'z', 
		'\t', 'z', '\x4', '{', '\t', '{', '\x4', '|', '\t', '|', '\x4', '}', '\t', 
		'}', '\x4', '~', '\t', '~', '\x4', '\x7F', '\t', '\x7F', '\x4', '\x80', 
		'\t', '\x80', '\x4', '\x81', '\t', '\x81', '\x4', '\x82', '\t', '\x82', 
		'\x4', '\x83', '\t', '\x83', '\x4', '\x84', '\t', '\x84', '\x4', '\x85', 
		'\t', '\x85', '\x4', '\x86', '\t', '\x86', '\x4', '\x87', '\t', '\x87', 
		'\x4', '\x88', '\t', '\x88', '\x4', '\x89', '\t', '\x89', '\x4', '\x8A', 
		'\t', '\x8A', '\x4', '\x8B', '\t', '\x8B', '\x4', '\x8C', '\t', '\x8C', 
		'\x4', '\x8D', '\t', '\x8D', '\x4', '\x8E', '\t', '\x8E', '\x4', '\x8F', 
		'\t', '\x8F', '\x4', '\x90', '\t', '\x90', '\x4', '\x91', '\t', '\x91', 
		'\x4', '\x92', '\t', '\x92', '\x4', '\x93', '\t', '\x93', '\x4', '\x94', 
		'\t', '\x94', '\x4', '\x95', '\t', '\x95', '\x4', '\x96', '\t', '\x96', 
		'\x4', '\x97', '\t', '\x97', '\x4', '\x98', '\t', '\x98', '\x4', '\x99', 
		'\t', '\x99', '\x4', '\x9A', '\t', '\x9A', '\x4', '\x9B', '\t', '\x9B', 
		'\x4', '\x9C', '\t', '\x9C', '\x4', '\x9D', '\t', '\x9D', '\x4', '\x9E', 
		'\t', '\x9E', '\x4', '\x9F', '\t', '\x9F', '\x4', '\xA0', '\t', '\xA0', 
		'\x4', '\xA1', '\t', '\xA1', '\x4', '\xA2', '\t', '\xA2', '\x4', '\xA3', 
		'\t', '\xA3', '\x4', '\xA4', '\t', '\xA4', '\x4', '\xA5', '\t', '\xA5', 
		'\x4', '\xA6', '\t', '\xA6', '\x4', '\xA7', '\t', '\xA7', '\x4', '\xA8', 
		'\t', '\xA8', '\x4', '\xA9', '\t', '\xA9', '\x4', '\xAA', '\t', '\xAA', 
		'\x4', '\xAB', '\t', '\xAB', '\x4', '\xAC', '\t', '\xAC', '\x4', '\xAD', 
		'\t', '\xAD', '\x4', '\xAE', '\t', '\xAE', '\x4', '\xAF', '\t', '\xAF', 
		'\x4', '\xB0', '\t', '\xB0', '\x4', '\xB1', '\t', '\xB1', '\x4', '\xB2', 
		'\t', '\xB2', '\x4', '\xB3', '\t', '\xB3', '\x4', '\xB4', '\t', '\xB4', 
		'\x4', '\xB5', '\t', '\xB5', '\x4', '\xB6', '\t', '\xB6', '\x4', '\xB7', 
		'\t', '\xB7', '\x4', '\xB8', '\t', '\xB8', '\x4', '\xB9', '\t', '\xB9', 
		'\x4', '\xBA', '\t', '\xBA', '\x4', '\xBB', '\t', '\xBB', '\x4', '\xBC', 
		'\t', '\xBC', '\x4', '\xBD', '\t', '\xBD', '\x4', '\xBE', '\t', '\xBE', 
		'\x4', '\xBF', '\t', '\xBF', '\x4', '\xC0', '\t', '\xC0', '\x4', '\xC1', 
		'\t', '\xC1', '\x4', '\xC2', '\t', '\xC2', '\x4', '\xC3', '\t', '\xC3', 
		'\x4', '\xC4', '\t', '\xC4', '\x4', '\xC5', '\t', '\xC5', '\x4', '\xC6', 
		'\t', '\xC6', '\x4', '\xC7', '\t', '\xC7', '\x4', '\xC8', '\t', '\xC8', 
		'\x4', '\xC9', '\t', '\xC9', '\x4', '\xCA', '\t', '\xCA', '\x4', '\xCB', 
		'\t', '\xCB', '\x4', '\xCC', '\t', '\xCC', '\x4', '\xCD', '\t', '\xCD', 
		'\x4', '\xCE', '\t', '\xCE', '\x4', '\xCF', '\t', '\xCF', '\x4', '\xD0', 
		'\t', '\xD0', '\x4', '\xD1', '\t', '\xD1', '\x4', '\xD2', '\t', '\xD2', 
		'\x4', '\xD3', '\t', '\xD3', '\x4', '\xD4', '\t', '\xD4', '\x4', '\xD5', 
		'\t', '\xD5', '\x4', '\xD6', '\t', '\xD6', '\x4', '\xD7', '\t', '\xD7', 
		'\x4', '\xD8', '\t', '\xD8', '\x4', '\xD9', '\t', '\xD9', '\x4', '\xDA', 
		'\t', '\xDA', '\x4', '\xDB', '\t', '\xDB', '\x4', '\xDC', '\t', '\xDC', 
		'\x4', '\xDD', '\t', '\xDD', '\x4', '\xDE', '\t', '\xDE', '\x4', '\xDF', 
		'\t', '\xDF', '\x4', '\xE0', '\t', '\xE0', '\x4', '\xE1', '\t', '\xE1', 
		'\x4', '\xE2', '\t', '\xE2', '\x4', '\xE3', '\t', '\xE3', '\x4', '\xE4', 
		'\t', '\xE4', '\x4', '\xE5', '\t', '\xE5', '\x4', '\xE6', '\t', '\xE6', 
		'\x4', '\xE7', '\t', '\xE7', '\x4', '\xE8', '\t', '\xE8', '\x4', '\xE9', 
		'\t', '\xE9', '\x4', '\xEA', '\t', '\xEA', '\x4', '\xEB', '\t', '\xEB', 
		'\x4', '\xEC', '\t', '\xEC', '\x4', '\xED', '\t', '\xED', '\x4', '\xEE', 
		'\t', '\xEE', '\x4', '\xEF', '\t', '\xEF', '\x4', '\xF0', '\t', '\xF0', 
		'\x4', '\xF1', '\t', '\xF1', '\x4', '\xF2', '\t', '\xF2', '\x4', '\xF3', 
		'\t', '\xF3', '\x4', '\xF4', '\t', '\xF4', '\x4', '\xF5', '\t', '\xF5', 
		'\x4', '\xF6', '\t', '\xF6', '\x4', '\xF7', '\t', '\xF7', '\x4', '\xF8', 
		'\t', '\xF8', '\x4', '\xF9', '\t', '\xF9', '\x4', '\xFA', '\t', '\xFA', 
		'\x4', '\xFB', '\t', '\xFB', '\x4', '\xFC', '\t', '\xFC', '\x4', '\xFD', 
		'\t', '\xFD', '\x4', '\xFE', '\t', '\xFE', '\x4', '\xFF', '\t', '\xFF', 
		'\x4', '\x100', '\t', '\x100', '\x4', '\x101', '\t', '\x101', '\x4', '\x102', 
		'\t', '\x102', '\x4', '\x103', '\t', '\x103', '\x4', '\x104', '\t', '\x104', 
		'\x4', '\x105', '\t', '\x105', '\x4', '\x106', '\t', '\x106', '\x4', '\x107', 
		'\t', '\x107', '\x4', '\x108', '\t', '\x108', '\x4', '\x109', '\t', '\x109', 
		'\x4', '\x10A', '\t', '\x10A', '\x4', '\x10B', '\t', '\x10B', '\x4', '\x10C', 
		'\t', '\x10C', '\x4', '\x10D', '\t', '\x10D', '\x4', '\x10E', '\t', '\x10E', 
		'\x4', '\x10F', '\t', '\x10F', '\x4', '\x110', '\t', '\x110', '\x4', '\x111', 
		'\t', '\x111', '\x4', '\x112', '\t', '\x112', '\x4', '\x113', '\t', '\x113', 
		'\x4', '\x114', '\t', '\x114', '\x4', '\x115', '\t', '\x115', '\x4', '\x116', 
		'\t', '\x116', '\x4', '\x117', '\t', '\x117', '\x4', '\x118', '\t', '\x118', 
		'\x4', '\x119', '\t', '\x119', '\x4', '\x11A', '\t', '\x11A', '\x4', '\x11B', 
		'\t', '\x11B', '\x4', '\x11C', '\t', '\x11C', '\x4', '\x11D', '\t', '\x11D', 
		'\x4', '\x11E', '\t', '\x11E', '\x4', '\x11F', '\t', '\x11F', '\x4', '\x120', 
		'\t', '\x120', '\x4', '\x121', '\t', '\x121', '\x4', '\x122', '\t', '\x122', 
		'\x4', '\x123', '\t', '\x123', '\x4', '\x124', '\t', '\x124', '\x4', '\x125', 
		'\t', '\x125', '\x4', '\x126', '\t', '\x126', '\x4', '\x127', '\t', '\x127', 
		'\x4', '\x128', '\t', '\x128', '\x4', '\x129', '\t', '\x129', '\x4', '\x12A', 
		'\t', '\x12A', '\x4', '\x12B', '\t', '\x12B', '\x4', '\x12C', '\t', '\x12C', 
		'\x4', '\x12D', '\t', '\x12D', '\x4', '\x12E', '\t', '\x12E', '\x4', '\x12F', 
		'\t', '\x12F', '\x4', '\x130', '\t', '\x130', '\x4', '\x131', '\t', '\x131', 
		'\x4', '\x132', '\t', '\x132', '\x4', '\x133', '\t', '\x133', '\x4', '\x134', 
		'\t', '\x134', '\x4', '\x135', '\t', '\x135', '\x4', '\x136', '\t', '\x136', 
		'\x4', '\x137', '\t', '\x137', '\x4', '\x138', '\t', '\x138', '\x4', '\x139', 
		'\t', '\x139', '\x4', '\x13A', '\t', '\x13A', '\x4', '\x13B', '\t', '\x13B', 
		'\x4', '\x13C', '\t', '\x13C', '\x4', '\x13D', '\t', '\x13D', '\x4', '\x13E', 
		'\t', '\x13E', '\x4', '\x13F', '\t', '\x13F', '\x4', '\x140', '\t', '\x140', 
		'\x4', '\x141', '\t', '\x141', '\x4', '\x142', '\t', '\x142', '\x4', '\x143', 
		'\t', '\x143', '\x4', '\x144', '\t', '\x144', '\x4', '\x145', '\t', '\x145', 
		'\x4', '\x146', '\t', '\x146', '\x4', '\x147', '\t', '\x147', '\x4', '\x148', 
		'\t', '\x148', '\x4', '\x149', '\t', '\x149', '\x4', '\x14A', '\t', '\x14A', 
		'\x4', '\x14B', '\t', '\x14B', '\x4', '\x14C', '\t', '\x14C', '\x4', '\x14D', 
		'\t', '\x14D', '\x4', '\x14E', '\t', '\x14E', '\x4', '\x14F', '\t', '\x14F', 
		'\x4', '\x150', '\t', '\x150', '\x4', '\x151', '\t', '\x151', '\x4', '\x152', 
		'\t', '\x152', '\x4', '\x153', '\t', '\x153', '\x4', '\x154', '\t', '\x154', 
		'\x4', '\x155', '\t', '\x155', '\x4', '\x156', '\t', '\x156', '\x4', '\x157', 
		'\t', '\x157', '\x4', '\x158', '\t', '\x158', '\x4', '\x159', '\t', '\x159', 
		'\x4', '\x15A', '\t', '\x15A', '\x4', '\x15B', '\t', '\x15B', '\x4', '\x15C', 
		'\t', '\x15C', '\x4', '\x15D', '\t', '\x15D', '\x4', '\x15E', '\t', '\x15E', 
		'\x4', '\x15F', '\t', '\x15F', '\x4', '\x160', '\t', '\x160', '\x4', '\x161', 
		'\t', '\x161', '\x4', '\x162', '\t', '\x162', '\x4', '\x163', '\t', '\x163', 
		'\x4', '\x164', '\t', '\x164', '\x4', '\x165', '\t', '\x165', '\x4', '\x166', 
		'\t', '\x166', '\x4', '\x167', '\t', '\x167', '\x4', '\x168', '\t', '\x168', 
		'\x4', '\x169', '\t', '\x169', '\x4', '\x16A', '\t', '\x16A', '\x4', '\x16B', 
		'\t', '\x16B', '\x4', '\x16C', '\t', '\x16C', '\x4', '\x16D', '\t', '\x16D', 
		'\x4', '\x16E', '\t', '\x16E', '\x4', '\x16F', '\t', '\x16F', '\x4', '\x170', 
		'\t', '\x170', '\x4', '\x171', '\t', '\x171', '\x4', '\x172', '\t', '\x172', 
		'\x4', '\x173', '\t', '\x173', '\x4', '\x174', '\t', '\x174', '\x4', '\x175', 
		'\t', '\x175', '\x4', '\x176', '\t', '\x176', '\x4', '\x177', '\t', '\x177', 
		'\x4', '\x178', '\t', '\x178', '\x4', '\x179', '\t', '\x179', '\x4', '\x17A', 
		'\t', '\x17A', '\x4', '\x17B', '\t', '\x17B', '\x4', '\x17C', '\t', '\x17C', 
		'\x4', '\x17D', '\t', '\x17D', '\x4', '\x17E', '\t', '\x17E', '\x4', '\x17F', 
		'\t', '\x17F', '\x4', '\x180', '\t', '\x180', '\x4', '\x181', '\t', '\x181', 
		'\x4', '\x182', '\t', '\x182', '\x4', '\x183', '\t', '\x183', '\x4', '\x184', 
		'\t', '\x184', '\x4', '\x185', '\t', '\x185', '\x4', '\x186', '\t', '\x186', 
		'\x4', '\x187', '\t', '\x187', '\x4', '\x188', '\t', '\x188', '\x4', '\x189', 
		'\t', '\x189', '\x4', '\x18A', '\t', '\x18A', '\x4', '\x18B', '\t', '\x18B', 
		'\x4', '\x18C', '\t', '\x18C', '\x4', '\x18D', '\t', '\x18D', '\x4', '\x18E', 
		'\t', '\x18E', '\x4', '\x18F', '\t', '\x18F', '\x4', '\x190', '\t', '\x190', 
		'\x4', '\x191', '\t', '\x191', '\x4', '\x192', '\t', '\x192', '\x4', '\x193', 
		'\t', '\x193', '\x4', '\x194', '\t', '\x194', '\x4', '\x195', '\t', '\x195', 
		'\x4', '\x196', '\t', '\x196', '\x4', '\x197', '\t', '\x197', '\x4', '\x198', 
		'\t', '\x198', '\x4', '\x199', '\t', '\x199', '\x4', '\x19A', '\t', '\x19A', 
		'\x4', '\x19B', '\t', '\x19B', '\x4', '\x19C', '\t', '\x19C', '\x4', '\x19D', 
		'\t', '\x19D', '\x4', '\x19E', '\t', '\x19E', '\x4', '\x19F', '\t', '\x19F', 
		'\x4', '\x1A0', '\t', '\x1A0', '\x4', '\x1A1', '\t', '\x1A1', '\x4', '\x1A2', 
		'\t', '\x1A2', '\x4', '\x1A3', '\t', '\x1A3', '\x4', '\x1A4', '\t', '\x1A4', 
		'\x4', '\x1A5', '\t', '\x1A5', '\x4', '\x1A6', '\t', '\x1A6', '\x4', '\x1A7', 
		'\t', '\x1A7', '\x4', '\x1A8', '\t', '\x1A8', '\x4', '\x1A9', '\t', '\x1A9', 
		'\x4', '\x1AA', '\t', '\x1AA', '\x4', '\x1AB', '\t', '\x1AB', '\x4', '\x1AC', 
		'\t', '\x1AC', '\x4', '\x1AD', '\t', '\x1AD', '\x4', '\x1AE', '\t', '\x1AE', 
		'\x4', '\x1AF', '\t', '\x1AF', '\x4', '\x1B0', '\t', '\x1B0', '\x4', '\x1B1', 
		'\t', '\x1B1', '\x4', '\x1B2', '\t', '\x1B2', '\x4', '\x1B3', '\t', '\x1B3', 
		'\x4', '\x1B4', '\t', '\x1B4', '\x4', '\x1B5', '\t', '\x1B5', '\x4', '\x1B6', 
		'\t', '\x1B6', '\x4', '\x1B7', '\t', '\x1B7', '\x4', '\x1B8', '\t', '\x1B8', 
		'\x4', '\x1B9', '\t', '\x1B9', '\x4', '\x1BA', '\t', '\x1BA', '\x4', '\x1BB', 
		'\t', '\x1BB', '\x4', '\x1BC', '\t', '\x1BC', '\x4', '\x1BD', '\t', '\x1BD', 
		'\x4', '\x1BE', '\t', '\x1BE', '\x4', '\x1BF', '\t', '\x1BF', '\x4', '\x1C0', 
		'\t', '\x1C0', '\x4', '\x1C1', '\t', '\x1C1', '\x4', '\x1C2', '\t', '\x1C2', 
		'\x4', '\x1C3', '\t', '\x1C3', '\x4', '\x1C4', '\t', '\x1C4', '\x4', '\x1C5', 
		'\t', '\x1C5', '\x4', '\x1C6', '\t', '\x1C6', '\x4', '\x1C7', '\t', '\x1C7', 
		'\x4', '\x1C8', '\t', '\x1C8', '\x4', '\x1C9', '\t', '\x1C9', '\x4', '\x1CA', 
		'\t', '\x1CA', '\x4', '\x1CB', '\t', '\x1CB', '\x4', '\x1CC', '\t', '\x1CC', 
		'\x4', '\x1CD', '\t', '\x1CD', '\x4', '\x1CE', '\t', '\x1CE', '\x4', '\x1CF', 
		'\t', '\x1CF', '\x4', '\x1D0', '\t', '\x1D0', '\x4', '\x1D1', '\t', '\x1D1', 
		'\x4', '\x1D2', '\t', '\x1D2', '\x4', '\x1D3', '\t', '\x1D3', '\x4', '\x1D4', 
		'\t', '\x1D4', '\x4', '\x1D5', '\t', '\x1D5', '\x4', '\x1D6', '\t', '\x1D6', 
		'\x4', '\x1D7', '\t', '\x1D7', '\x4', '\x1D8', '\t', '\x1D8', '\x4', '\x1D9', 
		'\t', '\x1D9', '\x4', '\x1DA', '\t', '\x1DA', '\x4', '\x1DB', '\t', '\x1DB', 
		'\x4', '\x1DC', '\t', '\x1DC', '\x4', '\x1DD', '\t', '\x1DD', '\x4', '\x1DE', 
		'\t', '\x1DE', '\x4', '\x1DF', '\t', '\x1DF', '\x4', '\x1E0', '\t', '\x1E0', 
		'\x4', '\x1E1', '\t', '\x1E1', '\x4', '\x1E2', '\t', '\x1E2', '\x4', '\x1E3', 
		'\t', '\x1E3', '\x4', '\x1E4', '\t', '\x1E4', '\x4', '\x1E5', '\t', '\x1E5', 
		'\x4', '\x1E6', '\t', '\x1E6', '\x4', '\x1E7', '\t', '\x1E7', '\x4', '\x1E8', 
		'\t', '\x1E8', '\x4', '\x1E9', '\t', '\x1E9', '\x4', '\x1EA', '\t', '\x1EA', 
		'\x4', '\x1EB', '\t', '\x1EB', '\x4', '\x1EC', '\t', '\x1EC', '\x4', '\x1ED', 
		'\t', '\x1ED', '\x4', '\x1EE', '\t', '\x1EE', '\x4', '\x1EF', '\t', '\x1EF', 
		'\x4', '\x1F0', '\t', '\x1F0', '\x4', '\x1F1', '\t', '\x1F1', '\x4', '\x1F2', 
		'\t', '\x1F2', '\x4', '\x1F3', '\t', '\x1F3', '\x4', '\x1F4', '\t', '\x1F4', 
		'\x4', '\x1F5', '\t', '\x1F5', '\x4', '\x1F6', '\t', '\x1F6', '\x4', '\x1F7', 
		'\t', '\x1F7', '\x4', '\x1F8', '\t', '\x1F8', '\x4', '\x1F9', '\t', '\x1F9', 
		'\x4', '\x1FA', '\t', '\x1FA', '\x4', '\x1FB', '\t', '\x1FB', '\x4', '\x1FC', 
		'\t', '\x1FC', '\x4', '\x1FD', '\t', '\x1FD', '\x4', '\x1FE', '\t', '\x1FE', 
		'\x4', '\x1FF', '\t', '\x1FF', '\x4', '\x200', '\t', '\x200', '\x4', '\x201', 
		'\t', '\x201', '\x4', '\x202', '\t', '\x202', '\x4', '\x203', '\t', '\x203', 
		'\x4', '\x204', '\t', '\x204', '\x4', '\x205', '\t', '\x205', '\x4', '\x206', 
		'\t', '\x206', '\x4', '\x207', '\t', '\x207', '\x4', '\x208', '\t', '\x208', 
		'\x4', '\x209', '\t', '\x209', '\x4', '\x20A', '\t', '\x20A', '\x4', '\x20B', 
		'\t', '\x20B', '\x4', '\x20C', '\t', '\x20C', '\x4', '\x20D', '\t', '\x20D', 
		'\x4', '\x20E', '\t', '\x20E', '\x4', '\x20F', '\t', '\x20F', '\x4', '\x210', 
		'\t', '\x210', '\x4', '\x211', '\t', '\x211', '\x4', '\x212', '\t', '\x212', 
		'\x4', '\x213', '\t', '\x213', '\x4', '\x214', '\t', '\x214', '\x4', '\x215', 
		'\t', '\x215', '\x4', '\x216', '\t', '\x216', '\x4', '\x217', '\t', '\x217', 
		'\x4', '\x218', '\t', '\x218', '\x4', '\x219', '\t', '\x219', '\x4', '\x21A', 
		'\t', '\x21A', '\x4', '\x21B', '\t', '\x21B', '\x4', '\x21C', '\t', '\x21C', 
		'\x4', '\x21D', '\t', '\x21D', '\x4', '\x21E', '\t', '\x21E', '\x4', '\x21F', 
		'\t', '\x21F', '\x4', '\x220', '\t', '\x220', '\x4', '\x221', '\t', '\x221', 
		'\x4', '\x222', '\t', '\x222', '\x4', '\x223', '\t', '\x223', '\x4', '\x224', 
		'\t', '\x224', '\x4', '\x225', '\t', '\x225', '\x4', '\x226', '\t', '\x226', 
		'\x4', '\x227', '\t', '\x227', '\x4', '\x228', '\t', '\x228', '\x4', '\x229', 
		'\t', '\x229', '\x4', '\x22A', '\t', '\x22A', '\x4', '\x22B', '\t', '\x22B', 
		'\x4', '\x22C', '\t', '\x22C', '\x4', '\x22D', '\t', '\x22D', '\x4', '\x22E', 
		'\t', '\x22E', '\x4', '\x22F', '\t', '\x22F', '\x4', '\x230', '\t', '\x230', 
		'\x4', '\x231', '\t', '\x231', '\x4', '\x232', '\t', '\x232', '\x4', '\x233', 
		'\t', '\x233', '\x4', '\x234', '\t', '\x234', '\x4', '\x235', '\t', '\x235', 
		'\x4', '\x236', '\t', '\x236', '\x4', '\x237', '\t', '\x237', '\x4', '\x238', 
		'\t', '\x238', '\x4', '\x239', '\t', '\x239', '\x4', '\x23A', '\t', '\x23A', 
		'\x4', '\x23B', '\t', '\x23B', '\x4', '\x23C', '\t', '\x23C', '\x4', '\x23D', 
		'\t', '\x23D', '\x4', '\x23E', '\t', '\x23E', '\x4', '\x23F', '\t', '\x23F', 
		'\x4', '\x240', '\t', '\x240', '\x4', '\x241', '\t', '\x241', '\x4', '\x242', 
		'\t', '\x242', '\x4', '\x243', '\t', '\x243', '\x4', '\x244', '\t', '\x244', 
		'\x4', '\x245', '\t', '\x245', '\x4', '\x246', '\t', '\x246', '\x4', '\x247', 
		'\t', '\x247', '\x4', '\x248', '\t', '\x248', '\x4', '\x249', '\t', '\x249', 
		'\x4', '\x24A', '\t', '\x24A', '\x4', '\x24B', '\t', '\x24B', '\x4', '\x24C', 
		'\t', '\x24C', '\x4', '\x24D', '\t', '\x24D', '\x4', '\x24E', '\t', '\x24E', 
		'\x4', '\x24F', '\t', '\x24F', '\x4', '\x250', '\t', '\x250', '\x4', '\x251', 
		'\t', '\x251', '\x4', '\x252', '\t', '\x252', '\x4', '\x253', '\t', '\x253', 
		'\x4', '\x254', '\t', '\x254', '\x4', '\x255', '\t', '\x255', '\x4', '\x256', 
		'\t', '\x256', '\x3', '\x2', '\x3', '\x2', '\x5', '\x2', '\x4AF', '\n', 
		'\x2', '\x3', '\x2', '\x5', '\x2', '\x4B2', '\n', '\x2', '\a', '\x2', 
		'\x4B4', '\n', '\x2', '\f', '\x2', '\xE', '\x2', '\x4B7', '\v', '\x2', 
		'\x3', '\x2', '\x3', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x5', '\x3', '\x4DF', '\n', 
		'\x3', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', 
		'\x5', '\x5', '\x5', '\x4EB', '\n', '\x5', '\x3', '\x5', '\a', '\x5', 
		'\x4EE', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\x4F1', '\v', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x5', '\x5', '\x4F5', '\n', '\x5', '\x3', 
		'\x5', '\x3', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x5', 
		'\x6', '\x4FC', '\n', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x5', '\x6', '\x502', '\n', '\x6', '\x3', '\x6', '\x6', 
		'\x6', '\x505', '\n', '\x6', '\r', '\x6', '\xE', '\x6', '\x506', '\x3', 
		'\x6', '\x3', '\x6', '\x5', '\x6', '\x50B', '\n', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\a', '\x6', '\x513', '\n', '\x6', '\f', '\x6', '\xE', '\x6', '\x516', 
		'\v', '\x6', '\x3', '\x6', '\x5', '\x6', '\x519', '\n', '\x6', '\x3', 
		'\x6', '\x3', '\x6', '\x5', '\x6', '\x51D', '\n', '\x6', '\x3', '\x6', 
		'\x5', '\x6', '\x520', '\n', '\x6', '\x3', '\x6', '\x3', '\x6', '\x5', 
		'\x6', '\x524', '\n', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x5', '\x6', '\x529', '\n', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', 
		'\a', '\x3', '\a', '\x5', '\a', '\x52F', '\n', '\a', '\x3', '\b', '\x3', 
		'\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', 
		'\x5', '\b', '\x538', '\n', '\b', '\x3', '\b', '\x5', '\b', '\x53B', '\n', 
		'\b', '\x3', '\b', '\x3', '\b', '\x3', '\t', '\x3', '\t', '\x5', '\t', 
		'\x541', '\n', '\t', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', 
		'\x3', '\n', '\a', '\n', '\x548', '\n', '\n', '\f', '\n', '\xE', '\n', 
		'\x54B', '\v', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', '\v', 
		'\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x5', '\f', '\x557', '\n', '\f', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x5', '\f', '\x55C', '\n', '\f', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x5', '\r', '\x566', '\n', '\r', '\x3', '\r', '\x5', '\r', '\x569', '\n', 
		'\r', '\x3', '\r', '\a', '\r', '\x56C', '\n', '\r', '\f', '\r', '\xE', 
		'\r', '\x56F', '\v', '\r', '\x3', '\r', '\x3', '\r', '\x5', '\r', '\x573', 
		'\n', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\xE', '\x3', '\xE', '\x3', 
		'\xE', '\x5', '\xE', '\x57A', '\n', '\xE', '\x3', '\xE', '\x3', '\xE', 
		'\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x580', '\n', '\xE', '\x3', 
		'\xE', '\x3', '\xE', '\x5', '\xE', '\x584', '\n', '\xE', '\x3', '\xE', 
		'\x3', '\xE', '\a', '\xE', '\x588', '\n', '\xE', '\f', '\xE', '\xE', '\xE', 
		'\x58B', '\v', '\xE', '\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x58F', 
		'\n', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\x5', '\xF', '\x596', '\n', '\xF', '\x3', '\xF', '\x3', '\xF', 
		'\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x5', '\xF', '\x59D', '\n', 
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\a', '\xF', '\x5A2', 
		'\n', '\xF', '\f', '\xF', '\xE', '\xF', '\x5A5', '\v', '\xF', '\x3', '\xF', 
		'\x3', '\xF', '\x5', '\xF', '\x5A9', '\n', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\x5', '\xF', '\x5AD', '\n', '\xF', '\x3', '\xF', '\x3', '\xF', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x5', '\x10', '\x5B9', '\n', 
		'\x10', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', 
		'\x11', '\x3', '\x11', '\a', '\x11', '\x5C1', '\n', '\x11', '\f', '\x11', 
		'\xE', '\x11', '\x5C4', '\v', '\x11', '\x3', '\x11', '\x3', '\x11', '\x5', 
		'\x11', '\x5C8', '\n', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x12', 
		'\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', 
		'\a', '\x12', '\x5D2', '\n', '\x12', '\f', '\x12', '\xE', '\x12', '\x5D5', 
		'\v', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\x5D9', '\n', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\x5DE', 
		'\n', '\x12', '\x3', '\x12', '\x5', '\x12', '\x5E1', '\n', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', 
		'\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', 
		'\x13', '\x5', '\x13', '\x5EE', '\n', '\x13', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x15', '\x3', '\x15', 
		'\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x5', '\x15', '\x5FA', '\n', 
		'\x15', '\x3', '\x15', '\a', '\x15', '\x5FD', '\n', '\x15', '\f', '\x15', 
		'\xE', '\x15', '\x600', '\v', '\x15', '\x3', '\x15', '\x3', '\x15', '\x5', 
		'\x15', '\x604', '\n', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x16', 
		'\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', 
		'\a', '\x16', '\x60E', '\n', '\x16', '\f', '\x16', '\xE', '\x16', '\x611', 
		'\v', '\x16', '\x3', '\x16', '\x3', '\x16', '\x5', '\x16', '\x615', '\n', 
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\a', '\x16', '\x61D', '\n', '\x16', '\f', '\x16', 
		'\xE', '\x16', '\x620', '\v', '\x16', '\x3', '\x16', '\x5', '\x16', '\x623', 
		'\n', '\x16', '\x3', '\x16', '\x3', '\x16', '\x5', '\x16', '\x627', '\n', 
		'\x16', '\x3', '\x16', '\x5', '\x16', '\x62A', '\n', '\x16', '\x3', '\x16', 
		'\x3', '\x16', '\x5', '\x16', '\x62E', '\n', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\x5', '\x16', '\x633', '\n', '\x16', '\x3', '\x16', 
		'\x3', '\x16', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', 
		'\x3', '\x17', '\x3', '\x17', '\a', '\x17', '\x63D', '\n', '\x17', '\f', 
		'\x17', '\xE', '\x17', '\x640', '\v', '\x17', '\x3', '\x17', '\x3', '\x17', 
		'\x5', '\x17', '\x644', '\n', '\x17', '\x3', '\x17', '\x3', '\x17', '\x5', 
		'\x17', '\x648', '\n', '\x17', '\x3', '\x17', '\x5', '\x17', '\x64B', 
		'\n', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x5', '\x17', 
		'\x650', '\n', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x18', '\x3', 
		'\x18', '\x3', '\x18', '\x5', '\x18', '\x657', '\n', '\x18', '\x3', '\x18', 
		'\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', 
		'\a', '\x18', '\x65F', '\n', '\x18', '\f', '\x18', '\xE', '\x18', '\x662', 
		'\v', '\x18', '\x3', '\x18', '\x3', '\x18', '\x5', '\x18', '\x666', '\n', 
		'\x18', '\x3', '\x18', '\x5', '\x18', '\x669', '\n', '\x18', '\x3', '\x18', 
		'\x3', '\x18', '\x5', '\x18', '\x66D', '\n', '\x18', '\x3', '\x18', '\x5', 
		'\x18', '\x670', '\n', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', 
		'\x5', '\x18', '\x675', '\n', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', 
		'\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', 
		'\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', 
		'\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x5', '\x1A', '\x687', 
		'\n', '\x1A', '\x3', '\x1A', '\a', '\x1A', '\x68A', '\n', '\x1A', '\f', 
		'\x1A', '\xE', '\x1A', '\x68D', '\v', '\x1A', '\x3', '\x1A', '\x3', '\x1A', 
		'\x5', '\x1A', '\x691', '\n', '\x1A', '\x5', '\x1A', '\x693', '\n', '\x1A', 
		'\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B', 
		'\x5', '\x1B', '\x69A', '\n', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', 
		'\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x6A1', '\n', '\x1B', 
		'\x3', '\x1B', '\x5', '\x1B', '\x6A4', '\n', '\x1B', '\x3', '\x1B', '\x5', 
		'\x1B', '\x6A7', '\n', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x6AA', 
		'\n', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1C', 
		'\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\a', '\x1C', '\x6B3', '\n', 
		'\x1C', '\f', '\x1C', '\xE', '\x1C', '\x6B6', '\v', '\x1C', '\x3', '\x1D', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1E', 
		'\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x5', '\x1E', '\x6C1', '\n', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x5', '\x1E', '\x6C5', '\n', '\x1E', 
		'\x3', '\x1E', '\x5', '\x1E', '\x6C8', '\n', '\x1E', '\x3', '\x1F', '\x3', 
		'\x1F', '\x3', '\x1F', '\x3', '\x1F', '\x3', ' ', '\x3', ' ', '\x3', ' ', 
		'\x5', ' ', '\x6D1', '\n', ' ', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', 
		'!', '\a', '!', '\x6D7', '\n', '!', '\f', '!', '\xE', '!', '\x6DA', '\v', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x5', 
		'!', '\x6E1', '\n', '!', '\x3', '!', '\x5', '!', '\x6E4', '\n', '!', '\x3', 
		'\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x5', '\"', 
		'\x6EB', '\n', '\"', '\x3', '#', '\x5', '#', '\x6EE', '\n', '#', '\x3', 
		'#', '\x5', '#', '\x6F1', '\n', '#', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x5', '$', '\x6F6', '\n', '$', '\x3', '$', '\x6', '$', '\x6F9', '\n', 
		'$', '\r', '$', '\xE', '$', '\x6FA', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', 
		'\x5', '%', '\x724', '\n', '%', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', 
		'&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', 
		'&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', 
		'&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', 
		'&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x5', '&', '\x740', 
		'\n', '&', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\a', '\'', '\x745', 
		'\n', '\'', '\f', '\'', '\xE', '\'', '\x748', '\v', '\'', '\x3', '\'', 
		'\x3', '\'', '\x5', '\'', '\x74C', '\n', '\'', '\x3', '\'', '\x3', '\'', 
		'\x3', '(', '\x3', '(', '\x3', '(', '\x5', '(', '\x753', '\n', '(', '\x3', 
		')', '\x3', ')', '\x3', ')', '\x3', ')', '\x3', ')', '\x3', '*', '\x3', 
		'*', '\x6', '*', '\x75C', '\n', '*', '\r', '*', '\xE', '*', '\x75D', '\x3', 
		'+', '\x3', '+', '\x3', '+', '\x3', ',', '\x3', ',', '\x3', ',', '\x5', 
		',', '\x766', '\n', ',', '\x3', ',', '\x3', ',', '\x5', ',', '\x76A', 
		'\n', ',', '\x3', ',', '\x3', ',', '\x3', '-', '\x3', '-', '\x3', '-', 
		'\x3', '-', '\x3', '-', '\x3', '-', '\x3', '-', '\x3', '-', '\x5', '-', 
		'\x776', '\n', '-', '\x3', '-', '\x5', '-', '\x779', '\n', '-', '\x3', 
		'-', '\x3', '-', '\x3', '.', '\x3', '.', '\x5', '.', '\x77F', '\n', '.', 
		'\x3', '.', '\x5', '.', '\x782', '\n', '.', '\x3', '.', '\a', '.', '\x785', 
		'\n', '.', '\f', '.', '\xE', '.', '\x788', '\v', '.', '\x3', '.', '\x3', 
		'.', '\x5', '.', '\x78C', '\n', '.', '\x3', '/', '\x3', '/', '\x5', '/', 
		'\x790', '\n', '/', '\x3', '/', '\x3', '/', '\x3', '/', '\x3', '/', '\x3', 
		'/', '\x3', '/', '\a', '/', '\x798', '\n', '/', '\f', '/', '\xE', '/', 
		'\x79B', '\v', '/', '\x3', '/', '\x3', '/', '\x3', '\x30', '\x3', '\x30', 
		'\x3', '\x30', '\a', '\x30', '\x7A2', '\n', '\x30', '\f', '\x30', '\xE', 
		'\x30', '\x7A5', '\v', '\x30', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', 
		'\x5', '\x31', '\x7AA', '\n', '\x31', '\x3', '\x32', '\x3', '\x32', '\x3', 
		'\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\a', 
		'\x32', '\x7B3', '\n', '\x32', '\f', '\x32', '\xE', '\x32', '\x7B6', '\v', 
		'\x32', '\x3', '\x32', '\x3', '\x32', '\x5', '\x32', '\x7BA', '\n', '\x32', 
		'\x3', '\x33', '\x3', '\x33', '\x5', '\x33', '\x7BE', '\n', '\x33', '\x3', 
		'\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', 
		'\x34', '\x5', '\x34', '\x7C6', '\n', '\x34', '\x3', '\x35', '\x3', '\x35', 
		'\x3', '\x35', '\x3', '\x35', '\x3', '\x35', '\x3', '\x35', '\x5', '\x35', 
		'\x7CE', '\n', '\x35', '\x3', '\x35', '\x3', '\x35', '\x3', '\x35', '\x5', 
		'\x35', '\x7D3', '\n', '\x35', '\x3', '\x35', '\x5', '\x35', '\x7D6', 
		'\n', '\x35', '\x5', '\x35', '\x7D8', '\n', '\x35', '\x3', '\x36', '\x5', 
		'\x36', '\x7DB', '\n', '\x36', '\x3', '\x36', '\x3', '\x36', '\x3', '\x36', 
		'\x3', '\x36', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', '\x5', '\x37', 
		'\x7E4', '\n', '\x37', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', '\x5', 
		'\x37', '\x7E9', '\n', '\x37', '\x3', '\x37', '\x3', '\x37', '\x3', '\x38', 
		'\x3', '\x38', '\x3', '\x38', '\x5', '\x38', '\x7F0', '\n', '\x38', '\x3', 
		'\x38', '\x5', '\x38', '\x7F3', '\n', '\x38', '\x3', '\x39', '\x5', '\x39', 
		'\x7F6', '\n', '\x39', '\x3', '\x39', '\x3', '\x39', '\x5', '\x39', '\x7FA', 
		'\n', '\x39', '\x3', '\x39', '\x5', '\x39', '\x7FD', '\n', '\x39', '\x3', 
		'\x39', '\x3', '\x39', '\x3', '\x39', '\x3', '\x39', '\a', '\x39', '\x803', 
		'\n', '\x39', '\f', '\x39', '\xE', '\x39', '\x806', '\v', '\x39', '\x3', 
		'\x39', '\x3', '\x39', '\x5', '\x39', '\x80A', '\n', '\x39', '\x3', '\x39', 
		'\a', '\x39', '\x80D', '\n', '\x39', '\f', '\x39', '\xE', '\x39', '\x810', 
		'\v', '\x39', '\x3', ':', '\x3', ':', '\x3', ':', '\x3', ':', '\x5', ':', 
		'\x816', '\n', ':', '\x3', ';', '\x3', ';', '\x3', ';', '\x3', '<', '\x3', 
		'<', '\x3', '<', '\x3', '<', '\x3', '<', '\x5', '<', '\x820', '\n', '<', 
		'\x3', '=', '\x3', '=', '\x3', '=', '\x3', '=', '\x3', '=', '\x3', '=', 
		'\x3', '=', '\x3', '=', '\x3', '>', '\x3', '>', '\x3', '>', '\x3', '>', 
		'\x6', '>', '\x82E', '\n', '>', '\r', '>', '\xE', '>', '\x82F', '\x3', 
		'>', '\x3', '>', '\x3', '?', '\x3', '?', '\x5', '?', '\x836', '\n', '?', 
		'\x3', '@', '\x3', '@', '\x3', '@', '\x3', '@', '\x3', '\x41', '\x3', 
		'\x41', '\x3', '\x41', '\x3', '\x41', '\x5', '\x41', '\x840', '\n', '\x41', 
		'\x3', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', '\x42', 
		'\x3', '\x42', '\a', '\x42', '\x848', '\n', '\x42', '\f', '\x42', '\xE', 
		'\x42', '\x84B', '\v', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', '\x42', 
		'\x3', '\x42', '\x5', '\x42', '\x851', '\n', '\x42', '\x3', '\x42', '\x5', 
		'\x42', '\x854', '\n', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', '\x42', 
		'\x5', '\x42', '\x859', '\n', '\x42', '\x3', '\x43', '\x3', '\x43', '\x3', 
		'\x43', '\x3', '\x43', '\x3', '\x43', '\x3', '\x43', '\a', '\x43', '\x861', 
		'\n', '\x43', '\f', '\x43', '\xE', '\x43', '\x864', '\v', '\x43', '\x3', 
		'\x43', '\x3', '\x43', '\x5', '\x43', '\x868', '\n', '\x43', '\x3', '\x43', 
		'\x3', '\x43', '\x3', '\x43', '\x3', '\x43', '\x3', '\x43', '\x5', '\x43', 
		'\x86F', '\n', '\x43', '\x3', '\x43', '\x5', '\x43', '\x872', '\n', '\x43', 
		'\x3', '\x43', '\x3', '\x43', '\x3', '\x43', '\x5', '\x43', '\x877', '\n', 
		'\x43', '\x3', '\x44', '\x5', '\x44', '\x87A', '\n', '\x44', '\x3', '\x44', 
		'\x5', '\x44', '\x87D', '\n', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', 
		'\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', 
		'\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', 
		'\x44', '\a', '\x44', '\x88C', '\n', '\x44', '\f', '\x44', '\xE', '\x44', 
		'\x88F', '\v', '\x44', '\x3', '\x44', '\x3', '\x44', '\x5', '\x44', '\x893', 
		'\n', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', 
		'\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x5', '\x44', '\x89C', '\n', 
		'\x44', '\x3', '\x44', '\x5', '\x44', '\x89F', '\n', '\x44', '\x3', '\x44', 
		'\x3', '\x44', '\x3', '\x44', '\x5', '\x44', '\x8A4', '\n', '\x44', '\x3', 
		'\x45', '\x5', '\x45', '\x8A7', '\n', '\x45', '\x3', '\x45', '\x3', '\x45', 
		'\x3', '\x46', '\x3', '\x46', '\x3', '\x46', '\x5', '\x46', '\x8AE', '\n', 
		'\x46', '\x3', '\x46', '\x5', '\x46', '\x8B1', '\n', '\x46', '\x3', 'G', 
		'\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'H', '\x5', 'H', '\x8B8', '\n', 
		'H', '\x3', 'H', '\x6', 'H', '\x8BB', '\n', 'H', '\r', 'H', '\xE', 'H', 
		'\x8BC', '\x3', 'H', '\x3', 'H', '\x5', 'H', '\x8C1', '\n', 'H', '\x3', 
		'I', '\x3', 'I', '\x3', 'I', '\x5', 'I', '\x8C6', '\n', 'I', '\x3', 'J', 
		'\x3', 'J', '\x3', 'J', '\x5', 'J', '\x8CB', '\n', 'J', '\x3', 'K', '\x3', 
		'K', '\x3', 'K', '\x3', 'K', '\x3', 'K', '\x3', 'K', '\a', 'K', '\x8D3', 
		'\n', 'K', '\f', 'K', '\xE', 'K', '\x8D6', '\v', 'K', '\x3', 'K', '\x3', 
		'K', '\x3', 'K', '\x5', 'K', '\x8DB', '\n', 'K', '\x3', 'L', '\x3', 'L', 
		'\x3', 'L', '\x3', 'L', '\x3', 'L', '\x3', 'L', '\a', 'L', '\x8E3', '\n', 
		'L', '\f', 'L', '\xE', 'L', '\x8E6', '\v', 'L', '\x3', 'L', '\x3', 'L', 
		'\x5', 'L', '\x8EA', '\n', 'L', '\x3', 'L', '\x3', 'L', '\x3', 'L', '\x3', 
		'L', '\x3', 'L', '\x5', 'L', '\x8F1', '\n', 'L', '\x3', 'L', '\x3', 'L', 
		'\x3', 'L', '\x3', 'L', '\x5', 'L', '\x8F7', '\n', 'L', '\x3', 'L', '\x3', 
		'L', '\x5', 'L', '\x8FB', '\n', 'L', '\x3', 'M', '\x5', 'M', '\x8FE', 
		'\n', 'M', '\x3', 'M', '\x5', 'M', '\x901', '\n', 'M', '\x3', 'M', '\x3', 
		'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 
		'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\a', 
		'M', '\x910', '\n', 'M', '\f', 'M', '\xE', 'M', '\x913', '\v', 'M', '\x3', 
		'M', '\x3', 'M', '\x5', 'M', '\x917', '\n', 'M', '\x3', 'M', '\x3', 'M', 
		'\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x5', 'M', '\x91F', '\n', 
		'M', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\a', 'O', '\x92B', 
		'\n', 'O', '\f', 'O', '\xE', 'O', '\x92E', '\v', 'O', '\x3', 'O', '\x3', 
		'O', '\x3', 'P', '\x3', 'P', '\x5', 'P', '\x934', '\n', 'P', '\x3', 'Q', 
		'\x3', 'Q', '\x3', 'Q', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', 
		'\x3', 'R', '\x3', 'S', '\x3', 'S', '\x3', 'S', '\x3', 'S', '\x6', 'S', 
		'\x942', '\n', 'S', '\r', 'S', '\xE', 'S', '\x943', '\x3', 'S', '\x3', 
		'S', '\x3', 'T', '\x3', 'T', '\x3', 'T', '\x3', 'T', '\a', 'T', '\x94C', 
		'\n', 'T', '\f', 'T', '\xE', 'T', '\x94F', '\v', 'T', '\x3', 'T', '\x3', 
		'T', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', '\x957', 
		'\n', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', 
		'\x95D', '\n', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', '\x962', 
		'\n', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', 
		'\x968', '\n', 'U', '\x3', 'U', '\x3', 'U', '\x3', 'U', '\x5', 'U', '\x96D', 
		'\n', 'U', '\x3', 'V', '\x3', 'V', '\x5', 'V', '\x971', '\n', 'V', '\x3', 
		'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 
		'V', '\x5', 'V', '\x97A', '\n', 'V', '\x3', 'V', '\x3', 'V', '\x5', 'V', 
		'\x97E', '\n', 'V', '\x3', 'V', '\x3', 'V', '\x3', 'W', '\x3', 'W', '\x3', 
		'W', '\x3', 'W', '\x3', 'W', '\x3', 'W', '\x3', 'W', '\x3', 'W', '\x3', 
		'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 
		'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x6', 
		'X', '\x996', '\n', 'X', '\r', 'X', '\xE', 'X', '\x997', '\x3', 'X', '\x3', 
		'X', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\x3', 'Y', '\x6', 'Y', '\x9AA', '\n', 'Y', '\r', 'Y', 
		'\xE', 'Y', '\x9AB', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 'Y', '\x9B1', 
		'\n', 'Y', '\x3', 'Y', '\x6', 'Y', '\x9B4', '\n', 'Y', '\r', 'Y', '\xE', 
		'Y', '\x9B5', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 'Y', '\x9BB', 
		'\n', 'Y', '\x3', 'Z', '\x3', 'Z', '\x3', 'Z', '\x5', 'Z', '\x9C0', '\n', 
		'Z', '\x3', '[', '\x3', '[', '\x3', '[', '\x3', '[', '\x3', '\\', '\x3', 
		'\\', '\x3', '\\', '\x3', '\\', '\x5', '\\', '\x9CA', '\n', '\\', '\x3', 
		']', '\x3', ']', '\x3', ']', '\x3', ']', '\x3', '^', '\x3', '^', '\x3', 
		'^', '\x5', '^', '\x9D3', '\n', '^', '\x3', '^', '\x3', '^', '\x3', '^', 
		'\x3', '_', '\x3', '_', '\x3', '_', '\x3', '`', '\x5', '`', '\x9DC', '\n', 
		'`', '\x3', '`', '\x6', '`', '\x9DF', '\n', '`', '\r', '`', '\xE', '`', 
		'\x9E0', '\x3', '`', '\x3', '`', '\x3', '`', '\x5', '`', '\x9E6', '\n', 
		'`', '\x3', '`', '\x6', '`', '\x9E9', '\n', '`', '\r', '`', '\xE', '`', 
		'\x9EA', '\a', '`', '\x9ED', '\n', '`', '\f', '`', '\xE', '`', '\x9F0', 
		'\v', '`', '\x5', '`', '\x9F2', '\n', '`', '\x3', '\x61', '\x3', '\x61', 
		'\x3', '\x61', '\x3', '\x61', '\x5', '\x61', '\x9F8', '\n', '\x61', '\x3', 
		'\x62', '\x3', '\x62', '\x3', '\x62', '\x3', '\x63', '\x3', '\x63', '\x3', 
		'\x63', '\x3', '\x64', '\x3', '\x64', '\x3', '\x64', '\x3', '\x65', '\x3', 
		'\x65', '\x3', '\x65', '\x5', '\x65', '\xA06', '\n', '\x65', '\x3', '\x65', 
		'\x6', '\x65', '\xA09', '\n', '\x65', '\r', '\x65', '\xE', '\x65', '\xA0A', 
		'\x5', '\x65', '\xA0D', '\n', '\x65', '\x3', '\x65', '\x5', '\x65', '\xA10', 
		'\n', '\x65', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', 
		'\x3', '\x66', '\x3', '\x66', '\x5', '\x66', '\xA18', '\n', '\x66', '\x3', 
		'\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', 
		'\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', 
		'\x66', '\x5', '\x66', '\xA25', '\n', '\x66', '\x5', '\x66', '\xA27', 
		'\n', '\x66', '\x3', '\x66', '\x3', '\x66', '\x5', '\x66', '\xA2B', '\n', 
		'\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\x3', 
		'\x66', '\x3', '\x66', '\x5', '\x66', '\xA33', '\n', '\x66', '\x5', '\x66', 
		'\xA35', '\n', '\x66', '\x5', '\x66', '\xA37', '\n', '\x66', '\x5', '\x66', 
		'\xA39', '\n', '\x66', '\x3', 'g', '\x3', 'g', '\x5', 'g', '\xA3D', '\n', 
		'g', '\x3', 'g', '\x6', 'g', '\xA40', '\n', 'g', '\r', 'g', '\xE', 'g', 
		'\xA41', '\x3', 'g', '\x3', 'g', '\x3', 'h', '\x3', 'h', '\x3', 'h', '\x3', 
		'h', '\x3', 'h', '\x3', 'h', '\x5', 'h', '\xA4C', '\n', 'h', '\x3', 'i', 
		'\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'j', '\x3', 'j', 
		'\x3', 'j', '\x3', 'j', '\x5', 'j', '\xA57', '\n', 'j', '\x5', 'j', '\xA59', 
		'\n', 'j', '\x3', 'k', '\x3', 'k', '\x3', 'k', '\x3', 'k', '\x3', 'k', 
		'\x3', 'l', '\x3', 'l', '\x3', 'l', '\x5', 'l', '\xA63', '\n', 'l', '\x3', 
		'l', '\x3', 'l', '\x3', 'm', '\x5', 'm', '\xA68', '\n', 'm', '\x3', 'm', 
		'\x3', 'm', '\x5', 'm', '\xA6C', '\n', 'm', '\x3', 'm', '\x3', 'm', '\x5', 
		'm', '\xA70', '\n', 'm', '\x3', 'm', '\x3', 'm', '\x6', 'm', '\xA74', 
		'\n', 'm', '\r', 'm', '\xE', 'm', '\xA75', '\x3', 'n', '\x5', 'n', '\xA79', 
		'\n', 'n', '\x3', 'n', '\x3', 'n', '\x5', 'n', '\xA7D', '\n', 'n', '\x6', 
		'n', '\xA7F', '\n', 'n', '\r', 'n', '\xE', 'n', '\xA80', '\x3', 'n', '\x3', 
		'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x5', 'n', '\xA88', '\n', 'n', 
		'\x3', 'n', '\x3', 'n', '\x3', 'n', '\x6', 'n', '\xA8D', '\n', 'n', '\r', 
		'n', '\xE', 'n', '\xA8E', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x5', 'n', 
		'\xA94', '\n', 'n', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\xA98', '\n', 
		'o', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\xA9E', 
		'\n', 'o', '\x5', 'o', '\xAA0', '\n', 'o', '\x6', 'o', '\xAA2', '\n', 
		'o', '\r', 'o', '\xE', 'o', '\xAA3', '\x3', 'o', '\x3', 'o', '\x5', 'o', 
		'\xAA8', '\n', 'o', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\xAAC', '\n', 
		'o', '\x3', 'o', '\x3', 'o', '\x6', 'o', '\xAB0', '\n', 'o', '\r', 'o', 
		'\xE', 'o', '\xAB1', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\xAB7', 
		'\n', 'o', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\xABC', '\n', 
		'o', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\xAC1', '\n', 'o', 
		'\x3', 'o', '\x5', 'o', '\xAC4', '\n', 'o', '\x3', 'o', '\x3', 'o', '\x3', 
		'p', '\x3', 'p', '\x3', 'p', '\x3', 'p', '\x3', 'q', '\x3', 'q', '\x3', 
		'q', '\x5', 'q', '\xACF', '\n', 'q', '\x3', 'q', '\x5', 'q', '\xAD2', 
		'\n', 'q', '\x3', 'q', '\x5', 'q', '\xAD5', '\n', 'q', '\x3', 'q', '\x3', 
		'q', '\x3', 'q', '\x5', 'q', '\xADA', '\n', 'q', '\x3', 'q', '\x5', 'q', 
		'\xADD', '\n', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x5', 'q', '\xAE2', 
		'\n', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x5', 'q', '\xAE7', '\n', 
		'q', '\x3', 'r', '\x3', 'r', '\x5', 'r', '\xAEB', '\n', 'r', '\x3', 's', 
		'\x3', 's', '\x5', 's', '\xAEF', '\n', 's', '\x3', 's', '\x3', 's', '\x5', 
		's', '\xAF3', '\n', 's', '\x3', 's', '\a', 's', '\xAF6', '\n', 's', '\f', 
		's', '\xE', 's', '\xAF9', '\v', 's', '\x3', 's', '\x5', 's', '\xAFC', 
		'\n', 's', '\x6', 's', '\xAFE', '\n', 's', '\r', 's', '\xE', 's', '\xAFF', 
		'\x3', 's', '\x3', 's', '\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', 
		'\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', '\x5', 't', '\xB0C', '\n', 
		't', '\x3', 't', '\x6', 't', '\xB0F', '\n', 't', '\r', 't', '\xE', 't', 
		'\xB10', '\x3', 't', '\x5', 't', '\xB14', '\n', 't', '\x3', 't', '\x3', 
		't', '\x5', 't', '\xB18', '\n', 't', '\x3', 't', '\x3', 't', '\x5', 't', 
		'\xB1C', '\n', 't', '\x3', 't', '\x3', 't', '\x3', 't', '\x5', 't', '\xB21', 
		'\n', 't', '\x6', 't', '\xB23', '\n', 't', '\r', 't', '\xE', 't', '\xB24', 
		'\x3', 't', '\x3', 't', '\a', 't', '\xB29', '\n', 't', '\f', 't', '\xE', 
		't', '\xB2C', '\v', 't', '\x3', 'u', '\x3', 'u', '\x3', 'u', '\x3', 'u', 
		'\x3', 'u', '\x3', 'v', '\x3', 'v', '\x5', 'v', '\xB35', '\n', 'v', '\x3', 
		'v', '\x5', 'v', '\xB38', '\n', 'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', 
		'\x3', 'v', '\x3', 'v', '\x3', 'v', '\x5', 'v', '\xB40', '\n', 'v', '\x3', 
		'v', '\x5', 'v', '\xB43', '\n', 'v', '\x3', 'w', '\x6', 'w', '\xB46', 
		'\n', 'w', '\r', 'w', '\xE', 'w', '\xB47', '\x3', 'w', '\x5', 'w', '\xB4B', 
		'\n', 'w', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\xB4F', '\n', 'x', '\x3', 
		'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\xB55', '\n', 'x', 
		'\x3', 'y', '\x5', 'y', '\xB58', '\n', 'y', '\x3', 'y', '\x3', 'y', '\x3', 
		'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x6', 
		'y', '\xB62', '\n', 'y', '\r', 'y', '\xE', 'y', '\xB63', '\x3', 'z', '\x3', 
		'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 
		'z', '\x5', 'z', '\xB6E', '\n', 'z', '\x5', 'z', '\xB70', '\n', 'z', '\x3', 
		'{', '\x3', '{', '\x5', '{', '\xB74', '\n', '{', '\x3', '{', '\x6', '{', 
		'\xB77', '\n', '{', '\r', '{', '\xE', '{', '\xB78', '\x6', '{', '\xB7B', 
		'\n', '{', '\r', '{', '\xE', '{', '\xB7C', '\x3', '{', '\x3', '{', '\x3', 
		'{', '\x3', '{', '\x5', '{', '\xB83', '\n', '{', '\x5', '{', '\xB85', 
		'\n', '{', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x3', '|', '\x5', '|', '\xB94', '\n', '|', '\x5', '|', '\xB96', 
		'\n', '|', '\x3', '}', '\x3', '}', '\x5', '}', '\xB9A', '\n', '}', '\x3', 
		'}', '\x3', '}', '\x5', '}', '\xB9E', '\n', '}', '\x3', '}', '\x3', '}', 
		'\x6', '}', '\xBA2', '\n', '}', '\r', '}', '\xE', '}', '\xBA3', '\x3', 
		'}', '\x3', '}', '\x3', '~', '\x3', '~', '\x3', '~', '\x3', '~', '\x3', 
		'~', '\x3', '~', '\x3', '~', '\x3', '~', '\a', '~', '\xBB0', '\n', '~', 
		'\f', '~', '\xE', '~', '\xBB3', '\v', '~', '\x3', '~', '\x3', '~', '\x5', 
		'~', '\xBB7', '\n', '~', '\x3', '\x7F', '\x3', '\x7F', '\x3', '\x7F', 
		'\x6', '\x7F', '\xBBC', '\n', '\x7F', '\r', '\x7F', '\xE', '\x7F', '\xBBD', 
		'\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', 
		'\x3', '\x80', '\x5', '\x80', '\xBC6', '\n', '\x80', '\x3', '\x80', '\x3', 
		'\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x5', 
		'\x80', '\xBCE', '\n', '\x80', '\x3', '\x81', '\x6', '\x81', '\xBD1', 
		'\n', '\x81', '\r', '\x81', '\xE', '\x81', '\xBD2', '\x3', '\x82', '\x3', 
		'\x82', '\x3', '\x82', '\x3', '\x82', '\x3', '\x82', '\x3', '\x82', '\x3', 
		'\x82', '\x3', '\x82', '\x3', '\x82', '\x5', '\x82', '\xBDE', '\n', '\x82', 
		'\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x83', 
		'\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\a', '\x83', '\xBE8', '\n', 
		'\x83', '\f', '\x83', '\xE', '\x83', '\xBEB', '\v', '\x83', '\x3', '\x83', 
		'\x3', '\x83', '\x5', '\x83', '\xBEF', '\n', '\x83', '\x3', '\x83', '\x3', 
		'\x83', '\x5', '\x83', '\xBF3', '\n', '\x83', '\x3', '\x83', '\x3', '\x83', 
		'\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x83', '\x3', '\x83', 
		'\a', '\x83', '\xBFC', '\n', '\x83', '\f', '\x83', '\xE', '\x83', '\xBFF', 
		'\v', '\x83', '\x3', '\x83', '\x3', '\x83', '\x5', '\x83', '\xC03', '\n', 
		'\x83', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x5', '\x84', '\xC0A', '\n', '\x84', '\x3', '\x85', '\x3', '\x85', 
		'\x3', '\x85', '\x3', '\x85', '\x6', '\x85', '\xC10', '\n', '\x85', '\r', 
		'\x85', '\xE', '\x85', '\xC11', '\x5', '\x85', '\xC14', '\n', '\x85', 
		'\x3', '\x85', '\x5', '\x85', '\xC17', '\n', '\x85', '\x3', '\x85', '\x3', 
		'\x85', '\x3', '\x85', '\x5', '\x85', '\xC1C', '\n', '\x85', '\x3', '\x85', 
		'\x3', '\x85', '\x6', '\x85', '\xC20', '\n', '\x85', '\r', '\x85', '\xE', 
		'\x85', '\xC21', '\x5', '\x85', '\xC24', '\n', '\x85', '\x3', '\x85', 
		'\x5', '\x85', '\xC27', '\n', '\x85', '\a', '\x85', '\xC29', '\n', '\x85', 
		'\f', '\x85', '\xE', '\x85', '\xC2C', '\v', '\x85', '\x3', '\x85', '\x3', 
		'\x85', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x6', 
		'\x86', '\xC34', '\n', '\x86', '\r', '\x86', '\xE', '\x86', '\xC35', '\x5', 
		'\x86', '\xC38', '\n', '\x86', '\x3', '\x86', '\x5', '\x86', '\xC3B', 
		'\n', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', 
		'\x6', '\x86', '\xC41', '\n', '\x86', '\r', '\x86', '\xE', '\x86', '\xC42', 
		'\x5', '\x86', '\xC45', '\n', '\x86', '\x3', '\x86', '\x5', '\x86', '\xC48', 
		'\n', '\x86', '\a', '\x86', '\xC4A', '\n', '\x86', '\f', '\x86', '\xE', 
		'\x86', '\xC4D', '\v', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x87', 
		'\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\a', '\x87', '\xC57', '\n', '\x87', '\f', '\x87', '\xE', '\x87', '\xC5A', 
		'\v', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\x3', '\x87', '\x5', '\x87', '\xC61', '\n', '\x87', '\x3', '\x87', '\x5', 
		'\x87', '\xC64', '\n', '\x87', '\x3', '\x87', '\x5', '\x87', '\xC67', 
		'\n', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x5', '\x87', 
		'\xC6C', '\n', '\x87', '\x3', '\x87', '\x5', '\x87', '\xC6F', '\n', '\x87', 
		'\x3', '\x87', '\x5', '\x87', '\xC72', '\n', '\x87', '\a', '\x87', '\xC74', 
		'\n', '\x87', '\f', '\x87', '\xE', '\x87', '\xC77', '\v', '\x87', '\x3', 
		'\x87', '\x3', '\x87', '\x5', '\x87', '\xC7B', '\n', '\x87', '\x3', '\x88', 
		'\x5', '\x88', '\xC7E', '\n', '\x88', '\x3', '\x88', '\x3', '\x88', '\x3', 
		'\x88', '\x3', '\x88', '\x6', '\x88', '\xC84', '\n', '\x88', '\r', '\x88', 
		'\xE', '\x88', '\xC85', '\x5', '\x88', '\xC88', '\n', '\x88', '\x3', '\x88', 
		'\x5', '\x88', '\xC8B', '\n', '\x88', '\x3', '\x88', '\x5', '\x88', '\xC8E', 
		'\n', '\x88', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', 
		'\x6', '\x88', '\xC94', '\n', '\x88', '\r', '\x88', '\xE', '\x88', '\xC95', 
		'\x5', '\x88', '\xC98', '\n', '\x88', '\x3', '\x88', '\x5', '\x88', '\xC9B', 
		'\n', '\x88', '\x3', '\x88', '\x5', '\x88', '\xC9E', '\n', '\x88', '\a', 
		'\x88', '\xCA0', '\n', '\x88', '\f', '\x88', '\xE', '\x88', '\xCA3', '\v', 
		'\x88', '\x3', '\x88', '\x3', '\x88', '\x3', '\x89', '\x3', '\x89', '\x3', 
		'\x8A', '\x3', '\x8A', '\x3', '\x8B', '\x3', '\x8B', '\x3', '\x8B', '\x3', 
		'\x8C', '\x3', '\x8C', '\x5', '\x8C', '\xCB0', '\n', '\x8C', '\x3', '\x8D', 
		'\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', 
		'\x5', '\x8E', '\xCB8', '\n', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', 
		'\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', 
		'\x8E', '\x3', '\x8E', '\x5', '\x8E', '\xCC3', '\n', '\x8E', '\x3', '\x8E', 
		'\x3', '\x8E', '\x3', '\x8E', '\x6', '\x8E', '\xCC8', '\n', '\x8E', '\r', 
		'\x8E', '\xE', '\x8E', '\xCC9', '\x3', '\x8F', '\x3', '\x8F', '\x3', '\x8F', 
		'\x3', '\x8F', '\x5', '\x8F', '\xCD0', '\n', '\x8F', '\x3', '\x8F', '\x3', 
		'\x8F', '\x5', '\x8F', '\xCD4', '\n', '\x8F', '\x3', '\x90', '\x3', '\x90', 
		'\x5', '\x90', '\xCD8', '\n', '\x90', '\x3', '\x90', '\x3', '\x90', '\x3', 
		'\x90', '\x5', '\x90', '\xCDD', '\n', '\x90', '\x3', '\x91', '\x3', '\x91', 
		'\x3', '\x91', '\x3', '\x91', '\x5', '\x91', '\xCE3', '\n', '\x91', '\x3', 
		'\x92', '\x5', '\x92', '\xCE6', '\n', '\x92', '\x3', '\x92', '\x5', '\x92', 
		'\xCE9', '\n', '\x92', '\x3', '\x92', '\x5', '\x92', '\xCEC', '\n', '\x92', 
		'\x3', '\x92', '\x5', '\x92', '\xCEF', '\n', '\x92', '\x5', '\x92', '\xCF1', 
		'\n', '\x92', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', 
		'\x3', '\x93', '\x5', '\x93', '\xCF8', '\n', '\x93', '\x5', '\x93', '\xCFA', 
		'\n', '\x93', '\x3', '\x93', '\x3', '\x93', '\x5', '\x93', '\xCFE', '\n', 
		'\x93', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x95', '\x3', 
		'\x95', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', 
		'\x95', '\x5', '\x95', '\xD0A', '\n', '\x95', '\x5', '\x95', '\xD0C', 
		'\n', '\x95', '\x3', '\x96', '\x3', '\x96', '\x5', '\x96', '\xD10', '\n', 
		'\x96', '\x3', '\x96', '\x3', '\x96', '\x5', '\x96', '\xD14', '\n', '\x96', 
		'\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', 
		'\x5', '\x97', '\xD1B', '\n', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', 
		'\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x5', '\x97', '\xD23', 
		'\n', '\x97', '\x5', '\x97', '\xD25', '\n', '\x97', '\x3', '\x97', '\x5', 
		'\x97', '\xD28', '\n', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', 
		'\x5', '\x97', '\xD2D', '\n', '\x97', '\x3', '\x97', '\x3', '\x97', '\x5', 
		'\x97', '\xD31', '\n', '\x97', '\x3', '\x98', '\x3', '\x98', '\x5', '\x98', 
		'\xD35', '\n', '\x98', '\x3', '\x99', '\x3', '\x99', '\x5', '\x99', '\xD39', 
		'\n', '\x99', '\x3', '\x99', '\x5', '\x99', '\xD3C', '\n', '\x99', '\x3', 
		'\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x5', '\x9A', '\xD42', 
		'\n', '\x9A', '\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', 
		'\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x5', '\x9B', '\xD4B', '\n', 
		'\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x3', '\x9B', '\x3', 
		'\x9B', '\x5', '\x9B', '\xD52', '\n', '\x9B', '\x3', '\x9B', '\x3', '\x9B', 
		'\x3', '\x9B', '\x3', '\x9B', '\x5', '\x9B', '\xD58', '\n', '\x9B', '\x3', 
		'\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x5', '\x9C', '\xD5E', 
		'\n', '\x9C', '\x3', '\x9C', '\x5', '\x9C', '\xD61', '\n', '\x9C', '\x3', 
		'\x9C', '\x5', '\x9C', '\xD64', '\n', '\x9C', '\x3', '\x9C', '\x3', '\x9C', 
		'\x3', '\x9C', '\x5', '\x9C', '\xD69', '\n', '\x9C', '\x3', '\x9C', '\x5', 
		'\x9C', '\xD6C', '\n', '\x9C', '\x3', '\x9C', '\x5', '\x9C', '\xD6F', 
		'\n', '\x9C', '\a', '\x9C', '\xD71', '\n', '\x9C', '\f', '\x9C', '\xE', 
		'\x9C', '\xD74', '\v', '\x9C', '\x3', '\x9C', '\x3', '\x9C', '\x5', '\x9C', 
		'\xD78', '\n', '\x9C', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9E', '\x3', 
		'\x9E', '\x3', '\x9F', '\x3', '\x9F', '\x3', '\xA0', '\x3', '\xA0', '\x3', 
		'\xA0', '\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\x5', '\xA1', '\xD86', 
		'\n', '\xA1', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xD8A', '\n', 
		'\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xD8D', '\n', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', 
		'\xD94', '\n', '\xA2', '\x3', '\xA3', '\x3', '\xA3', '\x5', '\xA3', '\xD98', 
		'\n', '\xA3', '\x3', '\xA3', '\x3', '\xA3', '\a', '\xA3', '\xD9C', '\n', 
		'\xA3', '\f', '\xA3', '\xE', '\xA3', '\xD9F', '\v', '\xA3', '\x3', '\xA4', 
		'\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', 
		'\x3', '\xA4', '\x3', '\xA4', '\x5', '\xA4', '\xDA9', '\n', '\xA4', '\x3', 
		'\xA4', '\x3', '\xA4', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA6', '\x3', 
		'\xA6', '\x3', '\xA6', '\x3', '\xA6', '\x3', '\xA7', '\x3', '\xA7', '\x5', 
		'\xA7', '\xDB5', '\n', '\xA7', '\x3', '\xA7', '\x3', '\xA7', '\x3', '\xA7', 
		'\x5', '\xA7', '\xDBA', '\n', '\xA7', '\x3', '\xA7', '\x3', '\xA7', '\x3', 
		'\xA8', '\x3', '\xA8', '\x5', '\xA8', '\xDC0', '\n', '\xA8', '\x3', '\xA8', 
		'\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', 
		'\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', 
		'\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA8', '\a', '\xA8', 
		'\xDD1', '\n', '\xA8', '\f', '\xA8', '\xE', '\xA8', '\xDD4', '\v', '\xA8', 
		'\x3', '\xA9', '\x3', '\xA9', '\x3', '\xA9', '\x3', '\xAA', '\x3', '\xAA', 
		'\x3', '\xAB', '\x3', '\xAB', '\x3', '\xAB', '\x3', '\xAB', '\x3', '\xAB', 
		'\x3', '\xAB', '\x3', '\xAB', '\x5', '\xAB', '\xDE2', '\n', '\xAB', '\x5', 
		'\xAB', '\xDE4', '\n', '\xAB', '\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAC', 
		'\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAD', '\x3', '\xAD', '\x3', '\xAD', 
		'\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x5', '\xAE', '\xDF1', '\n', 
		'\xAE', '\x3', '\xAE', '\x5', '\xAE', '\xDF4', '\n', '\xAE', '\x3', '\xAE', 
		'\x5', '\xAE', '\xDF7', '\n', '\xAE', '\x3', '\xAF', '\x3', '\xAF', '\x3', 
		'\xAF', '\x3', '\xAF', '\x3', '\xB0', '\x3', '\xB0', '\x3', '\xB0', '\x5', 
		'\xB0', '\xE00', '\n', '\xB0', '\x3', '\xB0', '\x5', '\xB0', '\xE03', 
		'\n', '\xB0', '\x3', '\xB0', '\x5', '\xB0', '\xE06', '\n', '\xB0', '\x3', 
		'\xB1', '\x3', '\xB1', '\x3', '\xB1', '\x3', '\xB2', '\x3', '\xB2', '\x5', 
		'\xB2', '\xE0D', '\n', '\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x3', '\xB3', 
		'\x3', '\xB3', '\x5', '\xB3', '\xE13', '\n', '\xB3', '\x3', '\xB3', '\x3', 
		'\xB3', '\x3', '\xB4', '\x5', '\xB4', '\xE18', '\n', '\xB4', '\x3', '\xB4', 
		'\x3', '\xB4', '\x5', '\xB4', '\xE1C', '\n', '\xB4', '\x3', '\xB4', '\x5', 
		'\xB4', '\xE1F', '\n', '\xB4', '\x3', '\xB4', '\x5', '\xB4', '\xE22', 
		'\n', '\xB4', '\x3', '\xB5', '\x3', '\xB5', '\x3', '\xB5', '\x3', '\xB5', 
		'\x5', '\xB5', '\xE28', '\n', '\xB5', '\x3', '\xB5', '\x6', '\xB5', '\xE2B', 
		'\n', '\xB5', '\r', '\xB5', '\xE', '\xB5', '\xE2C', '\x3', '\xB5', '\x5', 
		'\xB5', '\xE30', '\n', '\xB5', '\x3', '\xB5', '\x3', '\xB5', '\x5', '\xB5', 
		'\xE34', '\n', '\xB5', '\x3', '\xB5', '\x3', '\xB5', '\x5', '\xB5', '\xE38', 
		'\n', '\xB5', '\x3', '\xB5', '\x5', '\xB5', '\xE3B', '\n', '\xB5', '\x3', 
		'\xB6', '\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB6', '\x5', 
		'\xB6', '\xE42', '\n', '\xB6', '\x3', '\xB6', '\x5', '\xB6', '\xE45', 
		'\n', '\xB6', '\x5', '\xB6', '\xE47', '\n', '\xB6', '\x3', '\xB7', '\x3', 
		'\xB7', '\x3', '\xB7', '\x5', '\xB7', '\xE4C', '\n', '\xB7', '\x3', '\xB8', 
		'\x3', '\xB8', '\a', '\xB8', '\xE50', '\n', '\xB8', '\f', '\xB8', '\xE', 
		'\xB8', '\xE53', '\v', '\xB8', '\x3', '\xB9', '\x3', '\xB9', '\x3', '\xB9', 
		'\x5', '\xB9', '\xE58', '\n', '\xB9', '\x3', '\xB9', '\x3', '\xB9', '\x3', 
		'\xB9', '\x3', '\xB9', '\x3', '\xBA', '\x3', '\xBA', '\x3', '\xBA', '\x3', 
		'\xBA', '\x5', '\xBA', '\xE62', '\n', '\xBA', '\x3', '\xBA', '\x3', '\xBA', 
		'\x3', '\xBA', '\x5', '\xBA', '\xE67', '\n', '\xBA', '\x3', '\xBA', '\x5', 
		'\xBA', '\xE6A', '\n', '\xBA', '\x3', '\xBA', '\x5', '\xBA', '\xE6D', 
		'\n', '\xBA', '\x3', '\xBA', '\x3', '\xBA', '\x3', '\xBB', '\x3', '\xBB', 
		'\x3', '\xBB', '\a', '\xBB', '\xE74', '\n', '\xBB', '\f', '\xBB', '\xE', 
		'\xBB', '\xE77', '\v', '\xBB', '\x3', '\xBC', '\x3', '\xBC', '\x3', '\xBC', 
		'\x3', '\xBC', '\x3', '\xBC', '\x5', '\xBC', '\xE7E', '\n', '\xBC', '\x3', 
		'\xBC', '\x5', '\xBC', '\xE81', '\n', '\xBC', '\x3', '\xBD', '\x5', '\xBD', 
		'\xE84', '\n', '\xBD', '\x3', '\xBD', '\x5', '\xBD', '\xE87', '\n', '\xBD', 
		'\x3', '\xBD', '\x5', '\xBD', '\xE8A', '\n', '\xBD', '\x3', '\xBD', '\x5', 
		'\xBD', '\xE8D', '\n', '\xBD', '\x3', '\xBD', '\x5', '\xBD', '\xE90', 
		'\n', '\xBD', '\x3', '\xBD', '\x3', '\xBD', '\x3', '\xBD', '\x3', '\xBD', 
		'\x3', '\xBD', '\x5', '\xBD', '\xE97', '\n', '\xBD', '\x3', '\xBD', '\x5', 
		'\xBD', '\xE9A', '\n', '\xBD', '\x3', '\xBD', '\x5', '\xBD', '\xE9D', 
		'\n', '\xBD', '\x3', '\xBD', '\a', '\xBD', '\xEA0', '\n', '\xBD', '\f', 
		'\xBD', '\xE', '\xBD', '\xEA3', '\v', '\xBD', '\x3', '\xBD', '\x5', '\xBD', 
		'\xEA6', '\n', '\xBD', '\x3', '\xBD', '\x5', '\xBD', '\xEA9', '\n', '\xBD', 
		'\x3', '\xBD', '\x3', '\xBD', '\x5', '\xBD', '\xEAD', '\n', '\xBD', '\x3', 
		'\xBD', '\x3', '\xBD', '\x5', '\xBD', '\xEB1', '\n', '\xBD', '\x3', '\xBE', 
		'\x3', '\xBE', '\x3', '\xBE', '\x5', '\xBE', '\xEB6', '\n', '\xBE', '\x3', 
		'\xBE', '\x3', '\xBE', '\x3', '\xBE', '\x5', '\xBE', '\xEBB', '\n', '\xBE', 
		'\x3', '\xBF', '\x3', '\xBF', '\x3', '\xBF', '\x3', '\xBF', '\x3', '\xC0', 
		'\x3', '\xC0', '\x5', '\xC0', '\xEC3', '\n', '\xC0', '\x3', '\xC0', '\x3', 
		'\xC0', '\x5', '\xC0', '\xEC7', '\n', '\xC0', '\x3', '\xC0', '\x3', '\xC0', 
		'\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC1', '\x3', '\xC2', 
		'\x3', '\xC2', '\x5', '\xC2', '\xED1', '\n', '\xC2', '\x3', '\xC2', '\x3', 
		'\xC2', '\x3', '\xC2', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x3', 
		'\xC3', '\x3', '\xC3', '\x6', '\xC3', '\xEDB', '\n', '\xC3', '\r', '\xC3', 
		'\xE', '\xC3', '\xEDC', '\x3', '\xC3', '\x3', '\xC3', '\x5', '\xC3', '\xEE1', 
		'\n', '\xC3', '\x3', '\xC4', '\x3', '\xC4', '\x3', '\xC5', '\x3', '\xC5', 
		'\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', 
		'\x5', '\xC5', '\xEEC', '\n', '\xC5', '\x3', '\xC6', '\x3', '\xC6', '\x3', 
		'\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x3', 
		'\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x5', '\xC6', '\xEF8', '\n', '\xC6', 
		'\x3', '\xC7', '\x3', '\xC7', '\x5', '\xC7', '\xEFC', '\n', '\xC7', '\x3', 
		'\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', 
		'\xC7', '\x5', '\xC7', '\xF04', '\n', '\xC7', '\x3', '\xC7', '\x5', '\xC7', 
		'\xF07', '\n', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x5', '\xC7', '\xF0B', 
		'\n', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x5', '\xC7', 
		'\xF10', '\n', '\xC7', '\x3', '\xC8', '\x3', '\xC8', '\x3', '\xC8', '\x3', 
		'\xC8', '\x3', '\xC8', '\x3', '\xC8', '\x3', '\xC8', '\x5', '\xC8', '\xF19', 
		'\n', '\xC8', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', 
		'\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', 
		'\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', 
		'\a', '\xC9', '\xF29', '\n', '\xC9', '\f', '\xC9', '\xE', '\xC9', '\xF2C', 
		'\v', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x5', '\xC9', '\xF30', '\n', 
		'\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x5', '\xC9', '\xF35', 
		'\n', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', 
		'\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCA', 
		'\x3', '\xCA', '\x5', '\xCA', '\xF41', '\n', '\xCA', '\x3', '\xCB', '\x3', 
		'\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x5', '\xCB', '\xF47', '\n', '\xCB', 
		'\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\a', '\xCB', 
		'\xF4D', '\n', '\xCB', '\f', '\xCB', '\xE', '\xCB', '\xF50', '\v', '\xCB', 
		'\x3', '\xCB', '\x5', '\xCB', '\xF53', '\n', '\xCB', '\x3', '\xCC', '\x3', 
		'\xCC', '\x5', '\xCC', '\xF57', '\n', '\xCC', '\x3', '\xCC', '\x3', '\xCC', 
		'\x5', '\xCC', '\xF5B', '\n', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x3', 
		'\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x5', 
		'\xCD', '\xF64', '\n', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCD', 
		'\x5', '\xCD', '\xF69', '\n', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x5', 
		'\xCD', '\xF6D', '\n', '\xCD', '\x3', '\xCD', '\x5', '\xCD', '\xF70', 
		'\n', '\xCD', '\x5', '\xCD', '\xF72', '\n', '\xCD', '\x3', '\xCD', '\x3', 
		'\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x5', '\xCD', '\xF78', '\n', '\xCD', 
		'\x3', '\xCE', '\x3', '\xCE', '\x5', '\xCE', '\xF7C', '\n', '\xCE', '\x3', 
		'\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x5', 
		'\xCE', '\xF83', '\n', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', 
		'\x3', '\xCE', '\x3', '\xCE', '\x5', '\xCE', '\xF8A', '\n', '\xCE', '\x3', 
		'\xCE', '\x3', '\xCE', '\x5', '\xCE', '\xF8E', '\n', '\xCE', '\x3', '\xCE', 
		'\x3', '\xCE', '\x5', '\xCE', '\xF92', '\n', '\xCE', '\x3', '\xCF', '\x3', 
		'\xCF', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xCF', '\x3', 
		'\xCF', '\x5', '\xCF', '\xF9B', '\n', '\xCF', '\x3', '\xCF', '\x3', '\xCF', 
		'\x3', '\xCF', '\x6', '\xCF', '\xFA0', '\n', '\xCF', '\r', '\xCF', '\xE', 
		'\xCF', '\xFA1', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xD0', '\x3', '\xD0', 
		'\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', 
		'\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', 
		'\x3', '\xD0', '\x3', '\xD0', '\a', '\xD0', '\xFB4', '\n', '\xD0', '\f', 
		'\xD0', '\xE', '\xD0', '\xFB7', '\v', '\xD0', '\x3', '\xD0', '\x3', '\xD0', 
		'\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x5', '\xD0', '\xFBE', '\n', 
		'\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', 
		'\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD1', '\x3', 
		'\xD1', '\x3', '\xD1', '\x5', '\xD1', '\xFCB', '\n', '\xD1', '\x3', '\xD1', 
		'\x3', '\xD1', '\x5', '\xD1', '\xFCF', '\n', '\xD1', '\x3', '\xD2', '\x3', 
		'\xD2', '\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD2', '\x3', 
		'\xD2', '\x5', '\xD2', '\xFD8', '\n', '\xD2', '\x3', '\xD2', '\x3', '\xD2', 
		'\x3', '\xD2', '\a', '\xD2', '\xFDD', '\n', '\xD2', '\f', '\xD2', '\xE', 
		'\xD2', '\xFE0', '\v', '\xD2', '\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', 
		'\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', 
		'\a', '\xD3', '\xFEA', '\n', '\xD3', '\f', '\xD3', '\xE', '\xD3', '\xFED', 
		'\v', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\a', '\xD3', 
		'\xFF2', '\n', '\xD3', '\f', '\xD3', '\xE', '\xD3', '\xFF5', '\v', '\xD3', 
		'\x3', '\xD3', '\x3', '\xD3', '\x3', '\xD3', '\a', '\xD3', '\xFFA', '\n', 
		'\xD3', '\f', '\xD3', '\xE', '\xD3', '\xFFD', '\v', '\xD3', '\x3', '\xD3', 
		'\x3', '\xD3', '\x3', '\xD3', '\x5', '\xD3', '\x1002', '\n', '\xD3', '\x3', 
		'\xD4', '\x3', '\xD4', '\x3', '\xD4', '\x3', '\xD4', '\x3', '\xD4', '\x3', 
		'\xD4', '\x3', '\xD4', '\x3', '\xD4', '\a', '\xD4', '\x100C', '\n', '\xD4', 
		'\f', '\xD4', '\xE', '\xD4', '\x100F', '\v', '\xD4', '\x3', '\xD4', '\x3', 
		'\xD4', '\x3', '\xD4', '\a', '\xD4', '\x1014', '\n', '\xD4', '\f', '\xD4', 
		'\xE', '\xD4', '\x1017', '\v', '\xD4', '\x3', '\xD4', '\x3', '\xD4', '\x3', 
		'\xD4', '\a', '\xD4', '\x101C', '\n', '\xD4', '\f', '\xD4', '\xE', '\xD4', 
		'\x101F', '\v', '\xD4', '\x3', '\xD4', '\x3', '\xD4', '\x3', '\xD4', '\x5', 
		'\xD4', '\x1024', '\n', '\xD4', '\x3', '\xD5', '\x3', '\xD5', '\x5', '\xD5', 
		'\x1028', '\n', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\x5', '\xD5', '\x102C', 
		'\n', '\xD5', '\x3', '\xD5', '\x5', '\xD5', '\x102F', '\n', '\xD5', '\x3', 
		'\xD6', '\x3', '\xD6', '\x5', '\xD6', '\x1033', '\n', '\xD6', '\x3', '\xD6', 
		'\x3', '\xD6', '\x5', '\xD6', '\x1037', '\n', '\xD6', '\x3', '\xD6', '\x5', 
		'\xD6', '\x103A', '\n', '\xD6', '\x3', '\xD7', '\x3', '\xD7', '\x5', '\xD7', 
		'\x103E', '\n', '\xD7', '\x3', '\xD7', '\x5', '\xD7', '\x1041', '\n', 
		'\xD7', '\x3', '\xD7', '\x5', '\xD7', '\x1044', '\n', '\xD7', '\x3', '\xD8', 
		'\x3', '\xD8', '\x3', '\xD8', '\x3', '\xD8', '\x3', '\xD8', '\x3', '\xD8', 
		'\x3', '\xD8', '\x3', '\xD8', '\a', '\xD8', '\x104E', '\n', '\xD8', '\f', 
		'\xD8', '\xE', '\xD8', '\x1051', '\v', '\xD8', '\x3', '\xD8', '\x3', '\xD8', 
		'\x5', '\xD8', '\x1055', '\n', '\xD8', '\x3', '\xD9', '\x5', '\xD9', '\x1058', 
		'\n', '\xD9', '\x3', '\xD9', '\x5', '\xD9', '\x105B', '\n', '\xD9', '\x3', 
		'\xD9', '\x5', '\xD9', '\x105E', '\n', '\xD9', '\x3', '\xD9', '\x3', '\xD9', 
		'\x5', '\xD9', '\x1062', '\n', '\xD9', '\x3', '\xD9', '\x5', '\xD9', '\x1065', 
		'\n', '\xD9', '\x3', '\xD9', '\x5', '\xD9', '\x1068', '\n', '\xD9', '\x3', 
		'\xD9', '\x3', '\xD9', '\x5', '\xD9', '\x106C', '\n', '\xD9', '\x5', '\xD9', 
		'\x106E', '\n', '\xD9', '\x3', '\xD9', '\x3', '\xD9', '\x3', '\xD9', '\a', 
		'\xD9', '\x1073', '\n', '\xD9', '\f', '\xD9', '\xE', '\xD9', '\x1076', 
		'\v', '\xD9', '\x3', '\xDA', '\x3', '\xDA', '\x3', '\xDA', '\x3', '\xDA', 
		'\x3', '\xDA', '\x3', '\xDA', '\x3', '\xDA', '\a', '\xDA', '\x107F', '\n', 
		'\xDA', '\f', '\xDA', '\xE', '\xDA', '\x1082', '\v', '\xDA', '\x3', '\xDA', 
		'\x5', '\xDA', '\x1085', '\n', '\xDA', '\x3', '\xDA', '\x3', '\xDA', '\x3', 
		'\xDB', '\x3', '\xDB', '\x3', '\xDB', '\x3', '\xDB', '\x3', '\xDB', '\a', 
		'\xDB', '\x108E', '\n', '\xDB', '\f', '\xDB', '\xE', '\xDB', '\x1091', 
		'\v', '\xDB', '\x3', '\xDB', '\x5', '\xDB', '\x1094', '\n', '\xDB', '\x3', 
		'\xDB', '\x3', '\xDB', '\x5', '\xDB', '\x1098', '\n', '\xDB', '\x3', '\xDC', 
		'\x3', '\xDC', '\x3', '\xDC', '\x3', '\xDC', '\x3', '\xDC', '\x3', '\xDC', 
		'\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', '\x3', '\xDD', 
		'\x3', '\xDD', '\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', 
		'\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', 
		'\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\a', '\xDE', '\x10B2', '\n', 
		'\xDE', '\f', '\xDE', '\xE', '\xDE', '\x10B5', '\v', '\xDE', '\x3', '\xDE', 
		'\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDE', '\x3', '\xDF', '\x3', '\xDF', 
		'\x3', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\a', '\xDF', 
		'\x10C1', '\n', '\xDF', '\f', '\xDF', '\xE', '\xDF', '\x10C4', '\v', '\xDF', 
		'\x3', '\xDF', '\x3', '\xDF', '\x3', '\xDF', '\a', '\xDF', '\x10C9', '\n', 
		'\xDF', '\f', '\xDF', '\xE', '\xDF', '\x10CC', '\v', '\xDF', '\x3', '\xDF', 
		'\x3', '\xDF', '\x3', '\xDF', '\a', '\xDF', '\x10D1', '\n', '\xDF', '\f', 
		'\xDF', '\xE', '\xDF', '\x10D4', '\v', '\xDF', '\x3', '\xDF', '\x3', '\xDF', 
		'\x3', '\xDF', '\x5', '\xDF', '\x10D9', '\n', '\xDF', '\x3', '\xE0', '\x3', 
		'\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', 
		'\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x5', '\xE0', '\x10E5', 
		'\n', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x5', '\xE0', '\x10E9', '\n', 
		'\xE0', '\x3', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', 
		'\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x6', '\xE1', '\x10F3', 
		'\n', '\xE1', '\r', '\xE1', '\xE', '\xE1', '\x10F4', '\x5', '\xE1', '\x10F7', 
		'\n', '\xE1', '\x3', '\xE2', '\x3', '\xE2', '\x3', '\xE2', '\x3', '\xE2', 
		'\x3', '\xE3', '\x5', '\xE3', '\x10FE', '\n', '\xE3', '\x3', '\xE3', '\x3', 
		'\xE3', '\x3', '\xE3', '\x5', '\xE3', '\x1103', '\n', '\xE3', '\x3', '\xE3', 
		'\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', 
		'\x5', '\xE3', '\x110B', '\n', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', 
		'\xE3', '\x3', '\xE3', '\x5', '\xE3', '\x1111', '\n', '\xE3', '\x3', '\xE4', 
		'\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x5', '\xE4', 
		'\x1118', '\n', '\xE4', '\x3', '\xE4', '\x5', '\xE4', '\x111B', '\n', 
		'\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x5', '\xE4', '\x111F', '\n', '\xE4', 
		'\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', 
		'\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', 
		'\x6', '\xE4', '\x112B', '\n', '\xE4', '\r', '\xE4', '\xE', '\xE4', '\x112C', 
		'\x3', '\xE4', '\x3', '\xE4', '\x5', '\xE4', '\x1131', '\n', '\xE4', '\x3', 
		'\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE4', '\x3', '\xE5', '\x3', 
		'\xE5', '\x5', '\xE5', '\x1139', '\n', '\xE5', '\x3', '\xE5', '\x3', '\xE5', 
		'\x5', '\xE5', '\x113D', '\n', '\xE5', '\x3', '\xE5', '\x6', '\xE5', '\x1140', 
		'\n', '\xE5', '\r', '\xE5', '\xE', '\xE5', '\x1141', '\x3', '\xE5', '\x5', 
		'\xE5', '\x1145', '\n', '\xE5', '\x3', '\xE5', '\x3', '\xE5', '\x3', '\xE5', 
		'\x5', '\xE5', '\x114A', '\n', '\xE5', '\x5', '\xE5', '\x114C', '\n', 
		'\xE5', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', '\x5', '\xE6', '\x1151', 
		'\n', '\xE6', '\x3', '\xE6', '\x3', '\xE6', '\x5', '\xE6', '\x1155', '\n', 
		'\xE6', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x5', '\xE7', '\x115A', 
		'\n', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x5', '\xE7', '\x115E', '\n', 
		'\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', 
		'\xE7', '\x5', '\xE7', '\x1165', '\n', '\xE7', '\x3', '\xE8', '\x3', '\xE8', 
		'\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\a', '\xE8', '\x116C', '\n', 
		'\xE8', '\f', '\xE8', '\xE', '\xE8', '\x116F', '\v', '\xE8', '\x3', '\xE8', 
		'\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', 
		'\x3', '\xE8', '\x3', '\xE8', '\x5', '\xE8', '\x1179', '\n', '\xE8', '\x3', 
		'\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\a', '\xE8', '\x117F', 
		'\n', '\xE8', '\f', '\xE8', '\xE', '\xE8', '\x1182', '\v', '\xE8', '\x3', 
		'\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', 
		'\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x5', '\xE8', '\x118D', 
		'\n', '\xE8', '\x5', '\xE8', '\x118F', '\n', '\xE8', '\x3', '\xE9', '\x3', 
		'\xE9', '\x6', '\xE9', '\x1193', '\n', '\xE9', '\r', '\xE9', '\xE', '\xE9', 
		'\x1194', '\x3', '\xE9', '\x5', '\xE9', '\x1198', '\n', '\xE9', '\x5', 
		'\xE9', '\x119A', '\n', '\xE9', '\x3', '\xE9', '\x5', '\xE9', '\x119D', 
		'\n', '\xE9', '\x3', '\xEA', '\x3', '\xEA', '\x3', '\xEA', '\x3', '\xEA', 
		'\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', 
		'\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', 
		'\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEB', 
		'\x3', '\xEB', '\x5', '\xEB', '\x11B3', '\n', '\xEB', '\x3', '\xEB', '\x3', 
		'\xEB', '\x3', '\xEB', '\x3', '\xEB', '\x5', '\xEB', '\x11B9', '\n', '\xEB', 
		'\x3', '\xEB', '\x5', '\xEB', '\x11BC', '\n', '\xEB', '\x3', '\xEC', '\x3', 
		'\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x5', 
		'\xEC', '\x11C4', '\n', '\xEC', '\x3', '\xED', '\x3', '\xED', '\x3', '\xEE', 
		'\x3', '\xEE', '\x5', '\xEE', '\x11CA', '\n', '\xEE', '\x3', '\xEE', '\x5', 
		'\xEE', '\x11CD', '\n', '\xEE', '\x3', '\xEF', '\x5', '\xEF', '\x11D0', 
		'\n', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11D4', '\n', 
		'\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11D7', '\n', '\xEF', '\x3', '\xEF', 
		'\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11DC', '\n', '\xEF', '\x3', 
		'\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11E1', '\n', '\xEF', 
		'\x3', '\xEF', '\x5', '\xEF', '\x11E4', '\n', '\xEF', '\x3', '\xEF', '\x5', 
		'\xEF', '\x11E7', '\n', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11EA', 
		'\n', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11EE', '\n', 
		'\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', '\x11F3', 
		'\n', '\xEF', '\x5', '\xEF', '\x11F5', '\n', '\xEF', '\x3', '\xF0', '\x3', 
		'\xF0', '\x5', '\xF0', '\x11F9', '\n', '\xF0', '\x3', '\xF0', '\x3', '\xF0', 
		'\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x5', '\xF0', 
		'\x1201', '\n', '\xF0', '\x5', '\xF0', '\x1203', '\n', '\xF0', '\x3', 
		'\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', 
		'\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x5', 
		'\xF1', '\x120F', '\n', '\xF1', '\x3', '\xF1', '\x3', '\xF1', '\x3', '\xF1', 
		'\x3', '\xF1', '\x3', '\xF1', '\x6', '\xF1', '\x1216', '\n', '\xF1', '\r', 
		'\xF1', '\xE', '\xF1', '\x1217', '\x3', '\xF1', '\x3', '\xF1', '\x3', 
		'\xF2', '\x5', '\xF2', '\x121D', '\n', '\xF2', '\x3', '\xF2', '\x5', '\xF2', 
		'\x1220', '\n', '\xF2', '\x3', '\xF2', '\x3', '\xF2', '\x3', '\xF3', '\x3', 
		'\xF3', '\x3', '\xF3', '\x3', '\xF3', '\x5', '\xF3', '\x1228', '\n', '\xF3', 
		'\x3', '\xF3', '\x3', '\xF3', '\x3', '\xF4', '\x3', '\xF4', '\x3', '\xF4', 
		'\x5', '\xF4', '\x122F', '\n', '\xF4', '\x3', '\xF5', '\x3', '\xF5', '\x5', 
		'\xF5', '\x1233', '\n', '\xF5', '\x3', '\xF5', '\x3', '\xF5', '\x5', '\xF5', 
		'\x1237', '\n', '\xF5', '\x3', '\xF6', '\x3', '\xF6', '\x3', '\xF6', '\x3', 
		'\xF6', '\x3', '\xF7', '\x3', '\xF7', '\x3', '\xF7', '\x3', '\xF8', '\x3', 
		'\xF8', '\x3', '\xF8', '\x3', '\xF8', '\x3', '\xF8', '\x3', '\xF8', '\a', 
		'\xF8', '\x1246', '\n', '\xF8', '\f', '\xF8', '\xE', '\xF8', '\x1249', 
		'\v', '\xF8', '\x3', '\xF8', '\x3', '\xF8', '\x3', '\xF9', '\x3', '\xF9', 
		'\x3', '\xF9', '\x3', '\xF9', '\x3', '\xF9', '\x3', '\xF9', '\x3', '\xF9', 
		'\x3', '\xF9', '\x3', '\xF9', '\x3', '\xF9', '\x3', '\xF9', '\x3', '\xF9', 
		'\x3', '\xF9', '\x5', '\xF9', '\x125A', '\n', '\xF9', '\x5', '\xF9', '\x125C', 
		'\n', '\xF9', '\x3', '\xFA', '\x3', '\xFA', '\x5', '\xFA', '\x1260', '\n', 
		'\xFA', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', 
		'\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', 
		'\xFB', '\x5', '\xFB', '\x126C', '\n', '\xFB', '\x3', '\xFB', '\x3', '\xFB', 
		'\x5', '\xFB', '\x1270', '\n', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', 
		'\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', 
		'\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFB', '\x5', '\xFB', '\x127D', 
		'\n', '\xFB', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', 
		'\x5', '\xFC', '\x1283', '\n', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', 
		'\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', 
		'\xFC', '\x3', '\xFC', '\x5', '\xFC', '\x128E', '\n', '\xFC', '\x3', '\xFC', 
		'\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', 
		'\x3', '\xFC', '\x3', '\xFC', '\x5', '\xFC', '\x1298', '\n', '\xFC', '\x3', 
		'\xFC', '\x3', '\xFC', '\x5', '\xFC', '\x129C', '\n', '\xFC', '\x5', '\xFC', 
		'\x129E', '\n', '\xFC', '\x3', '\xFD', '\x3', '\xFD', '\x3', '\xFD', '\x3', 
		'\xFE', '\x3', '\xFE', '\x3', '\xFE', '\x6', '\xFE', '\x12A6', '\n', '\xFE', 
		'\r', '\xFE', '\xE', '\xFE', '\x12A7', '\x3', '\xFE', '\x3', '\xFE', '\x3', 
		'\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', 
		'\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', 
		'\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x3', 
		'\xFF', '\x5', '\xFF', '\x12BC', '\n', '\xFF', '\x3', '\xFF', '\x3', '\xFF', 
		'\x3', '\xFF', '\x3', '\xFF', '\x3', '\xFF', '\x5', '\xFF', '\x12C3', 
		'\n', '\xFF', '\x3', '\x100', '\x3', '\x100', '\x5', '\x100', '\x12C7', 
		'\n', '\x100', '\x3', '\x100', '\x5', '\x100', '\x12CA', '\n', '\x100', 
		'\x3', '\x100', '\x5', '\x100', '\x12CD', '\n', '\x100', '\x3', '\x100', 
		'\x3', '\x100', '\x3', '\x100', '\x5', '\x100', '\x12D2', '\n', '\x100', 
		'\x3', '\x100', '\x3', '\x100', '\x3', '\x100', '\x3', '\x100', '\x3', 
		'\x100', '\x3', '\x100', '\x3', '\x100', '\x5', '\x100', '\x12DB', '\n', 
		'\x100', '\x5', '\x100', '\x12DD', '\n', '\x100', '\x3', '\x100', '\x3', 
		'\x100', '\x3', '\x100', '\x3', '\x100', '\x3', '\x100', '\x3', '\x100', 
		'\x5', '\x100', '\x12E5', '\n', '\x100', '\x5', '\x100', '\x12E7', '\n', 
		'\x100', '\x3', '\x100', '\x3', '\x100', '\x5', '\x100', '\x12EB', '\n', 
		'\x100', '\x3', '\x100', '\x6', '\x100', '\x12EE', '\n', '\x100', '\r', 
		'\x100', '\xE', '\x100', '\x12EF', '\x3', '\x100', '\x5', '\x100', '\x12F3', 
		'\n', '\x100', '\x3', '\x101', '\x3', '\x101', '\x5', '\x101', '\x12F7', 
		'\n', '\x101', '\x3', '\x101', '\x5', '\x101', '\x12FA', '\n', '\x101', 
		'\x3', '\x101', '\x5', '\x101', '\x12FD', '\n', '\x101', '\x3', '\x101', 
		'\x3', '\x101', '\x5', '\x101', '\x1301', '\n', '\x101', '\x3', '\x101', 
		'\x3', '\x101', '\x3', '\x101', '\x3', '\x101', '\x3', '\x101', '\x5', 
		'\x101', '\x1308', '\n', '\x101', '\x3', '\x101', '\x5', '\x101', '\x130B', 
		'\n', '\x101', '\x3', '\x101', '\x5', '\x101', '\x130E', '\n', '\x101', 
		'\x3', '\x101', '\a', '\x101', '\x1311', '\n', '\x101', '\f', '\x101', 
		'\xE', '\x101', '\x1314', '\v', '\x101', '\x3', '\x102', '\x3', '\x102', 
		'\x5', '\x102', '\x1318', '\n', '\x102', '\x3', '\x103', '\x3', '\x103', 
		'\x3', '\x103', '\x3', '\x103', '\x3', '\x103', '\x3', '\x103', '\x3', 
		'\x103', '\x5', '\x103', '\x1321', '\n', '\x103', '\x3', '\x104', '\x3', 
		'\x104', '\x3', '\x104', '\x3', '\x104', '\x5', '\x104', '\x1327', '\n', 
		'\x104', '\x3', '\x105', '\x3', '\x105', '\x3', '\x105', '\x3', '\x105', 
		'\x3', '\x105', '\x3', '\x105', '\a', '\x105', '\x132F', '\n', '\x105', 
		'\f', '\x105', '\xE', '\x105', '\x1332', '\v', '\x105', '\x3', '\x105', 
		'\x3', '\x105', '\x5', '\x105', '\x1336', '\n', '\x105', '\x3', '\x106', 
		'\x3', '\x106', '\x3', '\x106', '\x3', '\x106', '\x3', '\x106', '\x3', 
		'\x106', '\x3', '\x106', '\x3', '\x106', '\x6', '\x106', '\x1340', '\n', 
		'\x106', '\r', '\x106', '\xE', '\x106', '\x1341', '\x3', '\x106', '\x3', 
		'\x106', '\x3', '\x106', '\x3', '\x107', '\x3', '\x107', '\x3', '\x107', 
		'\x5', '\x107', '\x134A', '\n', '\x107', '\x3', '\x108', '\x3', '\x108', 
		'\x3', '\x108', '\x3', '\x108', '\x3', '\x108', '\x3', '\x108', '\x3', 
		'\x108', '\x3', '\x108', '\x5', '\x108', '\x1354', '\n', '\x108', '\x3', 
		'\x109', '\x3', '\x109', '\x3', '\x10A', '\x3', '\x10A', '\x3', '\x10A', 
		'\x3', '\x10A', '\x3', '\x10A', '\x3', '\x10A', '\x5', '\x10A', '\x135E', 
		'\n', '\x10A', '\x3', '\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x3', 
		'\x10B', '\x5', '\x10B', '\x1364', '\n', '\x10B', '\x3', '\x10B', '\x3', 
		'\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x5', '\x10B', '\x136A', '\n', 
		'\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x5', '\x10B', 
		'\x136F', '\n', '\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x3', '\x10B', 
		'\x3', '\x10B', '\x5', '\x10B', '\x1375', '\n', '\x10B', '\x3', '\x10B', 
		'\x5', '\x10B', '\x1378', '\n', '\x10B', '\x3', '\x10C', '\x3', '\x10C', 
		'\x5', '\x10C', '\x137C', '\n', '\x10C', '\x3', '\x10C', '\x3', '\x10C', 
		'\x3', '\x10C', '\x5', '\x10C', '\x1381', '\n', '\x10C', '\x3', '\x10C', 
		'\x5', '\x10C', '\x1384', '\n', '\x10C', '\x3', '\x10C', '\x5', '\x10C', 
		'\x1387', '\n', '\x10C', '\x3', '\x10C', '\x5', '\x10C', '\x138A', '\n', 
		'\x10C', '\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10D', 
		'\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10D', '\x5', '\x10D', '\x1393', 
		'\n', '\x10D', '\x3', '\x10D', '\x3', '\x10D', '\x5', '\x10D', '\x1397', 
		'\n', '\x10D', '\x5', '\x10D', '\x1399', '\n', '\x10D', '\x3', '\x10E', 
		'\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', 
		'\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', 
		'\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', 
		'\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x5', '\x10E', '\x13AC', '\n', 
		'\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', 
		'\x3', '\x10E', '\x5', '\x10E', '\x13B3', '\n', '\x10E', '\x5', '\x10E', 
		'\x13B5', '\n', '\x10E', '\x3', '\x10F', '\x3', '\x10F', '\x5', '\x10F', 
		'\x13B9', '\n', '\x10F', '\x3', '\x110', '\x3', '\x110', '\x3', '\x110', 
		'\x3', '\x110', '\x3', '\x110', '\x3', '\x111', '\x3', '\x111', '\x3', 
		'\x111', '\x3', '\x111', '\x3', '\x111', '\x3', '\x111', '\x3', '\x111', 
		'\x3', '\x111', '\x3', '\x111', '\x3', '\x112', '\x3', '\x112', '\x3', 
		'\x112', '\x5', '\x112', '\x13CC', '\n', '\x112', '\x3', '\x112', '\x5', 
		'\x112', '\x13CF', '\n', '\x112', '\x3', '\x112', '\x5', '\x112', '\x13D2', 
		'\n', '\x112', '\x3', '\x112', '\x3', '\x112', '\x3', '\x112', '\x3', 
		'\x112', '\x5', '\x112', '\x13D8', '\n', '\x112', '\x3', '\x112', '\x3', 
		'\x112', '\x3', '\x112', '\x3', '\x112', '\x3', '\x112', '\x5', '\x112', 
		'\x13DF', '\n', '\x112', '\x3', '\x112', '\x3', '\x112', '\x3', '\x112', 
		'\x5', '\x112', '\x13E4', '\n', '\x112', '\x3', '\x113', '\x3', '\x113', 
		'\x3', '\x113', '\x3', '\x113', '\x3', '\x113', '\x3', '\x113', '\x3', 
		'\x113', '\x3', '\x114', '\x3', '\x114', '\x3', '\x114', '\x3', '\x114', 
		'\x3', '\x114', '\x3', '\x114', '\x3', '\x114', '\x5', '\x114', '\x13F4', 
		'\n', '\x114', '\x3', '\x115', '\x3', '\x115', '\x3', '\x115', '\x5', 
		'\x115', '\x13F9', '\n', '\x115', '\x3', '\x115', '\x3', '\x115', '\x3', 
		'\x115', '\x3', '\x115', '\x5', '\x115', '\x13FF', '\n', '\x115', '\x3', 
		'\x116', '\x3', '\x116', '\x3', '\x116', '\x3', '\x116', '\x3', '\x116', 
		'\x5', '\x116', '\x1406', '\n', '\x116', '\x3', '\x117', '\x3', '\x117', 
		'\x3', '\x117', '\x3', '\x117', '\x3', '\x118', '\x3', '\x118', '\x3', 
		'\x118', '\x3', '\x118', '\x3', '\x119', '\x3', '\x119', '\x3', '\x119', 
		'\x3', '\x119', '\x3', '\x11A', '\x3', '\x11A', '\x3', '\x11A', '\x3', 
		'\x11A', '\x3', '\x11A', '\x3', '\x11B', '\x3', '\x11B', '\x3', '\x11B', 
		'\x3', '\x11B', '\x3', '\x11B', '\x3', '\x11B', '\x3', '\x11B', '\x3', 
		'\x11B', '\x5', '\x11B', '\x1421', '\n', '\x11B', '\x5', '\x11B', '\x1423', 
		'\n', '\x11B', '\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x3', 
		'\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x3', '\x11E', 
		'\x3', '\x11E', '\x5', '\x11E', '\x142E', '\n', '\x11E', '\x3', '\x11E', 
		'\x3', '\x11E', '\x3', '\x11E', '\x3', '\x11E', '\x6', '\x11E', '\x1434', 
		'\n', '\x11E', '\r', '\x11E', '\xE', '\x11E', '\x1435', '\x5', '\x11E', 
		'\x1438', '\n', '\x11E', '\x3', '\x11E', '\x3', '\x11E', '\x3', '\x11E', 
		'\x3', '\x11F', '\x3', '\x11F', '\x3', '\x11F', '\x3', '\x120', '\x3', 
		'\x120', '\x3', '\x120', '\x3', '\x120', '\x3', '\x121', '\x3', '\x121', 
		'\x3', '\x121', '\x5', '\x121', '\x1447', '\n', '\x121', '\x3', '\x122', 
		'\x3', '\x122', '\x3', '\x122', '\x3', '\x122', '\x3', '\x123', '\x3', 
		'\x123', '\x3', '\x123', '\x5', '\x123', '\x1450', '\n', '\x123', '\x3', 
		'\x123', '\x3', '\x123', '\x3', '\x123', '\x5', '\x123', '\x1455', '\n', 
		'\x123', '\x3', '\x123', '\x3', '\x123', '\x5', '\x123', '\x1459', '\n', 
		'\x123', '\x3', '\x123', '\x5', '\x123', '\x145C', '\n', '\x123', '\x3', 
		'\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', 
		'\x3', '\x124', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', 
		'\x125', '\x3', '\x125', '\x3', '\x125', '\x5', '\x125', '\x146A', '\n', 
		'\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x126', '\x3', '\x126', 
		'\a', '\x126', '\x1470', '\n', '\x126', '\f', '\x126', '\xE', '\x126', 
		'\x1473', '\v', '\x126', '\x3', '\x126', '\x5', '\x126', '\x1476', '\n', 
		'\x126', '\x3', '\x126', '\x5', '\x126', '\x1479', '\n', '\x126', '\x3', 
		'\x127', '\x3', '\x127', '\x3', '\x127', '\x3', '\x128', '\x6', '\x128', 
		'\x147F', '\n', '\x128', '\r', '\x128', '\xE', '\x128', '\x1480', '\x3', 
		'\x129', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', 
		'\x3', '\x129', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', '\x3', 
		'\x129', '\x5', '\x129', '\x148D', '\n', '\x129', '\x3', '\x12A', '\x3', 
		'\x12A', '\x5', '\x12A', '\x1491', '\n', '\x12A', '\x3', '\x12A', '\x3', 
		'\x12A', '\x3', '\x12A', '\x5', '\x12A', '\x1496', '\n', '\x12A', '\x3', 
		'\x12A', '\x5', '\x12A', '\x1499', '\n', '\x12A', '\x3', '\x12A', '\x3', 
		'\x12A', '\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', 
		'\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', 
		'\x12B', '\x5', '\x12B', '\x14A6', '\n', '\x12B', '\x3', '\x12B', '\x3', 
		'\x12B', '\x5', '\x12B', '\x14AA', '\n', '\x12B', '\x3', '\x12B', '\x3', 
		'\x12B', '\x3', '\x12C', '\x3', '\x12C', '\x3', '\x12C', '\x3', '\x12C', 
		'\x5', '\x12C', '\x14B2', '\n', '\x12C', '\x3', '\x12C', '\x6', '\x12C', 
		'\x14B5', '\n', '\x12C', '\r', '\x12C', '\xE', '\x12C', '\x14B6', '\x3', 
		'\x12C', '\x3', '\x12C', '\x5', '\x12C', '\x14BB', '\n', '\x12C', '\x3', 
		'\x12C', '\x3', '\x12C', '\x5', '\x12C', '\x14BF', '\n', '\x12C', '\x3', 
		'\x12C', '\x3', '\x12C', '\x5', '\x12C', '\x14C3', '\n', '\x12C', '\x3', 
		'\x12C', '\x3', '\x12C', '\x3', '\x12D', '\x3', '\x12D', '\x5', '\x12D', 
		'\x14C9', '\n', '\x12D', '\x3', '\x12D', '\x5', '\x12D', '\x14CC', '\n', 
		'\x12D', '\x3', '\x12D', '\x5', '\x12D', '\x14CF', '\n', '\x12D', '\x3', 
		'\x12E', '\x3', '\x12E', '\x3', '\x12E', '\x3', '\x12E', '\x3', '\x12F', 
		'\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', 
		'\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', 
		'\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', 
		'\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', '\x3', '\x12F', 
		'\x3', '\x12F', '\x3', '\x12F', '\x5', '\x12F', '\x14EA', '\n', '\x12F', 
		'\x3', '\x12F', '\x3', '\x12F', '\x6', '\x12F', '\x14EE', '\n', '\x12F', 
		'\r', '\x12F', '\xE', '\x12F', '\x14EF', '\x3', '\x12F', '\x3', '\x12F', 
		'\x5', '\x12F', '\x14F4', '\n', '\x12F', '\x3', '\x12F', '\x3', '\x12F', 
		'\x3', '\x130', '\x3', '\x130', '\x3', '\x130', '\x3', '\x130', '\x3', 
		'\x130', '\x3', '\x130', '\x3', '\x130', '\x5', '\x130', '\x14FF', '\n', 
		'\x130', '\x3', '\x130', '\x3', '\x130', '\x3', '\x131', '\x3', '\x131', 
		'\x3', '\x131', '\x3', '\x131', '\x5', '\x131', '\x1507', '\n', '\x131', 
		'\x3', '\x132', '\x3', '\x132', '\x3', '\x132', '\x3', '\x132', '\x5', 
		'\x132', '\x150D', '\n', '\x132', '\x3', '\x132', '\x3', '\x132', '\x5', 
		'\x132', '\x1511', '\n', '\x132', '\x3', '\x133', '\x3', '\x133', '\x3', 
		'\x133', '\x3', '\x133', '\x3', '\x134', '\x3', '\x134', '\x3', '\x134', 
		'\x5', '\x134', '\x151A', '\n', '\x134', '\x3', '\x134', '\x3', '\x134', 
		'\x3', '\x134', '\x3', '\x134', '\x3', '\x134', '\x3', '\x134', '\x3', 
		'\x134', '\x5', '\x134', '\x1523', '\n', '\x134', '\x3', '\x135', '\x3', 
		'\x135', '\x3', '\x135', '\x5', '\x135', '\x1528', '\n', '\x135', '\x3', 
		'\x135', '\x6', '\x135', '\x152B', '\n', '\x135', '\r', '\x135', '\xE', 
		'\x135', '\x152C', '\x3', '\x135', '\x3', '\x135', '\x3', '\x136', '\x3', 
		'\x136', '\x5', '\x136', '\x1533', '\n', '\x136', '\x3', '\x136', '\x3', 
		'\x136', '\x5', '\x136', '\x1537', '\n', '\x136', '\x3', '\x136', '\x5', 
		'\x136', '\x153A', '\n', '\x136', '\x3', '\x137', '\x3', '\x137', '\x3', 
		'\x137', '\x3', '\x137', '\x6', '\x137', '\x1540', '\n', '\x137', '\r', 
		'\x137', '\xE', '\x137', '\x1541', '\x3', '\x138', '\x3', '\x138', '\x3', 
		'\x138', '\x3', '\x138', '\x3', '\x138', '\x3', '\x138', '\x3', '\x139', 
		'\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', 
		'\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', 
		'\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', 
		'\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', 
		'\x3', '\x139', '\x5', '\x139', '\x155E', '\n', '\x139', '\x3', '\x13A', 
		'\x6', '\x13A', '\x1561', '\n', '\x13A', '\r', '\x13A', '\xE', '\x13A', 
		'\x1562', '\x3', '\x13B', '\x3', '\x13B', '\x5', '\x13B', '\x1567', '\n', 
		'\x13B', '\x3', '\x13B', '\x3', '\x13B', '\x3', '\x13B', '\x3', '\x13C', 
		'\x3', '\x13C', '\x5', '\x13C', '\x156E', '\n', '\x13C', '\x3', '\x13C', 
		'\x3', '\x13C', '\x5', '\x13C', '\x1572', '\n', '\x13C', '\x3', '\x13D', 
		'\x3', '\x13D', '\x5', '\x13D', '\x1576', '\n', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x5', '\x13D', '\x157A', '\n', '\x13D', '\x3', '\x13E', 
		'\x3', '\x13E', '\x3', '\x13E', '\x3', '\x13F', '\x3', '\x13F', '\x3', 
		'\x13F', '\x3', '\x13F', '\x3', '\x13F', '\a', '\x13F', '\x1584', '\n', 
		'\x13F', '\f', '\x13F', '\xE', '\x13F', '\x1587', '\v', '\x13F', '\x3', 
		'\x13F', '\x5', '\x13F', '\x158A', '\n', '\x13F', '\x3', '\x13F', '\x3', 
		'\x13F', '\x3', '\x13F', '\x3', '\x140', '\x3', '\x140', '\x3', '\x140', 
		'\x3', '\x140', '\x3', '\x140', '\x3', '\x141', '\x3', '\x141', '\x3', 
		'\x141', '\x3', '\x142', '\x5', '\x142', '\x1598', '\n', '\x142', '\x3', 
		'\x142', '\x3', '\x142', '\x3', '\x142', '\x3', '\x142', '\x5', '\x142', 
		'\x159E', '\n', '\x142', '\x3', '\x142', '\x3', '\x142', '\x3', '\x142', 
		'\x3', '\x142', '\x3', '\x142', '\x5', '\x142', '\x15A5', '\n', '\x142', 
		'\x3', '\x143', '\x3', '\x143', '\x3', '\x143', '\x5', '\x143', '\x15AA', 
		'\n', '\x143', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', '\x3', 
		'\x143', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', 
		'\x3', '\x143', '\x5', '\x143', '\x15B5', '\n', '\x143', '\x3', '\x143', 
		'\x5', '\x143', '\x15B8', '\n', '\x143', '\x3', '\x143', '\x3', '\x143', 
		'\x3', '\x143', '\x3', '\x143', '\x5', '\x143', '\x15BE', '\n', '\x143', 
		'\x5', '\x143', '\x15C0', '\n', '\x143', '\x3', '\x144', '\x3', '\x144', 
		'\x3', '\x144', '\x3', '\x144', '\x3', '\x144', '\x3', '\x144', '\x3', 
		'\x144', '\x5', '\x144', '\x15C9', '\n', '\x144', '\x3', '\x145', '\x3', 
		'\x145', '\x3', '\x145', '\x3', '\x145', '\x3', '\x145', '\x3', '\x145', 
		'\x3', '\x145', '\x3', '\x145', '\x5', '\x145', '\x15D3', '\n', '\x145', 
		'\x3', '\x145', '\x3', '\x145', '\x3', '\x145', '\x5', '\x145', '\x15D8', 
		'\n', '\x145', '\x3', '\x146', '\x3', '\x146', '\x3', '\x146', '\x3', 
		'\x146', '\x3', '\x146', '\x3', '\x147', '\x3', '\x147', '\x3', '\x148', 
		'\x3', '\x148', '\x3', '\x149', '\x3', '\x149', '\x3', '\x14A', '\x3', 
		'\x14A', '\x5', '\x14A', '\x15E7', '\n', '\x14A', '\x3', '\x14B', '\x3', 
		'\x14B', '\x5', '\x14B', '\x15EB', '\n', '\x14B', '\x3', '\x14C', '\x5', 
		'\x14C', '\x15EE', '\n', '\x14C', '\x3', '\x14C', '\x3', '\x14C', '\x5', 
		'\x14C', '\x15F2', '\n', '\x14C', '\x3', '\x14C', '\x5', '\x14C', '\x15F5', 
		'\n', '\x14C', '\x3', '\x14D', '\x3', '\x14D', '\x3', '\x14D', '\x3', 
		'\x14D', '\x3', '\x14D', '\x3', '\x14D', '\x3', '\x14E', '\x3', '\x14E', 
		'\x3', '\x14E', '\x3', '\x14E', '\x6', '\x14E', '\x1601', '\n', '\x14E', 
		'\r', '\x14E', '\xE', '\x14E', '\x1602', '\x5', '\x14E', '\x1605', '\n', 
		'\x14E', '\x3', '\x14E', '\x3', '\x14E', '\x5', '\x14E', '\x1609', '\n', 
		'\x14E', '\x3', '\x14F', '\x3', '\x14F', '\x3', '\x14F', '\x3', '\x14F', 
		'\a', '\x14F', '\x160F', '\n', '\x14F', '\f', '\x14F', '\xE', '\x14F', 
		'\x1612', '\v', '\x14F', '\x3', '\x14F', '\x3', '\x14F', '\x3', '\x14F', 
		'\x3', '\x150', '\x5', '\x150', '\x1618', '\n', '\x150', '\x3', '\x150', 
		'\x6', '\x150', '\x161B', '\n', '\x150', '\r', '\x150', '\xE', '\x150', 
		'\x161C', '\x5', '\x150', '\x161F', '\n', '\x150', '\x3', '\x150', '\x3', 
		'\x150', '\x3', '\x151', '\x5', '\x151', '\x1624', '\n', '\x151', '\x3', 
		'\x151', '\x6', '\x151', '\x1627', '\n', '\x151', '\r', '\x151', '\xE', 
		'\x151', '\x1628', '\x3', '\x151', '\x3', '\x151', '\x3', '\x152', '\x3', 
		'\x152', '\x3', '\x152', '\x3', '\x152', '\x5', '\x152', '\x1631', '\n', 
		'\x152', '\x3', '\x153', '\x3', '\x153', '\x3', '\x153', '\x3', '\x153', 
		'\x3', '\x153', '\x5', '\x153', '\x1638', '\n', '\x153', '\x3', '\x153', 
		'\x3', '\x153', '\x5', '\x153', '\x163C', '\n', '\x153', '\x3', '\x153', 
		'\x5', '\x153', '\x163F', '\n', '\x153', '\x3', '\x154', '\x3', '\x154', 
		'\x3', '\x154', '\x3', '\x155', '\x3', '\x155', '\x3', '\x155', '\x3', 
		'\x155', '\x3', '\x155', '\x3', '\x155', '\x5', '\x155', '\x164A', '\n', 
		'\x155', '\x3', '\x156', '\x3', '\x156', '\x3', '\x156', '\x3', '\x156', 
		'\x5', '\x156', '\x1650', '\n', '\x156', '\x3', '\x157', '\x3', '\x157', 
		'\x3', '\x157', '\x3', '\x158', '\x3', '\x158', '\x3', '\x158', '\x3', 
		'\x158', '\x5', '\x158', '\x1659', '\n', '\x158', '\x3', '\x158', '\x5', 
		'\x158', '\x165C', '\n', '\x158', '\x3', '\x159', '\x3', '\x159', '\x3', 
		'\x159', '\x3', '\x159', '\x5', '\x159', '\x1662', '\n', '\x159', '\x3', 
		'\x159', '\x6', '\x159', '\x1665', '\n', '\x159', '\r', '\x159', '\xE', 
		'\x159', '\x1666', '\x3', '\x159', '\x3', '\x159', '\x3', '\x159', '\x3', 
		'\x159', '\x5', '\x159', '\x166D', '\n', '\x159', '\x3', '\x159', '\x6', 
		'\x159', '\x1670', '\n', '\x159', '\r', '\x159', '\xE', '\x159', '\x1671', 
		'\x5', '\x159', '\x1674', '\n', '\x159', '\x3', '\x15A', '\x3', '\x15A', 
		'\x3', '\x15A', '\x3', '\x15A', '\x3', '\x15A', '\x5', '\x15A', '\x167B', 
		'\n', '\x15A', '\x3', '\x15A', '\x5', '\x15A', '\x167E', '\n', '\x15A', 
		'\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x3', 
		'\x15B', '\x5', '\x15B', '\x1685', '\n', '\x15B', '\x3', '\x15C', '\x3', 
		'\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15C', 
		'\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x5', '\x15C', '\x1690', 
		'\n', '\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', '\x15C', '\x3', 
		'\x15C', '\x5', '\x15C', '\x1696', '\n', '\x15C', '\x3', '\x15C', '\x3', 
		'\x15C', '\x5', '\x15C', '\x169A', '\n', '\x15C', '\x3', '\x15D', '\x3', 
		'\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x5', '\x15D', '\x16A0', '\n', 
		'\x15D', '\x3', '\x15D', '\x6', '\x15D', '\x16A3', '\n', '\x15D', '\r', 
		'\x15D', '\xE', '\x15D', '\x16A4', '\x5', '\x15D', '\x16A7', '\n', '\x15D', 
		'\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15E', '\x3', '\x15E', '\x5', 
		'\x15E', '\x16AD', '\n', '\x15E', '\x3', '\x15E', '\x3', '\x15E', '\x3', 
		'\x15E', '\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15E', '\x3', '\x15E', 
		'\x3', '\x15E', '\x3', '\x15E', '\x5', '\x15E', '\x16B8', '\n', '\x15E', 
		'\x5', '\x15E', '\x16BA', '\n', '\x15E', '\x5', '\x15E', '\x16BC', '\n', 
		'\x15E', '\x3', '\x15E', '\x5', '\x15E', '\x16BF', '\n', '\x15E', '\x3', 
		'\x15F', '\x3', '\x15F', '\x5', '\x15F', '\x16C3', '\n', '\x15F', '\x3', 
		'\x15F', '\x5', '\x15F', '\x16C6', '\n', '\x15F', '\x3', '\x160', '\x3', 
		'\x160', '\x5', '\x160', '\x16CA', '\n', '\x160', '\x3', '\x160', '\x3', 
		'\x160', '\x5', '\x160', '\x16CE', '\n', '\x160', '\x3', '\x160', '\x3', 
		'\x160', '\x3', '\x160', '\x5', '\x160', '\x16D3', '\n', '\x160', '\x3', 
		'\x161', '\x3', '\x161', '\x3', '\x161', '\x3', '\x162', '\x3', '\x162', 
		'\x3', '\x162', '\x3', '\x162', '\x3', '\x162', '\x3', '\x162', '\x5', 
		'\x162', '\x16DE', '\n', '\x162', '\x3', '\x162', '\x3', '\x162', '\x5', 
		'\x162', '\x16E2', '\n', '\x162', '\x3', '\x162', '\x3', '\x162', '\x3', 
		'\x162', '\x3', '\x162', '\x3', '\x162', '\x3', '\x162', '\x5', '\x162', 
		'\x16EA', '\n', '\x162', '\x3', '\x163', '\x5', '\x163', '\x16ED', '\n', 
		'\x163', '\x3', '\x163', '\x3', '\x163', '\x3', '\x163', '\a', '\x163', 
		'\x16F2', '\n', '\x163', '\f', '\x163', '\xE', '\x163', '\x16F5', '\v', 
		'\x163', '\x3', '\x164', '\x3', '\x164', '\x5', '\x164', '\x16F9', '\n', 
		'\x164', '\x3', '\x164', '\x6', '\x164', '\x16FC', '\n', '\x164', '\r', 
		'\x164', '\xE', '\x164', '\x16FD', '\x3', '\x165', '\x3', '\x165', '\x5', 
		'\x165', '\x1702', '\n', '\x165', '\x3', '\x165', '\x3', '\x165', '\x3', 
		'\x165', '\x3', '\x165', '\x5', '\x165', '\x1708', '\n', '\x165', '\x3', 
		'\x165', '\x3', '\x165', '\x5', '\x165', '\x170C', '\n', '\x165', '\x3', 
		'\x165', '\x5', '\x165', '\x170F', '\n', '\x165', '\x3', '\x166', '\x3', 
		'\x166', '\x3', '\x166', '\x3', '\x166', '\x3', '\x166', '\x3', '\x166', 
		'\x5', '\x166', '\x1717', '\n', '\x166', '\x3', '\x166', '\x5', '\x166', 
		'\x171A', '\n', '\x166', '\x3', '\x166', '\x3', '\x166', '\x5', '\x166', 
		'\x171E', '\n', '\x166', '\x3', '\x166', '\x3', '\x166', '\x5', '\x166', 
		'\x1722', '\n', '\x166', '\x3', '\x166', '\x3', '\x166', '\x3', '\x166', 
		'\x5', '\x166', '\x1727', '\n', '\x166', '\x3', '\x166', '\x5', '\x166', 
		'\x172A', '\n', '\x166', '\x3', '\x166', '\x3', '\x166', '\x5', '\x166', 
		'\x172E', '\n', '\x166', '\x3', '\x166', '\x3', '\x166', '\x5', '\x166', 
		'\x1732', '\n', '\x166', '\a', '\x166', '\x1734', '\n', '\x166', '\f', 
		'\x166', '\xE', '\x166', '\x1737', '\v', '\x166', '\x3', '\x166', '\x3', 
		'\x166', '\x3', '\x166', '\x3', '\x167', '\x3', '\x167', '\x3', '\x167', 
		'\x3', '\x167', '\x3', '\x167', '\x3', '\x167', '\x3', '\x167', '\x3', 
		'\x167', '\x3', '\x167', '\x3', '\x168', '\x3', '\x168', '\x3', '\x168', 
		'\x3', '\x168', '\x3', '\x168', '\x5', '\x168', '\x174A', '\n', '\x168', 
		'\x3', '\x169', '\x3', '\x169', '\x5', '\x169', '\x174E', '\n', '\x169', 
		'\x3', '\x169', '\x3', '\x169', '\x5', '\x169', '\x1752', '\n', '\x169', 
		'\x3', '\x169', '\x3', '\x169', '\x3', '\x16A', '\x3', '\x16A', '\x5', 
		'\x16A', '\x1758', '\n', '\x16A', '\x3', '\x16A', '\x3', '\x16A', '\x5', 
		'\x16A', '\x175C', '\n', '\x16A', '\x3', '\x16A', '\x6', '\x16A', '\x175F', 
		'\n', '\x16A', '\r', '\x16A', '\xE', '\x16A', '\x1760', '\x5', '\x16A', 
		'\x1763', '\n', '\x16A', '\x3', '\x16A', '\x5', '\x16A', '\x1766', '\n', 
		'\x16A', '\x3', '\x16A', '\x3', '\x16A', '\x5', '\x16A', '\x176A', '\n', 
		'\x16A', '\x3', '\x16A', '\x5', '\x16A', '\x176D', '\n', '\x16A', '\x3', 
		'\x16A', '\x5', '\x16A', '\x1770', '\n', '\x16A', '\x3', '\x16A', '\x5', 
		'\x16A', '\x1773', '\n', '\x16A', '\x3', '\x16B', '\x3', '\x16B', '\x5', 
		'\x16B', '\x1777', '\n', '\x16B', '\x3', '\x16C', '\x3', '\x16C', '\x3', 
		'\x16C', '\x3', '\x16D', '\x3', '\x16D', '\x3', '\x16D', '\x3', '\x16D', 
		'\x3', '\x16D', '\x3', '\x16D', '\x3', '\x16D', '\x5', '\x16D', '\x1783', 
		'\n', '\x16D', '\x3', '\x16D', '\x5', '\x16D', '\x1786', '\n', '\x16D', 
		'\x3', '\x16E', '\x5', '\x16E', '\x1789', '\n', '\x16E', '\x3', '\x16E', 
		'\x6', '\x16E', '\x178C', '\n', '\x16E', '\r', '\x16E', '\xE', '\x16E', 
		'\x178D', '\x3', '\x16F', '\x3', '\x16F', '\a', '\x16F', '\x1792', '\n', 
		'\x16F', '\f', '\x16F', '\xE', '\x16F', '\x1795', '\v', '\x16F', '\x3', 
		'\x16F', '\x3', '\x16F', '\x5', '\x16F', '\x1799', '\n', '\x16F', '\x3', 
		'\x170', '\x3', '\x170', '\a', '\x170', '\x179D', '\n', '\x170', '\f', 
		'\x170', '\xE', '\x170', '\x17A0', '\v', '\x170', '\x3', '\x170', '\x5', 
		'\x170', '\x17A3', '\n', '\x170', '\x3', '\x171', '\x3', '\x171', '\x3', 
		'\x171', '\x5', '\x171', '\x17A8', '\n', '\x171', '\x3', '\x171', '\x3', 
		'\x171', '\x3', '\x171', '\a', '\x171', '\x17AD', '\n', '\x171', '\f', 
		'\x171', '\xE', '\x171', '\x17B0', '\v', '\x171', '\x3', '\x171', '\x3', 
		'\x171', '\x3', '\x171', '\x5', '\x171', '\x17B5', '\n', '\x171', '\x3', 
		'\x171', '\x3', '\x171', '\x3', '\x171', '\x3', '\x171', '\x3', '\x171', 
		'\x5', '\x171', '\x17BC', '\n', '\x171', '\x3', '\x172', '\x5', '\x172', 
		'\x17BF', '\n', '\x172', '\x3', '\x172', '\x5', '\x172', '\x17C2', '\n', 
		'\x172', '\x3', '\x172', '\x3', '\x172', '\x5', '\x172', '\x17C6', '\n', 
		'\x172', '\x3', '\x172', '\x3', '\x172', '\x3', '\x172', '\x5', '\x172', 
		'\x17CB', '\n', '\x172', '\x3', '\x172', '\x3', '\x172', '\a', '\x172', 
		'\x17CF', '\n', '\x172', '\f', '\x172', '\xE', '\x172', '\x17D2', '\v', 
		'\x172', '\x3', '\x173', '\x3', '\x173', '\x3', '\x173', '\x3', '\x174', 
		'\x3', '\x174', '\x3', '\x174', '\x3', '\x175', '\x3', '\x175', '\x5', 
		'\x175', '\x17DC', '\n', '\x175', '\x3', '\x176', '\x3', '\x176', '\x3', 
		'\x176', '\x3', '\x176', '\x3', '\x176', '\x5', '\x176', '\x17E3', '\n', 
		'\x176', '\x3', '\x176', '\x3', '\x176', '\x5', '\x176', '\x17E7', '\n', 
		'\x176', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', 
		'\x3', '\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', '\x5', 
		'\x177', '\x17F1', '\n', '\x177', '\x3', '\x178', '\x3', '\x178', '\x5', 
		'\x178', '\x17F5', '\n', '\x178', '\x3', '\x178', '\x3', '\x178', '\x5', 
		'\x178', '\x17F9', '\n', '\x178', '\x3', '\x178', '\x6', '\x178', '\x17FC', 
		'\n', '\x178', '\r', '\x178', '\xE', '\x178', '\x17FD', '\x3', '\x178', 
		'\x3', '\x178', '\x3', '\x178', '\x3', '\x178', '\x3', '\x179', '\x3', 
		'\x179', '\x3', '\x179', '\x3', '\x179', '\x3', '\x179', '\x5', '\x179', 
		'\x1809', '\n', '\x179', '\x3', '\x17A', '\x3', '\x17A', '\x3', '\x17A', 
		'\x5', '\x17A', '\x180E', '\n', '\x17A', '\x3', '\x17B', '\x3', '\x17B', 
		'\x3', '\x17B', '\x3', '\x17B', '\x5', '\x17B', '\x1814', '\n', '\x17B', 
		'\x3', '\x17B', '\x6', '\x17B', '\x1817', '\n', '\x17B', '\r', '\x17B', 
		'\xE', '\x17B', '\x1818', '\x3', '\x17B', '\x5', '\x17B', '\x181C', '\n', 
		'\x17B', '\x3', '\x17B', '\x6', '\x17B', '\x181F', '\n', '\x17B', '\r', 
		'\x17B', '\xE', '\x17B', '\x1820', '\x5', '\x17B', '\x1823', '\n', '\x17B', 
		'\x3', '\x17B', '\x3', '\x17B', '\x3', '\x17C', '\x3', '\x17C', '\x5', 
		'\x17C', '\x1829', '\n', '\x17C', '\x3', '\x17D', '\x3', '\x17D', '\x3', 
		'\x17D', '\x5', '\x17D', '\x182E', '\n', '\x17D', '\x3', '\x17D', '\x5', 
		'\x17D', '\x1831', '\n', '\x17D', '\x3', '\x17E', '\x3', '\x17E', '\x3', 
		'\x17E', '\x5', '\x17E', '\x1836', '\n', '\x17E', '\x3', '\x17E', '\x3', 
		'\x17E', '\x3', '\x17E', '\x5', '\x17E', '\x183B', '\n', '\x17E', '\x3', 
		'\x17E', '\x3', '\x17E', '\x3', '\x17E', '\x3', '\x17E', '\x3', '\x17F', 
		'\x3', '\x17F', '\x3', '\x17F', '\x5', '\x17F', '\x1844', '\n', '\x17F', 
		'\x3', '\x17F', '\x6', '\x17F', '\x1847', '\n', '\x17F', '\r', '\x17F', 
		'\xE', '\x17F', '\x1848', '\x3', '\x17F', '\x3', '\x17F', '\x3', '\x180', 
		'\x3', '\x180', '\x5', '\x180', '\x184F', '\n', '\x180', '\x3', '\x180', 
		'\x3', '\x180', '\x3', '\x180', '\x3', '\x180', '\x5', '\x180', '\x1855', 
		'\n', '\x180', '\x3', '\x180', '\x6', '\x180', '\x1858', '\n', '\x180', 
		'\r', '\x180', '\xE', '\x180', '\x1859', '\x3', '\x180', '\x3', '\x180', 
		'\x5', '\x180', '\x185E', '\n', '\x180', '\x5', '\x180', '\x1860', '\n', 
		'\x180', '\x3', '\x181', '\x3', '\x181', '\x3', '\x181', '\x5', '\x181', 
		'\x1865', '\n', '\x181', '\x3', '\x181', '\x3', '\x181', '\x5', '\x181', 
		'\x1869', '\n', '\x181', '\x3', '\x181', '\x3', '\x181', '\x3', '\x181', 
		'\x3', '\x181', '\x5', '\x181', '\x186F', '\n', '\x181', '\x3', '\x181', 
		'\x3', '\x181', '\x5', '\x181', '\x1873', '\n', '\x181', '\x3', '\x182', 
		'\x3', '\x182', '\x3', '\x182', '\x3', '\x182', '\x3', '\x183', '\x3', 
		'\x183', '\x3', '\x183', '\x5', '\x183', '\x187C', '\n', '\x183', '\x3', 
		'\x183', '\x6', '\x183', '\x187F', '\n', '\x183', '\r', '\x183', '\xE', 
		'\x183', '\x1880', '\x3', '\x183', '\x5', '\x183', '\x1884', '\n', '\x183', 
		'\x3', '\x183', '\x3', '\x183', '\x3', '\x183', '\x3', '\x183', '\x5', 
		'\x183', '\x188A', '\n', '\x183', '\x3', '\x183', '\x6', '\x183', '\x188D', 
		'\n', '\x183', '\r', '\x183', '\xE', '\x183', '\x188E', '\x5', '\x183', 
		'\x1891', '\n', '\x183', '\x5', '\x183', '\x1893', '\n', '\x183', '\x3', 
		'\x184', '\x3', '\x184', '\x3', '\x184', '\x5', '\x184', '\x1898', '\n', 
		'\x184', '\x3', '\x185', '\x3', '\x185', '\x3', '\x185', '\x5', '\x185', 
		'\x189D', '\n', '\x185', '\x3', '\x185', '\x6', '\x185', '\x18A0', '\n', 
		'\x185', '\r', '\x185', '\xE', '\x185', '\x18A1', '\x3', '\x185', '\x3', 
		'\x185', '\x3', '\x186', '\x3', '\x186', '\x3', '\x186', '\x3', '\x186', 
		'\x5', '\x186', '\x18AA', '\n', '\x186', '\x3', '\x186', '\x6', '\x186', 
		'\x18AD', '\n', '\x186', '\r', '\x186', '\xE', '\x186', '\x18AE', '\x3', 
		'\x186', '\x3', '\x186', '\x3', '\x187', '\x3', '\x187', '\x3', '\x187', 
		'\x5', '\x187', '\x18B6', '\n', '\x187', '\x3', '\x187', '\x3', '\x187', 
		'\x5', '\x187', '\x18BA', '\n', '\x187', '\x3', '\x188', '\x3', '\x188', 
		'\x3', '\x188', '\x3', '\x189', '\x3', '\x189', '\a', '\x189', '\x18C1', 
		'\n', '\x189', '\f', '\x189', '\xE', '\x189', '\x18C4', '\v', '\x189', 
		'\x3', '\x189', '\x5', '\x189', '\x18C7', '\n', '\x189', '\x3', '\x189', 
		'\a', '\x189', '\x18CA', '\n', '\x189', '\f', '\x189', '\xE', '\x189', 
		'\x18CD', '\v', '\x189', '\x3', '\x189', '\x3', '\x189', '\x3', '\x18A', 
		'\x3', '\x18A', '\x3', '\x18A', '\x3', '\x18A', '\x3', '\x18A', '\x3', 
		'\x18A', '\x5', '\x18A', '\x18D7', '\n', '\x18A', '\x5', '\x18A', '\x18D9', 
		'\n', '\x18A', '\x3', '\x18B', '\x3', '\x18B', '\x3', '\x18B', '\x3', 
		'\x18B', '\x3', '\x18C', '\x3', '\x18C', '\x3', '\x18C', '\x3', '\x18C', 
		'\x3', '\x18C', '\x3', '\x18C', '\x3', '\x18C', '\x3', '\x18C', '\a', 
		'\x18C', '\x18E7', '\n', '\x18C', '\f', '\x18C', '\xE', '\x18C', '\x18EA', 
		'\v', '\x18C', '\x3', '\x18D', '\x3', '\x18D', '\x5', '\x18D', '\x18EE', 
		'\n', '\x18D', '\x3', '\x18D', '\x3', '\x18D', '\a', '\x18D', '\x18F2', 
		'\n', '\x18D', '\f', '\x18D', '\xE', '\x18D', '\x18F5', '\v', '\x18D', 
		'\x3', '\x18D', '\x3', '\x18D', '\x3', '\x18E', '\x5', '\x18E', '\x18FA', 
		'\n', '\x18E', '\x3', '\x18E', '\x3', '\x18E', '\x3', '\x18E', '\x3', 
		'\x18E', '\x3', '\x18E', '\x3', '\x18E', '\x3', '\x18F', '\x3', '\x18F', 
		'\x3', '\x18F', '\x3', '\x18F', '\x3', '\x190', '\x3', '\x190', '\x5', 
		'\x190', '\x1908', '\n', '\x190', '\x3', '\x190', '\x6', '\x190', '\x190B', 
		'\n', '\x190', '\r', '\x190', '\xE', '\x190', '\x190C', '\x3', '\x190', 
		'\x3', '\x190', '\x3', '\x191', '\x3', '\x191', '\x5', '\x191', '\x1913', 
		'\n', '\x191', '\x3', '\x191', '\x5', '\x191', '\x1916', '\n', '\x191', 
		'\x3', '\x192', '\x5', '\x192', '\x1919', '\n', '\x192', '\x3', '\x192', 
		'\x3', '\x192', '\x5', '\x192', '\x191D', '\n', '\x192', '\x3', '\x192', 
		'\a', '\x192', '\x1920', '\n', '\x192', '\f', '\x192', '\xE', '\x192', 
		'\x1923', '\v', '\x192', '\x3', '\x192', '\x3', '\x192', '\x3', '\x193', 
		'\x3', '\x193', '\x3', '\x193', '\x3', '\x193', '\x5', '\x193', '\x192B', 
		'\n', '\x193', '\x5', '\x193', '\x192D', '\n', '\x193', '\x3', '\x193', 
		'\x3', '\x193', '\x5', '\x193', '\x1931', '\n', '\x193', '\x3', '\x193', 
		'\x5', '\x193', '\x1934', '\n', '\x193', '\x3', '\x194', '\x3', '\x194', 
		'\x3', '\x194', '\x5', '\x194', '\x1939', '\n', '\x194', '\x5', '\x194', 
		'\x193B', '\n', '\x194', '\x3', '\x194', '\x3', '\x194', '\x5', '\x194', 
		'\x193F', '\n', '\x194', '\x3', '\x194', '\x3', '\x194', '\x3', '\x194', 
		'\x3', '\x195', '\x3', '\x195', '\x3', '\x196', '\x3', '\x196', '\x3', 
		'\x196', '\x3', '\x196', '\x3', '\x196', '\x5', '\x196', '\x194B', '\n', 
		'\x196', '\x3', '\x197', '\x3', '\x197', '\x3', '\x197', '\x3', '\x197', 
		'\x3', '\x197', '\x3', '\x198', '\x3', '\x198', '\x5', '\x198', '\x1954', 
		'\n', '\x198', '\x3', '\x198', '\x3', '\x198', '\x5', '\x198', '\x1958', 
		'\n', '\x198', '\x3', '\x198', '\x6', '\x198', '\x195B', '\n', '\x198', 
		'\r', '\x198', '\xE', '\x198', '\x195C', '\x3', '\x199', '\x3', '\x199', 
		'\x5', '\x199', '\x1961', '\n', '\x199', '\x3', '\x199', '\x3', '\x199', 
		'\x5', '\x199', '\x1965', '\n', '\x199', '\x3', '\x19A', '\x3', '\x19A', 
		'\x3', '\x19A', '\x5', '\x19A', '\x196A', '\n', '\x19A', '\x3', '\x19A', 
		'\x5', '\x19A', '\x196D', '\n', '\x19A', '\x3', '\x19B', '\x3', '\x19B', 
		'\x3', '\x19B', '\x3', '\x19C', '\x3', '\x19C', '\x3', '\x19C', '\x3', 
		'\x19C', '\x3', '\x19C', '\x5', '\x19C', '\x1977', '\n', '\x19C', '\x3', 
		'\x19D', '\x3', '\x19D', '\x3', '\x19D', '\x3', '\x19D', '\x5', '\x19D', 
		'\x197D', '\n', '\x19D', '\x3', '\x19D', '\x5', '\x19D', '\x1980', '\n', 
		'\x19D', '\x3', '\x19D', '\x5', '\x19D', '\x1983', '\n', '\x19D', '\x3', 
		'\x19E', '\x3', '\x19E', '\x5', '\x19E', '\x1987', '\n', '\x19E', '\x3', 
		'\x19E', '\x6', '\x19E', '\x198A', '\n', '\x19E', '\r', '\x19E', '\xE', 
		'\x19E', '\x198B', '\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x3', 
		'\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x3', '\x19E', '\x5', '\x19E', 
		'\x1995', '\n', '\x19E', '\x3', '\x19F', '\x3', '\x19F', '\x3', '\x19F', 
		'\x3', '\x19F', '\x3', '\x19F', '\x3', '\x19F', '\x3', '\x19F', '\x3', 
		'\x19F', '\x5', '\x19F', '\x199F', '\n', '\x19F', '\x3', '\x1A0', '\x3', 
		'\x1A0', '\x5', '\x1A0', '\x19A3', '\n', '\x1A0', '\x3', '\x1A0', '\x3', 
		'\x1A0', '\x5', '\x1A0', '\x19A7', '\n', '\x1A0', '\x3', '\x1A0', '\x5', 
		'\x1A0', '\x19AA', '\n', '\x1A0', '\x3', '\x1A0', '\x5', '\x1A0', '\x19AD', 
		'\n', '\x1A0', '\x3', '\x1A1', '\x3', '\x1A1', '\x3', '\x1A1', '\x5', 
		'\x1A1', '\x19B2', '\n', '\x1A1', '\x3', '\x1A2', '\x3', '\x1A2', '\x3', 
		'\x1A2', '\x5', '\x1A2', '\x19B7', '\n', '\x1A2', '\x3', '\x1A2', '\x5', 
		'\x1A2', '\x19BA', '\n', '\x1A2', '\x3', '\x1A2', '\x5', '\x1A2', '\x19BD', 
		'\n', '\x1A2', '\x3', '\x1A3', '\x3', '\x1A3', '\x6', '\x1A3', '\x19C1', 
		'\n', '\x1A3', '\r', '\x1A3', '\xE', '\x1A3', '\x19C2', '\x3', '\x1A3', 
		'\x5', '\x1A3', '\x19C6', '\n', '\x1A3', '\x3', '\x1A3', '\x3', '\x1A3', 
		'\x3', '\x1A4', '\x3', '\x1A4', '\x5', '\x1A4', '\x19CC', '\n', '\x1A4', 
		'\x3', '\x1A4', '\x5', '\x1A4', '\x19CF', '\n', '\x1A4', '\x3', '\x1A5', 
		'\x5', '\x1A5', '\x19D2', '\n', '\x1A5', '\x3', '\x1A5', '\x6', '\x1A5', 
		'\x19D5', '\n', '\x1A5', '\r', '\x1A5', '\xE', '\x1A5', '\x19D6', '\x3', 
		'\x1A5', '\x5', '\x1A5', '\x19DA', '\n', '\x1A5', '\x3', '\x1A6', '\x3', 
		'\x1A6', '\x3', '\x1A6', '\x3', '\x1A6', '\x6', '\x1A6', '\x19E0', '\n', 
		'\x1A6', '\r', '\x1A6', '\xE', '\x1A6', '\x19E1', '\x3', '\x1A7', '\x3', 
		'\x1A7', '\x6', '\x1A7', '\x19E6', '\n', '\x1A7', '\r', '\x1A7', '\xE', 
		'\x1A7', '\x19E7', '\x3', '\x1A8', '\x3', '\x1A8', '\x3', '\x1A8', '\x5', 
		'\x1A8', '\x19ED', '\n', '\x1A8', '\x3', '\x1A9', '\x3', '\x1A9', '\x3', 
		'\x1A9', '\x5', '\x1A9', '\x19F2', '\n', '\x1A9', '\x3', '\x1A9', '\x3', 
		'\x1A9', '\x3', '\x1AA', '\x3', '\x1AA', '\x3', '\x1AA', '\x3', '\x1AA', 
		'\x5', '\x1AA', '\x19FA', '\n', '\x1AA', '\x3', '\x1AA', '\x3', '\x1AA', 
		'\x3', '\x1AA', '\x3', '\x1AA', '\x3', '\x1AA', '\x3', '\x1AA', '\x3', 
		'\x1AA', '\x3', '\x1AA', '\x5', '\x1AA', '\x1A04', '\n', '\x1AA', '\x3', 
		'\x1AA', '\x3', '\x1AA', '\x5', '\x1AA', '\x1A08', '\n', '\x1AA', '\x5', 
		'\x1AA', '\x1A0A', '\n', '\x1AA', '\x3', '\x1AA', '\x5', '\x1AA', '\x1A0D', 
		'\n', '\x1AA', '\x3', '\x1AB', '\x3', '\x1AB', '\x3', '\x1AB', '\x3', 
		'\x1AB', '\x3', '\x1AB', '\x3', '\x1AB', '\x3', '\x1AB', '\x3', '\x1AB', 
		'\a', '\x1AB', '\x1A17', '\n', '\x1AB', '\f', '\x1AB', '\xE', '\x1AB', 
		'\x1A1A', '\v', '\x1AB', '\x3', '\x1AB', '\x5', '\x1AB', '\x1A1D', '\n', 
		'\x1AB', '\x3', '\x1AB', '\x5', '\x1AB', '\x1A20', '\n', '\x1AB', '\x3', 
		'\x1AC', '\x3', '\x1AC', '\x3', '\x1AC', '\x3', '\x1AC', '\x3', '\x1AD', 
		'\x3', '\x1AD', '\x3', '\x1AD', '\x3', '\x1AE', '\x3', '\x1AE', '\x3', 
		'\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', '\x5', '\x1AE', 
		'\x1A2F', '\n', '\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', 
		'\x5', '\x1AE', '\x1A34', '\n', '\x1AE', '\x3', '\x1AE', '\x3', '\x1AE', 
		'\x5', '\x1AE', '\x1A38', '\n', '\x1AE', '\x3', '\x1AF', '\x3', '\x1AF', 
		'\x3', '\x1AF', '\x3', '\x1AF', '\x3', '\x1AF', '\x5', '\x1AF', '\x1A3F', 
		'\n', '\x1AF', '\x3', '\x1AF', '\x5', '\x1AF', '\x1A42', '\n', '\x1AF', 
		'\x3', '\x1B0', '\x3', '\x1B0', '\x3', '\x1B0', '\x3', '\x1B0', '\x3', 
		'\x1B0', '\a', '\x1B0', '\x1A49', '\n', '\x1B0', '\f', '\x1B0', '\xE', 
		'\x1B0', '\x1A4C', '\v', '\x1B0', '\x3', '\x1B0', '\x3', '\x1B0', '\x3', 
		'\x1B0', '\x3', '\x1B0', '\x5', '\x1B0', '\x1A52', '\n', '\x1B0', '\x3', 
		'\x1B1', '\x3', '\x1B1', '\x3', '\x1B1', '\x5', '\x1B1', '\x1A57', '\n', 
		'\x1B1', '\x3', '\x1B2', '\x3', '\x1B2', '\x5', '\x1B2', '\x1A5B', '\n', 
		'\x1B2', '\x3', '\x1B3', '\x3', '\x1B3', '\x3', '\x1B3', '\x3', '\x1B3', 
		'\x3', '\x1B3', '\x3', '\x1B3', '\x5', '\x1B3', '\x1A63', '\n', '\x1B3', 
		'\x3', '\x1B3', '\x3', '\x1B3', '\x3', '\x1B3', '\x3', '\x1B3', '\x5', 
		'\x1B3', '\x1A69', '\n', '\x1B3', '\x3', '\x1B4', '\x3', '\x1B4', '\x3', 
		'\x1B4', '\x3', '\x1B4', '\x3', '\x1B4', '\x3', '\x1B4', '\x5', '\x1B4', 
		'\x1A71', '\n', '\x1B4', '\x3', '\x1B4', '\x5', '\x1B4', '\x1A74', '\n', 
		'\x1B4', '\x3', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B5', '\x3', '\x1B5', 
		'\x3', '\x1B6', '\x3', '\x1B6', '\x3', '\x1B6', '\x5', '\x1B6', '\x1A7D', 
		'\n', '\x1B6', '\x3', '\x1B6', '\x5', '\x1B6', '\x1A80', '\n', '\x1B6', 
		'\x3', '\x1B6', '\x5', '\x1B6', '\x1A83', '\n', '\x1B6', '\x3', '\x1B7', 
		'\x3', '\x1B7', '\x3', '\x1B7', '\x3', '\x1B8', '\x3', '\x1B8', '\x3', 
		'\x1B8', '\x3', '\x1B8', '\x5', '\x1B8', '\x1A8C', '\n', '\x1B8', '\x3', 
		'\x1B9', '\x3', '\x1B9', '\x3', '\x1B9', '\x3', '\x1B9', '\x5', '\x1B9', 
		'\x1A92', '\n', '\x1B9', '\x3', '\x1B9', '\x3', '\x1B9', '\x3', '\x1B9', 
		'\x3', '\x1B9', '\x5', '\x1B9', '\x1A98', '\n', '\x1B9', '\x5', '\x1B9', 
		'\x1A9A', '\n', '\x1B9', '\x3', '\x1BA', '\x3', '\x1BA', '\x3', '\x1BA', 
		'\x3', '\x1BA', '\x3', '\x1BA', '\x3', '\x1BA', '\x3', '\x1BA', '\x3', 
		'\x1BA', '\x3', '\x1BA', '\x3', '\x1BA', '\x3', '\x1BA', '\x5', '\x1BA', 
		'\x1AA7', '\n', '\x1BA', '\x5', '\x1BA', '\x1AA9', '\n', '\x1BA', '\x3', 
		'\x1BB', '\x3', '\x1BB', '\x3', '\x1BB', '\x3', '\x1BB', '\x3', '\x1BB', 
		'\x3', '\x1BB', '\x3', '\x1BB', '\x5', '\x1BB', '\x1AB2', '\n', '\x1BB', 
		'\x5', '\x1BB', '\x1AB4', '\n', '\x1BB', '\x3', '\x1BC', '\x3', '\x1BC', 
		'\x5', '\x1BC', '\x1AB8', '\n', '\x1BC', '\x3', '\x1BC', '\x3', '\x1BC', 
		'\x3', '\x1BC', '\x3', '\x1BC', '\x5', '\x1BC', '\x1ABE', '\n', '\x1BC', 
		'\x3', '\x1BC', '\x3', '\x1BC', '\x5', '\x1BC', '\x1AC2', '\n', '\x1BC', 
		'\x3', '\x1BD', '\x3', '\x1BD', '\x3', '\x1BD', '\x3', '\x1BD', '\x3', 
		'\x1BD', '\x3', '\x1BE', '\x3', '\x1BE', '\x3', '\x1BF', '\x3', '\x1BF', 
		'\x3', '\x1BF', '\a', '\x1BF', '\x1ACE', '\n', '\x1BF', '\f', '\x1BF', 
		'\xE', '\x1BF', '\x1AD1', '\v', '\x1BF', '\x3', '\x1C0', '\x3', '\x1C0', 
		'\x3', '\x1C0', '\x5', '\x1C0', '\x1AD6', '\n', '\x1C0', '\x3', '\x1C1', 
		'\x3', '\x1C1', '\x3', '\x1C1', '\x3', '\x1C1', '\x3', '\x1C1', '\x3', 
		'\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x5', '\x1C2', 
		'\x1AE1', '\n', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', 
		'\x3', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x3', 
		'\x1C2', '\x3', '\x1C2', '\x5', '\x1C2', '\x1AEC', '\n', '\x1C2', '\x3', 
		'\x1C2', '\x3', '\x1C2', '\x5', '\x1C2', '\x1AF0', '\n', '\x1C2', '\x3', 
		'\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\a', '\x1C2', '\x1AF5', '\n', 
		'\x1C2', '\f', '\x1C2', '\xE', '\x1C2', '\x1AF8', '\v', '\x1C2', '\x3', 
		'\x1C2', '\x3', '\x1C2', '\x5', '\x1C2', '\x1AFC', '\n', '\x1C2', '\a', 
		'\x1C2', '\x1AFE', '\n', '\x1C2', '\f', '\x1C2', '\xE', '\x1C2', '\x1B01', 
		'\v', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x5', '\x1C2', '\x1B05', 
		'\n', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\x3', 
		'\x1C2', '\x3', '\x1C2', '\x3', '\x1C2', '\a', '\x1C2', '\x1B0D', '\n', 
		'\x1C2', '\f', '\x1C2', '\xE', '\x1C2', '\x1B10', '\v', '\x1C2', '\x3', 
		'\x1C3', '\x3', '\x1C3', '\x3', '\x1C3', '\x5', '\x1C3', '\x1B15', '\n', 
		'\x1C3', '\x3', '\x1C3', '\x5', '\x1C3', '\x1B18', '\n', '\x1C3', '\x3', 
		'\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', '\x3', '\x1C4', 
		'\x3', '\x1C4', '\x3', '\x1C4', '\a', '\x1C4', '\x1B21', '\n', '\x1C4', 
		'\f', '\x1C4', '\xE', '\x1C4', '\x1B24', '\v', '\x1C4', '\x3', '\x1C5', 
		'\x3', '\x1C5', '\x5', '\x1C5', '\x1B28', '\n', '\x1C5', '\x3', '\x1C5', 
		'\x3', '\x1C5', '\x5', '\x1C5', '\x1B2C', '\n', '\x1C5', '\x3', '\x1C5', 
		'\x3', '\x1C5', '\x5', '\x1C5', '\x1B30', '\n', '\x1C5', '\x3', '\x1C5', 
		'\x3', '\x1C5', '\x3', '\x1C5', '\x3', '\x1C5', '\x3', '\x1C5', '\x3', 
		'\x1C5', '\x3', '\x1C5', '\x3', '\x1C5', '\x5', '\x1C5', '\x1B3A', '\n', 
		'\x1C5', '\x3', '\x1C6', '\x3', '\x1C6', '\x5', '\x1C6', '\x1B3E', '\n', 
		'\x1C6', '\x3', '\x1C6', '\x3', '\x1C6', '\x3', '\x1C6', '\x3', '\x1C6', 
		'\x3', '\x1C6', '\x3', '\x1C6', '\x3', '\x1C6', '\x3', '\x1C6', '\x5', 
		'\x1C6', '\x1B48', '\n', '\x1C6', '\x5', '\x1C6', '\x1B4A', '\n', '\x1C6', 
		'\x5', '\x1C6', '\x1B4C', '\n', '\x1C6', '\x3', '\x1C7', '\x3', '\x1C7', 
		'\x3', '\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', '\x3', 
		'\x1C7', '\x5', '\x1C7', '\x1B55', '\n', '\x1C7', '\x3', '\x1C7', '\x5', 
		'\x1C7', '\x1B58', '\n', '\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', '\x3', 
		'\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', 
		'\x3', '\x1C7', '\x3', '\x1C7', '\x3', '\x1C7', '\a', '\x1C7', '\x1B64', 
		'\n', '\x1C7', '\f', '\x1C7', '\xE', '\x1C7', '\x1B67', '\v', '\x1C7', 
		'\x3', '\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x3', 
		'\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x5', '\x1C8', 
		'\x1B71', '\n', '\x1C8', '\x3', '\x1C8', '\x3', '\x1C8', '\x5', '\x1C8', 
		'\x1B75', '\n', '\x1C8', '\x5', '\x1C8', '\x1B77', '\n', '\x1C8', '\x3', 
		'\x1C9', '\x3', '\x1C9', '\x3', '\x1C9', '\x3', '\x1C9', '\x3', '\x1C9', 
		'\x5', '\x1C9', '\x1B7E', '\n', '\x1C9', '\x3', '\x1CA', '\x3', '\x1CA', 
		'\x3', '\x1CA', '\x3', '\x1CA', '\x3', '\x1CA', '\x3', '\x1CA', '\x3', 
		'\x1CA', '\x3', '\x1CA', '\a', '\x1CA', '\x1B88', '\n', '\x1CA', '\f', 
		'\x1CA', '\xE', '\x1CA', '\x1B8B', '\v', '\x1CA', '\x3', '\x1CA', '\x3', 
		'\x1CA', '\x3', '\x1CA', '\x3', '\x1CA', '\x3', '\x1CA', '\x5', '\x1CA', 
		'\x1B92', '\n', '\x1CA', '\x3', '\x1CB', '\x3', '\x1CB', '\x3', '\x1CB', 
		'\x3', '\x1CB', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', 
		'\x1CC', '\x3', '\x1CC', '\x5', '\x1CC', '\x1B9D', '\n', '\x1CC', '\x3', 
		'\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', 
		'\x3', '\x1CC', '\x5', '\x1CC', '\x1BA5', '\n', '\x1CC', '\x3', '\x1CC', 
		'\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x5', 
		'\x1CC', '\x1BAC', '\n', '\x1CC', '\x3', '\x1CC', '\x3', '\x1CC', '\x5', 
		'\x1CC', '\x1BB0', '\n', '\x1CC', '\x3', '\x1CD', '\x3', '\x1CD', '\x5', 
		'\x1CD', '\x1BB4', '\n', '\x1CD', '\x3', '\x1CD', '\x3', '\x1CD', '\x3', 
		'\x1CD', '\x5', '\x1CD', '\x1BB9', '\n', '\x1CD', '\a', '\x1CD', '\x1BBB', 
		'\n', '\x1CD', '\f', '\x1CD', '\xE', '\x1CD', '\x1BBE', '\v', '\x1CD', 
		'\x3', '\x1CD', '\x3', '\x1CD', '\x3', '\x1CD', '\a', '\x1CD', '\x1BC3', 
		'\n', '\x1CD', '\f', '\x1CD', '\xE', '\x1CD', '\x1BC6', '\v', '\x1CD', 
		'\x3', '\x1CD', '\x5', '\x1CD', '\x1BC9', '\n', '\x1CD', '\x3', '\x1CE', 
		'\x3', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', '\x5', 
		'\x1CE', '\x1BD0', '\n', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', 
		'\x1CE', '\x5', '\x1CE', '\x1BD5', '\n', '\x1CE', '\x3', '\x1CE', '\x3', 
		'\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', '\x3', '\x1CE', 
		'\x3', '\x1CE', '\x5', '\x1CE', '\x1BDE', '\n', '\x1CE', '\x3', '\x1CF', 
		'\x3', '\x1CF', '\x3', '\x1CF', '\x3', '\x1CF', '\x3', '\x1CF', '\x3', 
		'\x1CF', '\x3', '\x1CF', '\x5', '\x1CF', '\x1BE7', '\n', '\x1CF', '\x3', 
		'\x1CF', '\x5', '\x1CF', '\x1BEA', '\n', '\x1CF', '\x3', '\x1CF', '\x3', 
		'\x1CF', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', 
		'\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', 
		'\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', 
		'\x3', '\x1D0', '\x3', '\x1D0', '\x3', '\x1D0', '\x5', '\x1D0', '\x1BFE', 
		'\n', '\x1D0', '\x3', '\x1D1', '\x3', '\x1D1', '\x5', '\x1D1', '\x1C02', 
		'\n', '\x1D1', '\x3', '\x1D2', '\x5', '\x1D2', '\x1C05', '\n', '\x1D2', 
		'\x3', '\x1D2', '\x3', '\x1D2', '\x3', '\x1D2', '\x6', '\x1D2', '\x1C0A', 
		'\n', '\x1D2', '\r', '\x1D2', '\xE', '\x1D2', '\x1C0B', '\x3', '\x1D2', 
		'\x5', '\x1D2', '\x1C0F', '\n', '\x1D2', '\x3', '\x1D2', '\x3', '\x1D2', 
		'\x5', '\x1D2', '\x1C13', '\n', '\x1D2', '\x3', '\x1D2', '\x5', '\x1D2', 
		'\x1C16', '\n', '\x1D2', '\x3', '\x1D3', '\x3', '\x1D3', '\x3', '\x1D3', 
		'\x3', '\x1D3', '\x3', '\x1D3', '\x5', '\x1D3', '\x1C1D', '\n', '\x1D3', 
		'\x3', '\x1D4', '\x5', '\x1D4', '\x1C20', '\n', '\x1D4', '\x3', '\x1D4', 
		'\x3', '\x1D4', '\x6', '\x1D4', '\x1C24', '\n', '\x1D4', '\r', '\x1D4', 
		'\xE', '\x1D4', '\x1C25', '\x3', '\x1D4', '\x5', '\x1D4', '\x1C29', '\n', 
		'\x1D4', '\x3', '\x1D4', '\x3', '\x1D4', '\x5', '\x1D4', '\x1C2D', '\n', 
		'\x1D4', '\x3', '\x1D4', '\x5', '\x1D4', '\x1C30', '\n', '\x1D4', '\x3', 
		'\x1D5', '\x3', '\x1D5', '\x3', '\x1D5', '\x3', '\x1D5', '\x3', '\x1D5', 
		'\x5', '\x1D5', '\x1C37', '\n', '\x1D5', '\x3', '\x1D6', '\x3', '\x1D6', 
		'\x3', '\x1D6', '\x5', '\x1D6', '\x1C3C', '\n', '\x1D6', '\x3', '\x1D7', 
		'\x3', '\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', '\x3', 
		'\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', 
		'\a', '\x1D7', '\x1C48', '\n', '\x1D7', '\f', '\x1D7', '\xE', '\x1D7', 
		'\x1C4B', '\v', '\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', '\x3', '\x1D7', 
		'\x3', '\x1D7', '\x5', '\x1D7', '\x1C51', '\n', '\x1D7', '\x3', '\x1D8', 
		'\x3', '\x1D8', '\x3', '\x1D8', '\x3', '\x1D8', '\x3', '\x1D8', '\x3', 
		'\x1D8', '\x3', '\x1D8', '\x3', '\x1D8', '\x3', '\x1D8', '\x5', '\x1D8', 
		'\x1C5C', '\n', '\x1D8', '\x3', '\x1D9', '\x3', '\x1D9', '\x3', '\x1D9', 
		'\x3', '\x1D9', '\x3', '\x1D9', '\x3', '\x1D9', '\x3', '\x1D9', '\x3', 
		'\x1D9', '\a', '\x1D9', '\x1C66', '\n', '\x1D9', '\f', '\x1D9', '\xE', 
		'\x1D9', '\x1C69', '\v', '\x1D9', '\x3', '\x1D9', '\x5', '\x1D9', '\x1C6C', 
		'\n', '\x1D9', '\x5', '\x1D9', '\x1C6E', '\n', '\x1D9', '\x3', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', 
		'\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1C77', '\n', '\x1DA', '\x3', 
		'\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1C80', '\n', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1C84', '\n', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1C88', '\n', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', 
		'\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', 
		'\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', 
		'\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', 
		'\x1C9B', '\n', '\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1C9E', '\n', 
		'\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1CA1', '\n', '\x1DA', '\x3', 
		'\x1DA', '\x3', '\x1DA', '\x3', '\x1DA', '\x5', '\x1DA', '\x1CA6', '\n', 
		'\x1DA', '\x3', '\x1DB', '\x3', '\x1DB', '\x3', '\x1DB', '\x5', '\x1DB', 
		'\x1CAB', '\n', '\x1DB', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', 
		'\x5', '\x1DC', '\x1CB0', '\n', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', 
		'\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', 
		'\x1DC', '\x5', '\x1DC', '\x1CB9', '\n', '\x1DC', '\x3', '\x1DC', '\x5', 
		'\x1DC', '\x1CBC', '\n', '\x1DC', '\x5', '\x1DC', '\x1CBE', '\n', '\x1DC', 
		'\x3', '\x1DC', '\x3', '\x1DC', '\x5', '\x1DC', '\x1CC2', '\n', '\x1DC', 
		'\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', 
		'\x1DC', '\x5', '\x1DC', '\x1CC9', '\n', '\x1DC', '\x3', '\x1DC', '\x3', 
		'\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x5', '\x1DC', 
		'\x1CD0', '\n', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', 
		'\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x5', '\x1DC', '\x1CD8', 
		'\n', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', 
		'\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', 
		'\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', '\x1DC', '\x3', 
		'\x1DC', '\x5', '\x1DC', '\x1CE7', '\n', '\x1DC', '\x3', '\x1DD', '\x3', 
		'\x1DD', '\x3', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DD', '\x5', '\x1DD', 
		'\x1CEE', '\n', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DD', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1CF5', '\n', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1CFA', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', 
		'\x1DE', '\x1D08', '\n', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1D0B', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1D0F', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1D19', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\a', '\x1DE', '\x1D24', '\n', 
		'\x1DE', '\f', '\x1DE', '\xE', '\x1DE', '\x1D27', '\v', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1D2E', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1D32', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1D39', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x6', '\x1DE', '\x1D3C', '\n', '\x1DE', 
		'\r', '\x1DE', '\xE', '\x1DE', '\x1D3D', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1D47', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1D55', '\n', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x5', '\x1DE', '\x1D5D', '\n', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1D60', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1D69', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\a', '\x1DE', '\x1D6D', '\n', '\x1DE', '\f', '\x1DE', '\xE', 
		'\x1DE', '\x1D70', '\v', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1D82', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1D8B', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1D90', '\n', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1D95', '\n', 
		'\x1DE', '\x3', '\x1DE', '\x6', '\x1DE', '\x1D98', '\n', '\x1DE', '\r', 
		'\x1DE', '\xE', '\x1DE', '\x1D99', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1D9F', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DA4', '\n', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1DA7', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DAC', '\n', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DB1', '\n', 
		'\x1DE', '\a', '\x1DE', '\x1DB3', '\n', '\x1DE', '\f', '\x1DE', '\xE', 
		'\x1DE', '\x1DB6', '\v', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1DBB', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DC1', '\n', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DCA', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', 
		'\x1DE', '\x1DCF', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', 
		'\x1DD7', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', 
		'\x1DDB', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1DE0', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DE6', '\n', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1DED', '\n', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1DF2', '\n', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1DF9', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x5', '\x1DE', '\x1DFD', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x5', '\x1DE', '\x1E02', '\n', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x5', '\x1DE', '\x1E0A', '\n', '\x1DE', '\x3', '\x1DE', '\x5', 
		'\x1DE', '\x1E0D', '\n', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E10', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E13', '\n', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E17', '\n', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E1C', 
		'\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', 
		'\x1DE', '\x1E21', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', 
		'\x1DE', '\x1E25', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E2C', '\n', 
		'\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', 
		'\x1E31', '\n', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', '\x3', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E38', '\n', '\x1DE', 
		'\x3', '\x1DE', '\x3', '\x1DE', '\x5', '\x1DE', '\x1E3C', '\n', '\x1DE', 
		'\x3', '\x1DF', '\x3', '\x1DF', '\x3', '\x1E0', '\x3', '\x1E0', '\x3', 
		'\x1E1', '\x3', '\x1E1', '\x3', '\x1E2', '\x3', '\x1E2', '\x3', '\x1E2', 
		'\x5', '\x1E2', '\x1E47', '\n', '\x1E2', '\x3', '\x1E2', '\x3', '\x1E2', 
		'\x5', '\x1E2', '\x1E4B', '\n', '\x1E2', '\x5', '\x1E2', '\x1E4D', '\n', 
		'\x1E2', '\x3', '\x1E2', '\x3', '\x1E2', '\x3', '\x1E3', '\x3', '\x1E3', 
		'\x3', '\x1E3', '\x3', '\x1E3', '\x3', '\x1E3', '\x3', '\x1E3', '\x3', 
		'\x1E3', '\x5', '\x1E3', '\x1E58', '\n', '\x1E3', '\x3', '\x1E4', '\x3', 
		'\x1E4', '\x3', '\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', 
		'\x3', '\x1E5', '\x3', '\x1E5', '\x3', '\x1E5', '\x5', '\x1E5', '\x1E63', 
		'\n', '\x1E5', '\x3', '\x1E6', '\x3', '\x1E6', '\x3', '\x1E6', '\x5', 
		'\x1E6', '\x1E68', '\n', '\x1E6', '\x3', '\x1E6', '\x6', '\x1E6', '\x1E6B', 
		'\n', '\x1E6', '\r', '\x1E6', '\xE', '\x1E6', '\x1E6C', '\x5', '\x1E6', 
		'\x1E6F', '\n', '\x1E6', '\x3', '\x1E7', '\x3', '\x1E7', '\x5', '\x1E7', 
		'\x1E73', '\n', '\x1E7', '\x3', '\x1E7', '\x5', '\x1E7', '\x1E76', '\n', 
		'\x1E7', '\x3', '\x1E7', '\x3', '\x1E7', '\x5', '\x1E7', '\x1E7A', '\n', 
		'\x1E7', '\x3', '\x1E8', '\x3', '\x1E8', '\x3', '\x1E8', '\x3', '\x1E8', 
		'\x3', '\x1E9', '\x3', '\x1E9', '\x3', '\x1E9', '\x3', '\x1E9', '\x3', 
		'\x1E9', '\x3', '\x1E9', '\x3', '\x1E9', '\x5', '\x1E9', '\x1E87', '\n', 
		'\x1E9', '\x3', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x5', '\x1EA', 
		'\x1E8C', '\n', '\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x5', '\x1EA', 
		'\x1E90', '\n', '\x1EA', '\x3', '\x1EA', '\x6', '\x1EA', '\x1E93', '\n', 
		'\x1EA', '\r', '\x1EA', '\xE', '\x1EA', '\x1E94', '\x3', '\x1EA', '\x3', 
		'\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x5', '\x1EA', '\x1E9B', '\n', 
		'\x1EA', '\x3', '\x1EA', '\x3', '\x1EA', '\x5', '\x1EA', '\x1E9F', '\n', 
		'\x1EA', '\x3', '\x1EB', '\x3', '\x1EB', '\x3', '\x1EB', '\x5', '\x1EB', 
		'\x1EA4', '\n', '\x1EB', '\x3', '\x1EB', '\x3', '\x1EB', '\x5', '\x1EB', 
		'\x1EA8', '\n', '\x1EB', '\x3', '\x1EB', '\x3', '\x1EB', '\x3', '\x1EB', 
		'\x5', '\x1EB', '\x1EAD', '\n', '\x1EB', '\x3', '\x1EC', '\x3', '\x1EC', 
		'\x3', '\x1EC', '\x5', '\x1EC', '\x1EB2', '\n', '\x1EC', '\x3', '\x1EC', 
		'\x5', '\x1EC', '\x1EB5', '\n', '\x1EC', '\x3', '\x1EC', '\x5', '\x1EC', 
		'\x1EB8', '\n', '\x1EC', '\x3', '\x1EC', '\x6', '\x1EC', '\x1EBB', '\n', 
		'\x1EC', '\r', '\x1EC', '\xE', '\x1EC', '\x1EBC', '\x3', '\x1EC', '\x3', 
		'\x1EC', '\x3', '\x1ED', '\x3', '\x1ED', '\x3', '\x1ED', '\x3', '\x1ED', 
		'\x3', '\x1ED', '\x5', '\x1ED', '\x1EC6', '\n', '\x1ED', '\x3', '\x1ED', 
		'\x3', '\x1ED', '\x3', '\x1ED', '\x3', '\x1ED', '\a', '\x1ED', '\x1ECC', 
		'\n', '\x1ED', '\f', '\x1ED', '\xE', '\x1ED', '\x1ECF', '\v', '\x1ED', 
		'\x3', '\x1ED', '\x5', '\x1ED', '\x1ED2', '\n', '\x1ED', '\x3', '\x1ED', 
		'\x3', '\x1ED', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x3', 
		'\x1EE', '\x3', '\x1EE', '\x3', '\x1EE', '\x5', '\x1EE', '\x1EDC', '\n', 
		'\x1EE', '\x3', '\x1EE', '\x5', '\x1EE', '\x1EDF', '\n', '\x1EE', '\x5', 
		'\x1EE', '\x1EE1', '\n', '\x1EE', '\x3', '\x1EF', '\x3', '\x1EF', '\x3', 
		'\x1EF', '\x3', '\x1F0', '\x3', '\x1F0', '\x3', '\x1F0', '\x3', '\x1F0', 
		'\x3', '\x1F0', '\x5', '\x1F0', '\x1EEB', '\n', '\x1F0', '\x5', '\x1F0', 
		'\x1EED', '\n', '\x1F0', '\x3', '\x1F1', '\x3', '\x1F1', '\x3', '\x1F1', 
		'\x3', '\x1F1', '\x5', '\x1F1', '\x1EF3', '\n', '\x1F1', '\x3', '\x1F2', 
		'\x3', '\x1F2', '\x3', '\x1F2', '\x3', '\x1F2', '\x5', '\x1F2', '\x1EF9', 
		'\n', '\x1F2', '\x5', '\x1F2', '\x1EFB', '\n', '\x1F2', '\x3', '\x1F3', 
		'\x3', '\x1F3', '\x3', '\x1F3', '\x3', '\x1F4', '\x3', '\x1F4', '\x3', 
		'\x1F4', '\x3', '\x1F5', '\x3', '\x1F5', '\x3', '\x1F5', '\x3', '\x1F5', 
		'\x3', '\x1F5', '\x3', '\x1F5', '\x5', '\x1F5', '\x1F09', '\n', '\x1F5', 
		'\x5', '\x1F5', '\x1F0B', '\n', '\x1F5', '\x3', '\x1F6', '\x3', '\x1F6', 
		'\x3', '\x1F6', '\x3', '\x1F6', '\x3', '\x1F6', '\x3', '\x1F6', '\x3', 
		'\x1F6', '\x3', '\x1F6', '\x3', '\x1F6', '\x5', '\x1F6', '\x1F16', '\n', 
		'\x1F6', '\x3', '\x1F7', '\x3', '\x1F7', '\x3', '\x1F7', '\x3', '\x1F8', 
		'\x3', '\x1F8', '\x3', '\x1F8', '\x3', '\x1F8', '\x3', '\x1F8', '\x3', 
		'\x1F8', '\x3', '\x1F8', '\x5', '\x1F8', '\x1F22', '\n', '\x1F8', '\x3', 
		'\x1F9', '\x3', '\x1F9', '\x3', '\x1F9', '\x3', '\x1F9', '\x3', '\x1FA', 
		'\x5', '\x1FA', '\x1F29', '\n', '\x1FA', '\x3', '\x1FA', '\x3', '\x1FA', 
		'\x6', '\x1FA', '\x1F2D', '\n', '\x1FA', '\r', '\x1FA', '\xE', '\x1FA', 
		'\x1F2E', '\x3', '\x1FB', '\x3', '\x1FB', '\x3', '\x1FB', '\x3', '\x1FB', 
		'\x3', '\x1FB', '\x5', '\x1FB', '\x1F36', '\n', '\x1FB', '\x3', '\x1FC', 
		'\x3', '\x1FC', '\x3', '\x1FC', '\x3', '\x1FC', '\x3', '\x1FC', '\x3', 
		'\x1FC', '\x3', '\x1FC', '\x5', '\x1FC', '\x1F3F', '\n', '\x1FC', '\x3', 
		'\x1FD', '\x3', '\x1FD', '\x5', '\x1FD', '\x1F43', '\n', '\x1FD', '\x3', 
		'\x1FD', '\x3', '\x1FD', '\x5', '\x1FD', '\x1F47', '\n', '\x1FD', '\x3', 
		'\x1FD', '\x3', '\x1FD', '\x3', '\x1FE', '\x5', '\x1FE', '\x1F4C', '\n', 
		'\x1FE', '\x3', '\x1FE', '\x3', '\x1FE', '\x5', '\x1FE', '\x1F50', '\n', 
		'\x1FE', '\x3', '\x1FE', '\x5', '\x1FE', '\x1F53', '\n', '\x1FE', '\x3', 
		'\x1FF', '\x3', '\x1FF', '\x5', '\x1FF', '\x1F57', '\n', '\x1FF', '\x3', 
		'\x200', '\x3', '\x200', '\x3', '\x200', '\x3', '\x200', '\x3', '\x200', 
		'\x5', '\x200', '\x1F5E', '\n', '\x200', '\x3', '\x201', '\x3', '\x201', 
		'\x5', '\x201', '\x1F62', '\n', '\x201', '\x3', '\x201', '\x3', '\x201', 
		'\x5', '\x201', '\x1F66', '\n', '\x201', '\x3', '\x201', '\x6', '\x201', 
		'\x1F69', '\n', '\x201', '\r', '\x201', '\xE', '\x201', '\x1F6A', '\x3', 
		'\x202', '\x3', '\x202', '\x5', '\x202', '\x1F6F', '\n', '\x202', '\x3', 
		'\x203', '\x3', '\x203', '\x3', '\x203', '\x5', '\x203', '\x1F74', '\n', 
		'\x203', '\x3', '\x204', '\x3', '\x204', '\x3', '\x205', '\x3', '\x205', 
		'\x5', '\x205', '\x1F7A', '\n', '\x205', '\x3', '\x206', '\x3', '\x206', 
		'\x5', '\x206', '\x1F7E', '\n', '\x206', '\x3', '\x207', '\x3', '\x207', 
		'\x3', '\x207', '\x5', '\x207', '\x1F83', '\n', '\x207', '\x3', '\x208', 
		'\x3', '\x208', '\x5', '\x208', '\x1F87', '\n', '\x208', '\x3', '\x208', 
		'\x3', '\x208', '\x3', '\x208', '\x5', '\x208', '\x1F8C', '\n', '\x208', 
		'\x3', '\x208', '\x5', '\x208', '\x1F8F', '\n', '\x208', '\x3', '\x209', 
		'\x3', '\x209', '\x5', '\x209', '\x1F93', '\n', '\x209', '\x3', '\x20A', 
		'\x3', '\x20A', '\x5', '\x20A', '\x1F97', '\n', '\x20A', '\x3', '\x20B', 
		'\x3', '\x20B', '\x3', '\x20C', '\x3', '\x20C', '\x3', '\x20C', '\x3', 
		'\x20C', '\x5', '\x20C', '\x1F9F', '\n', '\x20C', '\x3', '\x20D', '\x3', 
		'\x20D', '\x3', '\x20E', '\x3', '\x20E', '\x3', '\x20F', '\x3', '\x20F', 
		'\x3', '\x210', '\x3', '\x210', '\x3', '\x211', '\x3', '\x211', '\x3', 
		'\x212', '\x3', '\x212', '\x3', '\x213', '\x3', '\x213', '\x3', '\x214', 
		'\x3', '\x214', '\x3', '\x215', '\x3', '\x215', '\x3', '\x216', '\x3', 
		'\x216', '\x3', '\x217', '\x3', '\x217', '\x3', '\x218', '\x3', '\x218', 
		'\x3', '\x219', '\x3', '\x219', '\x3', '\x21A', '\x3', '\x21A', '\x3', 
		'\x21B', '\x3', '\x21B', '\x3', '\x21B', '\x5', '\x21B', '\x1FC0', '\n', 
		'\x21B', '\x3', '\x21C', '\x3', '\x21C', '\x3', '\x21D', '\x3', '\x21D', 
		'\x3', '\x21E', '\x3', '\x21E', '\x3', '\x21F', '\x3', '\x21F', '\x3', 
		'\x220', '\x3', '\x220', '\x3', '\x221', '\x3', '\x221', '\x3', '\x222', 
		'\x3', '\x222', '\x3', '\x223', '\x3', '\x223', '\x3', '\x224', '\x3', 
		'\x224', '\x3', '\x224', '\x5', '\x224', '\x1FD5', '\n', '\x224', '\x3', 
		'\x224', '\x6', '\x224', '\x1FD8', '\n', '\x224', '\r', '\x224', '\xE', 
		'\x224', '\x1FD9', '\x3', '\x224', '\x3', '\x224', '\x3', '\x224', '\x3', 
		'\x224', '\x3', '\x224', '\x3', '\x224', '\x3', '\x224', '\x3', '\x224', 
		'\x3', '\x224', '\x3', '\x224', '\x3', '\x224', '\x3', '\x224', '\x3', 
		'\x224', '\x3', '\x224', '\x5', '\x224', '\x1FEA', '\n', '\x224', '\x3', 
		'\x225', '\x5', '\x225', '\x1FED', '\n', '\x225', '\x3', '\x225', '\x6', 
		'\x225', '\x1FF0', '\n', '\x225', '\r', '\x225', '\xE', '\x225', '\x1FF1', 
		'\x3', '\x226', '\x3', '\x226', '\x3', '\x226', '\x3', '\x226', '\x3', 
		'\x227', '\x3', '\x227', '\x3', '\x227', '\x3', '\x227', '\x3', '\x227', 
		'\x3', '\x227', '\x3', '\x227', '\x5', '\x227', '\x1FFF', '\n', '\x227', 
		'\x3', '\x228', '\x3', '\x228', '\x5', '\x228', '\x2003', '\n', '\x228', 
		'\x3', '\x228', '\x3', '\x228', '\x5', '\x228', '\x2007', '\n', '\x228', 
		'\a', '\x228', '\x2009', '\n', '\x228', '\f', '\x228', '\xE', '\x228', 
		'\x200C', '\v', '\x228', '\x3', '\x228', '\x3', '\x228', '\x5', '\x228', 
		'\x2010', '\n', '\x228', '\x3', '\x229', '\x3', '\x229', '\x3', '\x229', 
		'\x3', '\x229', '\x3', '\x229', '\x5', '\x229', '\x2017', '\n', '\x229', 
		'\x3', '\x229', '\x3', '\x229', '\x3', '\x229', '\x5', '\x229', '\x201C', 
		'\n', '\x229', '\x5', '\x229', '\x201E', '\n', '\x229', '\x5', '\x229', 
		'\x2020', '\n', '\x229', '\x3', '\x229', '\x3', '\x229', '\x3', '\x229', 
		'\x3', '\x229', '\x3', '\x229', '\x3', '\x229', '\x3', '\x229', '\x5', 
		'\x229', '\x2029', '\n', '\x229', '\x3', '\x229', '\x3', '\x229', '\x5', 
		'\x229', '\x202D', '\n', '\x229', '\x6', '\x229', '\x202F', '\n', '\x229', 
		'\r', '\x229', '\xE', '\x229', '\x2030', '\x5', '\x229', '\x2033', '\n', 
		'\x229', '\x3', '\x229', '\x3', '\x229', '\x5', '\x229', '\x2037', '\n', 
		'\x229', '\x3', '\x22A', '\x3', '\x22A', '\x3', '\x22A', '\x3', '\x22B', 
		'\x3', '\x22B', '\x5', '\x22B', '\x203E', '\n', '\x22B', '\x3', '\x22B', 
		'\x3', '\x22B', '\x5', '\x22B', '\x2042', '\n', '\x22B', '\x5', '\x22B', 
		'\x2044', '\n', '\x22B', '\x3', '\x22C', '\x3', '\x22C', '\x5', '\x22C', 
		'\x2048', '\n', '\x22C', '\x3', '\x22C', '\x3', '\x22C', '\x5', '\x22C', 
		'\x204C', '\n', '\x22C', '\x3', '\x22C', '\x3', '\x22C', '\x3', '\x22C', 
		'\x3', '\x22C', '\x3', '\x22C', '\x5', '\x22C', '\x2053', '\n', '\x22C', 
		'\x3', '\x22C', '\x3', '\x22C', '\x3', '\x22C', '\x3', '\x22C', '\x3', 
		'\x22C', '\x3', '\x22C', '\x5', '\x22C', '\x205B', '\n', '\x22C', '\x3', 
		'\x22C', '\x3', '\x22C', '\x3', '\x22C', '\x3', '\x22C', '\x3', '\x22C', 
		'\x3', '\x22C', '\x5', '\x22C', '\x2063', '\n', '\x22C', '\x5', '\x22C', 
		'\x2065', '\n', '\x22C', '\x3', '\x22D', '\x3', '\x22D', '\x3', '\x22D', 
		'\x3', '\x22D', '\x5', '\x22D', '\x206B', '\n', '\x22D', '\x3', '\x22D', 
		'\x5', '\x22D', '\x206E', '\n', '\x22D', '\x3', '\x22D', '\x3', '\x22D', 
		'\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', 
		'\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', 
		'\x3', '\x22E', '\x3', '\x22E', '\x5', '\x22E', '\x2086', '\n', '\x22E', 
		'\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x5', '\x22E', '\x208D', '\n', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', 
		'\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', 
		'\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', 
		'\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x3', 
		'\x22E', '\x3', '\x22E', '\x3', '\x22E', '\x5', '\x22E', '\x20AE', '\n', 
		'\x22E', '\x3', '\x22F', '\x3', '\x22F', '\x3', '\x22F', '\x5', '\x22F', 
		'\x20B3', '\n', '\x22F', '\x3', '\x22F', '\x5', '\x22F', '\x20B6', '\n', 
		'\x22F', '\x3', '\x22F', '\x3', '\x22F', '\x3', '\x22F', '\x5', '\x22F', 
		'\x20BB', '\n', '\x22F', '\x5', '\x22F', '\x20BD', '\n', '\x22F', '\x3', 
		'\x22F', '\x3', '\x22F', '\a', '\x22F', '\x20C1', '\n', '\x22F', '\f', 
		'\x22F', '\xE', '\x22F', '\x20C4', '\v', '\x22F', '\x3', '\x230', '\x3', 
		'\x230', '\x3', '\x230', '\a', '\x230', '\x20C9', '\n', '\x230', '\f', 
		'\x230', '\xE', '\x230', '\x20CC', '\v', '\x230', '\x3', '\x231', '\x3', 
		'\x231', '\x5', '\x231', '\x20D0', '\n', '\x231', '\x3', '\x231', '\x3', 
		'\x231', '\x3', '\x231', '\x5', '\x231', '\x20D5', '\n', '\x231', '\x3', 
		'\x231', '\x5', '\x231', '\x20D8', '\n', '\x231', '\x3', '\x231', '\x5', 
		'\x231', '\x20DB', '\n', '\x231', '\x3', '\x232', '\x3', '\x232', '\x5', 
		'\x232', '\x20DF', '\n', '\x232', '\x3', '\x232', '\x3', '\x232', '\x3', 
		'\x233', '\x3', '\x233', '\x5', '\x233', '\x20E5', '\n', '\x233', '\x3', 
		'\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', 
		'\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', 
		'\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', 
		'\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', 
		'\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', 
		'\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', '\x233', '\x3', 
		'\x233', '\x3', '\x233', '\x5', '\x233', '\x2104', '\n', '\x233', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x5', '\x234', '\x210B', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x211A', '\n', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x5', '\x234', '\x212A', '\n', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x213D', '\n', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x5', '\x234', '\x214E', '\n', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x5', '\x234', '\x2155', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', 
		'\x234', '\x215D', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', 
		'\x234', '\x216A', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x5', '\x234', '\x2173', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x5', '\x234', '\x217C', '\n', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x5', '\x234', '\x2185', '\n', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x218F', '\n', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x2197', '\n', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', 
		'\x21A1', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x5', '\x234', '\x21AB', '\n', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', 
		'\x234', '\x21B7', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x21C7', '\n', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x21D9', 
		'\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x21E6', 
		'\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x5', '\x234', '\x21F5', '\n', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x2200', 
		'\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x5', '\x234', '\x220A', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', '\x2215', '\n', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', 
		'\x234', '\x221F', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x5', '\x234', 
		'\x2230', '\n', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x5', '\x234', '\x2236', '\n', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', 
		'\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', '\x3', '\x234', 
		'\x3', '\x234', '\x5', '\x234', '\x224C', '\n', '\x234', '\x3', '\x235', 
		'\x3', '\x235', '\x5', '\x235', '\x2250', '\n', '\x235', '\x3', '\x236', 
		'\x3', '\x236', '\x3', '\x236', '\x5', '\x236', '\x2255', '\n', '\x236', 
		'\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x5', '\x237', '\x225A', 
		'\n', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', 
		'\x237', '\x5', '\x237', '\x2260', '\n', '\x237', '\x3', '\x237', '\x3', 
		'\x237', '\x3', '\x237', '\x3', '\x237', '\x5', '\x237', '\x2266', '\n', 
		'\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', 
		'\x5', '\x237', '\x226C', '\n', '\x237', '\x3', '\x237', '\x3', '\x237', 
		'\x3', '\x237', '\x5', '\x237', '\x2271', '\n', '\x237', '\x5', '\x237', 
		'\x2273', '\n', '\x237', '\x3', '\x237', '\x5', '\x237', '\x2276', '\n', 
		'\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', 
		'\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x5', 
		'\x237', '\x2280', '\n', '\x237', '\x3', '\x237', '\x5', '\x237', '\x2283', 
		'\n', '\x237', '\x5', '\x237', '\x2285', '\n', '\x237', '\x5', '\x237', 
		'\x2287', '\n', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', 
		'\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', 
		'\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', '\x3', '\x237', 
		'\x5', '\x237', '\x2295', '\n', '\x237', '\x3', '\x238', '\x3', '\x238', 
		'\x5', '\x238', '\x2299', '\n', '\x238', '\x3', '\x238', '\x3', '\x238', 
		'\x3', '\x239', '\x3', '\x239', '\x3', '\x23A', '\x3', '\x23A', '\x3', 
		'\x23B', '\x3', '\x23B', '\x3', '\x23C', '\x3', '\x23C', '\x3', '\x23D', 
		'\x3', '\x23D', '\x3', '\x23E', '\x3', '\x23E', '\x3', '\x23F', '\x3', 
		'\x23F', '\x3', '\x240', '\x3', '\x240', '\x3', '\x241', '\x3', '\x241', 
		'\x3', '\x242', '\x3', '\x242', '\x3', '\x243', '\x3', '\x243', '\x3', 
		'\x244', '\x3', '\x244', '\x3', '\x245', '\x3', '\x245', '\x3', '\x246', 
		'\x3', '\x246', '\x3', '\x246', '\a', '\x246', '\x22BA', '\n', '\x246', 
		'\f', '\x246', '\xE', '\x246', '\x22BD', '\v', '\x246', '\x3', '\x247', 
		'\x3', '\x247', '\x3', '\x248', '\x3', '\x248', '\x3', '\x249', '\x3', 
		'\x249', '\x3', '\x24A', '\x3', '\x24A', '\x5', '\x24A', '\x22C7', '\n', 
		'\x24A', '\x3', '\x24B', '\x3', '\x24B', '\x3', '\x24B', '\a', '\x24B', 
		'\x22CC', '\n', '\x24B', '\f', '\x24B', '\xE', '\x24B', '\x22CF', '\v', 
		'\x24B', '\x3', '\x24C', '\x3', '\x24C', '\x3', '\x24D', '\x3', '\x24D', 
		'\x3', '\x24E', '\x3', '\x24E', '\x3', '\x24F', '\x3', '\x24F', '\x3', 
		'\x24F', '\x3', '\x24F', '\x3', '\x250', '\x3', '\x250', '\x3', '\x251', 
		'\x3', '\x251', '\x3', '\x252', '\x3', '\x252', '\x3', '\x253', '\x3', 
		'\x253', '\x5', '\x253', '\x22E3', '\n', '\x253', '\x3', '\x254', '\x5', 
		'\x254', '\x22E6', '\n', '\x254', '\x3', '\x254', '\x3', '\x254', '\x5', 
		'\x254', '\x22EA', '\n', '\x254', '\x3', '\x255', '\x3', '\x255', '\x3', 
		'\x255', '\x3', '\x256', '\x3', '\x256', '\x3', '\x256', '\x2', '\x5', 
		'\x382', '\x386', '\x38C', '\x257', '\x2', '\x4', '\x6', '\b', '\n', '\f', 
		'\xE', '\x10', '\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', 
		' ', '\"', '$', '&', '(', '*', ',', '.', '\x30', '\x32', '\x34', '\x36', 
		'\x38', ':', '<', '>', '@', '\x42', '\x44', '\x46', 'H', 'J', 'L', 'N', 
		'P', 'R', 'T', 'V', 'X', 'Z', '\\', '^', '`', '\x62', '\x64', '\x66', 
		'h', 'j', 'l', 'n', 'p', 'r', 't', 'v', 'x', 'z', '|', '~', '\x80', '\x82', 
		'\x84', '\x86', '\x88', '\x8A', '\x8C', '\x8E', '\x90', '\x92', '\x94', 
		'\x96', '\x98', '\x9A', '\x9C', '\x9E', '\xA0', '\xA2', '\xA4', '\xA6', 
		'\xA8', '\xAA', '\xAC', '\xAE', '\xB0', '\xB2', '\xB4', '\xB6', '\xB8', 
		'\xBA', '\xBC', '\xBE', '\xC0', '\xC2', '\xC4', '\xC6', '\xC8', '\xCA', 
		'\xCC', '\xCE', '\xD0', '\xD2', '\xD4', '\xD6', '\xD8', '\xDA', '\xDC', 
		'\xDE', '\xE0', '\xE2', '\xE4', '\xE6', '\xE8', '\xEA', '\xEC', '\xEE', 
		'\xF0', '\xF2', '\xF4', '\xF6', '\xF8', '\xFA', '\xFC', '\xFE', '\x100', 
		'\x102', '\x104', '\x106', '\x108', '\x10A', '\x10C', '\x10E', '\x110', 
		'\x112', '\x114', '\x116', '\x118', '\x11A', '\x11C', '\x11E', '\x120', 
		'\x122', '\x124', '\x126', '\x128', '\x12A', '\x12C', '\x12E', '\x130', 
		'\x132', '\x134', '\x136', '\x138', '\x13A', '\x13C', '\x13E', '\x140', 
		'\x142', '\x144', '\x146', '\x148', '\x14A', '\x14C', '\x14E', '\x150', 
		'\x152', '\x154', '\x156', '\x158', '\x15A', '\x15C', '\x15E', '\x160', 
		'\x162', '\x164', '\x166', '\x168', '\x16A', '\x16C', '\x16E', '\x170', 
		'\x172', '\x174', '\x176', '\x178', '\x17A', '\x17C', '\x17E', '\x180', 
		'\x182', '\x184', '\x186', '\x188', '\x18A', '\x18C', '\x18E', '\x190', 
		'\x192', '\x194', '\x196', '\x198', '\x19A', '\x19C', '\x19E', '\x1A0', 
		'\x1A2', '\x1A4', '\x1A6', '\x1A8', '\x1AA', '\x1AC', '\x1AE', '\x1B0', 
		'\x1B2', '\x1B4', '\x1B6', '\x1B8', '\x1BA', '\x1BC', '\x1BE', '\x1C0', 
		'\x1C2', '\x1C4', '\x1C6', '\x1C8', '\x1CA', '\x1CC', '\x1CE', '\x1D0', 
		'\x1D2', '\x1D4', '\x1D6', '\x1D8', '\x1DA', '\x1DC', '\x1DE', '\x1E0', 
		'\x1E2', '\x1E4', '\x1E6', '\x1E8', '\x1EA', '\x1EC', '\x1EE', '\x1F0', 
		'\x1F2', '\x1F4', '\x1F6', '\x1F8', '\x1FA', '\x1FC', '\x1FE', '\x200', 
		'\x202', '\x204', '\x206', '\x208', '\x20A', '\x20C', '\x20E', '\x210', 
		'\x212', '\x214', '\x216', '\x218', '\x21A', '\x21C', '\x21E', '\x220', 
		'\x222', '\x224', '\x226', '\x228', '\x22A', '\x22C', '\x22E', '\x230', 
		'\x232', '\x234', '\x236', '\x238', '\x23A', '\x23C', '\x23E', '\x240', 
		'\x242', '\x244', '\x246', '\x248', '\x24A', '\x24C', '\x24E', '\x250', 
		'\x252', '\x254', '\x256', '\x258', '\x25A', '\x25C', '\x25E', '\x260', 
		'\x262', '\x264', '\x266', '\x268', '\x26A', '\x26C', '\x26E', '\x270', 
		'\x272', '\x274', '\x276', '\x278', '\x27A', '\x27C', '\x27E', '\x280', 
		'\x282', '\x284', '\x286', '\x288', '\x28A', '\x28C', '\x28E', '\x290', 
		'\x292', '\x294', '\x296', '\x298', '\x29A', '\x29C', '\x29E', '\x2A0', 
		'\x2A2', '\x2A4', '\x2A6', '\x2A8', '\x2AA', '\x2AC', '\x2AE', '\x2B0', 
		'\x2B2', '\x2B4', '\x2B6', '\x2B8', '\x2BA', '\x2BC', '\x2BE', '\x2C0', 
		'\x2C2', '\x2C4', '\x2C6', '\x2C8', '\x2CA', '\x2CC', '\x2CE', '\x2D0', 
		'\x2D2', '\x2D4', '\x2D6', '\x2D8', '\x2DA', '\x2DC', '\x2DE', '\x2E0', 
		'\x2E2', '\x2E4', '\x2E6', '\x2E8', '\x2EA', '\x2EC', '\x2EE', '\x2F0', 
		'\x2F2', '\x2F4', '\x2F6', '\x2F8', '\x2FA', '\x2FC', '\x2FE', '\x300', 
		'\x302', '\x304', '\x306', '\x308', '\x30A', '\x30C', '\x30E', '\x310', 
		'\x312', '\x314', '\x316', '\x318', '\x31A', '\x31C', '\x31E', '\x320', 
		'\x322', '\x324', '\x326', '\x328', '\x32A', '\x32C', '\x32E', '\x330', 
		'\x332', '\x334', '\x336', '\x338', '\x33A', '\x33C', '\x33E', '\x340', 
		'\x342', '\x344', '\x346', '\x348', '\x34A', '\x34C', '\x34E', '\x350', 
		'\x352', '\x354', '\x356', '\x358', '\x35A', '\x35C', '\x35E', '\x360', 
		'\x362', '\x364', '\x366', '\x368', '\x36A', '\x36C', '\x36E', '\x370', 
		'\x372', '\x374', '\x376', '\x378', '\x37A', '\x37C', '\x37E', '\x380', 
		'\x382', '\x384', '\x386', '\x388', '\x38A', '\x38C', '\x38E', '\x390', 
		'\x392', '\x394', '\x396', '\x398', '\x39A', '\x39C', '\x39E', '\x3A0', 
		'\x3A2', '\x3A4', '\x3A6', '\x3A8', '\x3AA', '\x3AC', '\x3AE', '\x3B0', 
		'\x3B2', '\x3B4', '\x3B6', '\x3B8', '\x3BA', '\x3BC', '\x3BE', '\x3C0', 
		'\x3C2', '\x3C4', '\x3C6', '\x3C8', '\x3CA', '\x3CC', '\x3CE', '\x3D0', 
		'\x3D2', '\x3D4', '\x3D6', '\x3D8', '\x3DA', '\x3DC', '\x3DE', '\x3E0', 
		'\x3E2', '\x3E4', '\x3E6', '\x3E8', '\x3EA', '\x3EC', '\x3EE', '\x3F0', 
		'\x3F2', '\x3F4', '\x3F6', '\x3F8', '\x3FA', '\x3FC', '\x3FE', '\x400', 
		'\x402', '\x404', '\x406', '\x408', '\x40A', '\x40C', '\x40E', '\x410', 
		'\x412', '\x414', '\x416', '\x418', '\x41A', '\x41C', '\x41E', '\x420', 
		'\x422', '\x424', '\x426', '\x428', '\x42A', '\x42C', '\x42E', '\x430', 
		'\x432', '\x434', '\x436', '\x438', '\x43A', '\x43C', '\x43E', '\x440', 
		'\x442', '\x444', '\x446', '\x448', '\x44A', '\x44C', '\x44E', '\x450', 
		'\x452', '\x454', '\x456', '\x458', '\x45A', '\x45C', '\x45E', '\x460', 
		'\x462', '\x464', '\x466', '\x468', '\x46A', '\x46C', '\x46E', '\x470', 
		'\x472', '\x474', '\x476', '\x478', '\x47A', '\x47C', '\x47E', '\x480', 
		'\x482', '\x484', '\x486', '\x488', '\x48A', '\x48C', '\x48E', '\x490', 
		'\x492', '\x494', '\x496', '\x498', '\x49A', '\x49C', '\x49E', '\x4A0', 
		'\x4A2', '\x4A4', '\x4A6', '\x4A8', '\x4AA', '\x2', '\xA0', '\x4', '\x2', 
		'\x19', '\x19', '\x11B', '\x11B', '\x4', '\x2', '\f', '\f', '\x1C2', '\x1C2', 
		'\x5', '\x2', '\xED', '\xED', '\x134', '\x134', '\x1DE', '\x1DE', '\x4', 
		'\x2', 'T', 'T', '\x1A1', '\x1A1', '\x5', '\x2', '\x38', '\x38', '\x1AC', 
		'\x1AC', '\x237', '\x237', '\x4', '\x2', '\x9C', '\x9C', '\xB1', '\xB1', 
		'\x4', '\x2', '\n', '\n', ',', ',', '\x5', '\x2', '\x95', '\x95', '\x110', 
		'\x110', '\x287', '\x287', '\x5', '\x2', '\x170', '\x170', '\x197', '\x197', 
		'\x1B0', '\x1B0', '\x4', '\x2', '\xDB', '\xDB', '\x28F', '\x28F', '\x4', 
		'\x2', '\x38', '\x38', '\x237', '\x237', '\x4', '\x2', '\x5', '\x5', '\xA5', 
		'\xA5', '\x5', '\x2', '\x5', '\x5', '\xA5', '\xA5', '\x162', '\x162', 
		'\x5', '\x2', '{', '{', '\x1A0', '\x1A0', '\x238', '\x238', '\x4', '\x2', 
		'\x14A', '\x14A', '\x1A1', '\x1A1', '\x4', '\x2', '\x154', '\x154', '\x240', 
		'\x240', '\x5', '\x2', '\xD1', '\xD1', '\x111', '\x111', '\x1AB', '\x1AB', 
		'\x4', '\x2', '|', '|', '\x176', '\x176', '\x4', '\x2', '\x183', '\x183', 
		'\x1A1', '\x1A1', '\x4', '\x2', '\x122', '\x122', '\x17A', '\x17A', '\x4', 
		'\x2', '\xE5', '\xE5', '\x221', '\x221', '\x4', '\x2', '\xCB', '\xCB', 
		'\xE6', '\xE6', '\x4', '\x2', '\x8F', '\x8F', '\x25B', '\x25B', '\x4', 
		'\x2', '\x13D', '\x13D', '\x282', '\x282', '\x4', '\x2', '\x5', '\x5', 
		'\x1EF', '\x1EF', '\x4', '\x2', '\x6', '\x6', '\x94', '\x94', '\x4', '\x2', 
		'\xE', '\xE', 'w', 'w', '\x4', '\x2', '\x11A', '\x11A', '\x29C', '\x29C', 
		'\x5', '\x2', '\xF5', '\xF5', '\xF7', '\xF7', '\x196', '\x196', '\x4', 
		'\x2', '\x92', '\x92', '\xFB', '\xFB', '\x4', '\x2', '\x185', '\x185', 
		'\x1EE', '\x1EE', '\x4', '\x2', '\x18B', '\x18B', '\x28F', '\x28F', '\x4', 
		'\x2', '\x188', '\x188', '\x234', '\x234', '\x4', '\x2', '\x194', '\x194', 
		'\x19B', '\x19B', '\x4', '\x2', ')', ')', '\x217', '\x217', '\x4', '\x2', 
		'\x44', '\x44', '\x1DB', '\x1DB', '\x4', '\x2', '\xF2', '\xF2', '\x145', 
		'\x145', '\a', '\x2', 't', 't', '\xF2', '\xF2', '\x145', '\x145', '\x153', 
		'\x153', '\x180', '\x180', '\x4', '\x2', '\b', '\b', '(', '(', '\x4', 
		'\x2', '\x17', '\x17', '\x1DB', '\x1DB', '\x4', '\x2', '\x285', '\x285', 
		'\x28A', '\x28A', '\x4', '\x2', '\xE2', '\xE2', '\x1B1', '\x1B1', '\x4', 
		'\x2', '\x30', '\x30', '\x230', '\x230', '\x4', '\x2', '\x193', '\x193', 
		'\x199', '\x199', '\x5', '\x2', '\xD0', '\xD0', '\x13E', '\x13E', '\x17B', 
		'\x17B', '\x4', '\x2', '#', '#', '\x149', '\x149', '\x4', '\x2', '\x2EE', 
		'\x2EE', '\x310', '\x310', '\x4', '\x2', '\xEC', '\xEC', '\x179', '\x179', 
		'\x4', '\x2', '\x95', '\x95', '\x1CF', '\x1CF', '\x4', '\x2', '\x41', 
		'\x41', '\x173', '\x173', '\x4', '\x2', '\x8F', '\x8F', '\xDB', '\xDB', 
		'\x4', '\x2', '\x186', '\x186', '\x206', '\x206', '\x4', '\x2', '\x116', 
		'\x116', '\x132', '\x132', '\x4', '\x2', '\x181', '\x181', '\x2BC', '\x2BC', 
		'\x4', '\x2', '\x137', '\x137', '\x257', '\x257', '\x4', '\x2', '\xF', 
		'\xF', '\x9D', '\x9D', '\x4', '\x2', '\x13A', '\x13A', '\x291', '\x291', 
		'\x4', '\x2', '\x8E', '\x8E', '\x121', '\x121', '\x5', '\x2', '\xF2', 
		'\xF2', '\x145', '\x145', '\x153', '\x153', '\x5', '\x2', '\x95', '\x95', 
		'\x9C', '\x9C', '\xB1', '\xB1', '\x4', '\x2', '\xE9', '\xE9', '\x219', 
		'\x219', '\x5', '\x2', '\x81', '\x82', '\x163', '\x164', '\x2BA', '\x2BB', 
		'\x4', '\x2', '\x281', '\x281', '\x2EC', '\x2EC', '\x5', '\x2', '\x8F', 
		'\x8F', '\x122', '\x122', '\x1E4', '\x1E4', '\x5', '\x2', '\x8F', '\x8F', 
		'\x122', '\x122', '\x180', '\x180', '\x4', '\x2', '\xA9', '\xA9', '\x17F', 
		'\x17F', '\x4', '\x2', 'x', 'x', '\x93', '\x93', '\x6', '\x2', '\x108', 
		'\x108', '\x10F', '\x10F', '\x175', '\x175', '\x1A8', '\x1A8', '\x4', 
		'\x2', '\x8F', '\x8F', '\x2FB', '\x2FB', '\x3', '\x2', '\x100', '\x101', 
		'\x3', '\x3', '\x304', '\x304', '\x3', '\x2', '\x304', '\x304', '\x3', 
		'\x2', '\x1FB', '\x1FC', '\x4', '\x2', '\x19A', '\x19A', '\x2A8', '\x2A8', 
		'\x3', '\x2', '\x65', '\x66', '\x4', '\x2', '\x18C', '\x18C', '\x29D', 
		'\x29D', '\x4', '\x2', '*', '*', '\xFB', '\xFB', '\x4', '\x2', ';', ';', 
		'\x96', '\x96', '\x5', '\x2', '\xE', '\xE', '\x9F', '\x9F', '\x280', '\x280', 
		'\x4', '\x2', 'u', 'u', '\x169', '\x169', '\x5', '\x2', '\xE2', '\xE2', 
		'\x128', '\x128', '\x201', '\x201', '\x4', '\x2', '\x213', '\x213', '\x262', 
		'\x262', '\x5', '\x2', '\x213', '\x213', '\x232', '\x232', '\x262', '\x262', 
		'\x4', '\x2', '\xC1', '\xC1', '\xFC', '\xFC', '\x4', '\x2', 'v', 'v', 
		'\x205', '\x205', '\x4', '\x2', '\xF9', '\xF9', '\x122', '\x122', '\x4', 
		'\x2', '\xE', '\xE', '\x286', '\x286', '\x4', '\x2', '%', '%', '\x21D', 
		'\x21D', '\x4', '\x2', '\x1A', '\x1A', '\x97', '\x97', '\x4', '\x2', '\xD2', 
		'\xD2', '\x125', '\x125', '\x4', '\x2', '\xE', '\xE', '\xD2', '\xD2', 
		'\x4', '\x2', '\x258', '\x258', '\x25E', '\x25E', '\x4', '\x2', '\x154', 
		'\x154', '\x245', '\x245', '\x4', '\x2', 'y', 'y', '\x158', '\x158', '\x3', 
		'\x2', '\x12D', '\x130', '\x4', '\x2', '\x2F5', '\x2F5', '\x2F9', '\x2F9', 
		'\x3', '\x2', '\x2F6', '\x2F7', '\x3', '\x2', '\x301', '\x302', '\x4', 
		'\x2', '\x8C', '\x8C', '\xFE', '\xFE', '\x6', '\x2', '\xE', '\xE', '\x14', 
		'\x14', '\xC5', '\xC5', '\x233', '\x233', '\x5', '\x2', ':', ':', '\x127', 
		'\x127', '\x270', '\x270', '\x4', '\x2', '\xE', '\xE', '\x9F', '\x9F', 
		'\x4', '\x2', 'G', 'G', '\x2AB', '\x2AB', '\x4', '\x2', '\x9F', '\x9F', 
		'\x280', '\x280', '\x3', '\x2', '\x1BC', '\x1BF', '\x4', '\x2', '\x43', 
		'\x43', ']', ']', '\x4', '\x2', '\xD3', '\xD3', '\x126', '\x126', '\x4', 
		'\x2', 'L', 'L', '\x16C', '\x16C', '\x4', '\x2', '\x2AC', '\x2AC', '\x2AF', 
		'\x2AF', '\x4', '\x2', '\xB7', '\xB7', '\x178', '\x178', '\x4', '\x2', 
		'\xBB', '\xBB', '\x167', '\x167', '\x4', '\x2', 'j', 'j', '\xA3', '\xA3', 
		'\x4', '\x2', '\xF0', '\xF0', '\x228', '\x228', '\a', '\x2', '\x2CD', 
		'\x2CF', '\x2D1', '\x2D6', '\x2D8', '\x2D9', '\x2DB', '\x2DB', '\x2DF', 
		'\x2E2', '\x3', '\x2', '\x2C6', '\x2CC', '\x3', '\x2', '\x2C0', '\x2C5', 
		'\x4', '\x2', '\x1DE', '\x1DE', '\x20A', '\x20A', '\x4', '\x2', '\xD8', 
		'\xD8', '\x1CC', '\x1CC', '\x4', '\x2', '\x187', '\x187', '\x211', '\x211', 
		'\x3', '\x2', '\xB8', '\xB9', '\x4', '\x2', '\x1A5', '\x1A5', '\x239', 
		'\x239', '\x5', '\x2', '\xCD', '\xCD', '\x24A', '\x24A', '\x29E', '\x29E', 
		'\x4', '\x2', '[', '[', '\x204', '\x204', '\x5', '\x2', '[', '[', '\x180', 
		'\x180', '\x204', '\x204', '\x4', '\x2', '\x1B2', '\x1B2', '\x247', '\x247', 
		'\x4', '\x2', '\x1F3', '\x1F3', '\x235', '\x235', '\x4', '\x2', '\xF9', 
		'\xF9', '\x1F4', '\x1F4', '\x3', '\x2', '\x1C0', '\x1C1', '\x4', '\x2', 
		'\x81', '\x81', '\x2BB', '\x2BB', '\x4', '\x2', '\x163', '\x163', '\x216', 
		'\x216', '\x4', '\x2', '@', '@', 'K', 'K', '\x5', '\x2', '\x10', '\x10', 
		'r', 'r', '\xA5', '\xA5', '\x4', '\x2', '\x10', '\x10', '\xA5', '\xA5', 
		'\x4', '\x2', 'r', 'r', '\xA5', '\xA5', '\x4', '\x2', '\x10', '\x10', 
		'r', 'r', '\x5', '\x2', '\x10', '\x10', '\xA5', '\xA5', '\xC3', '\xC3', 
		'\x4', '\x2', '\x14', '\x14', '\xCA', '\xCA', '\x4', '\x2', 'P', 'P', 
		'\x1D8', '\x1D8', '\x6', '\x2', '\x10', '\x10', 'Z', 'Z', '\xA5', '\xA5', 
		'\x21A', '\x21A', '\x6', '\x2', '\x10', '\x10', '\xA5', '\xA5', '\x21A', 
		'\x21A', '\x287', '\x287', '\x5', '\x2', '\x95', '\x95', '\xA5', '\xA5', 
		'\x110', '\x110', '\b', '\x2', '\x10', '\x10', '\x95', '\x95', '\xA5', 
		'\xA5', '\x110', '\x110', '\x21A', '\x21A', '\x287', '\x287', '\x4', '\x2', 
		'\xA5', '\xA5', '\x287', '\x287', '\x5', '\x2', '\x10', '\x10', '\xA5', 
		'\xA5', '\xE8', '\xE8', '\x5', '\x2', '\x10', '\x10', '\xA5', '\xA5', 
		'\x21A', '\x21A', '\x5', '\x2', '\x10', '\x10', 'r', 'r', '\x1F5', '\x1F5', 
		'\x5', '\x2', '\x10', '\x10', '\xA5', '\xA5', '\x28D', '\x28D', '\f', 
		'\x2', '\x10', '\x10', '\'', '\'', 'Z', 'Z', '\x95', '\x95', '\xA5', '\xA5', 
		'\x110', '\x110', '\x13D', '\x13D', '\x1E0', '\x1E0', '\x21A', '\x21A', 
		'\x287', '\x287', '\a', '\x2', '\x10', '\x10', 'r', 'r', '\xA5', '\xA5', 
		'\x147', '\x147', '\x281', '\x281', '\x6', '\x2', '\x10', '\x10', '\xA5', 
		'\xA5', '\xC3', '\xC3', '\x27C', '\x27C', '\x5', '\x2', '\xA5', '\xA5', 
		'\x156', '\x156', '\x27C', '\x27C', '\x4', '\x2', '\x12', '\x12', '\x1E', 
		'\x1E', '\x4', '\x2', '\x99', '\x99', '\x271', '\x271', '\b', '\x2', '\x81', 
		'\x81', '\xF3', '\xF3', '\x15C', '\x15C', '\x163', '\x163', '\x216', '\x216', 
		'\x2BB', '\x2BB', '\xA9', '\x2', '\x4', '\x5', '\n', '\r', '\x12', '\x12', 
		'\x18', '\x18', '\x1B', '\x1E', '!', '!', '#', '#', '%', '&', '*', '*', 
		',', ',', '/', '/', '\x32', '\x36', '\x38', ':', '=', '>', '@', '@', '\x42', 
		'\x43', '\x45', '\x45', 'G', 'G', 'J', 'L', 'N', 'N', 'Q', 'T', 'W', 'W', 
		'Y', '_', '\x64', 'g', 'j', 'q', 'u', 'v', 'x', 'x', 'z', '~', '\x81', 
		'\x81', '\x84', '\x89', '\x8B', '\x8C', '\x90', '\x90', '\x92', '\x93', 
		'\x95', '\x95', '\x98', '\x98', '\x9A', '\x9A', '\x9C', '\x9C', '\x9E', 
		'\x9E', '\xA3', '\xA4', '\xA6', '\xA6', '\xA8', '\xA8', '\xAD', '\xAD', 
		'\xB0', '\xB2', '\xB7', '\xBB', '\xBE', '\xC1', '\xC3', '\xC3', '\xC6', 
		'\xC6', '\xC8', '\xC8', '\xCA', '\xCA', '\xCC', '\xCD', '\xD1', '\xD3', 
		'\xD6', '\xD6', '\xD8', '\xDB', '\xE2', '\xE3', '\xEA', '\xEA', '\xED', 
		'\xED', '\xF0', '\xF0', '\xF3', '\xF3', '\xF7', '\xF7', '\xF9', '\xF9', 
		'\xFB', '\x100', '\x104', '\x106', '\x10C', '\x10C', '\x10E', '\x10F', 
		'\x111', '\x113', '\x115', '\x115', '\x117', '\x117', '\x119', '\x119', 
		'\x11C', '\x11E', '\x120', '\x120', '\x122', '\x128', '\x12A', '\x12A', 
		'\x12C', '\x12F', '\x131', '\x131', '\x133', '\x134', '\x138', '\x138', 
		'\x13B', '\x13B', '\x13F', '\x13F', '\x141', '\x144', '\x146', '\x146', 
		'\x14A', '\x14A', '\x14C', '\x14C', '\x150', '\x150', '\x152', '\x152', 
		'\x154', '\x154', '\x156', '\x156', '\x159', '\x159', '\x15C', '\x15F', 
		'\x162', '\x163', '\x166', '\x170', '\x172', '\x172', '\x175', '\x176', 
		'\x178', '\x178', '\x180', '\x181', '\x187', '\x187', '\x18E', '\x192', 
		'\x194', '\x194', '\x196', '\x197', '\x19A', '\x19A', '\x19C', '\x19D', 
		'\x1A0', '\x1A0', '\x1A2', '\x1A2', '\x1A5', '\x1A6', '\x1A8', '\x1A8', 
		'\x1AA', '\x1AD', '\x1AF', '\x1B0', '\x1B2', '\x1B2', '\x1B4', '\x1B6', 
		'\x1C2', '\x1C2', '\x1C5', '\x1C6', '\x1C9', '\x1CE', '\x1D1', '\x1D1', 
		'\x1D3', '\x1D3', '\x1D8', '\x1D8', '\x1DD', '\x1E0', '\x1E2', '\x1E3', 
		'\x1E6', '\x1E6', '\x1E8', '\x1E9', '\x1EB', '\x1EB', '\x1ED', '\x1ED', 
		'\x1F0', '\x1F1', '\x1F4', '\x1F4', '\x1F6', '\x1F8', '\x1FB', '\x1FF', 
		'\x201', '\x201', '\x204', '\x205', '\x207', '\x207', '\x209', '\x20B', 
		'\x20D', '\x20F', '\x211', '\x213', '\x216', '\x216', '\x218', '\x219', 
		'\x21B', '\x220', '\x222', '\x225', '\x228', '\x22F', '\x231', '\x234', 
		'\x237', '\x239', '\x23B', '\x241', '\x243', '\x245', '\x247', '\x24A', 
		'\x24C', '\x24C', '\x24F', '\x24F', '\x25B', '\x25B', '\x261', '\x269', 
		'\x270', '\x272', '\x274', '\x275', '\x277', '\x277', '\x27A', '\x27C', 
		'\x281', '\x281', '\x284', '\x284', '\x286', '\x286', '\x288', '\x289', 
		'\x28B', '\x28D', '\x28F', '\x28F', '\x291', '\x294', '\x296', '\x299', 
		'\x29D', '\x2A0', '\x2A3', '\x2A4', '\x2A7', '\x2B4', '\x2B6', '\x2B9', 
		'\x2BB', '\x2BD', '\x2BF', '\x2CF', '\x2D1', '\x2D6', '\x2D8', '\x2D9', 
		'\x2DB', '\x2DC', '\x2DE', '\x2E2', '\x310', '\x310', '\x5', '\x2', 'N', 
		'N', '\x2D0', '\x2D0', '\x2DC', '\x2DE', '\a', '\x2', 'q', 'q', '\x2CD', 
		'\x2CD', '\x2D7', '\x2D7', '\x2DA', '\x2DA', '\x2DF', '\x2DF', '\x4', 
		'\x2', '\x2E7', '\x2E7', '\x2EE', '\x2EE', '\x2', '\x27C4', '\x2', '\x4B5', 
		'\x3', '\x2', '\x2', '\x2', '\x4', '\x4DE', '\x3', '\x2', '\x2', '\x2', 
		'\x6', '\x4E0', '\x3', '\x2', '\x2', '\x2', '\b', '\x4E5', '\x3', '\x2', 
		'\x2', '\x2', '\n', '\x4F8', '\x3', '\x2', '\x2', '\x2', '\f', '\x52C', 
		'\x3', '\x2', '\x2', '\x2', '\xE', '\x530', '\x3', '\x2', '\x2', '\x2', 
		'\x10', '\x53E', '\x3', '\x2', '\x2', '\x2', '\x12', '\x542', '\x3', '\x2', 
		'\x2', '\x2', '\x14', '\x54E', '\x3', '\x2', '\x2', '\x2', '\x16', '\x553', 
		'\x3', '\x2', '\x2', '\x2', '\x18', '\x560', '\x3', '\x2', '\x2', '\x2', 
		'\x1A', '\x576', '\x3', '\x2', '\x2', '\x2', '\x1C', '\x592', '\x3', '\x2', 
		'\x2', '\x2', '\x1E', '\x5B8', '\x3', '\x2', '\x2', '\x2', ' ', '\x5BA', 
		'\x3', '\x2', '\x2', '\x2', '\"', '\x5CB', '\x3', '\x2', '\x2', '\x2', 
		'$', '\x5ED', '\x3', '\x2', '\x2', '\x2', '&', '\x5EF', '\x3', '\x2', 
		'\x2', '\x2', '(', '\x5F4', '\x3', '\x2', '\x2', '\x2', '*', '\x607', 
		'\x3', '\x2', '\x2', '\x2', ',', '\x636', '\x3', '\x2', '\x2', '\x2', 
		'.', '\x653', '\x3', '\x2', '\x2', '\x2', '\x30', '\x678', '\x3', '\x2', 
		'\x2', '\x2', '\x32', '\x67D', '\x3', '\x2', '\x2', '\x2', '\x34', '\x696', 
		'\x3', '\x2', '\x2', '\x2', '\x36', '\x6AE', '\x3', '\x2', '\x2', '\x2', 
		'\x38', '\x6B7', '\x3', '\x2', '\x2', '\x2', ':', '\x6C0', '\x3', '\x2', 
		'\x2', '\x2', '<', '\x6C9', '\x3', '\x2', '\x2', '\x2', '>', '\x6CD', 
		'\x3', '\x2', '\x2', '\x2', '@', '\x6D2', '\x3', '\x2', '\x2', '\x2', 
		'\x42', '\x6EA', '\x3', '\x2', '\x2', '\x2', '\x44', '\x6ED', '\x3', '\x2', 
		'\x2', '\x2', '\x46', '\x6F2', '\x3', '\x2', '\x2', '\x2', 'H', '\x723', 
		'\x3', '\x2', '\x2', '\x2', 'J', '\x73F', '\x3', '\x2', '\x2', '\x2', 
		'L', '\x741', '\x3', '\x2', '\x2', '\x2', 'N', '\x74F', '\x3', '\x2', 
		'\x2', '\x2', 'P', '\x754', '\x3', '\x2', '\x2', '\x2', 'R', '\x759', 
		'\x3', '\x2', '\x2', '\x2', 'T', '\x75F', '\x3', '\x2', '\x2', '\x2', 
		'V', '\x762', '\x3', '\x2', '\x2', '\x2', 'X', '\x76D', '\x3', '\x2', 
		'\x2', '\x2', 'Z', '\x77C', '\x3', '\x2', '\x2', '\x2', '\\', '\x78D', 
		'\x3', '\x2', '\x2', '\x2', '^', '\x79E', '\x3', '\x2', '\x2', '\x2', 
		'`', '\x7A6', '\x3', '\x2', '\x2', '\x2', '\x62', '\x7AB', '\x3', '\x2', 
		'\x2', '\x2', '\x64', '\x7BB', '\x3', '\x2', '\x2', '\x2', '\x66', '\x7BF', 
		'\x3', '\x2', '\x2', '\x2', 'h', '\x7D7', '\x3', '\x2', '\x2', '\x2', 
		'j', '\x7DA', '\x3', '\x2', '\x2', '\x2', 'l', '\x7E0', '\x3', '\x2', 
		'\x2', '\x2', 'n', '\x7EC', '\x3', '\x2', '\x2', '\x2', 'p', '\x7F5', 
		'\x3', '\x2', '\x2', '\x2', 'r', '\x811', '\x3', '\x2', '\x2', '\x2', 
		't', '\x817', '\x3', '\x2', '\x2', '\x2', 'v', '\x81A', '\x3', '\x2', 
		'\x2', '\x2', 'x', '\x821', '\x3', '\x2', '\x2', '\x2', 'z', '\x829', 
		'\x3', '\x2', '\x2', '\x2', '|', '\x835', '\x3', '\x2', '\x2', '\x2', 
		'~', '\x837', '\x3', '\x2', '\x2', '\x2', '\x80', '\x83B', '\x3', '\x2', 
		'\x2', '\x2', '\x82', '\x841', '\x3', '\x2', '\x2', '\x2', '\x84', '\x85A', 
		'\x3', '\x2', '\x2', '\x2', '\x86', '\x879', '\x3', '\x2', '\x2', '\x2', 
		'\x88', '\x8A6', '\x3', '\x2', '\x2', '\x2', '\x8A', '\x8B0', '\x3', '\x2', 
		'\x2', '\x2', '\x8C', '\x8B2', '\x3', '\x2', '\x2', '\x2', '\x8E', '\x8B7', 
		'\x3', '\x2', '\x2', '\x2', '\x90', '\x8C5', '\x3', '\x2', '\x2', '\x2', 
		'\x92', '\x8C7', '\x3', '\x2', '\x2', '\x2', '\x94', '\x8CC', '\x3', '\x2', 
		'\x2', '\x2', '\x96', '\x8DC', '\x3', '\x2', '\x2', '\x2', '\x98', '\x8FD', 
		'\x3', '\x2', '\x2', '\x2', '\x9A', '\x920', '\x3', '\x2', '\x2', '\x2', 
		'\x9C', '\x924', '\x3', '\x2', '\x2', '\x2', '\x9E', '\x933', '\x3', '\x2', 
		'\x2', '\x2', '\xA0', '\x935', '\x3', '\x2', '\x2', '\x2', '\xA2', '\x938', 
		'\x3', '\x2', '\x2', '\x2', '\xA4', '\x93D', '\x3', '\x2', '\x2', '\x2', 
		'\xA6', '\x947', '\x3', '\x2', '\x2', '\x2', '\xA8', '\x96C', '\x3', '\x2', 
		'\x2', '\x2', '\xAA', '\x96E', '\x3', '\x2', '\x2', '\x2', '\xAC', '\x981', 
		'\x3', '\x2', '\x2', '\x2', '\xAE', '\x989', '\x3', '\x2', '\x2', '\x2', 
		'\xB0', '\x9BA', '\x3', '\x2', '\x2', '\x2', '\xB2', '\x9BC', '\x3', '\x2', 
		'\x2', '\x2', '\xB4', '\x9C1', '\x3', '\x2', '\x2', '\x2', '\xB6', '\x9C5', 
		'\x3', '\x2', '\x2', '\x2', '\xB8', '\x9CB', '\x3', '\x2', '\x2', '\x2', 
		'\xBA', '\x9CF', '\x3', '\x2', '\x2', '\x2', '\xBC', '\x9D7', '\x3', '\x2', 
		'\x2', '\x2', '\xBE', '\x9F1', '\x3', '\x2', '\x2', '\x2', '\xC0', '\x9F3', 
		'\x3', '\x2', '\x2', '\x2', '\xC2', '\x9F9', '\x3', '\x2', '\x2', '\x2', 
		'\xC4', '\x9FC', '\x3', '\x2', '\x2', '\x2', '\xC6', '\x9FF', '\x3', '\x2', 
		'\x2', '\x2', '\xC8', '\xA02', '\x3', '\x2', '\x2', '\x2', '\xCA', '\xA38', 
		'\x3', '\x2', '\x2', '\x2', '\xCC', '\xA3A', '\x3', '\x2', '\x2', '\x2', 
		'\xCE', '\xA45', '\x3', '\x2', '\x2', '\x2', '\xD0', '\xA4D', '\x3', '\x2', 
		'\x2', '\x2', '\xD2', '\xA58', '\x3', '\x2', '\x2', '\x2', '\xD4', '\xA5A', 
		'\x3', '\x2', '\x2', '\x2', '\xD6', '\xA5F', '\x3', '\x2', '\x2', '\x2', 
		'\xD8', '\xA67', '\x3', '\x2', '\x2', '\x2', '\xDA', '\xA7E', '\x3', '\x2', 
		'\x2', '\x2', '\xDC', '\xA95', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xAC7', 
		'\x3', '\x2', '\x2', '\x2', '\xE0', '\xACB', '\x3', '\x2', '\x2', '\x2', 
		'\xE2', '\xAEA', '\x3', '\x2', '\x2', '\x2', '\xE4', '\xAEC', '\x3', '\x2', 
		'\x2', '\x2', '\xE6', '\xB03', '\x3', '\x2', '\x2', '\x2', '\xE8', '\xB2D', 
		'\x3', '\x2', '\x2', '\x2', '\xEA', '\xB34', '\x3', '\x2', '\x2', '\x2', 
		'\xEC', '\xB45', '\x3', '\x2', '\x2', '\x2', '\xEE', '\xB4E', '\x3', '\x2', 
		'\x2', '\x2', '\xF0', '\xB61', '\x3', '\x2', '\x2', '\x2', '\xF2', '\xB65', 
		'\x3', '\x2', '\x2', '\x2', '\xF4', '\xB84', '\x3', '\x2', '\x2', '\x2', 
		'\xF6', '\xB86', '\x3', '\x2', '\x2', '\x2', '\xF8', '\xB97', '\x3', '\x2', 
		'\x2', '\x2', '\xFA', '\xBA7', '\x3', '\x2', '\x2', '\x2', '\xFC', '\xBBB', 
		'\x3', '\x2', '\x2', '\x2', '\xFE', '\xBCD', '\x3', '\x2', '\x2', '\x2', 
		'\x100', '\xBD0', '\x3', '\x2', '\x2', '\x2', '\x102', '\xBDD', '\x3', 
		'\x2', '\x2', '\x2', '\x104', '\xBDF', '\x3', '\x2', '\x2', '\x2', '\x106', 
		'\xC04', '\x3', '\x2', '\x2', '\x2', '\x108', '\xC0B', '\x3', '\x2', '\x2', 
		'\x2', '\x10A', '\xC2F', '\x3', '\x2', '\x2', '\x2', '\x10C', '\xC7A', 
		'\x3', '\x2', '\x2', '\x2', '\x10E', '\xC7D', '\x3', '\x2', '\x2', '\x2', 
		'\x110', '\xCA6', '\x3', '\x2', '\x2', '\x2', '\x112', '\xCA8', '\x3', 
		'\x2', '\x2', '\x2', '\x114', '\xCAA', '\x3', '\x2', '\x2', '\x2', '\x116', 
		'\xCAD', '\x3', '\x2', '\x2', '\x2', '\x118', '\xCB1', '\x3', '\x2', '\x2', 
		'\x2', '\x11A', '\xCC7', '\x3', '\x2', '\x2', '\x2', '\x11C', '\xCD3', 
		'\x3', '\x2', '\x2', '\x2', '\x11E', '\xCDC', '\x3', '\x2', '\x2', '\x2', 
		'\x120', '\xCE2', '\x3', '\x2', '\x2', '\x2', '\x122', '\xCF0', '\x3', 
		'\x2', '\x2', '\x2', '\x124', '\xCFD', '\x3', '\x2', '\x2', '\x2', '\x126', 
		'\xCFF', '\x3', '\x2', '\x2', '\x2', '\x128', '\xD02', '\x3', '\x2', '\x2', 
		'\x2', '\x12A', '\xD13', '\x3', '\x2', '\x2', '\x2', '\x12C', '\xD30', 
		'\x3', '\x2', '\x2', '\x2', '\x12E', '\xD34', '\x3', '\x2', '\x2', '\x2', 
		'\x130', '\xD3B', '\x3', '\x2', '\x2', '\x2', '\x132', '\xD41', '\x3', 
		'\x2', '\x2', '\x2', '\x134', '\xD43', '\x3', '\x2', '\x2', '\x2', '\x136', 
		'\xD77', '\x3', '\x2', '\x2', '\x2', '\x138', '\xD79', '\x3', '\x2', '\x2', 
		'\x2', '\x13A', '\xD7B', '\x3', '\x2', '\x2', '\x2', '\x13C', '\xD7D', 
		'\x3', '\x2', '\x2', '\x2', '\x13E', '\xD7F', '\x3', '\x2', '\x2', '\x2', 
		'\x140', '\xD85', '\x3', '\x2', '\x2', '\x2', '\x142', '\xD87', '\x3', 
		'\x2', '\x2', '\x2', '\x144', '\xD95', '\x3', '\x2', '\x2', '\x2', '\x146', 
		'\xDA0', '\x3', '\x2', '\x2', '\x2', '\x148', '\xDAC', '\x3', '\x2', '\x2', 
		'\x2', '\x14A', '\xDAE', '\x3', '\x2', '\x2', '\x2', '\x14C', '\xDB2', 
		'\x3', '\x2', '\x2', '\x2', '\x14E', '\xDBD', '\x3', '\x2', '\x2', '\x2', 
		'\x150', '\xDD5', '\x3', '\x2', '\x2', '\x2', '\x152', '\xDD8', '\x3', 
		'\x2', '\x2', '\x2', '\x154', '\xDDA', '\x3', '\x2', '\x2', '\x2', '\x156', 
		'\xDE5', '\x3', '\x2', '\x2', '\x2', '\x158', '\xDEA', '\x3', '\x2', '\x2', 
		'\x2', '\x15A', '\xDED', '\x3', '\x2', '\x2', '\x2', '\x15C', '\xDF8', 
		'\x3', '\x2', '\x2', '\x2', '\x15E', '\xDFC', '\x3', '\x2', '\x2', '\x2', 
		'\x160', '\xE07', '\x3', '\x2', '\x2', '\x2', '\x162', '\xE0A', '\x3', 
		'\x2', '\x2', '\x2', '\x164', '\xE10', '\x3', '\x2', '\x2', '\x2', '\x166', 
		'\xE17', '\x3', '\x2', '\x2', '\x2', '\x168', '\xE23', '\x3', '\x2', '\x2', 
		'\x2', '\x16A', '\xE3C', '\x3', '\x2', '\x2', '\x2', '\x16C', '\xE48', 
		'\x3', '\x2', '\x2', '\x2', '\x16E', '\xE4D', '\x3', '\x2', '\x2', '\x2', 
		'\x170', '\xE54', '\x3', '\x2', '\x2', '\x2', '\x172', '\xE61', '\x3', 
		'\x2', '\x2', '\x2', '\x174', '\xE70', '\x3', '\x2', '\x2', '\x2', '\x176', 
		'\xE80', '\x3', '\x2', '\x2', '\x2', '\x178', '\xE83', '\x3', '\x2', '\x2', 
		'\x2', '\x17A', '\xEBA', '\x3', '\x2', '\x2', '\x2', '\x17C', '\xEBC', 
		'\x3', '\x2', '\x2', '\x2', '\x17E', '\xEC0', '\x3', '\x2', '\x2', '\x2', 
		'\x180', '\xECA', '\x3', '\x2', '\x2', '\x2', '\x182', '\xECE', '\x3', 
		'\x2', '\x2', '\x2', '\x184', '\xEE0', '\x3', '\x2', '\x2', '\x2', '\x186', 
		'\xEE2', '\x3', '\x2', '\x2', '\x2', '\x188', '\xEEB', '\x3', '\x2', '\x2', 
		'\x2', '\x18A', '\xEF7', '\x3', '\x2', '\x2', '\x2', '\x18C', '\xEF9', 
		'\x3', '\x2', '\x2', '\x2', '\x18E', '\xF18', '\x3', '\x2', '\x2', '\x2', 
		'\x190', '\xF1A', '\x3', '\x2', '\x2', '\x2', '\x192', '\xF3A', '\x3', 
		'\x2', '\x2', '\x2', '\x194', '\xF52', '\x3', '\x2', '\x2', '\x2', '\x196', 
		'\xF54', '\x3', '\x2', '\x2', '\x2', '\x198', '\xF5E', '\x3', '\x2', '\x2', 
		'\x2', '\x19A', '\xF7B', '\x3', '\x2', '\x2', '\x2', '\x19C', '\xF93', 
		'\x3', '\x2', '\x2', '\x2', '\x19E', '\xFA5', '\x3', '\x2', '\x2', '\x2', 
		'\x1A0', '\xFC3', '\x3', '\x2', '\x2', '\x2', '\x1A2', '\xFD0', '\x3', 
		'\x2', '\x2', '\x2', '\x1A4', '\xFE1', '\x3', '\x2', '\x2', '\x2', '\x1A6', 
		'\x1003', '\x3', '\x2', '\x2', '\x2', '\x1A8', '\x1025', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA', '\x1030', '\x3', '\x2', '\x2', '\x2', '\x1AC', 
		'\x103B', '\x3', '\x2', '\x2', '\x2', '\x1AE', '\x1045', '\x3', '\x2', 
		'\x2', '\x2', '\x1B0', '\x1057', '\x3', '\x2', '\x2', '\x2', '\x1B2', 
		'\x1077', '\x3', '\x2', '\x2', '\x2', '\x1B4', '\x1097', '\x3', '\x2', 
		'\x2', '\x2', '\x1B6', '\x1099', '\x3', '\x2', '\x2', '\x2', '\x1B8', 
		'\x109F', '\x3', '\x2', '\x2', '\x2', '\x1BA', '\x10A5', '\x3', '\x2', 
		'\x2', '\x2', '\x1BC', '\x10BA', '\x3', '\x2', '\x2', '\x2', '\x1BE', 
		'\x10DA', '\x3', '\x2', '\x2', '\x2', '\x1C0', '\x10EA', '\x3', '\x2', 
		'\x2', '\x2', '\x1C2', '\x10F8', '\x3', '\x2', '\x2', '\x2', '\x1C4', 
		'\x1110', '\x3', '\x2', '\x2', '\x2', '\x1C6', '\x1112', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8', '\x114B', '\x3', '\x2', '\x2', '\x2', '\x1CA', 
		'\x114D', '\x3', '\x2', '\x2', '\x2', '\x1CC', '\x1156', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE', '\x1166', '\x3', '\x2', '\x2', '\x2', '\x1D0', 
		'\x119C', '\x3', '\x2', '\x2', '\x2', '\x1D2', '\x119E', '\x3', '\x2', 
		'\x2', '\x2', '\x1D4', '\x11BB', '\x3', '\x2', '\x2', '\x2', '\x1D6', 
		'\x11BD', '\x3', '\x2', '\x2', '\x2', '\x1D8', '\x11C5', '\x3', '\x2', 
		'\x2', '\x2', '\x1DA', '\x11CC', '\x3', '\x2', '\x2', '\x2', '\x1DC', 
		'\x11F4', '\x3', '\x2', '\x2', '\x2', '\x1DE', '\x11F6', '\x3', '\x2', 
		'\x2', '\x2', '\x1E0', '\x1204', '\x3', '\x2', '\x2', '\x2', '\x1E2', 
		'\x121F', '\x3', '\x2', '\x2', '\x2', '\x1E4', '\x1227', '\x3', '\x2', 
		'\x2', '\x2', '\x1E6', '\x122E', '\x3', '\x2', '\x2', '\x2', '\x1E8', 
		'\x1232', '\x3', '\x2', '\x2', '\x2', '\x1EA', '\x1238', '\x3', '\x2', 
		'\x2', '\x2', '\x1EC', '\x123C', '\x3', '\x2', '\x2', '\x2', '\x1EE', 
		'\x123F', '\x3', '\x2', '\x2', '\x2', '\x1F0', '\x125B', '\x3', '\x2', 
		'\x2', '\x2', '\x1F2', '\x125F', '\x3', '\x2', '\x2', '\x2', '\x1F4', 
		'\x127C', '\x3', '\x2', '\x2', '\x2', '\x1F6', '\x129D', '\x3', '\x2', 
		'\x2', '\x2', '\x1F8', '\x129F', '\x3', '\x2', '\x2', '\x2', '\x1FA', 
		'\x12A2', '\x3', '\x2', '\x2', '\x2', '\x1FC', '\x12C2', '\x3', '\x2', 
		'\x2', '\x2', '\x1FE', '\x12C4', '\x3', '\x2', '\x2', '\x2', '\x200', 
		'\x12F4', '\x3', '\x2', '\x2', '\x2', '\x202', '\x1317', '\x3', '\x2', 
		'\x2', '\x2', '\x204', '\x1319', '\x3', '\x2', '\x2', '\x2', '\x206', 
		'\x1322', '\x3', '\x2', '\x2', '\x2', '\x208', '\x1328', '\x3', '\x2', 
		'\x2', '\x2', '\x20A', '\x1337', '\x3', '\x2', '\x2', '\x2', '\x20C', 
		'\x1346', '\x3', '\x2', '\x2', '\x2', '\x20E', '\x134B', '\x3', '\x2', 
		'\x2', '\x2', '\x210', '\x1355', '\x3', '\x2', '\x2', '\x2', '\x212', 
		'\x1357', '\x3', '\x2', '\x2', '\x2', '\x214', '\x1377', '\x3', '\x2', 
		'\x2', '\x2', '\x216', '\x137B', '\x3', '\x2', '\x2', '\x2', '\x218', 
		'\x1398', '\x3', '\x2', '\x2', '\x2', '\x21A', '\x13B4', '\x3', '\x2', 
		'\x2', '\x2', '\x21C', '\x13B6', '\x3', '\x2', '\x2', '\x2', '\x21E', 
		'\x13BA', '\x3', '\x2', '\x2', '\x2', '\x220', '\x13BF', '\x3', '\x2', 
		'\x2', '\x2', '\x222', '\x13C8', '\x3', '\x2', '\x2', '\x2', '\x224', 
		'\x13E5', '\x3', '\x2', '\x2', '\x2', '\x226', '\x13EC', '\x3', '\x2', 
		'\x2', '\x2', '\x228', '\x13F5', '\x3', '\x2', '\x2', '\x2', '\x22A', 
		'\x1400', '\x3', '\x2', '\x2', '\x2', '\x22C', '\x1407', '\x3', '\x2', 
		'\x2', '\x2', '\x22E', '\x140B', '\x3', '\x2', '\x2', '\x2', '\x230', 
		'\x140F', '\x3', '\x2', '\x2', '\x2', '\x232', '\x1413', '\x3', '\x2', 
		'\x2', '\x2', '\x234', '\x1418', '\x3', '\x2', '\x2', '\x2', '\x236', 
		'\x1424', '\x3', '\x2', '\x2', '\x2', '\x238', '\x1427', '\x3', '\x2', 
		'\x2', '\x2', '\x23A', '\x142D', '\x3', '\x2', '\x2', '\x2', '\x23C', 
		'\x143C', '\x3', '\x2', '\x2', '\x2', '\x23E', '\x143F', '\x3', '\x2', 
		'\x2', '\x2', '\x240', '\x1443', '\x3', '\x2', '\x2', '\x2', '\x242', 
		'\x1448', '\x3', '\x2', '\x2', '\x2', '\x244', '\x144C', '\x3', '\x2', 
		'\x2', '\x2', '\x246', '\x145D', '\x3', '\x2', '\x2', '\x2', '\x248', 
		'\x1463', '\x3', '\x2', '\x2', '\x2', '\x24A', '\x146D', '\x3', '\x2', 
		'\x2', '\x2', '\x24C', '\x147A', '\x3', '\x2', '\x2', '\x2', '\x24E', 
		'\x147E', '\x3', '\x2', '\x2', '\x2', '\x250', '\x148C', '\x3', '\x2', 
		'\x2', '\x2', '\x252', '\x148E', '\x3', '\x2', '\x2', '\x2', '\x254', 
		'\x149C', '\x3', '\x2', '\x2', '\x2', '\x256', '\x14AD', '\x3', '\x2', 
		'\x2', '\x2', '\x258', '\x14C6', '\x3', '\x2', '\x2', '\x2', '\x25A', 
		'\x14D0', '\x3', '\x2', '\x2', '\x2', '\x25C', '\x14D4', '\x3', '\x2', 
		'\x2', '\x2', '\x25E', '\x14F7', '\x3', '\x2', '\x2', '\x2', '\x260', 
		'\x1502', '\x3', '\x2', '\x2', '\x2', '\x262', '\x1508', '\x3', '\x2', 
		'\x2', '\x2', '\x264', '\x1512', '\x3', '\x2', '\x2', '\x2', '\x266', 
		'\x1519', '\x3', '\x2', '\x2', '\x2', '\x268', '\x1524', '\x3', '\x2', 
		'\x2', '\x2', '\x26A', '\x1530', '\x3', '\x2', '\x2', '\x2', '\x26C', 
		'\x153F', '\x3', '\x2', '\x2', '\x2', '\x26E', '\x1543', '\x3', '\x2', 
		'\x2', '\x2', '\x270', '\x155D', '\x3', '\x2', '\x2', '\x2', '\x272', 
		'\x1560', '\x3', '\x2', '\x2', '\x2', '\x274', '\x1566', '\x3', '\x2', 
		'\x2', '\x2', '\x276', '\x156B', '\x3', '\x2', '\x2', '\x2', '\x278', 
		'\x1573', '\x3', '\x2', '\x2', '\x2', '\x27A', '\x157B', '\x3', '\x2', 
		'\x2', '\x2', '\x27C', '\x157E', '\x3', '\x2', '\x2', '\x2', '\x27E', 
		'\x158E', '\x3', '\x2', '\x2', '\x2', '\x280', '\x1593', '\x3', '\x2', 
		'\x2', '\x2', '\x282', '\x1597', '\x3', '\x2', '\x2', '\x2', '\x284', 
		'\x15BF', '\x3', '\x2', '\x2', '\x2', '\x286', '\x15C1', '\x3', '\x2', 
		'\x2', '\x2', '\x288', '\x15D7', '\x3', '\x2', '\x2', '\x2', '\x28A', 
		'\x15D9', '\x3', '\x2', '\x2', '\x2', '\x28C', '\x15DE', '\x3', '\x2', 
		'\x2', '\x2', '\x28E', '\x15E0', '\x3', '\x2', '\x2', '\x2', '\x290', 
		'\x15E2', '\x3', '\x2', '\x2', '\x2', '\x292', '\x15E4', '\x3', '\x2', 
		'\x2', '\x2', '\x294', '\x15E8', '\x3', '\x2', '\x2', '\x2', '\x296', 
		'\x15ED', '\x3', '\x2', '\x2', '\x2', '\x298', '\x15F6', '\x3', '\x2', 
		'\x2', '\x2', '\x29A', '\x15FC', '\x3', '\x2', '\x2', '\x2', '\x29C', 
		'\x160A', '\x3', '\x2', '\x2', '\x2', '\x29E', '\x161E', '\x3', '\x2', 
		'\x2', '\x2', '\x2A0', '\x1623', '\x3', '\x2', '\x2', '\x2', '\x2A2', 
		'\x1630', '\x3', '\x2', '\x2', '\x2', '\x2A4', '\x1632', '\x3', '\x2', 
		'\x2', '\x2', '\x2A6', '\x1640', '\x3', '\x2', '\x2', '\x2', '\x2A8', 
		'\x1649', '\x3', '\x2', '\x2', '\x2', '\x2AA', '\x164F', '\x3', '\x2', 
		'\x2', '\x2', '\x2AC', '\x1651', '\x3', '\x2', '\x2', '\x2', '\x2AE', 
		'\x1654', '\x3', '\x2', '\x2', '\x2', '\x2B0', '\x165D', '\x3', '\x2', 
		'\x2', '\x2', '\x2B2', '\x1675', '\x3', '\x2', '\x2', '\x2', '\x2B4', 
		'\x1684', '\x3', '\x2', '\x2', '\x2', '\x2B6', '\x1686', '\x3', '\x2', 
		'\x2', '\x2', '\x2B8', '\x169B', '\x3', '\x2', '\x2', '\x2', '\x2BA', 
		'\x16AA', '\x3', '\x2', '\x2', '\x2', '\x2BC', '\x16C0', '\x3', '\x2', 
		'\x2', '\x2', '\x2BE', '\x16C7', '\x3', '\x2', '\x2', '\x2', '\x2C0', 
		'\x16D4', '\x3', '\x2', '\x2', '\x2', '\x2C2', '\x16D7', '\x3', '\x2', 
		'\x2', '\x2', '\x2C4', '\x16EC', '\x3', '\x2', '\x2', '\x2', '\x2C6', 
		'\x16F6', '\x3', '\x2', '\x2', '\x2', '\x2C8', '\x16FF', '\x3', '\x2', 
		'\x2', '\x2', '\x2CA', '\x1710', '\x3', '\x2', '\x2', '\x2', '\x2CC', 
		'\x173B', '\x3', '\x2', '\x2', '\x2', '\x2CE', '\x1749', '\x3', '\x2', 
		'\x2', '\x2', '\x2D0', '\x1751', '\x3', '\x2', '\x2', '\x2', '\x2D2', 
		'\x1755', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x1774', '\x3', '\x2', 
		'\x2', '\x2', '\x2D6', '\x1778', '\x3', '\x2', '\x2', '\x2', '\x2D8', 
		'\x1785', '\x3', '\x2', '\x2', '\x2', '\x2DA', '\x178B', '\x3', '\x2', 
		'\x2', '\x2', '\x2DC', '\x178F', '\x3', '\x2', '\x2', '\x2', '\x2DE', 
		'\x179A', '\x3', '\x2', '\x2', '\x2', '\x2E0', '\x17BB', '\x3', '\x2', 
		'\x2', '\x2', '\x2E2', '\x17BE', '\x3', '\x2', '\x2', '\x2', '\x2E4', 
		'\x17D3', '\x3', '\x2', '\x2', '\x2', '\x2E6', '\x17D6', '\x3', '\x2', 
		'\x2', '\x2', '\x2E8', '\x17D9', '\x3', '\x2', '\x2', '\x2', '\x2EA', 
		'\x17DD', '\x3', '\x2', '\x2', '\x2', '\x2EC', '\x17F0', '\x3', '\x2', 
		'\x2', '\x2', '\x2EE', '\x17F2', '\x3', '\x2', '\x2', '\x2', '\x2F0', 
		'\x1803', '\x3', '\x2', '\x2', '\x2', '\x2F2', '\x180A', '\x3', '\x2', 
		'\x2', '\x2', '\x2F4', '\x180F', '\x3', '\x2', '\x2', '\x2', '\x2F6', 
		'\x1826', '\x3', '\x2', '\x2', '\x2', '\x2F8', '\x1830', '\x3', '\x2', 
		'\x2', '\x2', '\x2FA', '\x1832', '\x3', '\x2', '\x2', '\x2', '\x2FC', 
		'\x1840', '\x3', '\x2', '\x2', '\x2', '\x2FE', '\x184E', '\x3', '\x2', 
		'\x2', '\x2', '\x300', '\x1872', '\x3', '\x2', '\x2', '\x2', '\x302', 
		'\x1874', '\x3', '\x2', '\x2', '\x2', '\x304', '\x1892', '\x3', '\x2', 
		'\x2', '\x2', '\x306', '\x1897', '\x3', '\x2', '\x2', '\x2', '\x308', 
		'\x1899', '\x3', '\x2', '\x2', '\x2', '\x30A', '\x18A5', '\x3', '\x2', 
		'\x2', '\x2', '\x30C', '\x18B9', '\x3', '\x2', '\x2', '\x2', '\x30E', 
		'\x18BB', '\x3', '\x2', '\x2', '\x2', '\x310', '\x18BE', '\x3', '\x2', 
		'\x2', '\x2', '\x312', '\x18D8', '\x3', '\x2', '\x2', '\x2', '\x314', 
		'\x18DA', '\x3', '\x2', '\x2', '\x2', '\x316', '\x18DE', '\x3', '\x2', 
		'\x2', '\x2', '\x318', '\x18ED', '\x3', '\x2', '\x2', '\x2', '\x31A', 
		'\x18F9', '\x3', '\x2', '\x2', '\x2', '\x31C', '\x1901', '\x3', '\x2', 
		'\x2', '\x2', '\x31E', '\x1905', '\x3', '\x2', '\x2', '\x2', '\x320', 
		'\x1912', '\x3', '\x2', '\x2', '\x2', '\x322', '\x1918', '\x3', '\x2', 
		'\x2', '\x2', '\x324', '\x1926', '\x3', '\x2', '\x2', '\x2', '\x326', 
		'\x193A', '\x3', '\x2', '\x2', '\x2', '\x328', '\x1943', '\x3', '\x2', 
		'\x2', '\x2', '\x32A', '\x1945', '\x3', '\x2', '\x2', '\x2', '\x32C', 
		'\x194C', '\x3', '\x2', '\x2', '\x2', '\x32E', '\x1951', '\x3', '\x2', 
		'\x2', '\x2', '\x330', '\x195E', '\x3', '\x2', '\x2', '\x2', '\x332', 
		'\x1966', '\x3', '\x2', '\x2', '\x2', '\x334', '\x196E', '\x3', '\x2', 
		'\x2', '\x2', '\x336', '\x1976', '\x3', '\x2', '\x2', '\x2', '\x338', 
		'\x1978', '\x3', '\x2', '\x2', '\x2', '\x33A', '\x1984', '\x3', '\x2', 
		'\x2', '\x2', '\x33C', '\x199E', '\x3', '\x2', '\x2', '\x2', '\x33E', 
		'\x19A0', '\x3', '\x2', '\x2', '\x2', '\x340', '\x19AE', '\x3', '\x2', 
		'\x2', '\x2', '\x342', '\x19B3', '\x3', '\x2', '\x2', '\x2', '\x344', 
		'\x19C5', '\x3', '\x2', '\x2', '\x2', '\x346', '\x19C9', '\x3', '\x2', 
		'\x2', '\x2', '\x348', '\x19D1', '\x3', '\x2', '\x2', '\x2', '\x34A', 
		'\x19DB', '\x3', '\x2', '\x2', '\x2', '\x34C', '\x19E3', '\x3', '\x2', 
		'\x2', '\x2', '\x34E', '\x19E9', '\x3', '\x2', '\x2', '\x2', '\x350', 
		'\x19EE', '\x3', '\x2', '\x2', '\x2', '\x352', '\x19F5', '\x3', '\x2', 
		'\x2', '\x2', '\x354', '\x1A0E', '\x3', '\x2', '\x2', '\x2', '\x356', 
		'\x1A21', '\x3', '\x2', '\x2', '\x2', '\x358', '\x1A25', '\x3', '\x2', 
		'\x2', '\x2', '\x35A', '\x1A28', '\x3', '\x2', '\x2', '\x2', '\x35C', 
		'\x1A3E', '\x3', '\x2', '\x2', '\x2', '\x35E', '\x1A43', '\x3', '\x2', 
		'\x2', '\x2', '\x360', '\x1A56', '\x3', '\x2', '\x2', '\x2', '\x362', 
		'\x1A58', '\x3', '\x2', '\x2', '\x2', '\x364', '\x1A68', '\x3', '\x2', 
		'\x2', '\x2', '\x366', '\x1A70', '\x3', '\x2', '\x2', '\x2', '\x368', 
		'\x1A75', '\x3', '\x2', '\x2', '\x2', '\x36A', '\x1A79', '\x3', '\x2', 
		'\x2', '\x2', '\x36C', '\x1A84', '\x3', '\x2', '\x2', '\x2', '\x36E', 
		'\x1A87', '\x3', '\x2', '\x2', '\x2', '\x370', '\x1A99', '\x3', '\x2', 
		'\x2', '\x2', '\x372', '\x1A9B', '\x3', '\x2', '\x2', '\x2', '\x374', 
		'\x1AAA', '\x3', '\x2', '\x2', '\x2', '\x376', '\x1AB5', '\x3', '\x2', 
		'\x2', '\x2', '\x378', '\x1AC3', '\x3', '\x2', '\x2', '\x2', '\x37A', 
		'\x1AC8', '\x3', '\x2', '\x2', '\x2', '\x37C', '\x1ACA', '\x3', '\x2', 
		'\x2', '\x2', '\x37E', '\x1AD5', '\x3', '\x2', '\x2', '\x2', '\x380', 
		'\x1AD7', '\x3', '\x2', '\x2', '\x2', '\x382', '\x1B04', '\x3', '\x2', 
		'\x2', '\x2', '\x384', '\x1B11', '\x3', '\x2', '\x2', '\x2', '\x386', 
		'\x1B19', '\x3', '\x2', '\x2', '\x2', '\x388', '\x1B39', '\x3', '\x2', 
		'\x2', '\x2', '\x38A', '\x1B3B', '\x3', '\x2', '\x2', '\x2', '\x38C', 
		'\x1B4D', '\x3', '\x2', '\x2', '\x2', '\x38E', '\x1B76', '\x3', '\x2', 
		'\x2', '\x2', '\x390', '\x1B78', '\x3', '\x2', '\x2', '\x2', '\x392', 
		'\x1B91', '\x3', '\x2', '\x2', '\x2', '\x394', '\x1B93', '\x3', '\x2', 
		'\x2', '\x2', '\x396', '\x1BAF', '\x3', '\x2', '\x2', '\x2', '\x398', 
		'\x1BC8', '\x3', '\x2', '\x2', '\x2', '\x39A', '\x1BCA', '\x3', '\x2', 
		'\x2', '\x2', '\x39C', '\x1BDF', '\x3', '\x2', '\x2', '\x2', '\x39E', 
		'\x1BFD', '\x3', '\x2', '\x2', '\x2', '\x3A0', '\x1C01', '\x3', '\x2', 
		'\x2', '\x2', '\x3A2', '\x1C04', '\x3', '\x2', '\x2', '\x2', '\x3A4', 
		'\x1C17', '\x3', '\x2', '\x2', '\x2', '\x3A6', '\x1C1F', '\x3', '\x2', 
		'\x2', '\x2', '\x3A8', '\x1C31', '\x3', '\x2', '\x2', '\x2', '\x3AA', 
		'\x1C38', '\x3', '\x2', '\x2', '\x2', '\x3AC', '\x1C50', '\x3', '\x2', 
		'\x2', '\x2', '\x3AE', '\x1C52', '\x3', '\x2', '\x2', '\x2', '\x3B0', 
		'\x1C6D', '\x3', '\x2', '\x2', '\x2', '\x3B2', '\x1CA5', '\x3', '\x2', 
		'\x2', '\x2', '\x3B4', '\x1CA7', '\x3', '\x2', '\x2', '\x2', '\x3B6', 
		'\x1CE6', '\x3', '\x2', '\x2', '\x2', '\x3B8', '\x1CE8', '\x3', '\x2', 
		'\x2', '\x2', '\x3BA', '\x1E3B', '\x3', '\x2', '\x2', '\x2', '\x3BC', 
		'\x1E3D', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x1E3F', '\x3', '\x2', 
		'\x2', '\x2', '\x3C0', '\x1E41', '\x3', '\x2', '\x2', '\x2', '\x3C2', 
		'\x1E43', '\x3', '\x2', '\x2', '\x2', '\x3C4', '\x1E50', '\x3', '\x2', 
		'\x2', '\x2', '\x3C6', '\x1E59', '\x3', '\x2', '\x2', '\x2', '\x3C8', 
		'\x1E62', '\x3', '\x2', '\x2', '\x2', '\x3CA', '\x1E64', '\x3', '\x2', 
		'\x2', '\x2', '\x3CC', '\x1E75', '\x3', '\x2', '\x2', '\x2', '\x3CE', 
		'\x1E7B', '\x3', '\x2', '\x2', '\x2', '\x3D0', '\x1E86', '\x3', '\x2', 
		'\x2', '\x2', '\x3D2', '\x1E88', '\x3', '\x2', '\x2', '\x2', '\x3D4', 
		'\x1EA0', '\x3', '\x2', '\x2', '\x2', '\x3D6', '\x1EAE', '\x3', '\x2', 
		'\x2', '\x2', '\x3D8', '\x1EC0', '\x3', '\x2', '\x2', '\x2', '\x3DA', 
		'\x1ED5', '\x3', '\x2', '\x2', '\x2', '\x3DC', '\x1EE2', '\x3', '\x2', 
		'\x2', '\x2', '\x3DE', '\x1EE5', '\x3', '\x2', '\x2', '\x2', '\x3E0', 
		'\x1EEE', '\x3', '\x2', '\x2', '\x2', '\x3E2', '\x1EF4', '\x3', '\x2', 
		'\x2', '\x2', '\x3E4', '\x1EFC', '\x3', '\x2', '\x2', '\x2', '\x3E6', 
		'\x1EFF', '\x3', '\x2', '\x2', '\x2', '\x3E8', '\x1F0A', '\x3', '\x2', 
		'\x2', '\x2', '\x3EA', '\x1F15', '\x3', '\x2', '\x2', '\x2', '\x3EC', 
		'\x1F17', '\x3', '\x2', '\x2', '\x2', '\x3EE', '\x1F1A', '\x3', '\x2', 
		'\x2', '\x2', '\x3F0', '\x1F23', '\x3', '\x2', '\x2', '\x2', '\x3F2', 
		'\x1F28', '\x3', '\x2', '\x2', '\x2', '\x3F4', '\x1F35', '\x3', '\x2', 
		'\x2', '\x2', '\x3F6', '\x1F37', '\x3', '\x2', '\x2', '\x2', '\x3F8', 
		'\x1F40', '\x3', '\x2', '\x2', '\x2', '\x3FA', '\x1F52', '\x3', '\x2', 
		'\x2', '\x2', '\x3FC', '\x1F56', '\x3', '\x2', '\x2', '\x2', '\x3FE', 
		'\x1F58', '\x3', '\x2', '\x2', '\x2', '\x400', '\x1F61', '\x3', '\x2', 
		'\x2', '\x2', '\x402', '\x1F6E', '\x3', '\x2', '\x2', '\x2', '\x404', 
		'\x1F70', '\x3', '\x2', '\x2', '\x2', '\x406', '\x1F75', '\x3', '\x2', 
		'\x2', '\x2', '\x408', '\x1F77', '\x3', '\x2', '\x2', '\x2', '\x40A', 
		'\x1F7D', '\x3', '\x2', '\x2', '\x2', '\x40C', '\x1F7F', '\x3', '\x2', 
		'\x2', '\x2', '\x40E', '\x1F8E', '\x3', '\x2', '\x2', '\x2', '\x410', 
		'\x1F92', '\x3', '\x2', '\x2', '\x2', '\x412', '\x1F96', '\x3', '\x2', 
		'\x2', '\x2', '\x414', '\x1F98', '\x3', '\x2', '\x2', '\x2', '\x416', 
		'\x1F9A', '\x3', '\x2', '\x2', '\x2', '\x418', '\x1FA0', '\x3', '\x2', 
		'\x2', '\x2', '\x41A', '\x1FA2', '\x3', '\x2', '\x2', '\x2', '\x41C', 
		'\x1FA4', '\x3', '\x2', '\x2', '\x2', '\x41E', '\x1FA6', '\x3', '\x2', 
		'\x2', '\x2', '\x420', '\x1FA8', '\x3', '\x2', '\x2', '\x2', '\x422', 
		'\x1FAA', '\x3', '\x2', '\x2', '\x2', '\x424', '\x1FAC', '\x3', '\x2', 
		'\x2', '\x2', '\x426', '\x1FAE', '\x3', '\x2', '\x2', '\x2', '\x428', 
		'\x1FB0', '\x3', '\x2', '\x2', '\x2', '\x42A', '\x1FB2', '\x3', '\x2', 
		'\x2', '\x2', '\x42C', '\x1FB4', '\x3', '\x2', '\x2', '\x2', '\x42E', 
		'\x1FB6', '\x3', '\x2', '\x2', '\x2', '\x430', '\x1FB8', '\x3', '\x2', 
		'\x2', '\x2', '\x432', '\x1FBA', '\x3', '\x2', '\x2', '\x2', '\x434', 
		'\x1FBC', '\x3', '\x2', '\x2', '\x2', '\x436', '\x1FC1', '\x3', '\x2', 
		'\x2', '\x2', '\x438', '\x1FC3', '\x3', '\x2', '\x2', '\x2', '\x43A', 
		'\x1FC5', '\x3', '\x2', '\x2', '\x2', '\x43C', '\x1FC7', '\x3', '\x2', 
		'\x2', '\x2', '\x43E', '\x1FC9', '\x3', '\x2', '\x2', '\x2', '\x440', 
		'\x1FCB', '\x3', '\x2', '\x2', '\x2', '\x442', '\x1FCD', '\x3', '\x2', 
		'\x2', '\x2', '\x444', '\x1FCF', '\x3', '\x2', '\x2', '\x2', '\x446', 
		'\x1FE9', '\x3', '\x2', '\x2', '\x2', '\x448', '\x1FEF', '\x3', '\x2', 
		'\x2', '\x2', '\x44A', '\x1FF3', '\x3', '\x2', '\x2', '\x2', '\x44C', 
		'\x1FF7', '\x3', '\x2', '\x2', '\x2', '\x44E', '\x2000', '\x3', '\x2', 
		'\x2', '\x2', '\x450', '\x2011', '\x3', '\x2', '\x2', '\x2', '\x452', 
		'\x2038', '\x3', '\x2', '\x2', '\x2', '\x454', '\x2043', '\x3', '\x2', 
		'\x2', '\x2', '\x456', '\x2064', '\x3', '\x2', '\x2', '\x2', '\x458', 
		'\x2066', '\x3', '\x2', '\x2', '\x2', '\x45A', '\x20AD', '\x3', '\x2', 
		'\x2', '\x2', '\x45C', '\x20B2', '\x3', '\x2', '\x2', '\x2', '\x45E', 
		'\x20C5', '\x3', '\x2', '\x2', '\x2', '\x460', '\x20CF', '\x3', '\x2', 
		'\x2', '\x2', '\x462', '\x20DE', '\x3', '\x2', '\x2', '\x2', '\x464', 
		'\x2103', '\x3', '\x2', '\x2', '\x2', '\x466', '\x224B', '\x3', '\x2', 
		'\x2', '\x2', '\x468', '\x224F', '\x3', '\x2', '\x2', '\x2', '\x46A', 
		'\x2254', '\x3', '\x2', '\x2', '\x2', '\x46C', '\x2294', '\x3', '\x2', 
		'\x2', '\x2', '\x46E', '\x2298', '\x3', '\x2', '\x2', '\x2', '\x470', 
		'\x229C', '\x3', '\x2', '\x2', '\x2', '\x472', '\x229E', '\x3', '\x2', 
		'\x2', '\x2', '\x474', '\x22A0', '\x3', '\x2', '\x2', '\x2', '\x476', 
		'\x22A2', '\x3', '\x2', '\x2', '\x2', '\x478', '\x22A4', '\x3', '\x2', 
		'\x2', '\x2', '\x47A', '\x22A6', '\x3', '\x2', '\x2', '\x2', '\x47C', 
		'\x22A8', '\x3', '\x2', '\x2', '\x2', '\x47E', '\x22AA', '\x3', '\x2', 
		'\x2', '\x2', '\x480', '\x22AC', '\x3', '\x2', '\x2', '\x2', '\x482', 
		'\x22AE', '\x3', '\x2', '\x2', '\x2', '\x484', '\x22B0', '\x3', '\x2', 
		'\x2', '\x2', '\x486', '\x22B2', '\x3', '\x2', '\x2', '\x2', '\x488', 
		'\x22B4', '\x3', '\x2', '\x2', '\x2', '\x48A', '\x22B6', '\x3', '\x2', 
		'\x2', '\x2', '\x48C', '\x22BE', '\x3', '\x2', '\x2', '\x2', '\x48E', 
		'\x22C0', '\x3', '\x2', '\x2', '\x2', '\x490', '\x22C2', '\x3', '\x2', 
		'\x2', '\x2', '\x492', '\x22C6', '\x3', '\x2', '\x2', '\x2', '\x494', 
		'\x22C8', '\x3', '\x2', '\x2', '\x2', '\x496', '\x22D0', '\x3', '\x2', 
		'\x2', '\x2', '\x498', '\x22D2', '\x3', '\x2', '\x2', '\x2', '\x49A', 
		'\x22D4', '\x3', '\x2', '\x2', '\x2', '\x49C', '\x22D6', '\x3', '\x2', 
		'\x2', '\x2', '\x49E', '\x22DA', '\x3', '\x2', '\x2', '\x2', '\x4A0', 
		'\x22DC', '\x3', '\x2', '\x2', '\x2', '\x4A2', '\x22DE', '\x3', '\x2', 
		'\x2', '\x2', '\x4A4', '\x22E2', '\x3', '\x2', '\x2', '\x2', '\x4A6', 
		'\x22E9', '\x3', '\x2', '\x2', '\x2', '\x4A8', '\x22EB', '\x3', '\x2', 
		'\x2', '\x2', '\x4AA', '\x22EE', '\x3', '\x2', '\x2', '\x2', '\x4AC', 
		'\x4AF', '\x5', '\x4', '\x3', '\x2', '\x4AD', '\x4AF', '\x5', '\x3EA', 
		'\x1F6', '\x2', '\x4AE', '\x4AC', '\x3', '\x2', '\x2', '\x2', '\x4AE', 
		'\x4AD', '\x3', '\x2', '\x2', '\x2', '\x4AF', '\x4B1', '\x3', '\x2', '\x2', 
		'\x2', '\x4B0', '\x4B2', '\a', '\x304', '\x2', '\x2', '\x4B1', '\x4B0', 
		'\x3', '\x2', '\x2', '\x2', '\x4B1', '\x4B2', '\x3', '\x2', '\x2', '\x2', 
		'\x4B2', '\x4B4', '\x3', '\x2', '\x2', '\x2', '\x4B3', '\x4AE', '\x3', 
		'\x2', '\x2', '\x2', '\x4B4', '\x4B7', '\x3', '\x2', '\x2', '\x2', '\x4B5', 
		'\x4B3', '\x3', '\x2', '\x2', '\x2', '\x4B5', '\x4B6', '\x3', '\x2', '\x2', 
		'\x2', '\x4B6', '\x4B8', '\x3', '\x2', '\x2', '\x2', '\x4B7', '\x4B5', 
		'\x3', '\x2', '\x2', '\x2', '\x4B8', '\x4B9', '\a', '\x2', '\x2', '\x3', 
		'\x4B9', '\x3', '\x3', '\x2', '\x2', '\x2', '\x4BA', '\x4DF', '\x5', '\x2B4', 
		'\x15B', '\x2', '\x4BB', '\x4DF', '\x5', '\b', '\x5', '\x2', '\x4BC', 
		'\x4DF', '\x5', '\x18', '\r', '\x2', '\x4BD', '\x4DF', '\x5', '(', '\x15', 
		'\x2', '\x4BE', '\x4DF', '\x5', '\xA4', 'S', '\x2', '\x4BF', '\x4DF', 
		'\x5', '\x32', '\x1A', '\x2', '\x4C0', '\x4DF', '\x5', 'X', '-', '\x2', 
		'\x4C1', '\x4DF', '\x5', '\x226', '\x114', '\x2', '\x4C2', '\x4DF', '\x5', 
		'\xAC', 'W', '\x2', '\x4C3', '\x4DF', '\x5', '\xB0', 'Y', '\x2', '\x4C4', 
		'\x4DF', '\x5', '\n', '\x6', '\x2', '\x4C5', '\x4DF', '\x5', '.', '\x18', 
		'\x2', '\x4C6', '\x4DF', '\x5', '\x1A', '\xE', '\x2', '\x4C7', '\x4DF', 
		'\x5', '\x1C', '\xF', '\x2', '\x4C8', '\x4DF', '\x5', '\xAA', 'V', '\x2', 
		'\x4C9', '\x4DF', '\x5', '\x170', '\xB9', '\x2', '\x4CA', '\x4DF', '\x5', 
		'\x14C', '\xA7', '\x2', '\x4CB', '\x4DF', '\x5', '\xAE', 'X', '\x2', '\x4CC', 
		'\x4DF', '\x5', '\xA6', 'T', '\x2', '\x4CD', '\x4DF', '\x5', '\x34', '\x1B', 
		'\x2', '\x4CE', '\x4DF', '\x5', 'l', '\x37', '\x2', '\x4CF', '\x4DF', 
		'\x5', '\x222', '\x112', '\x2', '\x4D0', '\x4DF', '\x5', '\x6', '\x4', 
		'\x2', '\x4D1', '\x4DF', '\x5', '\x16', '\f', '\x2', '\x4D2', '\x4DF', 
		'\x5', '&', '\x14', '\x2', '\x4D3', '\x4DF', '\x5', '\xA2', 'R', '\x2', 
		'\x4D4', '\x4DF', '\x5', '\x30', '\x19', '\x2', '\x4D5', '\x4DF', '\x5', 
		'V', ',', '\x2', '\x4D6', '\x4DF', '\x5', '\x2A8', '\x155', '\x2', '\x4D7', 
		'\x4DF', '\x5', '\x21E', '\x110', '\x2', '\x4D8', '\x4DF', '\x5', '\xD4', 
		'k', '\x2', '\x4D9', '\x4DF', '\x5', '\x220', '\x111', '\x2', '\x4DA', 
		'\x4DF', '\x5', '\x224', '\x113', '\x2', '\x4DB', '\x4DF', '\x5', '\x23A', 
		'\x11E', '\x2', '\x4DC', '\x4DF', '\x5', '\xDC', 'o', '\x2', '\x4DD', 
		'\x4DF', '\x5', '\xD6', 'l', '\x2', '\x4DE', '\x4BA', '\x3', '\x2', '\x2', 
		'\x2', '\x4DE', '\x4BB', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4BC', 
		'\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4BD', '\x3', '\x2', '\x2', '\x2', 
		'\x4DE', '\x4BE', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4BF', '\x3', 
		'\x2', '\x2', '\x2', '\x4DE', '\x4C0', '\x3', '\x2', '\x2', '\x2', '\x4DE', 
		'\x4C1', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4C2', '\x3', '\x2', '\x2', 
		'\x2', '\x4DE', '\x4C3', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4C4', 
		'\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4C5', '\x3', '\x2', '\x2', '\x2', 
		'\x4DE', '\x4C6', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4C7', '\x3', 
		'\x2', '\x2', '\x2', '\x4DE', '\x4C8', '\x3', '\x2', '\x2', '\x2', '\x4DE', 
		'\x4C9', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4CA', '\x3', '\x2', '\x2', 
		'\x2', '\x4DE', '\x4CB', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4CC', 
		'\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4CD', '\x3', '\x2', '\x2', '\x2', 
		'\x4DE', '\x4CE', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4CF', '\x3', 
		'\x2', '\x2', '\x2', '\x4DE', '\x4D0', '\x3', '\x2', '\x2', '\x2', '\x4DE', 
		'\x4D1', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4D2', '\x3', '\x2', '\x2', 
		'\x2', '\x4DE', '\x4D3', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4D4', 
		'\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4D5', '\x3', '\x2', '\x2', '\x2', 
		'\x4DE', '\x4D6', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4D7', '\x3', 
		'\x2', '\x2', '\x2', '\x4DE', '\x4D8', '\x3', '\x2', '\x2', '\x2', '\x4DE', 
		'\x4D9', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4DA', '\x3', '\x2', '\x2', 
		'\x2', '\x4DE', '\x4DB', '\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4DC', 
		'\x3', '\x2', '\x2', '\x2', '\x4DE', '\x4DD', '\x3', '\x2', '\x2', '\x2', 
		'\x4DF', '\x5', '\x3', '\x2', '\x2', '\x2', '\x4E0', '\x4E1', '\a', '\xA5', 
		'\x2', '\x2', '\x4E1', '\x4E2', '\a', '\xE3', '\x2', '\x2', '\x4E2', '\x4E3', 
		'\x5', '\x43A', '\x21E', '\x2', '\x4E3', '\x4E4', '\a', '\x304', '\x2', 
		'\x2', '\x4E4', '\a', '\x3', '\x2', '\x2', '\x2', '\x4E5', '\x4E6', '\a', 
		'\x10', '\x2', '\x2', '\x4E6', '\x4E7', '\a', '\xE3', '\x2', '\x2', '\x4E7', 
		'\x4E8', '\x5', '\x43A', '\x21E', '\x2', '\x4E8', '\x4EA', '\a', '^', 
		'\x2', '\x2', '\x4E9', '\x4EB', '\a', '\x87', '\x2', '\x2', '\x4EA', '\x4E9', 
		'\x3', '\x2', '\x2', '\x2', '\x4EA', '\x4EB', '\x3', '\x2', '\x2', '\x2', 
		'\x4EB', '\x4EF', '\x3', '\x2', '\x2', '\x2', '\x4EC', '\x4EE', '\x5', 
		'\x23E', '\x120', '\x2', '\x4ED', '\x4EC', '\x3', '\x2', '\x2', '\x2', 
		'\x4EE', '\x4F1', '\x3', '\x2', '\x2', '\x2', '\x4EF', '\x4ED', '\x3', 
		'\x2', '\x2', '\x2', '\x4EF', '\x4F0', '\x3', '\x2', '\x2', '\x2', '\x4F0', 
		'\x4F4', '\x3', '\x2', '\x2', '\x2', '\x4F1', '\x4EF', '\x3', '\x2', '\x2', 
		'\x2', '\x4F2', '\x4F3', '\a', '\x1FD', '\x2', '\x2', '\x4F3', '\x4F5', 
		'\a', '\x225', '\x2', '\x2', '\x4F4', '\x4F2', '\x3', '\x2', '\x2', '\x2', 
		'\x4F4', '\x4F5', '\x3', '\x2', '\x2', '\x2', '\x4F5', '\x4F6', '\x3', 
		'\x2', '\x2', '\x2', '\x4F6', '\x4F7', '\a', '\x304', '\x2', '\x2', '\x4F7', 
		'\t', '\x3', '\x2', '\x2', '\x2', '\x4F8', '\x4FB', '\a', 'r', '\x2', 
		'\x2', '\x4F9', '\x4FA', '\a', '\x1A4', '\x2', '\x2', '\x4FA', '\x4FC', 
		'\a', '\x1F1', '\x2', '\x2', '\x4FB', '\x4F9', '\x3', '\x2', '\x2', '\x2', 
		'\x4FB', '\x4FC', '\x3', '\x2', '\x2', '\x2', '\x4FC', '\x4FD', '\x3', 
		'\x2', '\x2', '\x2', '\x4FD', '\x4FE', '\a', '\xE3', '\x2', '\x2', '\x4FE', 
		'\x50A', '\x5', '\x43A', '\x21E', '\x2', '\x4FF', '\x504', '\a', '\x2F2', 
		'\x2', '\x2', '\x500', '\x502', '\a', '\x2F8', '\x2', '\x2', '\x501', 
		'\x500', '\x3', '\x2', '\x2', '\x2', '\x501', '\x502', '\x3', '\x2', '\x2', 
		'\x2', '\x502', '\x503', '\x3', '\x2', '\x2', '\x2', '\x503', '\x505', 
		'\x5', '\x24A', '\x126', '\x2', '\x504', '\x501', '\x3', '\x2', '\x2', 
		'\x2', '\x505', '\x506', '\x3', '\x2', '\x2', '\x2', '\x506', '\x504', 
		'\x3', '\x2', '\x2', '\x2', '\x506', '\x507', '\x3', '\x2', '\x2', '\x2', 
		'\x507', '\x508', '\x3', '\x2', '\x2', '\x2', '\x508', '\x509', '\a', 
		'\x2F3', '\x2', '\x2', '\x509', '\x50B', '\x3', '\x2', '\x2', '\x2', '\x50A', 
		'\x4FF', '\x3', '\x2', '\x2', '\x2', '\x50A', '\x50B', '\x3', '\x2', '\x2', 
		'\x2', '\x50B', '\x50C', '\x3', '\x2', '\x2', '\x2', '\x50C', '\x50D', 
		'\a', '\x1FC', '\x2', '\x2', '\x50D', '\x514', '\x5', '\x454', '\x22B', 
		'\x2', '\x50E', '\x513', '\x5', '\x23C', '\x11F', '\x2', '\x50F', '\x513', 
		'\x5', '\f', '\a', '\x2', '\x510', '\x513', '\x5', '\x10', '\t', '\x2', 
		'\x511', '\x513', '\a', '\x98', '\x2', '\x2', '\x512', '\x50E', '\x3', 
		'\x2', '\x2', '\x2', '\x512', '\x50F', '\x3', '\x2', '\x2', '\x2', '\x512', 
		'\x510', '\x3', '\x2', '\x2', '\x2', '\x512', '\x511', '\x3', '\x2', '\x2', 
		'\x2', '\x513', '\x516', '\x3', '\x2', '\x2', '\x2', '\x514', '\x512', 
		'\x3', '\x2', '\x2', '\x2', '\x514', '\x515', '\x3', '\x2', '\x2', '\x2', 
		'\x515', '\x528', '\x3', '\x2', '\x2', '\x2', '\x516', '\x514', '\x3', 
		'\x2', '\x2', '\x2', '\x517', '\x519', '\a', '\x1C2', '\x2', '\x2', '\x518', 
		'\x517', '\x3', '\x2', '\x2', '\x2', '\x518', '\x519', '\x3', '\x2', '\x2', 
		'\x2', '\x519', '\x51A', '\x3', '\x2', '\x2', '\x2', '\x51A', '\x523', 
		'\t', '\x2', '\x2', '\x2', '\x51B', '\x51D', '\a', '\x8A', '\x2', '\x2', 
		'\x51C', '\x51B', '\x3', '\x2', '\x2', '\x2', '\x51C', '\x51D', '\x3', 
		'\x2', '\x2', '\x2', '\x51D', '\x51F', '\x3', '\x2', '\x2', '\x2', '\x51E', 
		'\x520', '\x5', '\x24E', '\x128', '\x2', '\x51F', '\x51E', '\x3', '\x2', 
		'\x2', '\x2', '\x51F', '\x520', '\x3', '\x2', '\x2', '\x2', '\x520', '\x521', 
		'\x3', '\x2', '\x2', '\x2', '\x521', '\x524', '\x5', '\x29A', '\x14E', 
		'\x2', '\x522', '\x524', '\x5', '\x240', '\x121', '\x2', '\x523', '\x51C', 
		'\x3', '\x2', '\x2', '\x2', '\x523', '\x522', '\x3', '\x2', '\x2', '\x2', 
		'\x524', '\x529', '\x3', '\x2', '\x2', '\x2', '\x525', '\x526', '\t', 
		'\x3', '\x2', '\x2', '\x526', '\x527', '\a', '\x28E', '\x2', '\x2', '\x527', 
		'\x529', '\x5', '\x436', '\x21C', '\x2', '\x528', '\x518', '\x3', '\x2', 
		'\x2', '\x2', '\x528', '\x525', '\x3', '\x2', '\x2', '\x2', '\x529', '\x52A', 
		'\x3', '\x2', '\x2', '\x2', '\x52A', '\x52B', '\a', '\x304', '\x2', '\x2', 
		'\x52B', '\v', '\x3', '\x2', '\x2', '\x2', '\x52C', '\x52E', '\a', '\x1AD', 
		'\x2', '\x2', '\x52D', '\x52F', '\x5', '\xE', '\b', '\x2', '\x52E', '\x52D', 
		'\x3', '\x2', '\x2', '\x2', '\x52E', '\x52F', '\x3', '\x2', '\x2', '\x2', 
		'\x52F', '\r', '\x3', '\x2', '\x2', '\x2', '\x530', '\x531', '\a', '\x2F2', 
		'\x2', '\x2', '\x531', '\x532', '\a', '\x1B2', '\x2', '\x2', '\x532', 
		'\x533', '\x5', '\x37E', '\x1C0', '\x2', '\x533', '\x537', '\a', '?', 
		'\x2', '\x2', '\x534', '\x538', '\a', '\x14', '\x2', '\x2', '\x535', '\x536', 
		'\t', '\x4', '\x2', '\x2', '\x536', '\x538', '\x5', '\x44A', '\x226', 
		'\x2', '\x537', '\x534', '\x3', '\x2', '\x2', '\x2', '\x537', '\x535', 
		'\x3', '\x2', '\x2', '\x2', '\x538', '\x53A', '\x3', '\x2', '\x2', '\x2', 
		'\x539', '\x53B', '\x5', '\x14', '\v', '\x2', '\x53A', '\x539', '\x3', 
		'\x2', '\x2', '\x2', '\x53A', '\x53B', '\x3', '\x2', '\x2', '\x2', '\x53B', 
		'\x53C', '\x3', '\x2', '\x2', '\x2', '\x53C', '\x53D', '\a', '\x2F3', 
		'\x2', '\x2', '\x53D', '\xF', '\x3', '\x2', '\x2', '\x2', '\x53E', '\x540', 
		'\a', '\x1F7', '\x2', '\x2', '\x53F', '\x541', '\x5', '\x12', '\n', '\x2', 
		'\x540', '\x53F', '\x3', '\x2', '\x2', '\x2', '\x540', '\x541', '\x3', 
		'\x2', '\x2', '\x2', '\x541', '\x11', '\x3', '\x2', '\x2', '\x2', '\x542', 
		'\x543', '\a', '\x1ED', '\x2', '\x2', '\x543', '\x544', '\a', '\x2F2', 
		'\x2', '\x2', '\x544', '\x549', '\x5', '\x416', '\x20C', '\x2', '\x545', 
		'\x546', '\a', '\x2F8', '\x2', '\x2', '\x546', '\x548', '\x5', '\x416', 
		'\x20C', '\x2', '\x547', '\x545', '\x3', '\x2', '\x2', '\x2', '\x548', 
		'\x54B', '\x3', '\x2', '\x2', '\x2', '\x549', '\x547', '\x3', '\x2', '\x2', 
		'\x2', '\x549', '\x54A', '\x3', '\x2', '\x2', '\x2', '\x54A', '\x54C', 
		'\x3', '\x2', '\x2', '\x2', '\x54B', '\x549', '\x3', '\x2', '\x2', '\x2', 
		'\x54C', '\x54D', '\a', '\x2F3', '\x2', '\x2', '\x54D', '\x13', '\x3', 
		'\x2', '\x2', '\x2', '\x54E', '\x54F', '\t', '\x5', '\x2', '\x2', '\x54F', 
		'\x550', '\x5', '\x37E', '\x1C0', '\x2', '\x550', '\x551', '\a', '?', 
		'\x2', '\x2', '\x551', '\x552', '\x5', '\x44A', '\x226', '\x2', '\x552', 
		'\x15', '\x3', '\x2', '\x2', '\x2', '\x553', '\x554', '\a', '\xA5', '\x2', 
		'\x2', '\x554', '\x556', '\a', '\x1AC', '\x2', '\x2', '\x555', '\x557', 
		'\a', '\x38', '\x2', '\x2', '\x556', '\x555', '\x3', '\x2', '\x2', '\x2', 
		'\x556', '\x557', '\x3', '\x2', '\x2', '\x2', '\x557', '\x55B', '\x3', 
		'\x2', '\x2', '\x2', '\x558', '\x559', '\x5', '\x42C', '\x217', '\x2', 
		'\x559', '\x55A', '\a', '\x2EB', '\x2', '\x2', '\x55A', '\x55C', '\x3', 
		'\x2', '\x2', '\x2', '\x55B', '\x558', '\x3', '\x2', '\x2', '\x2', '\x55B', 
		'\x55C', '\x3', '\x2', '\x2', '\x2', '\x55C', '\x55D', '\x3', '\x2', '\x2', 
		'\x2', '\x55D', '\x55E', '\x5', '\x472', '\x23A', '\x2', '\x55E', '\x55F', 
		'\a', '\x304', '\x2', '\x2', '\x55F', '\x17', '\x3', '\x2', '\x2', '\x2', 
		'\x560', '\x561', '\a', '\x10', '\x2', '\x2', '\x561', '\x562', '\a', 
		'\x1AC', '\x2', '\x2', '\x562', '\x563', '\x5', '\x472', '\x23A', '\x2', 
		'\x563', '\x565', '\a', '^', '\x2', '\x2', '\x564', '\x566', '\a', '\x87', 
		'\x2', '\x2', '\x565', '\x564', '\x3', '\x2', '\x2', '\x2', '\x565', '\x566', 
		'\x3', '\x2', '\x2', '\x2', '\x566', '\x568', '\x3', '\x2', '\x2', '\x2', 
		'\x567', '\x569', '\t', '\x6', '\x2', '\x2', '\x568', '\x567', '\x3', 
		'\x2', '\x2', '\x2', '\x568', '\x569', '\x3', '\x2', '\x2', '\x2', '\x569', 
		'\x56D', '\x3', '\x2', '\x2', '\x2', '\x56A', '\x56C', '\x5', '\x23E', 
		'\x120', '\x2', '\x56B', '\x56A', '\x3', '\x2', '\x2', '\x2', '\x56C', 
		'\x56F', '\x3', '\x2', '\x2', '\x2', '\x56D', '\x56B', '\x3', '\x2', '\x2', 
		'\x2', '\x56D', '\x56E', '\x3', '\x2', '\x2', '\x2', '\x56E', '\x572', 
		'\x3', '\x2', '\x2', '\x2', '\x56F', '\x56D', '\x3', '\x2', '\x2', '\x2', 
		'\x570', '\x571', '\a', '\x1FD', '\x2', '\x2', '\x571', '\x573', '\a', 
		'\x225', '\x2', '\x2', '\x572', '\x570', '\x3', '\x2', '\x2', '\x2', '\x572', 
		'\x573', '\x3', '\x2', '\x2', '\x2', '\x573', '\x574', '\x3', '\x2', '\x2', 
		'\x2', '\x574', '\x575', '\a', '\x304', '\x2', '\x2', '\x575', '\x19', 
		'\x3', '\x2', '\x2', '\x2', '\x576', '\x579', '\a', 'r', '\x2', '\x2', 
		'\x577', '\x578', '\a', '\x1A4', '\x2', '\x2', '\x578', '\x57A', '\a', 
		'\x1F1', '\x2', '\x2', '\x579', '\x577', '\x3', '\x2', '\x2', '\x2', '\x579', 
		'\x57A', '\x3', '\x2', '\x2', '\x2', '\x57A', '\x57B', '\x3', '\x2', '\x2', 
		'\x2', '\x57B', '\x57F', '\a', '\x1AC', '\x2', '\x2', '\x57C', '\x57D', 
		'\x5', '\x42C', '\x217', '\x2', '\x57D', '\x57E', '\a', '\x2EB', '\x2', 
		'\x2', '\x57E', '\x580', '\x3', '\x2', '\x2', '\x2', '\x57F', '\x57C', 
		'\x3', '\x2', '\x2', '\x2', '\x57F', '\x580', '\x3', '\x2', '\x2', '\x2', 
		'\x580', '\x581', '\x3', '\x2', '\x2', '\x2', '\x581', '\x583', '\x5', 
		'\x472', '\x23A', '\x2', '\x582', '\x584', '\x5', '\x23C', '\x11F', '\x2', 
		'\x583', '\x582', '\x3', '\x2', '\x2', '\x2', '\x583', '\x584', '\x3', 
		'\x2', '\x2', '\x2', '\x584', '\x585', '\x3', '\x2', '\x2', '\x2', '\x585', 
		'\x589', '\t', '\x2', '\x2', '\x2', '\x586', '\x588', '\x5', '\x1E', '\x10', 
		'\x2', '\x587', '\x586', '\x3', '\x2', '\x2', '\x2', '\x588', '\x58B', 
		'\x3', '\x2', '\x2', '\x2', '\x589', '\x587', '\x3', '\x2', '\x2', '\x2', 
		'\x589', '\x58A', '\x3', '\x2', '\x2', '\x2', '\x58A', '\x58C', '\x3', 
		'\x2', '\x2', '\x2', '\x58B', '\x589', '\x3', '\x2', '\x2', '\x2', '\x58C', 
		'\x58E', '\a', '\xB5', '\x2', '\x2', '\x58D', '\x58F', '\x5', '\x472', 
		'\x23A', '\x2', '\x58E', '\x58D', '\x3', '\x2', '\x2', '\x2', '\x58E', 
		'\x58F', '\x3', '\x2', '\x2', '\x2', '\x58F', '\x590', '\x3', '\x2', '\x2', 
		'\x2', '\x590', '\x591', '\a', '\x304', '\x2', '\x2', '\x591', '\x1B', 
		'\x3', '\x2', '\x2', '\x2', '\x592', '\x595', '\a', 'r', '\x2', '\x2', 
		'\x593', '\x594', '\a', '\x1A4', '\x2', '\x2', '\x594', '\x596', '\a', 
		'\x1F1', '\x2', '\x2', '\x595', '\x593', '\x3', '\x2', '\x2', '\x2', '\x595', 
		'\x596', '\x3', '\x2', '\x2', '\x2', '\x596', '\x597', '\x3', '\x2', '\x2', 
		'\x2', '\x597', '\x598', '\a', '\x1AC', '\x2', '\x2', '\x598', '\x59C', 
		'\a', '\x38', '\x2', '\x2', '\x599', '\x59A', '\x5', '\x42C', '\x217', 
		'\x2', '\x59A', '\x59B', '\a', '\x2EB', '\x2', '\x2', '\x59B', '\x59D', 
		'\x3', '\x2', '\x2', '\x2', '\x59C', '\x599', '\x3', '\x2', '\x2', '\x2', 
		'\x59C', '\x59D', '\x3', '\x2', '\x2', '\x2', '\x59D', '\x59E', '\x3', 
		'\x2', '\x2', '\x2', '\x59E', '\x59F', '\x5', '\x472', '\x23A', '\x2', 
		'\x59F', '\x5A3', '\t', '\x2', '\x2', '\x2', '\x5A0', '\x5A2', '\x5', 
		'$', '\x13', '\x2', '\x5A1', '\x5A0', '\x3', '\x2', '\x2', '\x2', '\x5A2', 
		'\x5A5', '\x3', '\x2', '\x2', '\x2', '\x5A3', '\x5A1', '\x3', '\x2', '\x2', 
		'\x2', '\x5A3', '\x5A4', '\x3', '\x2', '\x2', '\x2', '\x5A4', '\x5A8', 
		'\x3', '\x2', '\x2', '\x2', '\x5A5', '\x5A3', '\x3', '\x2', '\x2', '\x2', 
		'\x5A6', '\x5A7', '\a', '-', '\x2', '\x2', '\x5A7', '\x5A9', '\x5', '\x26C', 
		'\x137', '\x2', '\x5A8', '\x5A6', '\x3', '\x2', '\x2', '\x2', '\x5A8', 
		'\x5A9', '\x3', '\x2', '\x2', '\x2', '\x5A9', '\x5AA', '\x3', '\x2', '\x2', 
		'\x2', '\x5AA', '\x5AC', '\a', '\xB5', '\x2', '\x2', '\x5AB', '\x5AD', 
		'\x5', '\x472', '\x23A', '\x2', '\x5AC', '\x5AB', '\x3', '\x2', '\x2', 
		'\x2', '\x5AC', '\x5AD', '\x3', '\x2', '\x2', '\x2', '\x5AD', '\x5AE', 
		'\x3', '\x2', '\x2', '\x2', '\x5AE', '\x5AF', '\a', '\x304', '\x2', '\x2', 
		'\x5AF', '\x1D', '\x3', '\x2', '\x2', '\x2', '\x5B0', '\x5B9', '\x5', 
		'\x252', '\x12A', '\x2', '\x5B1', '\x5B9', '\x5', '\x254', '\x12B', '\x2', 
		'\x5B2', '\x5B9', '\x5', '\x256', '\x12C', '\x2', '\x5B3', '\x5B9', '\x5', 
		'\x25A', '\x12E', '\x2', '\x5B4', '\x5B9', '\x5', '\x25C', '\x12F', '\x2', 
		'\x5B5', '\x5B9', '\x5', '\x25E', '\x130', '\x2', '\x5B6', '\x5B9', '\x5', 
		' ', '\x11', '\x2', '\x5B7', '\x5B9', '\x5', '\"', '\x12', '\x2', '\x5B8', 
		'\x5B0', '\x3', '\x2', '\x2', '\x2', '\x5B8', '\x5B1', '\x3', '\x2', '\x2', 
		'\x2', '\x5B8', '\x5B2', '\x3', '\x2', '\x2', '\x2', '\x5B8', '\x5B3', 
		'\x3', '\x2', '\x2', '\x2', '\x5B8', '\x5B4', '\x3', '\x2', '\x2', '\x2', 
		'\x5B8', '\x5B5', '\x3', '\x2', '\x2', '\x2', '\x5B8', '\x5B6', '\x3', 
		'\x2', '\x2', '\x2', '\x5B8', '\x5B7', '\x3', '\x2', '\x2', '\x2', '\x5B9', 
		'\x1F', '\x3', '\x2', '\x2', '\x2', '\x5BA', '\x5BB', '\a', '\x1D5', '\x2', 
		'\x2', '\x5BB', '\x5C7', '\x5', '\x46E', '\x238', '\x2', '\x5BC', '\x5BD', 
		'\a', '\x2F2', '\x2', '\x2', '\x5BD', '\x5C2', '\x5', '\x24A', '\x126', 
		'\x2', '\x5BE', '\x5BF', '\a', '\x2F8', '\x2', '\x2', '\x5BF', '\x5C1', 
		'\x5', '\x24A', '\x126', '\x2', '\x5C0', '\x5BE', '\x3', '\x2', '\x2', 
		'\x2', '\x5C1', '\x5C4', '\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5C0', 
		'\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5C3', '\x3', '\x2', '\x2', '\x2', 
		'\x5C3', '\x5C5', '\x3', '\x2', '\x2', '\x2', '\x5C4', '\x5C2', '\x3', 
		'\x2', '\x2', '\x2', '\x5C5', '\x5C6', '\a', '\x2F3', '\x2', '\x2', '\x5C6', 
		'\x5C8', '\x3', '\x2', '\x2', '\x2', '\x5C7', '\x5BC', '\x3', '\x2', '\x2', 
		'\x2', '\x5C7', '\x5C8', '\x3', '\x2', '\x2', '\x2', '\x5C8', '\x5C9', 
		'\x3', '\x2', '\x2', '\x2', '\x5C9', '\x5CA', '\a', '\x304', '\x2', '\x2', 
		'\x5CA', '!', '\x3', '\x2', '\x2', '\x2', '\x5CB', '\x5CC', '\a', '\xE3', 
		'\x2', '\x2', '\x5CC', '\x5D8', '\x5', '\x46E', '\x238', '\x2', '\x5CD', 
		'\x5CE', '\a', '\x2F2', '\x2', '\x2', '\x5CE', '\x5D3', '\x5', '\x24A', 
		'\x126', '\x2', '\x5CF', '\x5D0', '\a', '\x2F8', '\x2', '\x2', '\x5D0', 
		'\x5D2', '\x5', '\x24A', '\x126', '\x2', '\x5D1', '\x5CF', '\x3', '\x2', 
		'\x2', '\x2', '\x5D2', '\x5D5', '\x3', '\x2', '\x2', '\x2', '\x5D3', '\x5D1', 
		'\x3', '\x2', '\x2', '\x2', '\x5D3', '\x5D4', '\x3', '\x2', '\x2', '\x2', 
		'\x5D4', '\x5D6', '\x3', '\x2', '\x2', '\x2', '\x5D5', '\x5D3', '\x3', 
		'\x2', '\x2', '\x2', '\x5D6', '\x5D7', '\a', '\x2F3', '\x2', '\x2', '\x5D7', 
		'\x5D9', '\x3', '\x2', '\x2', '\x2', '\x5D8', '\x5CD', '\x3', '\x2', '\x2', 
		'\x2', '\x5D8', '\x5D9', '\x3', '\x2', '\x2', '\x2', '\x5D9', '\x5DA', 
		'\x3', '\x2', '\x2', '\x2', '\x5DA', '\x5DB', '\a', '\x1FC', '\x2', '\x2', 
		'\x5DB', '\x5DD', '\x5', '\x454', '\x22B', '\x2', '\x5DC', '\x5DE', '\a', 
		'\x98', '\x2', '\x2', '\x5DD', '\x5DC', '\x3', '\x2', '\x2', '\x2', '\x5DD', 
		'\x5DE', '\x3', '\x2', '\x2', '\x2', '\x5DE', '\x5E0', '\x3', '\x2', '\x2', 
		'\x2', '\x5DF', '\x5E1', '\a', '\x1F7', '\x2', '\x2', '\x5E0', '\x5DF', 
		'\x3', '\x2', '\x2', '\x2', '\x5E0', '\x5E1', '\x3', '\x2', '\x2', '\x2', 
		'\x5E1', '\x5E2', '\x3', '\x2', '\x2', '\x2', '\x5E2', '\x5E3', '\a', 
		'\x304', '\x2', '\x2', '\x5E3', '#', '\x3', '\x2', '\x2', '\x2', '\x5E4', 
		'\x5EE', '\x5', '\x252', '\x12A', '\x2', '\x5E5', '\x5EE', '\x5', '\x254', 
		'\x12B', '\x2', '\x5E6', '\x5EE', '\x5', '\x256', '\x12C', '\x2', '\x5E7', 
		'\x5EE', '\x5', '\x25A', '\x12E', '\x2', '\x5E8', '\x5EE', '\x5', '\x25E', 
		'\x130', '\x2', '\x5E9', '\x5EE', '\x5', ',', '\x17', '\x2', '\x5EA', 
		'\x5EE', '\x5', '*', '\x16', '\x2', '\x5EB', '\x5EE', '\x5', ' ', '\x11', 
		'\x2', '\x5EC', '\x5EE', '\x5', '\"', '\x12', '\x2', '\x5ED', '\x5E4', 
		'\x3', '\x2', '\x2', '\x2', '\x5ED', '\x5E5', '\x3', '\x2', '\x2', '\x2', 
		'\x5ED', '\x5E6', '\x3', '\x2', '\x2', '\x2', '\x5ED', '\x5E7', '\x3', 
		'\x2', '\x2', '\x2', '\x5ED', '\x5E8', '\x3', '\x2', '\x2', '\x2', '\x5ED', 
		'\x5E9', '\x3', '\x2', '\x2', '\x2', '\x5ED', '\x5EA', '\x3', '\x2', '\x2', 
		'\x2', '\x5ED', '\x5EB', '\x3', '\x2', '\x2', '\x2', '\x5ED', '\x5EC', 
		'\x3', '\x2', '\x2', '\x2', '\x5EE', '%', '\x3', '\x2', '\x2', '\x2', 
		'\x5EF', '\x5F0', '\a', '\xA5', '\x2', '\x2', '\x5F0', '\x5F1', '\a', 
		'\x1D5', '\x2', '\x2', '\x5F1', '\x5F2', '\x5', '\x43C', '\x21F', '\x2', 
		'\x5F2', '\x5F3', '\a', '\x304', '\x2', '\x2', '\x5F3', '\'', '\x3', '\x2', 
		'\x2', '\x2', '\x5F4', '\x5F5', '\a', '\x10', '\x2', '\x2', '\x5F5', '\x5F6', 
		'\a', '\x1D5', '\x2', '\x2', '\x5F6', '\x5F7', '\x5', '\x43C', '\x21F', 
		'\x2', '\x5F7', '\x5F9', '\a', '^', '\x2', '\x2', '\x5F8', '\x5FA', '\a', 
		'\x87', '\x2', '\x2', '\x5F9', '\x5F8', '\x3', '\x2', '\x2', '\x2', '\x5F9', 
		'\x5FA', '\x3', '\x2', '\x2', '\x2', '\x5FA', '\x5FE', '\x3', '\x2', '\x2', 
		'\x2', '\x5FB', '\x5FD', '\x5', '\x23E', '\x120', '\x2', '\x5FC', '\x5FB', 
		'\x3', '\x2', '\x2', '\x2', '\x5FD', '\x600', '\x3', '\x2', '\x2', '\x2', 
		'\x5FE', '\x5FC', '\x3', '\x2', '\x2', '\x2', '\x5FE', '\x5FF', '\x3', 
		'\x2', '\x2', '\x2', '\x5FF', '\x603', '\x3', '\x2', '\x2', '\x2', '\x600', 
		'\x5FE', '\x3', '\x2', '\x2', '\x2', '\x601', '\x602', '\a', '\x1FD', 
		'\x2', '\x2', '\x602', '\x604', '\a', '\x225', '\x2', '\x2', '\x603', 
		'\x601', '\x3', '\x2', '\x2', '\x2', '\x603', '\x604', '\x3', '\x2', '\x2', 
		'\x2', '\x604', '\x605', '\x3', '\x2', '\x2', '\x2', '\x605', '\x606', 
		'\a', '\x304', '\x2', '\x2', '\x606', ')', '\x3', '\x2', '\x2', '\x2', 
		'\x607', '\x608', '\a', '\xE3', '\x2', '\x2', '\x608', '\x614', '\x5', 
		'\x43A', '\x21E', '\x2', '\x609', '\x60A', '\a', '\x2F2', '\x2', '\x2', 
		'\x60A', '\x60F', '\x5', '\x24A', '\x126', '\x2', '\x60B', '\x60C', '\a', 
		'\x2F8', '\x2', '\x2', '\x60C', '\x60E', '\x5', '\x24A', '\x126', '\x2', 
		'\x60D', '\x60B', '\x3', '\x2', '\x2', '\x2', '\x60E', '\x611', '\x3', 
		'\x2', '\x2', '\x2', '\x60F', '\x60D', '\x3', '\x2', '\x2', '\x2', '\x60F', 
		'\x610', '\x3', '\x2', '\x2', '\x2', '\x610', '\x612', '\x3', '\x2', '\x2', 
		'\x2', '\x611', '\x60F', '\x3', '\x2', '\x2', '\x2', '\x612', '\x613', 
		'\a', '\x2F3', '\x2', '\x2', '\x613', '\x615', '\x3', '\x2', '\x2', '\x2', 
		'\x614', '\x609', '\x3', '\x2', '\x2', '\x2', '\x614', '\x615', '\x3', 
		'\x2', '\x2', '\x2', '\x615', '\x616', '\x3', '\x2', '\x2', '\x2', '\x616', 
		'\x617', '\a', '\x1FC', '\x2', '\x2', '\x617', '\x61E', '\x5', '\x454', 
		'\x22B', '\x2', '\x618', '\x61D', '\x5', '\x23C', '\x11F', '\x2', '\x619', 
		'\x61D', '\x5', '\f', '\a', '\x2', '\x61A', '\x61D', '\x5', '\x10', '\t', 
		'\x2', '\x61B', '\x61D', '\a', '\x98', '\x2', '\x2', '\x61C', '\x618', 
		'\x3', '\x2', '\x2', '\x2', '\x61C', '\x619', '\x3', '\x2', '\x2', '\x2', 
		'\x61C', '\x61A', '\x3', '\x2', '\x2', '\x2', '\x61C', '\x61B', '\x3', 
		'\x2', '\x2', '\x2', '\x61D', '\x620', '\x3', '\x2', '\x2', '\x2', '\x61E', 
		'\x61C', '\x3', '\x2', '\x2', '\x2', '\x61E', '\x61F', '\x3', '\x2', '\x2', 
		'\x2', '\x61F', '\x632', '\x3', '\x2', '\x2', '\x2', '\x620', '\x61E', 
		'\x3', '\x2', '\x2', '\x2', '\x621', '\x623', '\a', '\x1C2', '\x2', '\x2', 
		'\x622', '\x621', '\x3', '\x2', '\x2', '\x2', '\x622', '\x623', '\x3', 
		'\x2', '\x2', '\x2', '\x623', '\x624', '\x3', '\x2', '\x2', '\x2', '\x624', 
		'\x62D', '\t', '\x2', '\x2', '\x2', '\x625', '\x627', '\a', '\x8A', '\x2', 
		'\x2', '\x626', '\x625', '\x3', '\x2', '\x2', '\x2', '\x626', '\x627', 
		'\x3', '\x2', '\x2', '\x2', '\x627', '\x629', '\x3', '\x2', '\x2', '\x2', 
		'\x628', '\x62A', '\x5', '\x24E', '\x128', '\x2', '\x629', '\x628', '\x3', 
		'\x2', '\x2', '\x2', '\x629', '\x62A', '\x3', '\x2', '\x2', '\x2', '\x62A', 
		'\x62B', '\x3', '\x2', '\x2', '\x2', '\x62B', '\x62E', '\x5', '\x29A', 
		'\x14E', '\x2', '\x62C', '\x62E', '\x5', '\x240', '\x121', '\x2', '\x62D', 
		'\x626', '\x3', '\x2', '\x2', '\x2', '\x62D', '\x62C', '\x3', '\x2', '\x2', 
		'\x2', '\x62E', '\x633', '\x3', '\x2', '\x2', '\x2', '\x62F', '\x630', 
		'\t', '\x3', '\x2', '\x2', '\x630', '\x631', '\a', '\x28E', '\x2', '\x2', 
		'\x631', '\x633', '\x5', '\x436', '\x21C', '\x2', '\x632', '\x622', '\x3', 
		'\x2', '\x2', '\x2', '\x632', '\x62F', '\x3', '\x2', '\x2', '\x2', '\x633', 
		'\x634', '\x3', '\x2', '\x2', '\x2', '\x634', '\x635', '\a', '\x304', 
		'\x2', '\x2', '\x635', '+', '\x3', '\x2', '\x2', '\x2', '\x636', '\x637', 
		'\a', '\x1D5', '\x2', '\x2', '\x637', '\x643', '\x5', '\x43C', '\x21F', 
		'\x2', '\x638', '\x639', '\a', '\x2F2', '\x2', '\x2', '\x639', '\x63E', 
		'\x5', '\x24A', '\x126', '\x2', '\x63A', '\x63B', '\a', '\x2F8', '\x2', 
		'\x2', '\x63B', '\x63D', '\x5', '\x24A', '\x126', '\x2', '\x63C', '\x63A', 
		'\x3', '\x2', '\x2', '\x2', '\x63D', '\x640', '\x3', '\x2', '\x2', '\x2', 
		'\x63E', '\x63C', '\x3', '\x2', '\x2', '\x2', '\x63E', '\x63F', '\x3', 
		'\x2', '\x2', '\x2', '\x63F', '\x641', '\x3', '\x2', '\x2', '\x2', '\x640', 
		'\x63E', '\x3', '\x2', '\x2', '\x2', '\x641', '\x642', '\a', '\x2F3', 
		'\x2', '\x2', '\x642', '\x644', '\x3', '\x2', '\x2', '\x2', '\x643', '\x638', 
		'\x3', '\x2', '\x2', '\x2', '\x643', '\x644', '\x3', '\x2', '\x2', '\x2', 
		'\x644', '\x645', '\x3', '\x2', '\x2', '\x2', '\x645', '\x64F', '\t', 
		'\x2', '\x2', '\x2', '\x646', '\x648', '\a', '\x8A', '\x2', '\x2', '\x647', 
		'\x646', '\x3', '\x2', '\x2', '\x2', '\x647', '\x648', '\x3', '\x2', '\x2', 
		'\x2', '\x648', '\x64A', '\x3', '\x2', '\x2', '\x2', '\x649', '\x64B', 
		'\x5', '\x24E', '\x128', '\x2', '\x64A', '\x649', '\x3', '\x2', '\x2', 
		'\x2', '\x64A', '\x64B', '\x3', '\x2', '\x2', '\x2', '\x64B', '\x64C', 
		'\x3', '\x2', '\x2', '\x2', '\x64C', '\x650', '\x5', '\x29A', '\x14E', 
		'\x2', '\x64D', '\x650', '\x5', '\x240', '\x121', '\x2', '\x64E', '\x650', 
		'\a', '\xCA', '\x2', '\x2', '\x64F', '\x647', '\x3', '\x2', '\x2', '\x2', 
		'\x64F', '\x64D', '\x3', '\x2', '\x2', '\x2', '\x64F', '\x64E', '\x3', 
		'\x2', '\x2', '\x2', '\x650', '\x651', '\x3', '\x2', '\x2', '\x2', '\x651', 
		'\x652', '\a', '\x304', '\x2', '\x2', '\x652', '-', '\x3', '\x2', '\x2', 
		'\x2', '\x653', '\x656', '\a', 'r', '\x2', '\x2', '\x654', '\x655', '\a', 
		'\x1A4', '\x2', '\x2', '\x655', '\x657', '\a', '\x1F1', '\x2', '\x2', 
		'\x656', '\x654', '\x3', '\x2', '\x2', '\x2', '\x656', '\x657', '\x3', 
		'\x2', '\x2', '\x2', '\x657', '\x658', '\x3', '\x2', '\x2', '\x2', '\x658', 
		'\x659', '\a', '\x1D5', '\x2', '\x2', '\x659', '\x665', '\x5', '\x43C', 
		'\x21F', '\x2', '\x65A', '\x65B', '\a', '\x2F2', '\x2', '\x2', '\x65B', 
		'\x660', '\x5', '\x24A', '\x126', '\x2', '\x65C', '\x65D', '\a', '\x2F8', 
		'\x2', '\x2', '\x65D', '\x65F', '\x5', '\x24A', '\x126', '\x2', '\x65E', 
		'\x65C', '\x3', '\x2', '\x2', '\x2', '\x65F', '\x662', '\x3', '\x2', '\x2', 
		'\x2', '\x660', '\x65E', '\x3', '\x2', '\x2', '\x2', '\x660', '\x661', 
		'\x3', '\x2', '\x2', '\x2', '\x661', '\x663', '\x3', '\x2', '\x2', '\x2', 
		'\x662', '\x660', '\x3', '\x2', '\x2', '\x2', '\x663', '\x664', '\a', 
		'\x2F3', '\x2', '\x2', '\x664', '\x666', '\x3', '\x2', '\x2', '\x2', '\x665', 
		'\x65A', '\x3', '\x2', '\x2', '\x2', '\x665', '\x666', '\x3', '\x2', '\x2', 
		'\x2', '\x666', '\x668', '\x3', '\x2', '\x2', '\x2', '\x667', '\x669', 
		'\x5', '\x23C', '\x11F', '\x2', '\x668', '\x667', '\x3', '\x2', '\x2', 
		'\x2', '\x668', '\x669', '\x3', '\x2', '\x2', '\x2', '\x669', '\x66A', 
		'\x3', '\x2', '\x2', '\x2', '\x66A', '\x674', '\t', '\x2', '\x2', '\x2', 
		'\x66B', '\x66D', '\a', '\x8A', '\x2', '\x2', '\x66C', '\x66B', '\x3', 
		'\x2', '\x2', '\x2', '\x66C', '\x66D', '\x3', '\x2', '\x2', '\x2', '\x66D', 
		'\x66F', '\x3', '\x2', '\x2', '\x2', '\x66E', '\x670', '\x5', '\x24E', 
		'\x128', '\x2', '\x66F', '\x66E', '\x3', '\x2', '\x2', '\x2', '\x66F', 
		'\x670', '\x3', '\x2', '\x2', '\x2', '\x670', '\x671', '\x3', '\x2', '\x2', 
		'\x2', '\x671', '\x675', '\x5', '\x29A', '\x14E', '\x2', '\x672', '\x675', 
		'\x5', '\x240', '\x121', '\x2', '\x673', '\x675', '\a', '\xCA', '\x2', 
		'\x2', '\x674', '\x66C', '\x3', '\x2', '\x2', '\x2', '\x674', '\x672', 
		'\x3', '\x2', '\x2', '\x2', '\x674', '\x673', '\x3', '\x2', '\x2', '\x2', 
		'\x675', '\x676', '\x3', '\x2', '\x2', '\x2', '\x676', '\x677', '\a', 
		'\x304', '\x2', '\x2', '\x677', '/', '\x3', '\x2', '\x2', '\x2', '\x678', 
		'\x679', '\a', '\xA5', '\x2', '\x2', '\x679', '\x67A', '\a', '\x275', 
		'\x2', '\x2', '\x67A', '\x67B', '\x5', '\x43E', '\x220', '\x2', '\x67B', 
		'\x67C', '\a', '\x304', '\x2', '\x2', '\x67C', '\x31', '\x3', '\x2', '\x2', 
		'\x2', '\x67D', '\x67E', '\a', '\x10', '\x2', '\x2', '\x67E', '\x67F', 
		'\a', '\x275', '\x2', '\x2', '\x67F', '\x692', '\x5', '\x43E', '\x220', 
		'\x2', '\x680', '\x693', '\t', '\a', '\x2', '\x2', '\x681', '\x682', '\a', 
		'\x1F0', '\x2', '\x2', '\x682', '\x683', '\a', '\x26E', '\x2', '\x2', 
		'\x683', '\x693', '\x5', '\x43E', '\x220', '\x2', '\x684', '\x686', '\a', 
		'^', '\x2', '\x2', '\x685', '\x687', '\a', '\x87', '\x2', '\x2', '\x686', 
		'\x685', '\x3', '\x2', '\x2', '\x2', '\x686', '\x687', '\x3', '\x2', '\x2', 
		'\x2', '\x687', '\x68B', '\x3', '\x2', '\x2', '\x2', '\x688', '\x68A', 
		'\x5', '\x23E', '\x120', '\x2', '\x689', '\x688', '\x3', '\x2', '\x2', 
		'\x2', '\x68A', '\x68D', '\x3', '\x2', '\x2', '\x2', '\x68B', '\x689', 
		'\x3', '\x2', '\x2', '\x2', '\x68B', '\x68C', '\x3', '\x2', '\x2', '\x2', 
		'\x68C', '\x690', '\x3', '\x2', '\x2', '\x2', '\x68D', '\x68B', '\x3', 
		'\x2', '\x2', '\x2', '\x68E', '\x68F', '\a', '\x1FD', '\x2', '\x2', '\x68F', 
		'\x691', '\a', '\x225', '\x2', '\x2', '\x690', '\x68E', '\x3', '\x2', 
		'\x2', '\x2', '\x690', '\x691', '\x3', '\x2', '\x2', '\x2', '\x691', '\x693', 
		'\x3', '\x2', '\x2', '\x2', '\x692', '\x680', '\x3', '\x2', '\x2', '\x2', 
		'\x692', '\x681', '\x3', '\x2', '\x2', '\x2', '\x692', '\x684', '\x3', 
		'\x2', '\x2', '\x2', '\x693', '\x694', '\x3', '\x2', '\x2', '\x2', '\x694', 
		'\x695', '\a', '\x304', '\x2', '\x2', '\x695', '\x33', '\x3', '\x2', '\x2', 
		'\x2', '\x696', '\x699', '\a', 'r', '\x2', '\x2', '\x697', '\x698', '\a', 
		'\x1A4', '\x2', '\x2', '\x698', '\x69A', '\a', '\x1F1', '\x2', '\x2', 
		'\x699', '\x697', '\x3', '\x2', '\x2', '\x2', '\x699', '\x69A', '\x3', 
		'\x2', '\x2', '\x2', '\x69A', '\x69B', '\x3', '\x2', '\x2', '\x2', '\x69B', 
		'\x69C', '\a', '\x275', '\x2', '\x2', '\x69C', '\x6A0', '\x5', '\x43E', 
		'\x220', '\x2', '\x69D', '\x6A1', '\x5', ':', '\x1E', '\x2', '\x69E', 
		'\x6A1', '\x5', '>', ' ', '\x2', '\x69F', '\x6A1', '\x5', '@', '!', '\x2', 
		'\x6A0', '\x69D', '\x3', '\x2', '\x2', '\x2', '\x6A0', '\x69E', '\x3', 
		'\x2', '\x2', '\x2', '\x6A0', '\x69F', '\x3', '\x2', '\x2', '\x2', '\x6A1', 
		'\x6A3', '\x3', '\x2', '\x2', '\x2', '\x6A2', '\x6A4', '\x5', '\x36', 
		'\x1C', '\x2', '\x6A3', '\x6A2', '\x3', '\x2', '\x2', '\x2', '\x6A3', 
		'\x6A4', '\x3', '\x2', '\x2', '\x2', '\x6A4', '\x6A6', '\x3', '\x2', '\x2', 
		'\x2', '\x6A5', '\x6A7', '\t', '\a', '\x2', '\x2', '\x6A6', '\x6A5', '\x3', 
		'\x2', '\x2', '\x2', '\x6A6', '\x6A7', '\x3', '\x2', '\x2', '\x2', '\x6A7', 
		'\x6A9', '\x3', '\x2', '\x2', '\x2', '\x6A8', '\x6AA', '\x5', '\x38', 
		'\x1D', '\x2', '\x6A9', '\x6A8', '\x3', '\x2', '\x2', '\x2', '\x6A9', 
		'\x6AA', '\x3', '\x2', '\x2', '\x2', '\x6AA', '\x6AB', '\x3', '\x2', '\x2', 
		'\x2', '\x6AB', '\x6AC', '\x5', '\x42', '\"', '\x2', '\x6AC', '\x6AD', 
		'\a', '\x304', '\x2', '\x2', '\x6AD', '\x35', '\x3', '\x2', '\x2', '\x2', 
		'\x6AE', '\x6AF', '\a', '\xD9', '\x2', '\x2', '\x6AF', '\x6B4', '\x5', 
		'\x43E', '\x220', '\x2', '\x6B0', '\x6B1', '\a', '\x2F8', '\x2', '\x2', 
		'\x6B1', '\x6B3', '\x5', '\x43E', '\x220', '\x2', '\x6B2', '\x6B0', '\x3', 
		'\x2', '\x2', '\x2', '\x6B3', '\x6B6', '\x3', '\x2', '\x2', '\x2', '\x6B4', 
		'\x6B2', '\x3', '\x2', '\x2', '\x2', '\x6B4', '\x6B5', '\x3', '\x2', '\x2', 
		'\x2', '\x6B5', '\x37', '\x3', '\x2', '\x2', '\x2', '\x6B6', '\x6B4', 
		'\x3', '\x2', '\x2', '\x2', '\x6B7', '\x6B8', '\a', '\x2A1', '\x2', '\x2', 
		'\x6B8', '\x6B9', '\a', '\x2F2', '\x2', '\x2', '\x6B9', '\x6BA', '\x5', 
		'\x37A', '\x1BE', '\x2', '\x6BA', '\x6BB', '\a', '\x2F3', '\x2', '\x2', 
		'\x6BB', '\x39', '\x3', '\x2', '\x2', '\x2', '\x6BC', '\x6C1', '\a', ',', 
		'\x2', '\x2', '\x6BD', '\x6C1', '\a', '\n', '\x2', '\x2', '\x6BE', '\x6BF', 
		'\a', '\x112', '\x2', '\x2', '\x6BF', '\x6C1', '\a', '\x195', '\x2', '\x2', 
		'\x6C0', '\x6BC', '\x3', '\x2', '\x2', '\x2', '\x6C0', '\x6BD', '\x3', 
		'\x2', '\x2', '\x2', '\x6C0', '\x6BE', '\x3', '\x2', '\x2', '\x2', '\x6C1', 
		'\x6C2', '\x3', '\x2', '\x2', '\x2', '\x6C2', '\x6C4', '\x5', 'L', '\'', 
		'\x2', '\x6C3', '\x6C5', '\x5', 'R', '*', '\x2', '\x6C4', '\x6C3', '\x3', 
		'\x2', '\x2', '\x2', '\x6C4', '\x6C5', '\x3', '\x2', '\x2', '\x2', '\x6C5', 
		'\x6C7', '\x3', '\x2', '\x2', '\x2', '\x6C6', '\x6C8', '\x5', '<', '\x1F', 
		'\x2', '\x6C7', '\x6C6', '\x3', '\x2', '\x2', '\x2', '\x6C7', '\x6C8', 
		'\x3', '\x2', '\x2', '\x2', '\x6C8', ';', '\x3', '\x2', '\x2', '\x2', 
		'\x6C9', '\x6CA', '\a', '\xDD', '\x2', '\x2', '\x6CA', '\x6CB', '\a', 
		'\xA8', '\x2', '\x2', '\x6CB', '\x6CC', '\a', '\x209', '\x2', '\x2', '\x6CC', 
		'=', '\x3', '\x2', '\x2', '\x2', '\x6CD', '\x6CE', '\a', '\xDD', '\x2', 
		'\x2', '\x6CE', '\x6D0', '\x5', 'L', '\'', '\x2', '\x6CF', '\x6D1', '\x5', 
		'R', '*', '\x2', '\x6D0', '\x6CF', '\x3', '\x2', '\x2', '\x2', '\x6D0', 
		'\x6D1', '\x3', '\x2', '\x2', '\x2', '\x6D1', '?', '\x3', '\x2', '\x2', 
		'\x2', '\x6D2', '\x6D3', '\t', '\b', '\x2', '\x2', '\x6D3', '\x6D8', '\x5', 
		'J', '&', '\x2', '\x6D4', '\x6D5', '\a', '\x1A4', '\x2', '\x2', '\x6D5', 
		'\x6D7', '\x5', 'J', '&', '\x2', '\x6D6', '\x6D4', '\x3', '\x2', '\x2', 
		'\x2', '\x6D7', '\x6DA', '\x3', '\x2', '\x2', '\x2', '\x6D8', '\x6D6', 
		'\x3', '\x2', '\x2', '\x2', '\x6D8', '\x6D9', '\x3', '\x2', '\x2', '\x2', 
		'\x6D9', '\x6DB', '\x3', '\x2', '\x2', '\x2', '\x6DA', '\x6D8', '\x3', 
		'\x2', '\x2', '\x2', '\x6DB', '\x6E3', '\a', '\x19B', '\x2', '\x2', '\x6DC', 
		'\x6E4', '\a', '}', '\x2', '\x2', '\x6DD', '\x6DE', '\x5', '\x482', '\x242', 
		'\x2', '\x6DE', '\x6DF', '\a', '\x2EB', '\x2', '\x2', '\x6DF', '\x6E1', 
		'\x3', '\x2', '\x2', '\x2', '\x6E0', '\x6DD', '\x3', '\x2', '\x2', '\x2', 
		'\x6E0', '\x6E1', '\x3', '\x2', '\x2', '\x2', '\x6E1', '\x6E2', '\x3', 
		'\x2', '\x2', '\x2', '\x6E2', '\x6E4', '\a', '\x212', '\x2', '\x2', '\x6E3', 
		'\x6DC', '\x3', '\x2', '\x2', '\x2', '\x6E3', '\x6E0', '\x3', '\x2', '\x2', 
		'\x2', '\x6E4', '\x41', '\x3', '\x2', '\x2', '\x2', '\x6E5', '\x6E6', 
		'\a', '_', '\x2', '\x2', '\x6E6', '\x6EB', '\a', '\x275', '\x2', '\x2', 
		'\x6E7', '\x6E8', '\a', '\x42', '\x2', '\x2', '\x6E8', '\x6EB', '\x5', 
		'\x46E', '\x238', '\x2', '\x6E9', '\x6EB', '\x5', '\x29E', '\x150', '\x2', 
		'\x6EA', '\x6E5', '\x3', '\x2', '\x2', '\x2', '\x6EA', '\x6E7', '\x3', 
		'\x2', '\x2', '\x2', '\x6EA', '\x6E9', '\x3', '\x2', '\x2', '\x2', '\x6EB', 
		'\x43', '\x3', '\x2', '\x2', '\x2', '\x6EC', '\x6EE', '\x5', '\x3F0', 
		'\x1F9', '\x2', '\x6ED', '\x6EC', '\x3', '\x2', '\x2', '\x2', '\x6ED', 
		'\x6EE', '\x3', '\x2', '\x2', '\x2', '\x6EE', '\x6F0', '\x3', '\x2', '\x2', 
		'\x2', '\x6EF', '\x6F1', '\x5', '\x44C', '\x227', '\x2', '\x6F0', '\x6EF', 
		'\x3', '\x2', '\x2', '\x2', '\x6F0', '\x6F1', '\x3', '\x2', '\x2', '\x2', 
		'\x6F1', '\x45', '\x3', '\x2', '\x2', '\x2', '\x6F2', '\x6F3', '\a', '_', 
		'\x2', '\x2', '\x6F3', '\x6F5', '\a', '\x275', '\x2', '\x2', '\x6F4', 
		'\x6F6', '\x5', '\x24E', '\x128', '\x2', '\x6F5', '\x6F4', '\x3', '\x2', 
		'\x2', '\x2', '\x6F5', '\x6F6', '\x3', '\x2', '\x2', '\x2', '\x6F6', '\x6F8', 
		'\x3', '\x2', '\x2', '\x2', '\x6F7', '\x6F9', '\x5', 'H', '%', '\x2', 
		'\x6F8', '\x6F7', '\x3', '\x2', '\x2', '\x2', '\x6F9', '\x6FA', '\x3', 
		'\x2', '\x2', '\x2', '\x6FA', '\x6F8', '\x3', '\x2', '\x2', '\x2', '\x6FA', 
		'\x6FB', '\x3', '\x2', '\x2', '\x2', '\x6FB', '\x6FC', '\x3', '\x2', '\x2', 
		'\x2', '\x6FC', '\x6FD', '\a', '\xB5', '\x2', '\x2', '\x6FD', '\x6FE', 
		'\x5', '\x43E', '\x220', '\x2', '\x6FE', 'G', '\x3', '\x2', '\x2', '\x2', 
		'\x6FF', '\x700', '\a', ',', '\x2', '\x2', '\x700', '\x701', '\a', '\x23F', 
		'\x2', '\x2', '\x701', '\x702', '\a', '\x11B', '\x2', '\x2', '\x702', 
		'\x703', '\x5', '\x29E', '\x150', '\x2', '\x703', '\x704', '\a', ',', 
		'\x2', '\x2', '\x704', '\x705', '\a', '\x23F', '\x2', '\x2', '\x705', 
		'\x706', '\a', '\x304', '\x2', '\x2', '\x706', '\x724', '\x3', '\x2', 
		'\x2', '\x2', '\x707', '\x708', '\a', ',', '\x2', '\x2', '\x708', '\x709', 
		'\a', '\xA8', '\x2', '\x2', '\x709', '\x70A', '\a', '\x209', '\x2', '\x2', 
		'\x70A', '\x70B', '\a', '\x11B', '\x2', '\x2', '\x70B', '\x70C', '\x5', 
		'\x29E', '\x150', '\x2', '\x70C', '\x70D', '\a', ',', '\x2', '\x2', '\x70D', 
		'\x70E', '\a', '\xA8', '\x2', '\x2', '\x70E', '\x70F', '\a', '\x209', 
		'\x2', '\x2', '\x70F', '\x710', '\a', '\x304', '\x2', '\x2', '\x710', 
		'\x724', '\x3', '\x2', '\x2', '\x2', '\x711', '\x712', '\a', '\n', '\x2', 
		'\x2', '\x712', '\x713', '\a', '\x23F', '\x2', '\x2', '\x713', '\x714', 
		'\a', '\x11B', '\x2', '\x2', '\x714', '\x715', '\x5', '\x29E', '\x150', 
		'\x2', '\x715', '\x716', '\a', '\n', '\x2', '\x2', '\x716', '\x717', '\a', 
		'\x23F', '\x2', '\x2', '\x717', '\x718', '\a', '\x304', '\x2', '\x2', 
		'\x718', '\x724', '\x3', '\x2', '\x2', '\x2', '\x719', '\x71A', '\a', 
		'\n', '\x2', '\x2', '\x71A', '\x71B', '\a', '\xA8', '\x2', '\x2', '\x71B', 
		'\x71C', '\a', '\x209', '\x2', '\x2', '\x71C', '\x71D', '\a', '\x11B', 
		'\x2', '\x2', '\x71D', '\x71E', '\x5', '\x29E', '\x150', '\x2', '\x71E', 
		'\x71F', '\a', '\n', '\x2', '\x2', '\x71F', '\x720', '\a', '\xA8', '\x2', 
		'\x2', '\x720', '\x721', '\a', '\x209', '\x2', '\x2', '\x721', '\x722', 
		'\a', '\x304', '\x2', '\x2', '\x722', '\x724', '\x3', '\x2', '\x2', '\x2', 
		'\x723', '\x6FF', '\x3', '\x2', '\x2', '\x2', '\x723', '\x707', '\x3', 
		'\x2', '\x2', '\x2', '\x723', '\x711', '\x3', '\x2', '\x2', '\x2', '\x723', 
		'\x719', '\x3', '\x2', '\x2', '\x2', '\x724', 'I', '\x3', '\x2', '\x2', 
		'\x2', '\x725', '\x740', '\a', '\x10', '\x2', '\x2', '\x726', '\x740', 
		'\a', '\x12', '\x2', '\x2', '\x727', '\x728', '\a', '\x1B', '\x2', '\x2', 
		'\x728', '\x740', '\a', '\x241', '\x2', '\x2', '\x729', '\x740', '\a', 
		'\x1E', '\x2', '\x2', '\x72A', '\x740', '\a', 'Z', '\x2', '\x2', '\x72B', 
		'\x740', '\a', 'r', '\x2', '\x2', '\x72C', '\x72D', '\a', '\x9E', '\x2', 
		'\x2', '\x72D', '\x740', '\a', '\x241', '\x2', '\x2', '\x72E', '\x740', 
		'\a', '\xA5', '\x2', '\x2', '\x72F', '\x740', '\a', '\xE8', '\x2', '\x2', 
		'\x730', '\x740', '\a', '\x172', '\x2', '\x2', '\x731', '\x740', '\a', 
		'\x1F0', '\x2', '\x2', '\x732', '\x740', '\a', '\x1FF', '\x2', '\x2', 
		'\x733', '\x740', '\a', '\x277', '\x2', '\x2', '\x734', '\x740', '\a', 
		'\x86', '\x2', '\x2', '\x735', '\x740', '\a', '\x23D', '\x2', '\x2', '\x736', 
		'\x740', '\a', '\x229', '\x2', '\x2', '\x737', '\x740', '\a', '\x84', 
		'\x2', '\x2', '\x738', '\x740', '\a', '\x142', '\x2', '\x2', '\x739', 
		'\x740', '\a', '\x141', '\x2', '\x2', '\x73A', '\x740', '\a', '\x220', 
		'\x2', '\x2', '\x73B', '\x740', '\a', '\x24C', '\x2', '\x2', '\x73C', 
		'\x740', '\a', '}', '\x2', '\x2', '\x73D', '\x740', '\a', '\x212', '\x2', 
		'\x2', '\x73E', '\x740', '\a', '\xD9', '\x2', '\x2', '\x73F', '\x725', 
		'\x3', '\x2', '\x2', '\x2', '\x73F', '\x726', '\x3', '\x2', '\x2', '\x2', 
		'\x73F', '\x727', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x729', '\x3', 
		'\x2', '\x2', '\x2', '\x73F', '\x72A', '\x3', '\x2', '\x2', '\x2', '\x73F', 
		'\x72B', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x72C', '\x3', '\x2', '\x2', 
		'\x2', '\x73F', '\x72E', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x72F', 
		'\x3', '\x2', '\x2', '\x2', '\x73F', '\x730', '\x3', '\x2', '\x2', '\x2', 
		'\x73F', '\x731', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x732', '\x3', 
		'\x2', '\x2', '\x2', '\x73F', '\x733', '\x3', '\x2', '\x2', '\x2', '\x73F', 
		'\x734', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x735', '\x3', '\x2', '\x2', 
		'\x2', '\x73F', '\x736', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x737', 
		'\x3', '\x2', '\x2', '\x2', '\x73F', '\x738', '\x3', '\x2', '\x2', '\x2', 
		'\x73F', '\x739', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x73A', '\x3', 
		'\x2', '\x2', '\x2', '\x73F', '\x73B', '\x3', '\x2', '\x2', '\x2', '\x73F', 
		'\x73C', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x73D', '\x3', '\x2', '\x2', 
		'\x2', '\x73F', '\x73E', '\x3', '\x2', '\x2', '\x2', '\x740', 'K', '\x3', 
		'\x2', '\x2', '\x2', '\x741', '\x746', '\x5', 'N', '(', '\x2', '\x742', 
		'\x743', '\a', '\x1A4', '\x2', '\x2', '\x743', '\x745', '\x5', 'N', '(', 
		'\x2', '\x744', '\x742', '\x3', '\x2', '\x2', '\x2', '\x745', '\x748', 
		'\x3', '\x2', '\x2', '\x2', '\x746', '\x744', '\x3', '\x2', '\x2', '\x2', 
		'\x746', '\x747', '\x3', '\x2', '\x2', '\x2', '\x747', '\x749', '\x3', 
		'\x2', '\x2', '\x2', '\x748', '\x746', '\x3', '\x2', '\x2', '\x2', '\x749', 
		'\x74B', '\a', '\x19B', '\x2', '\x2', '\x74A', '\x74C', '\x5', 'P', ')', 
		'\x2', '\x74B', '\x74A', '\x3', '\x2', '\x2', '\x2', '\x74B', '\x74C', 
		'\x3', '\x2', '\x2', '\x2', '\x74C', '\x74D', '\x3', '\x2', '\x2', '\x2', 
		'\x74D', '\x74E', '\x5', '\x416', '\x20C', '\x2', '\x74E', 'M', '\x3', 
		'\x2', '\x2', '\x2', '\x74F', '\x752', '\t', '\t', '\x2', '\x2', '\x750', 
		'\x751', '\a', '\x195', '\x2', '\x2', '\x751', '\x753', '\x5', '\x448', 
		'\x225', '\x2', '\x752', '\x750', '\x3', '\x2', '\x2', '\x2', '\x752', 
		'\x753', '\x3', '\x2', '\x2', '\x2', '\x753', 'O', '\x3', '\x2', '\x2', 
		'\x2', '\x754', '\x755', '\a', '\x16F', '\x2', '\x2', '\x755', '\x756', 
		'\a', '\x258', '\x2', '\x2', '\x756', '\x757', '\x5', '\x416', '\x20C', 
		'\x2', '\x757', '\x758', '\a', '\x195', '\x2', '\x2', '\x758', 'Q', '\x3', 
		'\x2', '\x2', '\x2', '\x759', '\x75B', '\a', '\x1E8', '\x2', '\x2', '\x75A', 
		'\x75C', '\x5', 'T', '+', '\x2', '\x75B', '\x75A', '\x3', '\x2', '\x2', 
		'\x2', '\x75C', '\x75D', '\x3', '\x2', '\x2', '\x2', '\x75D', '\x75B', 
		'\x3', '\x2', '\x2', '\x2', '\x75D', '\x75E', '\x3', '\x2', '\x2', '\x2', 
		'\x75E', 'S', '\x3', '\x2', '\x2', '\x2', '\x75F', '\x760', '\t', '\n', 
		'\x2', '\x2', '\x760', '\x761', '\x5', '\x3FA', '\x1FE', '\x2', '\x761', 
		'U', '\x3', '\x2', '\x2', '\x2', '\x762', '\x763', '\a', '\xA5', '\x2', 
		'\x2', '\x763', '\x765', '\a', '\x27A', '\x2', '\x2', '\x764', '\x766', 
		'\a', '\x38', '\x2', '\x2', '\x765', '\x764', '\x3', '\x2', '\x2', '\x2', 
		'\x765', '\x766', '\x3', '\x2', '\x2', '\x2', '\x766', '\x767', '\x3', 
		'\x2', '\x2', '\x2', '\x767', '\x769', '\x5', '\x496', '\x24C', '\x2', 
		'\x768', '\x76A', '\t', '\v', '\x2', '\x2', '\x769', '\x768', '\x3', '\x2', 
		'\x2', '\x2', '\x769', '\x76A', '\x3', '\x2', '\x2', '\x2', '\x76A', '\x76B', 
		'\x3', '\x2', '\x2', '\x2', '\x76B', '\x76C', '\a', '\x304', '\x2', '\x2', 
		'\x76C', 'W', '\x3', '\x2', '\x2', '\x2', '\x76D', '\x76E', '\a', '\x10', 
		'\x2', '\x2', '\x76E', '\x76F', '\a', '\x27A', '\x2', '\x2', '\x76F', 
		'\x775', '\x5', '\x496', '\x24C', '\x2', '\x770', '\x776', '\x5', 'Z', 
		'.', '\x2', '\x771', '\x776', '\x5', '\\', '/', '\x2', '\x772', '\x776', 
		'\x5', '^', '\x30', '\x2', '\x773', '\x776', '\x5', '\x66', '\x34', '\x2', 
		'\x774', '\x776', '\x5', '\x88', '\x45', '\x2', '\x775', '\x770', '\x3', 
		'\x2', '\x2', '\x2', '\x775', '\x771', '\x3', '\x2', '\x2', '\x2', '\x775', 
		'\x772', '\x3', '\x2', '\x2', '\x2', '\x775', '\x773', '\x3', '\x2', '\x2', 
		'\x2', '\x775', '\x774', '\x3', '\x2', '\x2', '\x2', '\x776', '\x778', 
		'\x3', '\x2', '\x2', '\x2', '\x777', '\x779', '\x5', 'h', '\x35', '\x2', 
		'\x778', '\x777', '\x3', '\x2', '\x2', '\x2', '\x778', '\x779', '\x3', 
		'\x2', '\x2', '\x2', '\x779', '\x77A', '\x3', '\x2', '\x2', '\x2', '\x77A', 
		'\x77B', '\a', '\x304', '\x2', '\x2', '\x77B', 'Y', '\x3', '\x2', '\x2', 
		'\x2', '\x77C', '\x77E', '\a', '^', '\x2', '\x2', '\x77D', '\x77F', '\a', 
		'\x87', '\x2', '\x2', '\x77E', '\x77D', '\x3', '\x2', '\x2', '\x2', '\x77E', 
		'\x77F', '\x3', '\x2', '\x2', '\x2', '\x77F', '\x781', '\x3', '\x2', '\x2', 
		'\x2', '\x780', '\x782', '\t', '\f', '\x2', '\x2', '\x781', '\x780', '\x3', 
		'\x2', '\x2', '\x2', '\x781', '\x782', '\x3', '\x2', '\x2', '\x2', '\x782', 
		'\x786', '\x3', '\x2', '\x2', '\x2', '\x783', '\x785', '\x5', '\x23E', 
		'\x120', '\x2', '\x784', '\x783', '\x3', '\x2', '\x2', '\x2', '\x785', 
		'\x788', '\x3', '\x2', '\x2', '\x2', '\x786', '\x784', '\x3', '\x2', '\x2', 
		'\x2', '\x786', '\x787', '\x3', '\x2', '\x2', '\x2', '\x787', '\x78B', 
		'\x3', '\x2', '\x2', '\x2', '\x788', '\x786', '\x3', '\x2', '\x2', '\x2', 
		'\x789', '\x78A', '\a', '\x1FD', '\x2', '\x2', '\x78A', '\x78C', '\a', 
		'\x225', '\x2', '\x2', '\x78B', '\x789', '\x3', '\x2', '\x2', '\x2', '\x78B', 
		'\x78C', '\x3', '\x2', '\x2', '\x2', '\x78C', '[', '\x3', '\x2', '\x2', 
		'\x2', '\x78D', '\x78F', '\a', '\x1F1', '\x2', '\x2', '\x78E', '\x790', 
		'\x5', '\x23C', '\x11F', '\x2', '\x78F', '\x78E', '\x3', '\x2', '\x2', 
		'\x2', '\x78F', '\x790', '\x3', '\x2', '\x2', '\x2', '\x790', '\x791', 
		'\x3', '\x2', '\x2', '\x2', '\x791', '\x792', '\a', '\x19', '\x2', '\x2', 
		'\x792', '\x793', '\a', '\x192', '\x2', '\x2', '\x793', '\x794', '\a', 
		'\x2F2', '\x2', '\x2', '\x794', '\x799', '\x5', '\x8A', '\x46', '\x2', 
		'\x795', '\x796', '\a', '\x2F8', '\x2', '\x2', '\x796', '\x798', '\x5', 
		'\x8A', '\x46', '\x2', '\x797', '\x795', '\x3', '\x2', '\x2', '\x2', '\x798', 
		'\x79B', '\x3', '\x2', '\x2', '\x2', '\x799', '\x797', '\x3', '\x2', '\x2', 
		'\x2', '\x799', '\x79A', '\x3', '\x2', '\x2', '\x2', '\x79A', '\x79C', 
		'\x3', '\x2', '\x2', '\x2', '\x79B', '\x799', '\x3', '\x2', '\x2', '\x2', 
		'\x79C', '\x79D', '\a', '\x2F3', '\x2', '\x2', '\x79D', ']', '\x3', '\x2', 
		'\x2', '\x2', '\x79E', '\x7A3', '\x5', '`', '\x31', '\x2', '\x79F', '\x7A0', 
		'\a', '\x2F8', '\x2', '\x2', '\x7A0', '\x7A2', '\x5', '`', '\x31', '\x2', 
		'\x7A1', '\x79F', '\x3', '\x2', '\x2', '\x2', '\x7A2', '\x7A5', '\x3', 
		'\x2', '\x2', '\x2', '\x7A3', '\x7A1', '\x3', '\x2', '\x2', '\x2', '\x7A3', 
		'\x7A4', '\x3', '\x2', '\x2', '\x2', '\x7A4', '_', '\x3', '\x2', '\x2', 
		'\x2', '\x7A5', '\x7A3', '\x3', '\x2', '\x2', '\x2', '\x7A6', '\x7A9', 
		'\t', '\r', '\x2', '\x2', '\x7A7', '\x7AA', '\x5', '\x9A', 'N', '\x2', 
		'\x7A8', '\x7AA', '\x5', '\x92', 'J', '\x2', '\x7A9', '\x7A7', '\x3', 
		'\x2', '\x2', '\x2', '\x7A9', '\x7A8', '\x3', '\x2', '\x2', '\x2', '\x7AA', 
		'\x61', '\x3', '\x2', '\x2', '\x2', '\x7AB', '\x7AC', '\t', '\xE', '\x2', 
		'\x2', '\x7AC', '\x7B9', '\a', '\x1D', '\x2', '\x2', '\x7AD', '\x7BA', 
		'\x5', '\x64', '\x33', '\x2', '\x7AE', '\x7AF', '\a', '\x2F2', '\x2', 
		'\x2', '\x7AF', '\x7B4', '\x5', '\x64', '\x33', '\x2', '\x7B0', '\x7B1', 
		'\a', '\x2F8', '\x2', '\x2', '\x7B1', '\x7B3', '\x5', '\x64', '\x33', 
		'\x2', '\x7B2', '\x7B0', '\x3', '\x2', '\x2', '\x2', '\x7B3', '\x7B6', 
		'\x3', '\x2', '\x2', '\x2', '\x7B4', '\x7B2', '\x3', '\x2', '\x2', '\x2', 
		'\x7B4', '\x7B5', '\x3', '\x2', '\x2', '\x2', '\x7B5', '\x7B7', '\x3', 
		'\x2', '\x2', '\x2', '\x7B6', '\x7B4', '\x3', '\x2', '\x2', '\x2', '\x7B7', 
		'\x7B8', '\a', '\x2F3', '\x2', '\x2', '\x7B8', '\x7BA', '\x3', '\x2', 
		'\x2', '\x2', '\x7B9', '\x7AD', '\x3', '\x2', '\x2', '\x2', '\x7B9', '\x7AE', 
		'\x3', '\x2', '\x2', '\x2', '\x7BA', '\x63', '\x3', '\x2', '\x2', '\x2', 
		'\x7BB', '\x7BD', '\x5', '\x47A', '\x23E', '\x2', '\x7BC', '\x7BE', '\x5', 
		'\x454', '\x22B', '\x2', '\x7BD', '\x7BC', '\x3', '\x2', '\x2', '\x2', 
		'\x7BD', '\x7BE', '\x3', '\x2', '\x2', '\x2', '\x7BE', '\x65', '\x3', 
		'\x2', '\x2', '\x2', '\x7BF', '\x7C5', '\a', '\x162', '\x2', '\x2', '\x7C0', 
		'\x7C1', '\a', '\x131', '\x2', '\x2', '\x7C1', '\x7C6', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x7C2', '\x7C3', '\a', '\xAD', '\x2', '\x2', '\x7C3', 
		'\x7C4', '\a', '\x27A', '\x2', '\x2', '\x7C4', '\x7C6', '\x5', '\x454', 
		'\x22B', '\x2', '\x7C5', '\x7C0', '\x3', '\x2', '\x2', '\x2', '\x7C5', 
		'\x7C2', '\x3', '\x2', '\x2', '\x2', '\x7C6', 'g', '\x3', '\x2', '\x2', 
		'\x2', '\x7C7', '\x7D8', '\a', '\x119', '\x2', '\x2', '\x7C8', '\x7D2', 
		'\a', '\x45', '\x2', '\x2', '\x7C9', '\x7CA', '\a', 'm', '\x2', '\x2', 
		'\x7CA', '\x7CB', '\a', '\x26E', '\x2', '\x2', '\x7CB', '\x7D3', '\a', 
		'\x248', '\x2', '\x2', '\x7CC', '\x7CE', '\a', '\x18A', '\x2', '\x2', 
		'\x7CD', '\x7CC', '\x3', '\x2', '\x2', '\x2', '\x7CD', '\x7CE', '\x3', 
		'\x2', '\x2', '\x2', '\x7CE', '\x7CF', '\x3', '\x2', '\x2', '\x2', '\x7CF', 
		'\x7D0', '\a', '\xFD', '\x2', '\x2', '\x7D0', '\x7D1', '\a', '\x258', 
		'\x2', '\x2', '\x7D1', '\x7D3', '\a', '~', '\x2', '\x2', '\x7D2', '\x7C9', 
		'\x3', '\x2', '\x2', '\x2', '\x7D2', '\x7CD', '\x3', '\x2', '\x2', '\x2', 
		'\x7D2', '\x7D3', '\x3', '\x2', '\x2', '\x2', '\x7D3', '\x7D5', '\x3', 
		'\x2', '\x2', '\x2', '\x7D4', '\x7D6', '\x5', 'j', '\x36', '\x2', '\x7D5', 
		'\x7D4', '\x3', '\x2', '\x2', '\x2', '\x7D5', '\x7D6', '\x3', '\x2', '\x2', 
		'\x2', '\x7D6', '\x7D8', '\x3', '\x2', '\x2', '\x2', '\x7D7', '\x7C7', 
		'\x3', '\x2', '\x2', '\x2', '\x7D7', '\x7C8', '\x3', '\x2', '\x2', '\x2', 
		'\x7D8', 'i', '\x3', '\x2', '\x2', '\x2', '\x7D9', '\x7DB', '\a', '\xDB', 
		'\x2', '\x2', '\x7DA', '\x7D9', '\x3', '\x2', '\x2', '\x2', '\x7DA', '\x7DB', 
		'\x3', '\x2', '\x2', '\x2', '\x7DB', '\x7DC', '\x3', '\x2', '\x2', '\x2', 
		'\x7DC', '\x7DD', '\a', '\xC0', '\x2', '\x2', '\x7DD', '\x7DE', '\a', 
		'\x118', '\x2', '\x2', '\x7DE', '\x7DF', '\x5', '\x416', '\x20C', '\x2', 
		'\x7DF', 'k', '\x3', '\x2', '\x2', '\x2', '\x7E0', '\x7E3', '\a', 'r', 
		'\x2', '\x2', '\x7E1', '\x7E2', '\a', '\x1A4', '\x2', '\x2', '\x7E2', 
		'\x7E4', '\a', '\x1F1', '\x2', '\x2', '\x7E3', '\x7E1', '\x3', '\x2', 
		'\x2', '\x2', '\x7E3', '\x7E4', '\x3', '\x2', '\x2', '\x2', '\x7E4', '\x7E5', 
		'\x3', '\x2', '\x2', '\x2', '\x7E5', '\x7E8', '\a', '\x27A', '\x2', '\x2', 
		'\x7E6', '\x7E9', '\x5', 'n', '\x38', '\x2', '\x7E7', '\x7E9', '\x5', 
		'z', '>', '\x2', '\x7E8', '\x7E6', '\x3', '\x2', '\x2', '\x2', '\x7E8', 
		'\x7E7', '\x3', '\x2', '\x2', '\x2', '\x7E9', '\x7EA', '\x3', '\x2', '\x2', 
		'\x2', '\x7EA', '\x7EB', '\a', '\x304', '\x2', '\x2', '\x7EB', 'm', '\x3', 
		'\x2', '\x2', '\x2', '\x7EC', '\x7EF', '\x5', '\x496', '\x24C', '\x2', 
		'\x7ED', '\x7EE', '\a', '\x196', '\x2', '\x2', '\x7EE', '\x7F0', '\a', 
		'\x2EE', '\x2', '\x2', '\x7EF', '\x7ED', '\x3', '\x2', '\x2', '\x2', '\x7EF', 
		'\x7F0', '\x3', '\x2', '\x2', '\x2', '\x7F0', '\x7F2', '\x3', '\x2', '\x2', 
		'\x2', '\x7F1', '\x7F3', '\x5', 'p', '\x39', '\x2', '\x7F2', '\x7F1', 
		'\x3', '\x2', '\x2', '\x2', '\x7F2', '\x7F3', '\x3', '\x2', '\x2', '\x2', 
		'\x7F3', 'o', '\x3', '\x2', '\x2', '\x2', '\x7F4', '\x7F6', '\x5', '\x23C', 
		'\x11F', '\x2', '\x7F5', '\x7F4', '\x3', '\x2', '\x2', '\x2', '\x7F5', 
		'\x7F6', '\x3', '\x2', '\x2', '\x2', '\x7F6', '\x7F9', '\x3', '\x2', '\x2', 
		'\x2', '\x7F7', '\x7FA', '\x5', 'r', ':', '\x2', '\x7F8', '\x7FA', '\x5', 
		't', ';', '\x2', '\x7F9', '\x7F7', '\x3', '\x2', '\x2', '\x2', '\x7F9', 
		'\x7F8', '\x3', '\x2', '\x2', '\x2', '\x7FA', '\x7FC', '\x3', '\x2', '\x2', 
		'\x2', '\x7FB', '\x7FD', '\x5', 'x', '=', '\x2', '\x7FC', '\x7FB', '\x3', 
		'\x2', '\x2', '\x2', '\x7FC', '\x7FD', '\x3', '\x2', '\x2', '\x2', '\x7FD', 
		'\x809', '\x3', '\x2', '\x2', '\x2', '\x7FE', '\x7FF', '\a', '\x2F2', 
		'\x2', '\x2', '\x7FF', '\x804', '\x5', '\x8A', '\x46', '\x2', '\x800', 
		'\x801', '\a', '\x2F8', '\x2', '\x2', '\x801', '\x803', '\x5', '\x8A', 
		'\x46', '\x2', '\x802', '\x800', '\x3', '\x2', '\x2', '\x2', '\x803', 
		'\x806', '\x3', '\x2', '\x2', '\x2', '\x804', '\x802', '\x3', '\x2', '\x2', 
		'\x2', '\x804', '\x805', '\x3', '\x2', '\x2', '\x2', '\x805', '\x807', 
		'\x3', '\x2', '\x2', '\x2', '\x806', '\x804', '\x3', '\x2', '\x2', '\x2', 
		'\x807', '\x808', '\a', '\x2F3', '\x2', '\x2', '\x808', '\x80A', '\x3', 
		'\x2', '\x2', '\x2', '\x809', '\x7FE', '\x3', '\x2', '\x2', '\x2', '\x809', 
		'\x80A', '\x3', '\x2', '\x2', '\x2', '\x80A', '\x80E', '\x3', '\x2', '\x2', 
		'\x2', '\x80B', '\x80D', '\x5', '\x88', '\x45', '\x2', '\x80C', '\x80B', 
		'\x3', '\x2', '\x2', '\x2', '\x80D', '\x810', '\x3', '\x2', '\x2', '\x2', 
		'\x80E', '\x80C', '\x3', '\x2', '\x2', '\x2', '\x80E', '\x80F', '\x3', 
		'\x2', '\x2', '\x2', '\x80F', 'q', '\x3', '\x2', '\x2', '\x2', '\x810', 
		'\x80E', '\x3', '\x2', '\x2', '\x2', '\x811', '\x815', '\t', '\x2', '\x2', 
		'\x2', '\x812', '\x816', '\a', '\x192', '\x2', '\x2', '\x813', '\x816', 
		'\x5', '\x266', '\x134', '\x2', '\x814', '\x816', '\x5', 'v', '<', '\x2', 
		'\x815', '\x812', '\x3', '\x2', '\x2', '\x2', '\x815', '\x813', '\x3', 
		'\x2', '\x2', '\x2', '\x815', '\x814', '\x3', '\x2', '\x2', '\x2', '\x816', 
		's', '\x3', '\x2', '\x2', '\x2', '\x817', '\x818', '\a', '\x27C', '\x2', 
		'\x2', '\x818', '\x819', '\x5', '\x454', '\x22B', '\x2', '\x819', 'u', 
		'\x3', '\x2', '\x2', '\x2', '\x81A', '\x81B', '\a', '\x258', '\x2', '\x2', 
		'\x81B', '\x81C', '\a', '\x195', '\x2', '\x2', '\x81C', '\x81F', '\x5', 
		'\x454', '\x22B', '\x2', '\x81D', '\x81E', '\a', '\x18A', '\x2', '\x2', 
		'\x81E', '\x820', '\a', '\x18D', '\x2', '\x2', '\x81F', '\x81D', '\x3', 
		'\x2', '\x2', '\x2', '\x81F', '\x820', '\x3', '\x2', '\x2', '\x2', '\x820', 
		'w', '\x3', '\x2', '\x2', '\x2', '\x821', '\x822', '\a', '\xCA', '\x2', 
		'\x2', '\x822', '\x823', '\a', '\x167', '\x2', '\x2', '\x823', '\x824', 
		'\x5', '\x37E', '\x1C0', '\x2', '\x824', '\x825', '\a', '\x124', '\x2', 
		'\x2', '\x825', '\x826', '\a', '\x11E', '\x2', '\x2', '\x826', '\x827', 
		'\a', '\x28E', '\x2', '\x2', '\x827', '\x828', '\t', '\xF', '\x2', '\x2', 
		'\x828', 'y', '\x3', '\x2', '\x2', '\x2', '\x829', '\x82A', '\a', '\x38', 
		'\x2', '\x2', '\x82A', '\x82B', '\x5', '\x496', '\x24C', '\x2', '\x82B', 
		'\x82D', '\t', '\x2', '\x2', '\x2', '\x82C', '\x82E', '\x5', '|', '?', 
		'\x2', '\x82D', '\x82C', '\x3', '\x2', '\x2', '\x2', '\x82E', '\x82F', 
		'\x3', '\x2', '\x2', '\x2', '\x82F', '\x82D', '\x3', '\x2', '\x2', '\x2', 
		'\x82F', '\x830', '\x3', '\x2', '\x2', '\x2', '\x830', '\x831', '\x3', 
		'\x2', '\x2', '\x2', '\x831', '\x832', '\a', '\xB5', '\x2', '\x2', '\x832', 
		'{', '\x3', '\x2', '\x2', '\x2', '\x833', '\x836', '\x5', '~', '@', '\x2', 
		'\x834', '\x836', '\x5', '\x80', '\x41', '\x2', '\x835', '\x833', '\x3', 
		'\x2', '\x2', '\x2', '\x835', '\x834', '\x3', '\x2', '\x2', '\x2', '\x836', 
		'}', '\x3', '\x2', '\x2', '\x2', '\x837', '\x838', '\t', '\x10', '\x2', 
		'\x2', '\x838', '\x839', '\a', '\x154', '\x2', '\x2', '\x839', '\x83A', 
		'\x5', '\x84', '\x43', '\x2', '\x83A', '\x7F', '\x3', '\x2', '\x2', '\x2', 
		'\x83B', '\x83F', '\t', '\x11', '\x2', '\x2', '\x83C', '\x840', '\x5', 
		'\x82', '\x42', '\x2', '\x83D', '\x840', '\x5', '\x84', '\x43', '\x2', 
		'\x83E', '\x840', '\x5', '\x86', '\x44', '\x2', '\x83F', '\x83C', '\x3', 
		'\x2', '\x2', '\x2', '\x83F', '\x83D', '\x3', '\x2', '\x2', '\x2', '\x83F', 
		'\x83E', '\x3', '\x2', '\x2', '\x2', '\x840', '\x81', '\x3', '\x2', '\x2', 
		'\x2', '\x841', '\x842', '\a', '\x1D5', '\x2', '\x2', '\x842', '\x843', 
		'\x5', '\x43C', '\x21F', '\x2', '\x843', '\x844', '\a', '\x2F2', '\x2', 
		'\x2', '\x844', '\x849', '\x5', '\xA0', 'Q', '\x2', '\x845', '\x846', 
		'\a', '\x2F8', '\x2', '\x2', '\x846', '\x848', '\x5', '\xA0', 'Q', '\x2', 
		'\x847', '\x845', '\x3', '\x2', '\x2', '\x2', '\x848', '\x84B', '\x3', 
		'\x2', '\x2', '\x2', '\x849', '\x847', '\x3', '\x2', '\x2', '\x2', '\x849', 
		'\x84A', '\x3', '\x2', '\x2', '\x2', '\x84A', '\x84C', '\x3', '\x2', '\x2', 
		'\x2', '\x84B', '\x849', '\x3', '\x2', '\x2', '\x2', '\x84C', '\x84D', 
		'\a', '\x2F3', '\x2', '\x2', '\x84D', '\x858', '\t', '\x2', '\x2', '\x2', 
		'\x84E', '\x859', '\x5', '\x240', '\x121', '\x2', '\x84F', '\x851', '\a', 
		'\x8A', '\x2', '\x2', '\x850', '\x84F', '\x3', '\x2', '\x2', '\x2', '\x850', 
		'\x851', '\x3', '\x2', '\x2', '\x2', '\x851', '\x853', '\x3', '\x2', '\x2', 
		'\x2', '\x852', '\x854', '\x5', '\x24E', '\x128', '\x2', '\x853', '\x852', 
		'\x3', '\x2', '\x2', '\x2', '\x853', '\x854', '\x3', '\x2', '\x2', '\x2', 
		'\x854', '\x855', '\x3', '\x2', '\x2', '\x2', '\x855', '\x856', '\x5', 
		'\x29A', '\x14E', '\x2', '\x856', '\x857', '\a', '\x304', '\x2', '\x2', 
		'\x857', '\x859', '\x3', '\x2', '\x2', '\x2', '\x858', '\x84E', '\x3', 
		'\x2', '\x2', '\x2', '\x858', '\x850', '\x3', '\x2', '\x2', '\x2', '\x859', 
		'\x83', '\x3', '\x2', '\x2', '\x2', '\x85A', '\x85B', '\a', '\xE3', '\x2', 
		'\x2', '\x85B', '\x867', '\x5', '\x43A', '\x21E', '\x2', '\x85C', '\x85D', 
		'\a', '\x2F2', '\x2', '\x2', '\x85D', '\x862', '\x5', '\xA0', 'Q', '\x2', 
		'\x85E', '\x85F', '\a', '\x2F8', '\x2', '\x2', '\x85F', '\x861', '\x5', 
		'\xA0', 'Q', '\x2', '\x860', '\x85E', '\x3', '\x2', '\x2', '\x2', '\x861', 
		'\x864', '\x3', '\x2', '\x2', '\x2', '\x862', '\x860', '\x3', '\x2', '\x2', 
		'\x2', '\x862', '\x863', '\x3', '\x2', '\x2', '\x2', '\x863', '\x865', 
		'\x3', '\x2', '\x2', '\x2', '\x864', '\x862', '\x3', '\x2', '\x2', '\x2', 
		'\x865', '\x866', '\a', '\x2F3', '\x2', '\x2', '\x866', '\x868', '\x3', 
		'\x2', '\x2', '\x2', '\x867', '\x85C', '\x3', '\x2', '\x2', '\x2', '\x867', 
		'\x868', '\x3', '\x2', '\x2', '\x2', '\x868', '\x869', '\x3', '\x2', '\x2', 
		'\x2', '\x869', '\x86A', '\a', '\x1FC', '\x2', '\x2', '\x86A', '\x86B', 
		'\x5', '\x454', '\x22B', '\x2', '\x86B', '\x876', '\t', '\x2', '\x2', 
		'\x2', '\x86C', '\x877', '\x5', '\x240', '\x121', '\x2', '\x86D', '\x86F', 
		'\a', '\x8A', '\x2', '\x2', '\x86E', '\x86D', '\x3', '\x2', '\x2', '\x2', 
		'\x86E', '\x86F', '\x3', '\x2', '\x2', '\x2', '\x86F', '\x871', '\x3', 
		'\x2', '\x2', '\x2', '\x870', '\x872', '\x5', '\x24E', '\x128', '\x2', 
		'\x871', '\x870', '\x3', '\x2', '\x2', '\x2', '\x871', '\x872', '\x3', 
		'\x2', '\x2', '\x2', '\x872', '\x873', '\x3', '\x2', '\x2', '\x2', '\x873', 
		'\x874', '\x5', '\x29A', '\x14E', '\x2', '\x874', '\x875', '\a', '\x304', 
		'\x2', '\x2', '\x875', '\x877', '\x3', '\x2', '\x2', '\x2', '\x876', '\x86C', 
		'\x3', '\x2', '\x2', '\x2', '\x876', '\x86E', '\x3', '\x2', '\x2', '\x2', 
		'\x877', '\x85', '\x3', '\x2', '\x2', '\x2', '\x878', '\x87A', '\a', '\xD1', 
		'\x2', '\x2', '\x879', '\x878', '\x3', '\x2', '\x2', '\x2', '\x879', '\x87A', 
		'\x3', '\x2', '\x2', '\x2', '\x87A', '\x87C', '\x3', '\x2', '\x2', '\x2', 
		'\x87B', '\x87D', '\a', '\x111', '\x2', '\x2', '\x87C', '\x87B', '\x3', 
		'\x2', '\x2', '\x2', '\x87C', '\x87D', '\x3', '\x2', '\x2', '\x2', '\x87D', 
		'\x87E', '\x3', '\x2', '\x2', '\x2', '\x87E', '\x87F', '\a', 'g', '\x2', 
		'\x2', '\x87F', '\x880', '\a', '\xE3', '\x2', '\x2', '\x880', '\x892', 
		'\x5', '\x454', '\x22B', '\x2', '\x881', '\x882', '\a', '\x2F2', '\x2', 
		'\x2', '\x882', '\x883', '\a', '\x21B', '\x2', '\x2', '\x883', '\x884', 
		'\a', '\x108', '\x2', '\x2', '\x884', '\x885', '\a', '\x1A8', '\x2', '\x2', 
		'\x885', '\x886', '\x5', '\x454', '\x22B', '\x2', '\x886', '\x887', '\a', 
		'\x2F8', '\x2', '\x2', '\x887', '\x888', '\x3', '\x2', '\x2', '\x2', '\x888', 
		'\x88D', '\x5', '\xA0', 'Q', '\x2', '\x889', '\x88A', '\a', '\x2F8', '\x2', 
		'\x2', '\x88A', '\x88C', '\x5', '\xA0', 'Q', '\x2', '\x88B', '\x889', 
		'\x3', '\x2', '\x2', '\x2', '\x88C', '\x88F', '\x3', '\x2', '\x2', '\x2', 
		'\x88D', '\x88B', '\x3', '\x2', '\x2', '\x2', '\x88D', '\x88E', '\x3', 
		'\x2', '\x2', '\x2', '\x88E', '\x890', '\x3', '\x2', '\x2', '\x2', '\x88F', 
		'\x88D', '\x3', '\x2', '\x2', '\x2', '\x890', '\x891', '\a', '\x2F3', 
		'\x2', '\x2', '\x891', '\x893', '\x3', '\x2', '\x2', '\x2', '\x892', '\x881', 
		'\x3', '\x2', '\x2', '\x2', '\x892', '\x893', '\x3', '\x2', '\x2', '\x2', 
		'\x893', '\x894', '\x3', '\x2', '\x2', '\x2', '\x894', '\x895', '\a', 
		'\x1FC', '\x2', '\x2', '\x895', '\x896', '\a', '\x21B', '\x2', '\x2', 
		'\x896', '\x897', '\a', '\x19', '\x2', '\x2', '\x897', '\x898', '\a', 
		'\x1F8', '\x2', '\x2', '\x898', '\x8A3', '\t', '\x2', '\x2', '\x2', '\x899', 
		'\x8A4', '\x5', '\x240', '\x121', '\x2', '\x89A', '\x89C', '\a', '\x8A', 
		'\x2', '\x2', '\x89B', '\x89A', '\x3', '\x2', '\x2', '\x2', '\x89B', '\x89C', 
		'\x3', '\x2', '\x2', '\x2', '\x89C', '\x89E', '\x3', '\x2', '\x2', '\x2', 
		'\x89D', '\x89F', '\x5', '\x24E', '\x128', '\x2', '\x89E', '\x89D', '\x3', 
		'\x2', '\x2', '\x2', '\x89E', '\x89F', '\x3', '\x2', '\x2', '\x2', '\x89F', 
		'\x8A0', '\x3', '\x2', '\x2', '\x2', '\x8A0', '\x8A1', '\x5', '\x29A', 
		'\x14E', '\x2', '\x8A1', '\x8A2', '\a', '\x304', '\x2', '\x2', '\x8A2', 
		'\x8A4', '\x3', '\x2', '\x2', '\x2', '\x8A3', '\x899', '\x3', '\x2', '\x2', 
		'\x2', '\x8A3', '\x89B', '\x3', '\x2', '\x2', '\x2', '\x8A4', '\x87', 
		'\x3', '\x2', '\x2', '\x2', '\x8A5', '\x8A7', '\a', '\x18A', '\x2', '\x2', 
		'\x8A6', '\x8A5', '\x3', '\x2', '\x2', '\x2', '\x8A6', '\x8A7', '\x3', 
		'\x2', '\x2', '\x2', '\x8A7', '\x8A8', '\x3', '\x2', '\x2', '\x2', '\x8A8', 
		'\x8A9', '\t', '\x12', '\x2', '\x2', '\x8A9', '\x89', '\x3', '\x2', '\x2', 
		'\x2', '\x8AA', '\x8AB', '\x5', '\x46E', '\x238', '\x2', '\x8AB', '\x8AD', 
		'\x5', '\x454', '\x22B', '\x2', '\x8AC', '\x8AE', '\x5', '\x8C', 'G', 
		'\x2', '\x8AD', '\x8AC', '\x3', '\x2', '\x2', '\x2', '\x8AD', '\x8AE', 
		'\x3', '\x2', '\x2', '\x2', '\x8AE', '\x8B1', '\x3', '\x2', '\x2', '\x2', 
		'\x8AF', '\x8B1', '\x5', '\x8E', 'H', '\x2', '\x8B0', '\x8AA', '\x3', 
		'\x2', '\x2', '\x2', '\x8B0', '\x8AF', '\x3', '\x2', '\x2', '\x2', '\x8B1', 
		'\x8B', '\x3', '\x2', '\x2', '\x2', '\x8B2', '\x8B3', '\a', '\xCA', '\x2', 
		'\x2', '\x8B3', '\x8B4', '\a', '\x167', '\x2', '\x2', '\x8B4', '\x8B5', 
		'\x5', '\x37E', '\x1C0', '\x2', '\x8B5', '\x8D', '\x3', '\x2', '\x2', 
		'\x2', '\x8B6', '\x8B8', '\x5', '\x88', '\x45', '\x2', '\x8B7', '\x8B6', 
		'\x3', '\x2', '\x2', '\x2', '\x8B7', '\x8B8', '\x3', '\x2', '\x2', '\x2', 
		'\x8B8', '\x8BA', '\x3', '\x2', '\x2', '\x2', '\x8B9', '\x8BB', '\x5', 
		'\x90', 'I', '\x2', '\x8BA', '\x8B9', '\x3', '\x2', '\x2', '\x2', '\x8BB', 
		'\x8BC', '\x3', '\x2', '\x2', '\x2', '\x8BC', '\x8BA', '\x3', '\x2', '\x2', 
		'\x2', '\x8BC', '\x8BD', '\x3', '\x2', '\x2', '\x2', '\x8BD', '\x8C0', 
		'\x3', '\x2', '\x2', '\x2', '\x8BE', '\x8BF', '\a', '\x2F8', '\x2', '\x2', 
		'\x8BF', '\x8C1', '\x5', '\x9C', 'O', '\x2', '\x8C0', '\x8BE', '\x3', 
		'\x2', '\x2', '\x2', '\x8C0', '\x8C1', '\x3', '\x2', '\x2', '\x2', '\x8C1', 
		'\x8F', '\x3', '\x2', '\x2', '\x2', '\x8C2', '\x8C6', '\x5', '\x92', 'J', 
		'\x2', '\x8C3', '\x8C6', '\x5', '\x98', 'M', '\x2', '\x8C4', '\x8C6', 
		'\x5', '\x9A', 'N', '\x2', '\x8C5', '\x8C2', '\x3', '\x2', '\x2', '\x2', 
		'\x8C5', '\x8C3', '\x3', '\x2', '\x2', '\x2', '\x8C5', '\x8C4', '\x3', 
		'\x2', '\x2', '\x2', '\x8C6', '\x91', '\x3', '\x2', '\x2', '\x2', '\x8C7', 
		'\x8CA', '\t', '\x11', '\x2', '\x2', '\x8C8', '\x8CB', '\x5', '\x94', 
		'K', '\x2', '\x8C9', '\x8CB', '\x5', '\x96', 'L', '\x2', '\x8CA', '\x8C8', 
		'\x3', '\x2', '\x2', '\x2', '\x8CA', '\x8C9', '\x3', '\x2', '\x2', '\x2', 
		'\x8CB', '\x93', '\x3', '\x2', '\x2', '\x2', '\x8CC', '\x8CD', '\a', '\x1D5', 
		'\x2', '\x2', '\x8CD', '\x8CE', '\x5', '\x43C', '\x21F', '\x2', '\x8CE', 
		'\x8CF', '\a', '\x2F2', '\x2', '\x2', '\x8CF', '\x8D4', '\x5', '\xA0', 
		'Q', '\x2', '\x8D0', '\x8D1', '\a', '\x2F8', '\x2', '\x2', '\x8D1', '\x8D3', 
		'\x5', '\xA0', 'Q', '\x2', '\x8D2', '\x8D0', '\x3', '\x2', '\x2', '\x2', 
		'\x8D3', '\x8D6', '\x3', '\x2', '\x2', '\x2', '\x8D4', '\x8D2', '\x3', 
		'\x2', '\x2', '\x2', '\x8D4', '\x8D5', '\x3', '\x2', '\x2', '\x2', '\x8D5', 
		'\x8D7', '\x3', '\x2', '\x2', '\x2', '\x8D6', '\x8D4', '\x3', '\x2', '\x2', 
		'\x2', '\x8D7', '\x8DA', '\a', '\x2F3', '\x2', '\x2', '\x8D8', '\x8D9', 
		'\t', '\x2', '\x2', '\x2', '\x8D9', '\x8DB', '\x5', '\x240', '\x121', 
		'\x2', '\x8DA', '\x8D8', '\x3', '\x2', '\x2', '\x2', '\x8DA', '\x8DB', 
		'\x3', '\x2', '\x2', '\x2', '\x8DB', '\x95', '\x3', '\x2', '\x2', '\x2', 
		'\x8DC', '\x8DD', '\a', '\xE3', '\x2', '\x2', '\x8DD', '\x8E9', '\x5', 
		'\x43A', '\x21E', '\x2', '\x8DE', '\x8DF', '\a', '\x2F2', '\x2', '\x2', 
		'\x8DF', '\x8E4', '\x5', '\xA0', 'Q', '\x2', '\x8E0', '\x8E1', '\a', '\x2F8', 
		'\x2', '\x2', '\x8E1', '\x8E3', '\x5', '\xA0', 'Q', '\x2', '\x8E2', '\x8E0', 
		'\x3', '\x2', '\x2', '\x2', '\x8E3', '\x8E6', '\x3', '\x2', '\x2', '\x2', 
		'\x8E4', '\x8E2', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8E5', '\x3', 
		'\x2', '\x2', '\x2', '\x8E5', '\x8E7', '\x3', '\x2', '\x2', '\x2', '\x8E6', 
		'\x8E4', '\x3', '\x2', '\x2', '\x2', '\x8E7', '\x8E8', '\a', '\x2F3', 
		'\x2', '\x2', '\x8E8', '\x8EA', '\x3', '\x2', '\x2', '\x2', '\x8E9', '\x8DE', 
		'\x3', '\x2', '\x2', '\x2', '\x8E9', '\x8EA', '\x3', '\x2', '\x2', '\x2', 
		'\x8EA', '\x8EB', '\x3', '\x2', '\x2', '\x2', '\x8EB', '\x8F0', '\a', 
		'\x1FC', '\x2', '\x2', '\x8EC', '\x8F1', '\x5', '\x454', '\x22B', '\x2', 
		'\x8ED', '\x8EE', '\a', '\x21B', '\x2', '\x2', '\x8EE', '\x8EF', '\a', 
		'\x19', '\x2', '\x2', '\x8EF', '\x8F1', '\a', '\x1F8', '\x2', '\x2', '\x8F0', 
		'\x8EC', '\x3', '\x2', '\x2', '\x2', '\x8F0', '\x8ED', '\x3', '\x2', '\x2', 
		'\x2', '\x8F1', '\x8FA', '\x3', '\x2', '\x2', '\x2', '\x8F2', '\x8F3', 
		'\t', '\x2', '\x2', '\x2', '\x8F3', '\x8FB', '\x5', '\x240', '\x121', 
		'\x2', '\x8F4', '\x8F6', '\a', '\xCA', '\x2', '\x2', '\x8F5', '\x8F7', 
		'\a', '\x294', '\x2', '\x2', '\x8F6', '\x8F5', '\x3', '\x2', '\x2', '\x2', 
		'\x8F6', '\x8F7', '\x3', '\x2', '\x2', '\x2', '\x8F7', '\x8F8', '\x3', 
		'\x2', '\x2', '\x2', '\x8F8', '\x8F9', '\a', '\x167', '\x2', '\x2', '\x8F9', 
		'\x8FB', '\x5', '\x37E', '\x1C0', '\x2', '\x8FA', '\x8F2', '\x3', '\x2', 
		'\x2', '\x2', '\x8FA', '\x8F4', '\x3', '\x2', '\x2', '\x2', '\x8FA', '\x8FB', 
		'\x3', '\x2', '\x2', '\x2', '\x8FB', '\x97', '\x3', '\x2', '\x2', '\x2', 
		'\x8FC', '\x8FE', '\a', '\xD1', '\x2', '\x2', '\x8FD', '\x8FC', '\x3', 
		'\x2', '\x2', '\x2', '\x8FD', '\x8FE', '\x3', '\x2', '\x2', '\x2', '\x8FE', 
		'\x900', '\x3', '\x2', '\x2', '\x2', '\x8FF', '\x901', '\a', '\x111', 
		'\x2', '\x2', '\x900', '\x8FF', '\x3', '\x2', '\x2', '\x2', '\x900', '\x901', 
		'\x3', '\x2', '\x2', '\x2', '\x901', '\x902', '\x3', '\x2', '\x2', '\x2', 
		'\x902', '\x903', '\a', 'g', '\x2', '\x2', '\x903', '\x904', '\a', '\xE3', 
		'\x2', '\x2', '\x904', '\x916', '\x5', '\x454', '\x22B', '\x2', '\x905', 
		'\x906', '\a', '\x2F2', '\x2', '\x2', '\x906', '\x907', '\a', '\x21B', 
		'\x2', '\x2', '\x907', '\x908', '\a', '\x108', '\x2', '\x2', '\x908', 
		'\x909', '\a', '\x1A8', '\x2', '\x2', '\x909', '\x90A', '\x5', '\x454', 
		'\x22B', '\x2', '\x90A', '\x90B', '\a', '\x2F8', '\x2', '\x2', '\x90B', 
		'\x90C', '\x3', '\x2', '\x2', '\x2', '\x90C', '\x911', '\x5', '\xA0', 
		'Q', '\x2', '\x90D', '\x90E', '\a', '\x2F8', '\x2', '\x2', '\x90E', '\x910', 
		'\x5', '\xA0', 'Q', '\x2', '\x90F', '\x90D', '\x3', '\x2', '\x2', '\x2', 
		'\x910', '\x913', '\x3', '\x2', '\x2', '\x2', '\x911', '\x90F', '\x3', 
		'\x2', '\x2', '\x2', '\x911', '\x912', '\x3', '\x2', '\x2', '\x2', '\x912', 
		'\x914', '\x3', '\x2', '\x2', '\x2', '\x913', '\x911', '\x3', '\x2', '\x2', 
		'\x2', '\x914', '\x915', '\a', '\x2F3', '\x2', '\x2', '\x915', '\x917', 
		'\x3', '\x2', '\x2', '\x2', '\x916', '\x905', '\x3', '\x2', '\x2', '\x2', 
		'\x916', '\x917', '\x3', '\x2', '\x2', '\x2', '\x917', '\x918', '\x3', 
		'\x2', '\x2', '\x2', '\x918', '\x919', '\a', '\x1FC', '\x2', '\x2', '\x919', 
		'\x91A', '\a', '\x21B', '\x2', '\x2', '\x91A', '\x91B', '\a', '\x19', 
		'\x2', '\x2', '\x91B', '\x91E', '\a', '\x1F8', '\x2', '\x2', '\x91C', 
		'\x91D', '\t', '\x2', '\x2', '\x2', '\x91D', '\x91F', '\x5', '\x240', 
		'\x121', '\x2', '\x91E', '\x91C', '\x3', '\x2', '\x2', '\x2', '\x91E', 
		'\x91F', '\x3', '\x2', '\x2', '\x2', '\x91F', '\x99', '\x3', '\x2', '\x2', 
		'\x2', '\x920', '\x921', '\t', '\x10', '\x2', '\x2', '\x921', '\x922', 
		'\a', '\x154', '\x2', '\x2', '\x922', '\x923', '\x5', '\x96', 'L', '\x2', 
		'\x923', '\x9B', '\x3', '\x2', '\x2', '\x2', '\x924', '\x925', '\a', '\x1CB', 
		'\x2', '\x2', '\x925', '\x926', '\a', '\x1F6', '\x2', '\x2', '\x926', 
		'\x927', '\a', '\x2F2', '\x2', '\x2', '\x927', '\x92C', '\x5', '\x9E', 
		'P', '\x2', '\x928', '\x929', '\a', '\x2F8', '\x2', '\x2', '\x929', '\x92B', 
		'\x5', '\x9E', 'P', '\x2', '\x92A', '\x928', '\x3', '\x2', '\x2', '\x2', 
		'\x92B', '\x92E', '\x3', '\x2', '\x2', '\x2', '\x92C', '\x92A', '\x3', 
		'\x2', '\x2', '\x2', '\x92C', '\x92D', '\x3', '\x2', '\x2', '\x2', '\x92D', 
		'\x92F', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x92C', '\x3', '\x2', '\x2', 
		'\x2', '\x92F', '\x930', '\a', '\x2F3', '\x2', '\x2', '\x930', '\x9D', 
		'\x3', '\x2', '\x2', '\x2', '\x931', '\x934', '\x5', '\x46E', '\x238', 
		'\x2', '\x932', '\x934', '\a', '\x8F', '\x2', '\x2', '\x933', '\x931', 
		'\x3', '\x2', '\x2', '\x2', '\x933', '\x932', '\x3', '\x2', '\x2', '\x2', 
		'\x934', '\x9F', '\x3', '\x2', '\x2', '\x2', '\x935', '\x936', '\x5', 
		'\x474', '\x23B', '\x2', '\x936', '\x937', '\x5', '\x454', '\x22B', '\x2', 
		'\x937', '\xA1', '\x3', '\x2', '\x2', '\x2', '\x938', '\x939', '\a', '\xA5', 
		'\x2', '\x2', '\x939', '\x93A', '\a', '\x21C', '\x2', '\x2', '\x93A', 
		'\x93B', '\x5', '\x498', '\x24D', '\x2', '\x93B', '\x93C', '\a', '\x304', 
		'\x2', '\x2', '\x93C', '\xA3', '\x3', '\x2', '\x2', '\x2', '\x93D', '\x93E', 
		'\a', '\x10', '\x2', '\x2', '\x93E', '\x93F', '\a', '\x21C', '\x2', '\x2', 
		'\x93F', '\x941', '\x5', '\x498', '\x24D', '\x2', '\x940', '\x942', '\x5', 
		'\xA8', 'U', '\x2', '\x941', '\x940', '\x3', '\x2', '\x2', '\x2', '\x942', 
		'\x943', '\x3', '\x2', '\x2', '\x2', '\x943', '\x941', '\x3', '\x2', '\x2', 
		'\x2', '\x943', '\x944', '\x3', '\x2', '\x2', '\x2', '\x944', '\x945', 
		'\x3', '\x2', '\x2', '\x2', '\x945', '\x946', '\a', '\x304', '\x2', '\x2', 
		'\x946', '\xA5', '\x3', '\x2', '\x2', '\x2', '\x947', '\x948', '\a', 'r', 
		'\x2', '\x2', '\x948', '\x949', '\a', '\x21C', '\x2', '\x2', '\x949', 
		'\x94D', '\x5', '\x498', '\x24D', '\x2', '\x94A', '\x94C', '\x5', '\xA8', 
		'U', '\x2', '\x94B', '\x94A', '\x3', '\x2', '\x2', '\x2', '\x94C', '\x94F', 
		'\x3', '\x2', '\x2', '\x2', '\x94D', '\x94B', '\x3', '\x2', '\x2', '\x2', 
		'\x94D', '\x94E', '\x3', '\x2', '\x2', '\x2', '\x94E', '\x950', '\x3', 
		'\x2', '\x2', '\x2', '\x94F', '\x94D', '\x3', '\x2', '\x2', '\x2', '\x950', 
		'\x951', '\a', '\x304', '\x2', '\x2', '\x951', '\xA7', '\x3', '\x2', '\x2', 
		'\x2', '\x952', '\x953', '\a', '\xFE', '\x2', '\x2', '\x953', '\x957', 
		'\a', '?', '\x2', '\x2', '\x954', '\x955', '\a', '\x23C', '\x2', '\x2', 
		'\x955', '\x957', '\a', '\x2A6', '\x2', '\x2', '\x956', '\x952', '\x3', 
		'\x2', '\x2', '\x2', '\x956', '\x954', '\x3', '\x2', '\x2', '\x2', '\x957', 
		'\x958', '\x3', '\x2', '\x2', '\x2', '\x958', '\x96D', '\x5', '\x4A4', 
		'\x253', '\x2', '\x959', '\x95A', '\a', '\x150', '\x2', '\x2', '\x95A', 
		'\x95D', '\x5', '\x4A4', '\x253', '\x2', '\x95B', '\x95D', '\a', '\x17D', 
		'\x2', '\x2', '\x95C', '\x959', '\x3', '\x2', '\x2', '\x2', '\x95C', '\x95B', 
		'\x3', '\x2', '\x2', '\x2', '\x95D', '\x96D', '\x3', '\x2', '\x2', '\x2', 
		'\x95E', '\x95F', '\a', '\x15D', '\x2', '\x2', '\x95F', '\x962', '\x5', 
		'\x4A4', '\x253', '\x2', '\x960', '\x962', '\a', '\x17E', '\x2', '\x2', 
		'\x961', '\x95E', '\x3', '\x2', '\x2', '\x2', '\x961', '\x960', '\x3', 
		'\x2', '\x2', '\x2', '\x962', '\x96D', '\x3', '\x2', '\x2', '\x2', '\x963', 
		'\x96D', '\t', '\x13', '\x2', '\x2', '\x964', '\x965', '\a', '\x41', '\x2', 
		'\x2', '\x965', '\x968', '\x5', '\x4A4', '\x253', '\x2', '\x966', '\x968', 
		'\a', '\x173', '\x2', '\x2', '\x967', '\x964', '\x3', '\x2', '\x2', '\x2', 
		'\x967', '\x966', '\x3', '\x2', '\x2', '\x2', '\x968', '\x96D', '\x3', 
		'\x2', '\x2', '\x2', '\x969', '\x96D', '\t', '\x14', '\x2', '\x2', '\x96A', 
		'\x96D', '\t', '\x15', '\x2', '\x2', '\x96B', '\x96D', '\t', '\x16', '\x2', 
		'\x2', '\x96C', '\x956', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x95C', 
		'\x3', '\x2', '\x2', '\x2', '\x96C', '\x961', '\x3', '\x2', '\x2', '\x2', 
		'\x96C', '\x963', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x967', '\x3', 
		'\x2', '\x2', '\x2', '\x96C', '\x969', '\x3', '\x2', '\x2', '\x2', '\x96C', 
		'\x96A', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x96B', '\x3', '\x2', '\x2', 
		'\x2', '\x96D', '\xA9', '\x3', '\x2', '\x2', '\x2', '\x96E', '\x970', 
		'\a', 'r', '\x2', '\x2', '\x96F', '\x971', '\a', '\x280', '\x2', '\x2', 
		'\x970', '\x96F', '\x3', '\x2', '\x2', '\x2', '\x970', '\x971', '\x3', 
		'\x2', '\x2', '\x2', '\x971', '\x972', '\x3', '\x2', '\x2', '\x2', '\x972', 
		'\x973', '\a', '\x101', '\x2', '\x2', '\x973', '\x974', '\x5', '\x442', 
		'\x222', '\x2', '\x974', '\x975', '\a', '\x19B', '\x2', '\x2', '\x975', 
		'\x976', '\x5', '\x416', '\x20C', '\x2', '\x976', '\x979', '\x5', '\x44A', 
		'\x226', '\x2', '\x977', '\x978', '\a', '\x256', '\x2', '\x2', '\x978', 
		'\x97A', '\a', '\x310', '\x2', '\x2', '\x979', '\x977', '\x3', '\x2', 
		'\x2', '\x2', '\x979', '\x97A', '\x3', '\x2', '\x2', '\x2', '\x97A', '\x97D', 
		'\x3', '\x2', '\x2', '\x2', '\x97B', '\x97C', '\a', '\x61', '\x2', '\x2', 
		'\x97C', '\x97E', '\a', '\x241', '\x2', '\x2', '\x97D', '\x97B', '\x3', 
		'\x2', '\x2', '\x2', '\x97D', '\x97E', '\x3', '\x2', '\x2', '\x2', '\x97E', 
		'\x97F', '\x3', '\x2', '\x2', '\x2', '\x97F', '\x980', '\a', '\x304', 
		'\x2', '\x2', '\x980', '\xAB', '\x3', '\x2', '\x2', '\x2', '\x981', '\x982', 
		'\a', '\x10', '\x2', '\x2', '\x982', '\x983', '\a', '\x101', '\x2', '\x2', 
		'\x983', '\x984', '\x5', '\x442', '\x222', '\x2', '\x984', '\x985', '\a', 
		'\x1F0', '\x2', '\x2', '\x985', '\x986', '\a', '\x26E', '\x2', '\x2', 
		'\x986', '\x987', '\x5', '\x442', '\x222', '\x2', '\x987', '\x988', '\a', 
		'\x304', '\x2', '\x2', '\x988', '\xAD', '\x3', '\x2', '\x2', '\x2', '\x989', 
		'\x98A', '\a', 'r', '\x2', '\x2', '\x98A', '\x98B', '\a', '\x28C', '\x2', 
		'\x2', '\x98B', '\x995', '\x5', '\x424', '\x213', '\x2', '\x98C', '\x996', 
		'\x5', '\xB4', '[', '\x2', '\x98D', '\x996', '\x5', '\xB6', '\\', '\x2', 
		'\x98E', '\x996', '\x5', '\xB8', ']', '\x2', '\x98F', '\x996', '\x5', 
		'\xBA', '^', '\x2', '\x990', '\x996', '\x5', '\xBC', '_', '\x2', '\x991', 
		'\x996', '\x5', '\xC2', '\x62', '\x2', '\x992', '\x996', '\x5', '\xC4', 
		'\x63', '\x2', '\x993', '\x996', '\x5', '\xC6', '\x64', '\x2', '\x994', 
		'\x996', '\x5', '\xDE', 'p', '\x2', '\x995', '\x98C', '\x3', '\x2', '\x2', 
		'\x2', '\x995', '\x98D', '\x3', '\x2', '\x2', '\x2', '\x995', '\x98E', 
		'\x3', '\x2', '\x2', '\x2', '\x995', '\x98F', '\x3', '\x2', '\x2', '\x2', 
		'\x995', '\x990', '\x3', '\x2', '\x2', '\x2', '\x995', '\x991', '\x3', 
		'\x2', '\x2', '\x2', '\x995', '\x992', '\x3', '\x2', '\x2', '\x2', '\x995', 
		'\x993', '\x3', '\x2', '\x2', '\x2', '\x995', '\x994', '\x3', '\x2', '\x2', 
		'\x2', '\x996', '\x997', '\x3', '\x2', '\x2', '\x2', '\x997', '\x995', 
		'\x3', '\x2', '\x2', '\x2', '\x997', '\x998', '\x3', '\x2', '\x2', '\x2', 
		'\x998', '\x999', '\x3', '\x2', '\x2', '\x2', '\x999', '\x99A', '\a', 
		'\x304', '\x2', '\x2', '\x99A', '\xAF', '\x3', '\x2', '\x2', '\x2', '\x99B', 
		'\x99C', '\a', '\x10', '\x2', '\x2', '\x99C', '\x99D', '\a', '\x28C', 
		'\x2', '\x2', '\x99D', '\x9A9', '\x5', '\x424', '\x213', '\x2', '\x99E', 
		'\x9AA', '\x5', '\xB2', 'Z', '\x2', '\x99F', '\x9AA', '\x5', '\xB6', '\\', 
		'\x2', '\x9A0', '\x9AA', '\x5', '\xB8', ']', '\x2', '\x9A1', '\x9AA', 
		'\x5', '\xBA', '^', '\x2', '\x9A2', '\x9AA', '\x5', '\xBC', '_', '\x2', 
		'\x9A3', '\x9AA', '\x5', '\xC0', '\x61', '\x2', '\x9A4', '\x9AA', '\x5', 
		'\xC2', '\x62', '\x2', '\x9A5', '\x9AA', '\x5', '\xC4', '\x63', '\x2', 
		'\x9A6', '\x9AA', '\x5', '\xC8', '\x65', '\x2', '\x9A7', '\x9AA', '\x5', 
		'\xDE', 'p', '\x2', '\x9A8', '\x9AA', '\x5', '\xD2', 'j', '\x2', '\x9A9', 
		'\x99E', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x99F', '\x3', '\x2', '\x2', 
		'\x2', '\x9A9', '\x9A0', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9A1', 
		'\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9A2', '\x3', '\x2', '\x2', '\x2', 
		'\x9A9', '\x9A3', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9A4', '\x3', 
		'\x2', '\x2', '\x2', '\x9A9', '\x9A5', '\x3', '\x2', '\x2', '\x2', '\x9A9', 
		'\x9A6', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9A7', '\x3', '\x2', '\x2', 
		'\x2', '\x9A9', '\x9A8', '\x3', '\x2', '\x2', '\x2', '\x9AA', '\x9AB', 
		'\x3', '\x2', '\x2', '\x2', '\x9AB', '\x9A9', '\x3', '\x2', '\x2', '\x2', 
		'\x9AB', '\x9AC', '\x3', '\x2', '\x2', '\x2', '\x9AC', '\x9AD', '\x3', 
		'\x2', '\x2', '\x2', '\x9AD', '\x9AE', '\a', '\x304', '\x2', '\x2', '\x9AE', 
		'\x9BB', '\x3', '\x2', '\x2', '\x2', '\x9AF', '\x9B1', '\a', '\x2F8', 
		'\x2', '\x2', '\x9B0', '\x9AF', '\x3', '\x2', '\x2', '\x2', '\x9B0', '\x9B1', 
		'\x3', '\x2', '\x2', '\x2', '\x9B1', '\x9B2', '\x3', '\x2', '\x2', '\x2', 
		'\x9B2', '\x9B4', '\x5', '\x424', '\x213', '\x2', '\x9B3', '\x9B0', '\x3', 
		'\x2', '\x2', '\x2', '\x9B4', '\x9B5', '\x3', '\x2', '\x2', '\x2', '\x9B5', 
		'\x9B3', '\x3', '\x2', '\x2', '\x2', '\x9B5', '\x9B6', '\x3', '\x2', '\x2', 
		'\x2', '\x9B6', '\x9B7', '\x3', '\x2', '\x2', '\x2', '\x9B7', '\x9B8', 
		'\x5', '\xCA', '\x66', '\x2', '\x9B8', '\x9B9', '\a', '\x304', '\x2', 
		'\x2', '\x9B9', '\x9BB', '\x3', '\x2', '\x2', '\x2', '\x9BA', '\x99B', 
		'\x3', '\x2', '\x2', '\x2', '\x9BA', '\x9B3', '\x3', '\x2', '\x2', '\x2', 
		'\x9BB', '\xB1', '\x3', '\x2', '\x2', '\x2', '\x9BC', '\x9BF', '\x5', 
		'\xB4', '[', '\x2', '\x9BD', '\x9BE', '\a', '\x1F1', '\x2', '\x2', '\x9BE', 
		'\x9C0', '\x5', '\x492', '\x24A', '\x2', '\x9BF', '\x9BD', '\x3', '\x2', 
		'\x2', '\x2', '\x9BF', '\x9C0', '\x3', '\x2', '\x2', '\x2', '\x9C0', '\xB3', 
		'\x3', '\x2', '\x2', '\x2', '\x9C1', '\x9C2', '\a', '\xF4', '\x2', '\x2', 
		'\x9C2', '\x9C3', '\a', '?', '\x2', '\x2', '\x9C3', '\x9C4', '\x5', '\x492', 
		'\x24A', '\x2', '\x9C4', '\xB5', '\x3', '\x2', '\x2', '\x2', '\x9C5', 
		'\x9C6', '\a', '\xF4', '\x2', '\x2', '\x9C6', '\x9C9', '\t', '\x17', '\x2', 
		'\x2', '\x9C7', '\x9C8', '\a', '\x19', '\x2', '\x2', '\x9C8', '\x9CA', 
		'\x5', '\x4AA', '\x256', '\x2', '\x9C9', '\x9C7', '\x3', '\x2', '\x2', 
		'\x2', '\x9C9', '\x9CA', '\x3', '\x2', '\x2', '\x2', '\x9CA', '\xB7', 
		'\x3', '\x2', '\x2', '\x2', '\x9CB', '\x9CC', '\t', '\x18', '\x2', '\x2', 
		'\x9CC', '\x9CD', '\a', '\x256', '\x2', '\x2', '\x9CD', '\x9CE', '\x5', 
		'\x492', '\x24A', '\x2', '\x9CE', '\xB9', '\x3', '\x2', '\x2', '\x2', 
		'\x9CF', '\x9D2', '\a', '\x1DC', '\x2', '\x2', '\x9D0', '\x9D3', '\x5', 
		'\x21C', '\x10F', '\x2', '\x9D1', '\x9D3', '\a', '\x281', '\x2', '\x2', 
		'\x9D2', '\x9D0', '\x3', '\x2', '\x2', '\x2', '\x9D2', '\x9D1', '\x3', 
		'\x2', '\x2', '\x2', '\x9D3', '\x9D4', '\x3', '\x2', '\x2', '\x2', '\x9D4', 
		'\x9D5', '\a', '\x19B', '\x2', '\x2', '\x9D5', '\x9D6', '\x5', '\x492', 
		'\x24A', '\x2', '\x9D6', '\xBB', '\x3', '\x2', '\x2', '\x2', '\x9D7', 
		'\x9D8', '\a', '\x1D7', '\x2', '\x2', '\x9D8', '\x9D9', '\x5', '\x492', 
		'\x24A', '\x2', '\x9D9', '\xBD', '\x3', '\x2', '\x2', '\x2', '\x9DA', 
		'\x9DC', '\a', '\x2F8', '\x2', '\x2', '\x9DB', '\x9DA', '\x3', '\x2', 
		'\x2', '\x2', '\x9DB', '\x9DC', '\x3', '\x2', '\x2', '\x2', '\x9DC', '\x9DD', 
		'\x3', '\x2', '\x2', '\x2', '\x9DD', '\x9DF', '\x5', '\x40A', '\x206', 
		'\x2', '\x9DE', '\x9DB', '\x3', '\x2', '\x2', '\x2', '\x9DF', '\x9E0', 
		'\x3', '\x2', '\x2', '\x2', '\x9E0', '\x9DE', '\x3', '\x2', '\x2', '\x2', 
		'\x9E0', '\x9E1', '\x3', '\x2', '\x2', '\x2', '\x9E1', '\x9F2', '\x3', 
		'\x2', '\x2', '\x2', '\x9E2', '\x9EE', '\a', '\xE', '\x2', '\x2', '\x9E3', 
		'\x9E8', '\a', '\xBD', '\x2', '\x2', '\x9E4', '\x9E6', '\a', '\x2F8', 
		'\x2', '\x2', '\x9E5', '\x9E4', '\x3', '\x2', '\x2', '\x2', '\x9E5', '\x9E6', 
		'\x3', '\x2', '\x2', '\x2', '\x9E6', '\x9E7', '\x3', '\x2', '\x2', '\x2', 
		'\x9E7', '\x9E9', '\x5', '\x40A', '\x206', '\x2', '\x9E8', '\x9E5', '\x3', 
		'\x2', '\x2', '\x2', '\x9E9', '\x9EA', '\x3', '\x2', '\x2', '\x2', '\x9EA', 
		'\x9E8', '\x3', '\x2', '\x2', '\x2', '\x9EA', '\x9EB', '\x3', '\x2', '\x2', 
		'\x2', '\x9EB', '\x9ED', '\x3', '\x2', '\x2', '\x2', '\x9EC', '\x9E3', 
		'\x3', '\x2', '\x2', '\x2', '\x9ED', '\x9F0', '\x3', '\x2', '\x2', '\x2', 
		'\x9EE', '\x9EC', '\x3', '\x2', '\x2', '\x2', '\x9EE', '\x9EF', '\x3', 
		'\x2', '\x2', '\x2', '\x9EF', '\x9F2', '\x3', '\x2', '\x2', '\x2', '\x9F0', 
		'\x9EE', '\x3', '\x2', '\x2', '\x2', '\x9F1', '\x9DE', '\x3', '\x2', '\x2', 
		'\x2', '\x9F1', '\x9E2', '\x3', '\x2', '\x2', '\x2', '\x9F2', '\xBF', 
		'\x3', '\x2', '\x2', '\x2', '\x9F3', '\x9F4', '\a', '\x8F', '\x2', '\x2', 
		'\x9F4', '\x9F7', '\a', '\x202', '\x2', '\x2', '\x9F5', '\x9F8', '\a', 
		'\x180', '\x2', '\x2', '\x9F6', '\x9F8', '\x5', '\xBE', '`', '\x2', '\x9F7', 
		'\x9F5', '\x3', '\x2', '\x2', '\x2', '\x9F7', '\x9F6', '\x3', '\x2', '\x2', 
		'\x2', '\x9F8', '\xC1', '\x3', '\x2', '\x2', '\x2', '\x9F9', '\x9FA', 
		'\a', '\x1B5', '\x2', '\x2', '\x9FA', '\x9FB', '\a', '\xC7', '\x2', '\x2', 
		'\x9FB', '\xC3', '\x3', '\x2', '\x2', '\x2', '\x9FC', '\x9FD', '\a', '\x4', 
		'\x2', '\x2', '\x9FD', '\x9FE', '\t', '\x19', '\x2', '\x2', '\x9FE', '\xC5', 
		'\x3', '\x2', '\x2', '\x2', '\x9FF', '\xA00', '\a', '\xB1', '\x2', '\x2', 
		'\xA00', '\xA01', '\a', '\xAC', '\x2', '\x2', '\xA01', '\xC7', '\x3', 
		'\x2', '\x2', '\x2', '\xA02', '\xA0C', '\x5', '\xC6', '\x64', '\x2', '\xA03', 
		'\xA08', '\a', '\xDD', '\x2', '\x2', '\xA04', '\xA06', '\a', '\x2F8', 
		'\x2', '\x2', '\xA05', '\xA04', '\x3', '\x2', '\x2', '\x2', '\xA05', '\xA06', 
		'\x3', '\x2', '\x2', '\x2', '\xA06', '\xA07', '\x3', '\x2', '\x2', '\x2', 
		'\xA07', '\xA09', '\x5', '\x49E', '\x250', '\x2', '\xA08', '\xA05', '\x3', 
		'\x2', '\x2', '\x2', '\xA09', '\xA0A', '\x3', '\x2', '\x2', '\x2', '\xA0A', 
		'\xA08', '\x3', '\x2', '\x2', '\x2', '\xA0A', '\xA0B', '\x3', '\x2', '\x2', 
		'\x2', '\xA0B', '\xA0D', '\x3', '\x2', '\x2', '\x2', '\xA0C', '\xA03', 
		'\x3', '\x2', '\x2', '\x2', '\xA0C', '\xA0D', '\x3', '\x2', '\x2', '\x2', 
		'\xA0D', '\xA0F', '\x3', '\x2', '\x2', '\x2', '\xA0E', '\xA10', '\a', 
		'\xDB', '\x2', '\x2', '\xA0F', '\xA0E', '\x3', '\x2', '\x2', '\x2', '\xA0F', 
		'\xA10', '\x3', '\x2', '\x2', '\x2', '\xA10', '\xC9', '\x3', '\x2', '\x2', 
		'\x2', '\xA11', '\xA12', '\a', '\x1FF', '\x2', '\x2', '\xA12', '\xA13', 
		'\a', '\x63', '\x2', '\x2', '\xA13', '\xA17', '\a', '\x25F', '\x2', '\x2', 
		'\xA14', '\xA15', '\a', '\xB6', '\x2', '\x2', '\xA15', '\xA18', '\a', 
		'\x28B', '\x2', '\x2', '\xA16', '\xA18', '\x5', '\x424', '\x213', '\x2', 
		'\xA17', '\xA14', '\x3', '\x2', '\x2', '\x2', '\xA17', '\xA16', '\x3', 
		'\x2', '\x2', '\x2', '\xA18', '\xA39', '\x3', '\x2', '\x2', '\x2', '\xA19', 
		'\xA1A', '\a', '\xE8', '\x2', '\x2', '\xA1A', '\xA1B', '\a', '\x63', '\x2', 
		'\x2', '\xA1B', '\xA36', '\a', '\x25F', '\x2', '\x2', '\xA1C', '\xA1D', 
		'\a', '\xB6', '\x2', '\x2', '\xA1D', '\xA37', '\a', '\x28B', '\x2', '\x2', 
		'\xA1E', '\xA26', '\x5', '\x424', '\x213', '\x2', '\xA1F', '\xA24', '\a', 
		'\x2A6', '\x2', '\x2', '\xA20', '\xA21', '\a', '\x181', '\x2', '\x2', 
		'\xA21', '\xA25', '\a', '\x203', '\x2', '\x2', '\xA22', '\xA23', '\a', 
		'\x202', '\x2', '\x2', '\xA23', '\xA25', '\x5', '\xBE', '`', '\x2', '\xA24', 
		'\xA20', '\x3', '\x2', '\x2', '\x2', '\xA24', '\xA22', '\x3', '\x2', '\x2', 
		'\x2', '\xA25', '\xA27', '\x3', '\x2', '\x2', '\x2', '\xA26', '\xA1F', 
		'\x3', '\x2', '\x2', '\x2', '\xA26', '\xA27', '\x3', '\x2', '\x2', '\x2', 
		'\xA27', '\xA2A', '\x3', '\x2', '\x2', '\x2', '\xA28', '\xA29', '\a', 
		' ', '\x2', '\x2', '\xA29', '\xA2B', '\a', '\x1F2', '\x2', '\x2', '\xA2A', 
		'\xA28', '\x3', '\x2', '\x2', '\x2', '\xA2A', '\xA2B', '\x3', '\x2', '\x2', 
		'\x2', '\xA2B', '\xA34', '\x3', '\x2', '\x2', '\x2', '\xA2C', '\xA2D', 
		'\a', '\x1F', '\x2', '\x2', '\xA2D', '\xA32', '\a', '\x28E', '\x2', '\x2', 
		'\xA2E', '\xA33', '\a', '\x1B5', '\x2', '\x2', '\xA2F', '\xA33', '\a', 
		'H', '\x2', '\x2', '\xA30', '\xA31', '\a', '\xA0', '\x2', '\x2', '\xA31', 
		'\xA33', '\a', '\x167', '\x2', '\x2', '\xA32', '\xA2E', '\x3', '\x2', 
		'\x2', '\x2', '\xA32', '\xA2F', '\x3', '\x2', '\x2', '\x2', '\xA32', '\xA30', 
		'\x3', '\x2', '\x2', '\x2', '\xA33', '\xA35', '\x3', '\x2', '\x2', '\x2', 
		'\xA34', '\xA2C', '\x3', '\x2', '\x2', '\x2', '\xA34', '\xA35', '\x3', 
		'\x2', '\x2', '\x2', '\xA35', '\xA37', '\x3', '\x2', '\x2', '\x2', '\xA36', 
		'\xA1C', '\x3', '\x2', '\x2', '\x2', '\xA36', '\xA1E', '\x3', '\x2', '\x2', 
		'\x2', '\xA37', '\xA39', '\x3', '\x2', '\x2', '\x2', '\xA38', '\xA11', 
		'\x3', '\x2', '\x2', '\x2', '\xA38', '\xA19', '\x3', '\x2', '\x2', '\x2', 
		'\xA39', '\xCB', '\x3', '\x2', '\x2', '\x2', '\xA3A', '\xA3F', '\a', '\x2F2', 
		'\x2', '\x2', '\xA3B', '\xA3D', '\a', '\x2F8', '\x2', '\x2', '\xA3C', 
		'\xA3B', '\x3', '\x2', '\x2', '\x2', '\xA3C', '\xA3D', '\x3', '\x2', '\x2', 
		'\x2', '\xA3D', '\xA3E', '\x3', '\x2', '\x2', '\x2', '\xA3E', '\xA40', 
		'\x5', '\x492', '\x24A', '\x2', '\xA3F', '\xA3C', '\x3', '\x2', '\x2', 
		'\x2', '\xA40', '\xA41', '\x3', '\x2', '\x2', '\x2', '\xA41', '\xA3F', 
		'\x3', '\x2', '\x2', '\x2', '\xA41', '\xA42', '\x3', '\x2', '\x2', '\x2', 
		'\xA42', '\xA43', '\x3', '\x2', '\x2', '\x2', '\xA43', '\xA44', '\a', 
		'\x2F3', '\x2', '\x2', '\xA44', '\xCD', '\x3', '\x2', '\x2', '\x2', '\xA45', 
		'\xA46', '\a', '\x223', '\x2', '\x2', '\xA46', '\xA47', '\a', 'i', '\x2', 
		'\x2', '\xA47', '\xA4B', '\a', '\x306', '\x2', '\x2', '\xA48', '\xA4C', 
		'\a', '\xE', '\x2', '\x2', '\xA49', '\xA4C', '\a', '\x8F', '\x2', '\x2', 
		'\xA4A', '\xA4C', '\x5', '\xCC', 'g', '\x2', '\xA4B', '\xA48', '\x3', 
		'\x2', '\x2', '\x2', '\xA4B', '\xA49', '\x3', '\x2', '\x2', '\x2', '\xA4B', 
		'\xA4A', '\x3', '\x2', '\x2', '\x2', '\xA4C', '\xCF', '\x3', '\x2', '\x2', 
		'\x2', '\xA4D', '\xA4E', '\t', '\x1A', '\x2', '\x2', '\xA4E', '\xA4F', 
		'\a', 'i', '\x2', '\x2', '\xA4F', '\xA50', '\a', '\x306', '\x2', '\x2', 
		'\xA50', '\xA51', '\x5', '\xCC', 'g', '\x2', '\xA51', '\xD1', '\x3', '\x2', 
		'\x2', '\x2', '\xA52', '\xA59', '\x5', '\xCE', 'h', '\x2', '\xA53', '\xA56', 
		'\x5', '\xD0', 'i', '\x2', '\xA54', '\xA55', '\a', '\xDD', '\x2', '\x2', 
		'\xA55', '\xA57', '\x5', '\x438', '\x21D', '\x2', '\xA56', '\xA54', '\x3', 
		'\x2', '\x2', '\x2', '\xA56', '\xA57', '\x3', '\x2', '\x2', '\x2', '\xA57', 
		'\xA59', '\x3', '\x2', '\x2', '\x2', '\xA58', '\xA52', '\x3', '\x2', '\x2', 
		'\x2', '\xA58', '\xA53', '\x3', '\x2', '\x2', '\x2', '\xA59', '\xD3', 
		'\x3', '\x2', '\x2', '\x2', '\xA5A', '\xA5B', '\a', '\xA5', '\x2', '\x2', 
		'\xA5B', '\xA5C', '\a', '\x101', '\x2', '\x2', '\xA5C', '\xA5D', '\x5', 
		'\x442', '\x222', '\x2', '\xA5D', '\xA5E', '\a', '\x304', '\x2', '\x2', 
		'\xA5E', '\xD5', '\x3', '\x2', '\x2', '\x2', '\xA5F', '\xA62', '\a', '\x1FF', 
		'\x2', '\x2', '\xA60', '\xA63', '\x5', '\xD8', 'm', '\x2', '\xA61', '\xA63', 
		'\x5', '\xDA', 'n', '\x2', '\xA62', '\xA60', '\x3', '\x2', '\x2', '\x2', 
		'\xA62', '\xA61', '\x3', '\x2', '\x2', '\x2', '\xA63', '\xA64', '\x3', 
		'\x2', '\x2', '\x2', '\xA64', '\xA65', '\a', '\x304', '\x2', '\x2', '\xA65', 
		'\xD7', '\x3', '\x2', '\x2', '\x2', '\xA66', '\xA68', '\a', '\x2F8', '\x2', 
		'\x2', '\xA67', '\xA66', '\x3', '\x2', '\x2', '\x2', '\xA67', '\xA68', 
		'\x3', '\x2', '\x2', '\x2', '\xA68', '\xA6B', '\x3', '\x2', '\x2', '\x2', 
		'\xA69', '\xA6C', '\x5', '\x40A', '\x206', '\x2', '\xA6A', '\xA6C', '\x5', 
		'\x466', '\x234', '\x2', '\xA6B', '\xA69', '\x3', '\x2', '\x2', '\x2', 
		'\xA6B', '\xA6A', '\x3', '\x2', '\x2', '\x2', '\xA6C', '\xA6D', '\x3', 
		'\x2', '\x2', '\x2', '\xA6D', '\xA73', '\a', '\xE1', '\x2', '\x2', '\xA6E', 
		'\xA70', '\a', '\x2F8', '\x2', '\x2', '\xA6F', '\xA6E', '\x3', '\x2', 
		'\x2', '\x2', '\xA6F', '\xA70', '\x3', '\x2', '\x2', '\x2', '\xA70', '\xA71', 
		'\x3', '\x2', '\x2', '\x2', '\xA71', '\xA74', '\x5', '\x408', '\x205', 
		'\x2', '\xA72', '\xA74', '\a', '\x1D9', '\x2', '\x2', '\xA73', '\xA6F', 
		'\x3', '\x2', '\x2', '\x2', '\xA73', '\xA72', '\x3', '\x2', '\x2', '\x2', 
		'\xA74', '\xA75', '\x3', '\x2', '\x2', '\x2', '\xA75', '\xA73', '\x3', 
		'\x2', '\x2', '\x2', '\xA75', '\xA76', '\x3', '\x2', '\x2', '\x2', '\xA76', 
		'\xD9', '\x3', '\x2', '\x2', '\x2', '\xA77', '\xA79', '\a', '\x2F8', '\x2', 
		'\x2', '\xA78', '\xA77', '\x3', '\x2', '\x2', '\x2', '\xA78', '\xA79', 
		'\x3', '\x2', '\x2', '\x2', '\xA79', '\xA7C', '\x3', '\x2', '\x2', '\x2', 
		'\xA7A', '\xA7D', '\x5', '\x40A', '\x206', '\x2', '\xA7B', '\xA7D', '\x5', 
		'\x464', '\x233', '\x2', '\xA7C', '\xA7A', '\x3', '\x2', '\x2', '\x2', 
		'\xA7C', '\xA7B', '\x3', '\x2', '\x2', '\x2', '\xA7D', '\xA7F', '\x3', 
		'\x2', '\x2', '\x2', '\xA7E', '\xA78', '\x3', '\x2', '\x2', '\x2', '\xA7F', 
		'\xA80', '\x3', '\x2', '\x2', '\x2', '\xA80', '\xA7E', '\x3', '\x2', '\x2', 
		'\x2', '\xA80', '\xA81', '\x3', '\x2', '\x2', '\x2', '\xA81', '\xA82', 
		'\x3', '\x2', '\x2', '\x2', '\xA82', '\xA83', '\a', '\x19B', '\x2', '\x2', 
		'\xA83', '\xA84', '\x5', '\x446', '\x224', '\x2', '\xA84', '\xA85', '\x3', 
		'\x2', '\x2', '\x2', '\xA85', '\xA8C', '\a', '\xE1', '\x2', '\x2', '\xA86', 
		'\xA88', '\a', '\x2F8', '\x2', '\x2', '\xA87', '\xA86', '\x3', '\x2', 
		'\x2', '\x2', '\xA87', '\xA88', '\x3', '\x2', '\x2', '\x2', '\xA88', '\xA89', 
		'\x3', '\x2', '\x2', '\x2', '\xA89', '\xA8D', '\x5', '\x408', '\x205', 
		'\x2', '\xA8A', '\xA8D', '\a', '\x1D9', '\x2', '\x2', '\xA8B', '\xA8D', 
		'\x5', '\x40A', '\x206', '\x2', '\xA8C', '\xA87', '\x3', '\x2', '\x2', 
		'\x2', '\xA8C', '\xA8A', '\x3', '\x2', '\x2', '\x2', '\xA8C', '\xA8B', 
		'\x3', '\x2', '\x2', '\x2', '\xA8D', '\xA8E', '\x3', '\x2', '\x2', '\x2', 
		'\xA8E', '\xA8C', '\x3', '\x2', '\x2', '\x2', '\xA8E', '\xA8F', '\x3', 
		'\x2', '\x2', '\x2', '\xA8F', '\xA93', '\x3', '\x2', '\x2', '\x2', '\xA90', 
		'\xA91', '\a', '\x45', '\x2', '\x2', '\xA91', '\xA94', '\a', '\x66', '\x2', 
		'\x2', '\xA92', '\xA94', '\a', '\xDB', '\x2', '\x2', '\xA93', '\xA90', 
		'\x3', '\x2', '\x2', '\x2', '\xA93', '\xA92', '\x3', '\x2', '\x2', '\x2', 
		'\xA93', '\xA94', '\x3', '\x2', '\x2', '\x2', '\xA94', '\xDB', '\x3', 
		'\x2', '\x2', '\x2', '\xA95', '\xAA1', '\a', '\xE8', '\x2', '\x2', '\xA96', 
		'\xA98', '\a', '\x2F8', '\x2', '\x2', '\xA97', '\xA96', '\x3', '\x2', 
		'\x2', '\x2', '\xA97', '\xA98', '\x3', '\x2', '\x2', '\x2', '\xA98', '\xA9F', 
		'\x3', '\x2', '\x2', '\x2', '\xA99', '\xAA0', '\x5', '\x40A', '\x206', 
		'\x2', '\xA9A', '\xAA0', '\x5', '\x466', '\x234', '\x2', '\xA9B', '\xA9D', 
		'\x5', '\x464', '\x233', '\x2', '\xA9C', '\xA9E', '\x5', '\x44A', '\x226', 
		'\x2', '\xA9D', '\xA9C', '\x3', '\x2', '\x2', '\x2', '\xA9D', '\xA9E', 
		'\x3', '\x2', '\x2', '\x2', '\xA9E', '\xAA0', '\x3', '\x2', '\x2', '\x2', 
		'\xA9F', '\xA99', '\x3', '\x2', '\x2', '\x2', '\xA9F', '\xA9A', '\x3', 
		'\x2', '\x2', '\x2', '\xA9F', '\xA9B', '\x3', '\x2', '\x2', '\x2', '\xAA0', 
		'\xAA2', '\x3', '\x2', '\x2', '\x2', '\xAA1', '\xA97', '\x3', '\x2', '\x2', 
		'\x2', '\xAA2', '\xAA3', '\x3', '\x2', '\x2', '\x2', '\xAA3', '\xAA1', 
		'\x3', '\x2', '\x2', '\x2', '\xAA3', '\xAA4', '\x3', '\x2', '\x2', '\x2', 
		'\xAA4', '\xAA7', '\x3', '\x2', '\x2', '\x2', '\xAA5', '\xAA6', '\a', 
		'\x19B', '\x2', '\x2', '\xAA6', '\xAA8', '\x5', '\x446', '\x224', '\x2', 
		'\xAA7', '\xAA5', '\x3', '\x2', '\x2', '\x2', '\xAA7', '\xAA8', '\x3', 
		'\x2', '\x2', '\x2', '\xAA8', '\xAA9', '\x3', '\x2', '\x2', '\x2', '\xAA9', 
		'\xAAF', '\a', '\x26E', '\x2', '\x2', '\xAAA', '\xAAC', '\a', '\x2F8', 
		'\x2', '\x2', '\xAAB', '\xAAA', '\x3', '\x2', '\x2', '\x2', '\xAAB', '\xAAC', 
		'\x3', '\x2', '\x2', '\x2', '\xAAC', '\xAAD', '\x3', '\x2', '\x2', '\x2', 
		'\xAAD', '\xAB0', '\x5', '\x408', '\x205', '\x2', '\xAAE', '\xAB0', '\a', 
		'\x1D9', '\x2', '\x2', '\xAAF', '\xAAB', '\x3', '\x2', '\x2', '\x2', '\xAAF', 
		'\xAAE', '\x3', '\x2', '\x2', '\x2', '\xAB0', '\xAB1', '\x3', '\x2', '\x2', 
		'\x2', '\xAB1', '\xAAF', '\x3', '\x2', '\x2', '\x2', '\xAB1', '\xAB2', 
		'\x3', '\x2', '\x2', '\x2', '\xAB2', '\xAB6', '\x3', '\x2', '\x2', '\x2', 
		'\xAB3', '\xAB4', '\a', '\x2A6', '\x2', '\x2', '\xAB4', '\xAB5', '\t', 
		'\x1B', '\x2', '\x2', '\xAB5', '\xAB7', '\a', '\x19F', '\x2', '\x2', '\xAB6', 
		'\xAB3', '\x3', '\x2', '\x2', '\x2', '\xAB6', '\xAB7', '\x3', '\x2', '\x2', 
		'\x2', '\xAB7', '\xABB', '\x3', '\x2', '\x2', '\x2', '\xAB8', '\xAB9', 
		'\a', '\x2A6', '\x2', '\x2', '\xAB9', '\xABA', '\a', '\xF1', '\x2', '\x2', 
		'\xABA', '\xABC', '\a', '\x19F', '\x2', '\x2', '\xABB', '\xAB8', '\x3', 
		'\x2', '\x2', '\x2', '\xABB', '\xABC', '\x3', '\x2', '\x2', '\x2', '\xABC', 
		'\xAC0', '\x3', '\x2', '\x2', '\x2', '\xABD', '\xABE', '\a', '\x2A6', 
		'\x2', '\x2', '\xABE', '\xABF', '\a', '\xE8', '\x2', '\x2', '\xABF', '\xAC1', 
		'\a', '\x19F', '\x2', '\x2', '\xAC0', '\xABD', '\x3', '\x2', '\x2', '\x2', 
		'\xAC0', '\xAC1', '\x3', '\x2', '\x2', '\x2', '\xAC1', '\xAC3', '\x3', 
		'\x2', '\x2', '\x2', '\xAC2', '\xAC4', '\x5', '\xDE', 'p', '\x2', '\xAC3', 
		'\xAC2', '\x3', '\x2', '\x2', '\x2', '\xAC3', '\xAC4', '\x3', '\x2', '\x2', 
		'\x2', '\xAC4', '\xAC5', '\x3', '\x2', '\x2', '\x2', '\xAC5', '\xAC6', 
		'\a', '\x304', '\x2', '\x2', '\xAC6', '\xDD', '\x3', '\x2', '\x2', '\x2', 
		'\xAC7', '\xAC8', '\a', 'h', '\x2', '\x2', '\xAC8', '\xAC9', '\a', '\x306', 
		'\x2', '\x2', '\xAC9', '\xACA', '\t', '\x1C', '\x2', '\x2', '\xACA', '\xDF', 
		'\x3', '\x2', '\x2', '\x2', '\xACB', '\xACE', '\a', 'r', '\x2', '\x2', 
		'\xACC', '\xACD', '\a', '\x1A4', '\x2', '\x2', '\xACD', '\xACF', '\a', 
		'\x1F1', '\x2', '\x2', '\xACE', '\xACC', '\x3', '\x2', '\x2', '\x2', '\xACE', 
		'\xACF', '\x3', '\x2', '\x2', '\x2', '\xACF', '\xAD4', '\x3', '\x2', '\x2', 
		'\x2', '\xAD0', '\xAD2', '\a', '\x181', '\x2', '\x2', '\xAD1', '\xAD0', 
		'\x3', '\x2', '\x2', '\x2', '\xAD1', '\xAD2', '\x3', '\x2', '\x2', '\x2', 
		'\xAD2', '\xAD3', '\x3', '\x2', '\x2', '\x2', '\xAD3', '\xAD5', '\a', 
		'\xDB', '\x2', '\x2', '\xAD4', '\xAD1', '\x3', '\x2', '\x2', '\x2', '\xAD4', 
		'\xAD5', '\x3', '\x2', '\x2', '\x2', '\xAD5', '\xADC', '\x3', '\x2', '\x2', 
		'\x2', '\xAD6', '\xADD', '\a', '\xAB', '\x2', '\x2', '\xAD7', '\xAD9', 
		'\a', '\xA9', '\x2', '\x2', '\xAD8', '\xADA', '\a', '\xAB', '\x2', '\x2', 
		'\xAD9', '\xAD8', '\x3', '\x2', '\x2', '\x2', '\xAD9', '\xADA', '\x3', 
		'\x2', '\x2', '\x2', '\xADA', '\xADD', '\x3', '\x2', '\x2', '\x2', '\xADB', 
		'\xADD', '\a', '\x177', '\x2', '\x2', '\xADC', '\xAD6', '\x3', '\x2', 
		'\x2', '\x2', '\xADC', '\xAD7', '\x3', '\x2', '\x2', '\x2', '\xADC', '\xADB', 
		'\x3', '\x2', '\x2', '\x2', '\xADC', '\xADD', '\x3', '\x2', '\x2', '\x2', 
		'\xADD', '\xADE', '\x3', '\x2', '\x2', '\x2', '\xADE', '\xADF', '\a', 
		'\x29A', '\x2', '\x2', '\xADF', '\xAE1', '\x5', '\x416', '\x20C', '\x2', 
		'\xAE0', '\xAE2', '\x5', '\xE2', 'r', '\x2', '\xAE1', '\xAE0', '\x3', 
		'\x2', '\x2', '\x2', '\xAE1', '\xAE2', '\x3', '\x2', '\x2', '\x2', '\xAE2', 
		'\xAE3', '\x3', '\x2', '\x2', '\x2', '\xAE3', '\xAE4', '\a', '\x19', '\x2', 
		'\x2', '\xAE4', '\xAE6', '\x5', '\x16E', '\xB8', '\x2', '\xAE5', '\xAE7', 
		'\x5', '\x374', '\x1BB', '\x2', '\xAE6', '\xAE5', '\x3', '\x2', '\x2', 
		'\x2', '\xAE6', '\xAE7', '\x3', '\x2', '\x2', '\x2', '\xAE7', '\xE1', 
		'\x3', '\x2', '\x2', '\x2', '\xAE8', '\xAEB', '\x5', '\xE4', 's', '\x2', 
		'\xAE9', '\xAEB', '\x5', '\xE6', 't', '\x2', '\xAEA', '\xAE8', '\x3', 
		'\x2', '\x2', '\x2', '\xAEA', '\xAE9', '\x3', '\x2', '\x2', '\x2', '\xAEB', 
		'\xE3', '\x3', '\x2', '\x2', '\x2', '\xAEC', '\xAFD', '\a', '\x2F2', '\x2', 
		'\x2', '\xAED', '\xAEF', '\a', '\x2F8', '\x2', '\x2', '\xAEE', '\xAED', 
		'\x3', '\x2', '\x2', '\x2', '\xAEE', '\xAEF', '\x3', '\x2', '\x2', '\x2', 
		'\xAEF', '\xAFB', '\x3', '\x2', '\x2', '\x2', '\xAF0', '\xAF2', '\x5', 
		'\x3FC', '\x1FF', '\x2', '\xAF1', '\xAF3', '\t', '\x1D', '\x2', '\x2', 
		'\xAF2', '\xAF1', '\x3', '\x2', '\x2', '\x2', '\xAF2', '\xAF3', '\x3', 
		'\x2', '\x2', '\x2', '\xAF3', '\xAF7', '\x3', '\x2', '\x2', '\x2', '\xAF4', 
		'\xAF6', '\x5', '\xEA', 'v', '\x2', '\xAF5', '\xAF4', '\x3', '\x2', '\x2', 
		'\x2', '\xAF6', '\xAF9', '\x3', '\x2', '\x2', '\x2', '\xAF7', '\xAF5', 
		'\x3', '\x2', '\x2', '\x2', '\xAF7', '\xAF8', '\x3', '\x2', '\x2', '\x2', 
		'\xAF8', '\xAFC', '\x3', '\x2', '\x2', '\x2', '\xAF9', '\xAF7', '\x3', 
		'\x2', '\x2', '\x2', '\xAFA', '\xAFC', '\x5', '\xEC', 'w', '\x2', '\xAFB', 
		'\xAF0', '\x3', '\x2', '\x2', '\x2', '\xAFB', '\xAFA', '\x3', '\x2', '\x2', 
		'\x2', '\xAFC', '\xAFE', '\x3', '\x2', '\x2', '\x2', '\xAFD', '\xAEE', 
		'\x3', '\x2', '\x2', '\x2', '\xAFE', '\xAFF', '\x3', '\x2', '\x2', '\x2', 
		'\xAFF', '\xAFD', '\x3', '\x2', '\x2', '\x2', '\xAFF', '\xB00', '\x3', 
		'\x2', '\x2', '\x2', '\xB00', '\xB01', '\x3', '\x2', '\x2', '\x2', '\xB01', 
		'\xB02', '\a', '\x2F3', '\x2', '\x2', '\xB02', '\xE5', '\x3', '\x2', '\x2', 
		'\x2', '\xB03', '\xB04', '\a', '\x195', '\x2', '\x2', '\xB04', '\xB17', 
		'\x5', '\x496', '\x24C', '\x2', '\xB05', '\xB06', '\a', '\x2A6', '\x2', 
		'\x2', '\xB06', '\xB07', '\a', '\x192', '\x2', '\x2', '\xB07', '\xB13', 
		'\t', '\x1E', '\x2', '\x2', '\xB08', '\xB14', '\a', '\x8F', '\x2', '\x2', 
		'\xB09', '\xB0E', '\a', '\x2F2', '\x2', '\x2', '\xB0A', '\xB0C', '\a', 
		'\x2F8', '\x2', '\x2', '\xB0B', '\xB0A', '\x3', '\x2', '\x2', '\x2', '\xB0B', 
		'\xB0C', '\x3', '\x2', '\x2', '\x2', '\xB0C', '\xB0D', '\x3', '\x2', '\x2', 
		'\x2', '\xB0D', '\xB0F', '\a', '\x310', '\x2', '\x2', '\xB0E', '\xB0B', 
		'\x3', '\x2', '\x2', '\x2', '\xB0F', '\xB10', '\x3', '\x2', '\x2', '\x2', 
		'\xB10', '\xB0E', '\x3', '\x2', '\x2', '\x2', '\xB10', '\xB11', '\x3', 
		'\x2', '\x2', '\x2', '\xB11', '\xB12', '\x3', '\x2', '\x2', '\x2', '\xB12', 
		'\xB14', '\a', '\x2F3', '\x2', '\x2', '\xB13', '\xB08', '\x3', '\x2', 
		'\x2', '\x2', '\xB13', '\xB09', '\x3', '\x2', '\x2', '\x2', '\xB14', '\xB18', 
		'\x3', '\x2', '\x2', '\x2', '\xB15', '\xB16', '\a', '\x27C', '\x2', '\x2', 
		'\xB16', '\xB18', '\x5', '\x416', '\x20C', '\x2', '\xB17', '\xB05', '\x3', 
		'\x2', '\x2', '\x2', '\xB17', '\xB15', '\x3', '\x2', '\x2', '\x2', '\xB18', 
		'\xB2A', '\x3', '\x2', '\x2', '\x2', '\xB19', '\xB22', '\a', '\x2F2', 
		'\x2', '\x2', '\xB1A', '\xB1C', '\a', '\x2F8', '\x2', '\x2', '\xB1B', 
		'\xB1A', '\x3', '\x2', '\x2', '\x2', '\xB1B', '\xB1C', '\x3', '\x2', '\x2', 
		'\x2', '\xB1C', '\xB20', '\x3', '\x2', '\x2', '\x2', '\xB1D', '\xB21', 
		'\x5', '\xEC', 'w', '\x2', '\xB1E', '\xB1F', '\a', '\x310', '\x2', '\x2', 
		'\xB1F', '\xB21', '\x5', '\xEA', 'v', '\x2', '\xB20', '\xB1D', '\x3', 
		'\x2', '\x2', '\x2', '\xB20', '\xB1E', '\x3', '\x2', '\x2', '\x2', '\xB21', 
		'\xB23', '\x3', '\x2', '\x2', '\x2', '\xB22', '\xB1B', '\x3', '\x2', '\x2', 
		'\x2', '\xB23', '\xB24', '\x3', '\x2', '\x2', '\x2', '\xB24', '\xB22', 
		'\x3', '\x2', '\x2', '\x2', '\xB24', '\xB25', '\x3', '\x2', '\x2', '\x2', 
		'\xB25', '\xB26', '\x3', '\x2', '\x2', '\x2', '\xB26', '\xB27', '\a', 
		'\x2F3', '\x2', '\x2', '\xB27', '\xB29', '\x3', '\x2', '\x2', '\x2', '\xB28', 
		'\xB19', '\x3', '\x2', '\x2', '\x2', '\xB29', '\xB2C', '\x3', '\x2', '\x2', 
		'\x2', '\xB2A', '\xB28', '\x3', '\x2', '\x2', '\x2', '\xB2A', '\xB2B', 
		'\x3', '\x2', '\x2', '\x2', '\xB2B', '\xE7', '\x3', '\x2', '\x2', '\x2', 
		'\xB2C', '\xB2A', '\x3', '\x2', '\x2', '\x2', '\xB2D', '\xB2E', '\x5', 
		'\xEA', 'v', '\x2', '\xB2E', '\xB2F', '\x5', '\xEC', 'w', '\x2', '\xB2F', 
		'\xB30', '\x5', '\x218', '\x10D', '\x2', '\xB30', '\xB31', '\x5', '\x21A', 
		'\x10E', '\x2', '\xB31', '\xE9', '\x3', '\x2', '\x2', '\x2', '\xB32', 
		'\xB33', '\a', '\x65', '\x2', '\x2', '\xB33', '\xB35', '\x5', '\x40C', 
		'\x207', '\x2', '\xB34', '\xB32', '\x3', '\x2', '\x2', '\x2', '\xB34', 
		'\xB35', '\x3', '\x2', '\x2', '\x2', '\xB35', '\xB3F', '\x3', '\x2', '\x2', 
		'\x2', '\xB36', '\xB38', '\a', '\x18A', '\x2', '\x2', '\xB37', '\xB36', 
		'\x3', '\x2', '\x2', '\x2', '\xB37', '\xB38', '\x3', '\x2', '\x2', '\x2', 
		'\xB38', '\xB39', '\x3', '\x2', '\x2', '\x2', '\xB39', '\xB40', '\a', 
		'\x18D', '\x2', '\x2', '\xB3A', '\xB40', '\a', '\x280', '\x2', '\x2', 
		'\xB3B', '\xB3C', '\a', '\x1D0', '\x2', '\x2', '\xB3C', '\xB40', '\a', 
		'\x123', '\x2', '\x2', '\xB3D', '\xB40', '\x5', '\x234', '\x11B', '\x2', 
		'\xB3E', '\xB40', '\x5', '\x22A', '\x116', '\x2', '\xB3F', '\xB37', '\x3', 
		'\x2', '\x2', '\x2', '\xB3F', '\xB3A', '\x3', '\x2', '\x2', '\x2', '\xB3F', 
		'\xB3B', '\x3', '\x2', '\x2', '\x2', '\xB3F', '\xB3D', '\x3', '\x2', '\x2', 
		'\x2', '\xB3F', '\xB3E', '\x3', '\x2', '\x2', '\x2', '\xB40', '\xB42', 
		'\x3', '\x2', '\x2', '\x2', '\xB41', '\xB43', '\x5', '\xF0', 'y', '\x2', 
		'\xB42', '\xB41', '\x3', '\x2', '\x2', '\x2', '\xB42', '\xB43', '\x3', 
		'\x2', '\x2', '\x2', '\xB43', '\xEB', '\x3', '\x2', '\x2', '\x2', '\xB44', 
		'\xB46', '\x5', '\xEE', 'x', '\x2', '\xB45', '\xB44', '\x3', '\x2', '\x2', 
		'\x2', '\xB46', '\xB47', '\x3', '\x2', '\x2', '\x2', '\xB47', '\xB45', 
		'\x3', '\x2', '\x2', '\x2', '\xB47', '\xB48', '\x3', '\x2', '\x2', '\x2', 
		'\xB48', '\xB4A', '\x3', '\x2', '\x2', '\x2', '\xB49', '\xB4B', '\x5', 
		'\xF0', 'y', '\x2', '\xB4A', '\xB49', '\x3', '\x2', '\x2', '\x2', '\xB4A', 
		'\xB4B', '\x3', '\x2', '\x2', '\x2', '\xB4B', '\xED', '\x3', '\x2', '\x2', 
		'\x2', '\xB4C', '\xB4D', '\a', '\x65', '\x2', '\x2', '\xB4D', '\xB4F', 
		'\x5', '\x40C', '\x207', '\x2', '\xB4E', '\xB4C', '\x3', '\x2', '\x2', 
		'\x2', '\xB4E', '\xB4F', '\x3', '\x2', '\x2', '\x2', '\xB4F', '\xB54', 
		'\x3', '\x2', '\x2', '\x2', '\xB50', '\xB55', '\x5', '\x238', '\x11D', 
		'\x2', '\xB51', '\xB55', '\x5', '\x232', '\x11A', '\x2', '\xB52', '\xB55', 
		'\x5', '\x236', '\x11C', '\x2', '\xB53', '\xB55', '\x5', '\x22A', '\x116', 
		'\x2', '\xB54', '\xB50', '\x3', '\x2', '\x2', '\x2', '\xB54', '\xB51', 
		'\x3', '\x2', '\x2', '\x2', '\xB54', '\xB52', '\x3', '\x2', '\x2', '\x2', 
		'\xB54', '\xB53', '\x3', '\x2', '\x2', '\x2', '\xB55', '\xEF', '\x3', 
		'\x2', '\x2', '\x2', '\xB56', '\xB58', '\a', '\x18A', '\x2', '\x2', '\xB57', 
		'\xB56', '\x3', '\x2', '\x2', '\x2', '\xB57', '\xB58', '\x3', '\x2', '\x2', 
		'\x2', '\xB58', '\xB59', '\x3', '\x2', '\x2', '\x2', '\xB59', '\xB62', 
		'\a', '\x91', '\x2', '\x2', '\xB5A', '\xB5B', '\a', '\x10A', '\x2', '\x2', 
		'\xB5B', '\xB62', '\t', '\x1F', '\x2', '\x2', '\xB5C', '\xB62', '\t', 
		' ', '\x2', '\x2', '\xB5D', '\xB62', '\x5', '\xF2', 'z', '\x2', '\xB5E', 
		'\xB62', '\t', '\a', '\x2', '\x2', '\xB5F', '\xB62', '\t', '!', '\x2', 
		'\x2', '\xB60', '\xB62', '\x5', '\x14A', '\xA6', '\x2', '\xB61', '\xB57', 
		'\x3', '\x2', '\x2', '\x2', '\xB61', '\xB5A', '\x3', '\x2', '\x2', '\x2', 
		'\xB61', '\xB5C', '\x3', '\x2', '\x2', '\x2', '\xB61', '\xB5D', '\x3', 
		'\x2', '\x2', '\x2', '\xB61', '\xB5E', '\x3', '\x2', '\x2', '\x2', '\xB61', 
		'\xB5F', '\x3', '\x2', '\x2', '\x2', '\xB61', '\xB60', '\x3', '\x2', '\x2', 
		'\x2', '\xB62', '\xB63', '\x3', '\x2', '\x2', '\x2', '\xB63', '\xB61', 
		'\x3', '\x2', '\x2', '\x2', '\xB63', '\xB64', '\x3', '\x2', '\x2', '\x2', 
		'\xB64', '\xF1', '\x3', '\x2', '\x2', '\x2', '\xB65', '\xB66', '\a', '\x28E', 
		'\x2', '\x2', '\xB66', '\xB6F', '\a', '\x101', '\x2', '\x2', '\xB67', 
		'\xB70', '\x5', '\x442', '\x222', '\x2', '\xB68', '\xB69', '\a', '\x2F2', 
		'\x2', '\x2', '\xB69', '\xB6A', '\x5', '\xAA', 'V', '\x2', '\xB6A', '\xB6B', 
		'\a', '\x2F3', '\x2', '\x2', '\xB6B', '\xB70', '\x3', '\x2', '\x2', '\x2', 
		'\xB6C', '\xB6E', '\x5', '\xF4', '{', '\x2', '\xB6D', '\xB6C', '\x3', 
		'\x2', '\x2', '\x2', '\xB6D', '\xB6E', '\x3', '\x2', '\x2', '\x2', '\xB6E', 
		'\xB70', '\x3', '\x2', '\x2', '\x2', '\xB6F', '\xB67', '\x3', '\x2', '\x2', 
		'\x2', '\xB6F', '\xB68', '\x3', '\x2', '\x2', '\x2', '\xB6F', '\xB6D', 
		'\x3', '\x2', '\x2', '\x2', '\xB70', '\xF3', '\x3', '\x2', '\x2', '\x2', 
		'\xB71', '\xB74', '\x5', '\xF6', '|', '\x2', '\xB72', '\xB74', '\x5', 
		'\x106', '\x84', '\x2', '\xB73', '\xB71', '\x3', '\x2', '\x2', '\x2', 
		'\xB73', '\xB72', '\x3', '\x2', '\x2', '\x2', '\xB74', '\xB7B', '\x3', 
		'\x2', '\x2', '\x2', '\xB75', '\xB77', '\x5', '\xFE', '\x80', '\x2', '\xB76', 
		'\xB75', '\x3', '\x2', '\x2', '\x2', '\xB77', '\xB78', '\x3', '\x2', '\x2', 
		'\x2', '\xB78', '\xB76', '\x3', '\x2', '\x2', '\x2', '\xB78', '\xB79', 
		'\x3', '\x2', '\x2', '\x2', '\xB79', '\xB7B', '\x3', '\x2', '\x2', '\x2', 
		'\xB7A', '\xB73', '\x3', '\x2', '\x2', '\x2', '\xB7A', '\xB76', '\x3', 
		'\x2', '\x2', '\x2', '\xB7B', '\xB7C', '\x3', '\x2', '\x2', '\x2', '\xB7C', 
		'\xB7A', '\x3', '\x2', '\x2', '\x2', '\xB7C', '\xB7D', '\x3', '\x2', '\x2', 
		'\x2', '\xB7D', '\xB85', '\x3', '\x2', '\x2', '\x2', '\xB7E', '\xB7F', 
		'\a', '\x103', '\x2', '\x2', '\xB7F', '\xB82', '\a', '\x11B', '\x2', '\x2', 
		'\xB80', '\xB83', '\x5', '\x142', '\xA2', '\x2', '\xB81', '\xB83', '\x5', 
		'\x112', '\x8A', '\x2', '\xB82', '\xB80', '\x3', '\x2', '\x2', '\x2', 
		'\xB82', '\xB81', '\x3', '\x2', '\x2', '\x2', '\xB83', '\xB85', '\x3', 
		'\x2', '\x2', '\x2', '\xB84', '\xB7A', '\x3', '\x2', '\x2', '\x2', '\xB84', 
		'\xB7E', '\x3', '\x2', '\x2', '\x2', '\xB85', '\xF5', '\x3', '\x2', '\x2', 
		'\x2', '\xB86', '\xB87', '\a', '\xE5', '\x2', '\x2', '\xB87', '\xB88', 
		'\a', '\x1B2', '\x2', '\x2', '\xB88', '\xB95', '\a', '?', '\x2', '\x2', 
		'\xB89', '\xB8A', '\a', '\x1DE', '\x2', '\x2', '\xB8A', '\xB8B', '\x5', 
		'\x44A', '\x226', '\x2', '\xB8B', '\xB8C', '\a', '\x2F2', '\x2', '\x2', 
		'\xB8C', '\xB8D', '\x5', '\xFA', '~', '\x2', '\xB8D', '\xB8E', '\a', '\x2F3', 
		'\x2', '\x2', '\xB8E', '\xB96', '\x3', '\x2', '\x2', '\x2', '\xB8F', '\xB90', 
		'\a', '\xED', '\x2', '\x2', '\xB90', '\xB93', '\x5', '\x44A', '\x226', 
		'\x2', '\xB91', '\xB94', '\x5', '\xF8', '}', '\x2', '\xB92', '\xB94', 
		'\x5', '\x104', '\x83', '\x2', '\xB93', '\xB91', '\x3', '\x2', '\x2', 
		'\x2', '\xB93', '\xB92', '\x3', '\x2', '\x2', '\x2', '\xB94', '\xB96', 
		'\x3', '\x2', '\x2', '\x2', '\xB95', '\xB89', '\x3', '\x2', '\x2', '\x2', 
		'\xB95', '\xB8F', '\x3', '\x2', '\x2', '\x2', '\xB96', '\xF7', '\x3', 
		'\x2', '\x2', '\x2', '\xB97', '\xBA1', '\a', '\x2F2', '\x2', '\x2', '\xB98', 
		'\xB9A', '\a', '\x2F8', '\x2', '\x2', '\xB99', '\xB98', '\x3', '\x2', 
		'\x2', '\x2', '\xB99', '\xB9A', '\x3', '\x2', '\x2', '\x2', '\xB9A', '\xB9B', 
		'\x3', '\x2', '\x2', '\x2', '\xB9B', '\xB9D', '\x5', '\x114', '\x8B', 
		'\x2', '\xB9C', '\xB9E', '\x5', '\x118', '\x8D', '\x2', '\xB9D', '\xB9C', 
		'\x3', '\x2', '\x2', '\x2', '\xB9D', '\xB9E', '\x3', '\x2', '\x2', '\x2', 
		'\xB9E', '\xB9F', '\x3', '\x2', '\x2', '\x2', '\xB9F', '\xBA0', '\x5', 
		'\x11A', '\x8E', '\x2', '\xBA0', '\xBA2', '\x3', '\x2', '\x2', '\x2', 
		'\xBA1', '\xB99', '\x3', '\x2', '\x2', '\x2', '\xBA2', '\xBA3', '\x3', 
		'\x2', '\x2', '\x2', '\xBA3', '\xBA1', '\x3', '\x2', '\x2', '\x2', '\xBA3', 
		'\xBA4', '\x3', '\x2', '\x2', '\x2', '\xBA4', '\xBA5', '\x3', '\x2', '\x2', 
		'\x2', '\xBA5', '\xBA6', '\a', '\x2F3', '\x2', '\x2', '\xBA6', '\xF9', 
		'\x3', '\x2', '\x2', '\x2', '\xBA7', '\xBA8', '\x5', '\x116', '\x8C', 
		'\x2', '\xBA8', '\xBA9', '\a', '\x290', '\x2', '\x2', '\xBA9', '\xBAA', 
		'\a', '\x129', '\x2', '\x2', '\xBAA', '\xBAB', '\a', '\x25C', '\x2', '\x2', 
		'\xBAB', '\xBAC', '\a', '\x2F2', '\x2', '\x2', '\xBAC', '\xBB1', '\x5', 
		'\x468', '\x235', '\x2', '\xBAD', '\xBAE', '\a', '\x2F8', '\x2', '\x2', 
		'\xBAE', '\xBB0', '\x5', '\x468', '\x235', '\x2', '\xBAF', '\xBAD', '\x3', 
		'\x2', '\x2', '\x2', '\xBB0', '\xBB3', '\x3', '\x2', '\x2', '\x2', '\xBB1', 
		'\xBAF', '\x3', '\x2', '\x2', '\x2', '\xBB1', '\xBB2', '\x3', '\x2', '\x2', 
		'\x2', '\xBB2', '\xBB4', '\x3', '\x2', '\x2', '\x2', '\xBB3', '\xBB1', 
		'\x3', '\x2', '\x2', '\x2', '\xBB4', '\xBB6', '\a', '\x2F3', '\x2', '\x2', 
		'\xBB5', '\xBB7', '\x5', '\xFC', '\x7F', '\x2', '\xBB6', '\xBB5', '\x3', 
		'\x2', '\x2', '\x2', '\xBB6', '\xBB7', '\x3', '\x2', '\x2', '\x2', '\xBB7', 
		'\xFB', '\x3', '\x2', '\x2', '\x2', '\xBB8', '\xBBC', '\x5', '\x100', 
		'\x81', '\x2', '\xBB9', '\xBBC', '\x5', '\x1EC', '\xF7', '\x2', '\xBBA', 
		'\xBBC', '\x5', '\x152', '\xAA', '\x2', '\xBBB', '\xBB8', '\x3', '\x2', 
		'\x2', '\x2', '\xBBB', '\xBB9', '\x3', '\x2', '\x2', '\x2', '\xBBB', '\xBBA', 
		'\x3', '\x2', '\x2', '\x2', '\xBBC', '\xBBD', '\x3', '\x2', '\x2', '\x2', 
		'\xBBD', '\xBBB', '\x3', '\x2', '\x2', '\x2', '\xBBD', '\xBBE', '\x3', 
		'\x2', '\x2', '\x2', '\xBBE', '\xFD', '\x3', '\x2', '\x2', '\x2', '\xBBF', 
		'\xBCE', '\x5', '\x100', '\x81', '\x2', '\xBC0', '\xBCE', '\x5', '\x152', 
		'\xAA', '\x2', '\xBC1', '\xBCE', '\a', '\x199', '\x2', '\x2', '\xBC2', 
		'\xBC5', '\a', '\x256', '\x2', '\x2', '\xBC3', '\xBC6', '\x5', '\x426', 
		'\x214', '\x2', '\xBC4', '\xBC6', '\a', '\x8F', '\x2', '\x2', '\xBC5', 
		'\xBC3', '\x3', '\x2', '\x2', '\x2', '\xBC5', '\xBC4', '\x3', '\x2', '\x2', 
		'\x2', '\xBC6', '\xBCE', '\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBCE', 
		'\x5', '\x132', '\x9A', '\x2', '\xBC8', '\xBCE', '\t', '\"', '\x2', '\x2', 
		'\xBC9', '\xBCE', '\a', '\x1FE', '\x2', '\x2', '\xBCA', '\xBCE', '\t', 
		'\x1D', '\x2', '\x2', '\xBCB', '\xBCE', '\x5', '\x13E', '\xA0', '\x2', 
		'\xBCC', '\xBCE', '\x5', '\x140', '\xA1', '\x2', '\xBCD', '\xBBF', '\x3', 
		'\x2', '\x2', '\x2', '\xBCD', '\xBC0', '\x3', '\x2', '\x2', '\x2', '\xBCD', 
		'\xBC1', '\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBC2', '\x3', '\x2', '\x2', 
		'\x2', '\xBCD', '\xBC7', '\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBC8', 
		'\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBC9', '\x3', '\x2', '\x2', '\x2', 
		'\xBCD', '\xBCA', '\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBCB', '\x3', 
		'\x2', '\x2', '\x2', '\xBCD', '\xBCC', '\x3', '\x2', '\x2', '\x2', '\xBCE', 
		'\xFF', '\x3', '\x2', '\x2', '\x2', '\xBCF', '\xBD1', '\x5', '\x102', 
		'\x82', '\x2', '\xBD0', '\xBCF', '\x3', '\x2', '\x2', '\x2', '\xBD1', 
		'\xBD2', '\x3', '\x2', '\x2', '\x2', '\xBD2', '\xBD0', '\x3', '\x2', '\x2', 
		'\x2', '\xBD2', '\xBD3', '\x3', '\x2', '\x2', '\x2', '\xBD3', '\x101', 
		'\x3', '\x2', '\x2', '\x2', '\xBD4', '\xBD5', '\a', '\x1B7', '\x2', '\x2', 
		'\xBD5', '\xBDE', '\x5', '\x4A4', '\x253', '\x2', '\xBD6', '\xBD7', '\a', 
		'\x1BA', '\x2', '\x2', '\xBD7', '\xBDE', '\x5', '\x4A4', '\x253', '\x2', 
		'\xBD8', '\xBD9', '\a', '\x10B', '\x2', '\x2', '\xBD9', '\xBDE', '\x5', 
		'\x4A4', '\x253', '\x2', '\xBDA', '\xBDB', '\a', '\x14F', '\x2', '\x2', 
		'\xBDB', '\xBDE', '\x5', '\x4A4', '\x253', '\x2', '\xBDC', '\xBDE', '\x5', 
		'\x1FA', '\xFE', '\x2', '\xBDD', '\xBD4', '\x3', '\x2', '\x2', '\x2', 
		'\xBDD', '\xBD6', '\x3', '\x2', '\x2', '\x2', '\xBDD', '\xBD8', '\x3', 
		'\x2', '\x2', '\x2', '\xBDD', '\xBDA', '\x3', '\x2', '\x2', '\x2', '\xBDD', 
		'\xBDC', '\x3', '\x2', '\x2', '\x2', '\xBDE', '\x103', '\x3', '\x2', '\x2', 
		'\x2', '\xBDF', '\xBE0', '\a', '\x1B3', '\x2', '\x2', '\xBE0', '\xBEE', 
		'\x5', '\x13A', '\x9E', '\x2', '\xBE1', '\xBE2', '\a', '\x243', '\x2', 
		'\x2', '\xBE2', '\xBE3', '\a', '\x108', '\x2', '\x2', '\xBE3', '\xBE4', 
		'\a', '\x2F2', '\x2', '\x2', '\xBE4', '\xBE9', '\x5', '\x426', '\x214', 
		'\x2', '\xBE5', '\xBE6', '\a', '\x2F8', '\x2', '\x2', '\xBE6', '\xBE8', 
		'\x5', '\x426', '\x214', '\x2', '\xBE7', '\xBE5', '\x3', '\x2', '\x2', 
		'\x2', '\xBE8', '\xBEB', '\x3', '\x2', '\x2', '\x2', '\xBE9', '\xBE7', 
		'\x3', '\x2', '\x2', '\x2', '\xBE9', '\xBEA', '\x3', '\x2', '\x2', '\x2', 
		'\xBEA', '\xBEC', '\x3', '\x2', '\x2', '\x2', '\xBEB', '\xBE9', '\x3', 
		'\x2', '\x2', '\x2', '\xBEC', '\xBED', '\a', '\x2F3', '\x2', '\x2', '\xBED', 
		'\xBEF', '\x3', '\x2', '\x2', '\x2', '\xBEE', '\xBE1', '\x3', '\x2', '\x2', 
		'\x2', '\xBEE', '\xBEF', '\x3', '\x2', '\x2', '\x2', '\xBEF', '\xBF2', 
		'\x3', '\x2', '\x2', '\x2', '\xBF0', '\xBF3', '\x5', '\x12C', '\x97', 
		'\x2', '\xBF1', '\xBF3', '\x5', '\x12E', '\x98', '\x2', '\xBF2', '\xBF0', 
		'\x3', '\x2', '\x2', '\x2', '\xBF2', '\xBF1', '\x3', '\x2', '\x2', '\x2', 
		'\xBF2', '\xBF3', '\x3', '\x2', '\x2', '\x2', '\xBF3', '\xC02', '\x3', 
		'\x2', '\x2', '\x2', '\xBF4', '\xBF5', '\a', '\x1A9', '\x2', '\x2', '\xBF5', 
		'\xBF6', '\a', '\x243', '\x2', '\x2', '\xBF6', '\xBF7', '\a', '\x108', 
		'\x2', '\x2', '\xBF7', '\xBF8', '\a', '\x2F2', '\x2', '\x2', '\xBF8', 
		'\xBFD', '\x5', '\x426', '\x214', '\x2', '\xBF9', '\xBFA', '\a', '\x2F8', 
		'\x2', '\x2', '\xBFA', '\xBFC', '\x5', '\x426', '\x214', '\x2', '\xBFB', 
		'\xBF9', '\x3', '\x2', '\x2', '\x2', '\xBFC', '\xBFF', '\x3', '\x2', '\x2', 
		'\x2', '\xBFD', '\xBFB', '\x3', '\x2', '\x2', '\x2', '\xBFD', '\xBFE', 
		'\x3', '\x2', '\x2', '\x2', '\xBFE', '\xC00', '\x3', '\x2', '\x2', '\x2', 
		'\xBFF', '\xBFD', '\x3', '\x2', '\x2', '\x2', '\xC00', '\xC01', '\a', 
		'\x2F3', '\x2', '\x2', '\xC01', '\xC03', '\x3', '\x2', '\x2', '\x2', '\xC02', 
		'\xBF4', '\x3', '\x2', '\x2', '\x2', '\xC02', '\xC03', '\x3', '\x2', '\x2', 
		'\x2', '\xC03', '\x105', '\x3', '\x2', '\x2', '\x2', '\xC04', '\xC09', 
		'\a', '\x138', '\x2', '\x2', '\xC05', '\xC0A', '\x5', '\x108', '\x85', 
		'\x2', '\xC06', '\xC0A', '\x5', '\x10A', '\x86', '\x2', '\xC07', '\xC0A', 
		'\x5', '\x10C', '\x87', '\x2', '\xC08', '\xC0A', '\x5', '\x10E', '\x88', 
		'\x2', '\xC09', '\xC05', '\x3', '\x2', '\x2', '\x2', '\xC09', '\xC06', 
		'\x3', '\x2', '\x2', '\x2', '\xC09', '\xC07', '\x3', '\x2', '\x2', '\x2', 
		'\xC09', '\xC08', '\x3', '\x2', '\x2', '\x2', '\xC09', '\xC0A', '\x3', 
		'\x2', '\x2', '\x2', '\xC0A', '\x107', '\x3', '\x2', '\x2', '\x2', '\xC0B', 
		'\xC0C', '\a', '\x2F2', '\x2', '\x2', '\xC0C', '\xC13', '\x5', '\x116', 
		'\x8C', '\x2', '\xC0D', '\xC10', '\x5', '\xFC', '\x7F', '\x2', '\xC0E', 
		'\xC10', '\x5', '\x12E', '\x98', '\x2', '\xC0F', '\xC0D', '\x3', '\x2', 
		'\x2', '\x2', '\xC0F', '\xC0E', '\x3', '\x2', '\x2', '\x2', '\xC10', '\xC11', 
		'\x3', '\x2', '\x2', '\x2', '\xC11', '\xC0F', '\x3', '\x2', '\x2', '\x2', 
		'\xC11', '\xC12', '\x3', '\x2', '\x2', '\x2', '\xC12', '\xC14', '\x3', 
		'\x2', '\x2', '\x2', '\xC13', '\xC0F', '\x3', '\x2', '\x2', '\x2', '\xC13', 
		'\xC14', '\x3', '\x2', '\x2', '\x2', '\xC14', '\xC16', '\x3', '\x2', '\x2', 
		'\x2', '\xC15', '\xC17', '\a', '\x285', '\x2', '\x2', '\xC16', '\xC15', 
		'\x3', '\x2', '\x2', '\x2', '\xC16', '\xC17', '\x3', '\x2', '\x2', '\x2', 
		'\xC17', '\xC2A', '\x3', '\x2', '\x2', '\x2', '\xC18', '\xC19', '\a', 
		'\x2F8', '\x2', '\x2', '\xC19', '\xC1B', '\a', '\x1B2', '\x2', '\x2', 
		'\xC1A', '\xC1C', '\x5', '\x42A', '\x216', '\x2', '\xC1B', '\xC1A', '\x3', 
		'\x2', '\x2', '\x2', '\xC1B', '\xC1C', '\x3', '\x2', '\x2', '\x2', '\xC1C', 
		'\xC23', '\x3', '\x2', '\x2', '\x2', '\xC1D', '\xC20', '\x5', '\xFC', 
		'\x7F', '\x2', '\xC1E', '\xC20', '\x5', '\x12E', '\x98', '\x2', '\xC1F', 
		'\xC1D', '\x3', '\x2', '\x2', '\x2', '\xC1F', '\xC1E', '\x3', '\x2', '\x2', 
		'\x2', '\xC20', '\xC21', '\x3', '\x2', '\x2', '\x2', '\xC21', '\xC1F', 
		'\x3', '\x2', '\x2', '\x2', '\xC21', '\xC22', '\x3', '\x2', '\x2', '\x2', 
		'\xC22', '\xC24', '\x3', '\x2', '\x2', '\x2', '\xC23', '\xC1F', '\x3', 
		'\x2', '\x2', '\x2', '\xC23', '\xC24', '\x3', '\x2', '\x2', '\x2', '\xC24', 
		'\xC26', '\x3', '\x2', '\x2', '\x2', '\xC25', '\xC27', '\a', '\x285', 
		'\x2', '\x2', '\xC26', '\xC25', '\x3', '\x2', '\x2', '\x2', '\xC26', '\xC27', 
		'\x3', '\x2', '\x2', '\x2', '\xC27', '\xC29', '\x3', '\x2', '\x2', '\x2', 
		'\xC28', '\xC18', '\x3', '\x2', '\x2', '\x2', '\xC29', '\xC2C', '\x3', 
		'\x2', '\x2', '\x2', '\xC2A', '\xC28', '\x3', '\x2', '\x2', '\x2', '\xC2A', 
		'\xC2B', '\x3', '\x2', '\x2', '\x2', '\xC2B', '\xC2D', '\x3', '\x2', '\x2', 
		'\x2', '\xC2C', '\xC2A', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC2E', 
		'\a', '\x2F3', '\x2', '\x2', '\xC2E', '\x109', '\x3', '\x2', '\x2', '\x2', 
		'\xC2F', '\xC30', '\a', '\x2F2', '\x2', '\x2', '\xC30', '\xC37', '\x5', 
		'\x116', '\x8C', '\x2', '\xC31', '\xC34', '\x5', '\xFC', '\x7F', '\x2', 
		'\xC32', '\xC34', '\x5', '\x12E', '\x98', '\x2', '\xC33', '\xC31', '\x3', 
		'\x2', '\x2', '\x2', '\xC33', '\xC32', '\x3', '\x2', '\x2', '\x2', '\xC34', 
		'\xC35', '\x3', '\x2', '\x2', '\x2', '\xC35', '\xC33', '\x3', '\x2', '\x2', 
		'\x2', '\xC35', '\xC36', '\x3', '\x2', '\x2', '\x2', '\xC36', '\xC38', 
		'\x3', '\x2', '\x2', '\x2', '\xC37', '\xC33', '\x3', '\x2', '\x2', '\x2', 
		'\xC37', '\xC38', '\x3', '\x2', '\x2', '\x2', '\xC38', '\xC3A', '\x3', 
		'\x2', '\x2', '\x2', '\xC39', '\xC3B', '\x5', '\x138', '\x9D', '\x2', 
		'\xC3A', '\xC39', '\x3', '\x2', '\x2', '\x2', '\xC3A', '\xC3B', '\x3', 
		'\x2', '\x2', '\x2', '\xC3B', '\xC4B', '\x3', '\x2', '\x2', '\x2', '\xC3C', 
		'\xC3D', '\a', '\x2F8', '\x2', '\x2', '\xC3D', '\xC44', '\x5', '\x116', 
		'\x8C', '\x2', '\xC3E', '\xC41', '\x5', '\xFC', '\x7F', '\x2', '\xC3F', 
		'\xC41', '\x5', '\x12E', '\x98', '\x2', '\xC40', '\xC3E', '\x3', '\x2', 
		'\x2', '\x2', '\xC40', '\xC3F', '\x3', '\x2', '\x2', '\x2', '\xC41', '\xC42', 
		'\x3', '\x2', '\x2', '\x2', '\xC42', '\xC40', '\x3', '\x2', '\x2', '\x2', 
		'\xC42', '\xC43', '\x3', '\x2', '\x2', '\x2', '\xC43', '\xC45', '\x3', 
		'\x2', '\x2', '\x2', '\xC44', '\xC40', '\x3', '\x2', '\x2', '\x2', '\xC44', 
		'\xC45', '\x3', '\x2', '\x2', '\x2', '\xC45', '\xC47', '\x3', '\x2', '\x2', 
		'\x2', '\xC46', '\xC48', '\x5', '\x138', '\x9D', '\x2', '\xC47', '\xC46', 
		'\x3', '\x2', '\x2', '\x2', '\xC47', '\xC48', '\x3', '\x2', '\x2', '\x2', 
		'\xC48', '\xC4A', '\x3', '\x2', '\x2', '\x2', '\xC49', '\xC3C', '\x3', 
		'\x2', '\x2', '\x2', '\xC4A', '\xC4D', '\x3', '\x2', '\x2', '\x2', '\xC4B', 
		'\xC49', '\x3', '\x2', '\x2', '\x2', '\xC4B', '\xC4C', '\x3', '\x2', '\x2', 
		'\x2', '\xC4C', '\xC4E', '\x3', '\x2', '\x2', '\x2', '\xC4D', '\xC4B', 
		'\x3', '\x2', '\x2', '\x2', '\xC4E', '\xC4F', '\a', '\x2F3', '\x2', '\x2', 
		'\xC4F', '\x10B', '\x3', '\x2', '\x2', '\x2', '\xC50', '\xC51', '\a', 
		'\x243', '\x2', '\x2', '\xC51', '\xC52', '\a', '\x108', '\x2', '\x2', 
		'\xC52', '\xC53', '\a', '\x2F2', '\x2', '\x2', '\xC53', '\xC58', '\x5', 
		'\x426', '\x214', '\x2', '\xC54', '\xC55', '\a', '\x2F8', '\x2', '\x2', 
		'\xC55', '\xC57', '\x5', '\x426', '\x214', '\x2', '\xC56', '\xC54', '\x3', 
		'\x2', '\x2', '\x2', '\xC57', '\xC5A', '\x3', '\x2', '\x2', '\x2', '\xC58', 
		'\xC56', '\x3', '\x2', '\x2', '\x2', '\xC58', '\xC59', '\x3', '\x2', '\x2', 
		'\x2', '\xC59', '\xC5B', '\x3', '\x2', '\x2', '\x2', '\xC5A', '\xC58', 
		'\x3', '\x2', '\x2', '\x2', '\xC5B', '\xC5C', '\a', '\x2F3', '\x2', '\x2', 
		'\xC5C', '\xC7B', '\x3', '\x2', '\x2', '\x2', '\xC5D', '\xC5E', '\a', 
		'\x2F2', '\x2', '\x2', '\xC5E', '\xC60', '\x5', '\x116', '\x8C', '\x2', 
		'\xC5F', '\xC61', '\x5', '\x1EC', '\xF7', '\x2', '\xC60', '\xC5F', '\x3', 
		'\x2', '\x2', '\x2', '\xC60', '\xC61', '\x3', '\x2', '\x2', '\x2', '\xC61', 
		'\xC63', '\x3', '\x2', '\x2', '\x2', '\xC62', '\xC64', '\x5', '\x132', 
		'\x9A', '\x2', '\xC63', '\xC62', '\x3', '\x2', '\x2', '\x2', '\xC63', 
		'\xC64', '\x3', '\x2', '\x2', '\x2', '\xC64', '\xC66', '\x3', '\x2', '\x2', 
		'\x2', '\xC65', '\xC67', '\x5', '\x138', '\x9D', '\x2', '\xC66', '\xC65', 
		'\x3', '\x2', '\x2', '\x2', '\xC66', '\xC67', '\x3', '\x2', '\x2', '\x2', 
		'\xC67', '\xC75', '\x3', '\x2', '\x2', '\x2', '\xC68', '\xC69', '\a', 
		'\x2F8', '\x2', '\x2', '\xC69', '\xC6B', '\x5', '\x116', '\x8C', '\x2', 
		'\xC6A', '\xC6C', '\x5', '\x1EC', '\xF7', '\x2', '\xC6B', '\xC6A', '\x3', 
		'\x2', '\x2', '\x2', '\xC6B', '\xC6C', '\x3', '\x2', '\x2', '\x2', '\xC6C', 
		'\xC6E', '\x3', '\x2', '\x2', '\x2', '\xC6D', '\xC6F', '\x5', '\x132', 
		'\x9A', '\x2', '\xC6E', '\xC6D', '\x3', '\x2', '\x2', '\x2', '\xC6E', 
		'\xC6F', '\x3', '\x2', '\x2', '\x2', '\xC6F', '\xC71', '\x3', '\x2', '\x2', 
		'\x2', '\xC70', '\xC72', '\x5', '\x138', '\x9D', '\x2', '\xC71', '\xC70', 
		'\x3', '\x2', '\x2', '\x2', '\xC71', '\xC72', '\x3', '\x2', '\x2', '\x2', 
		'\xC72', '\xC74', '\x3', '\x2', '\x2', '\x2', '\xC73', '\xC68', '\x3', 
		'\x2', '\x2', '\x2', '\xC74', '\xC77', '\x3', '\x2', '\x2', '\x2', '\xC75', 
		'\xC73', '\x3', '\x2', '\x2', '\x2', '\xC75', '\xC76', '\x3', '\x2', '\x2', 
		'\x2', '\xC76', '\xC78', '\x3', '\x2', '\x2', '\x2', '\xC77', '\xC75', 
		'\x3', '\x2', '\x2', '\x2', '\xC78', '\xC79', '\a', '\x2F3', '\x2', '\x2', 
		'\xC79', '\xC7B', '\x3', '\x2', '\x2', '\x2', '\xC7A', '\xC50', '\x3', 
		'\x2', '\x2', '\x2', '\xC7A', '\xC5D', '\x3', '\x2', '\x2', '\x2', '\xC7B', 
		'\x10D', '\x3', '\x2', '\x2', '\x2', '\xC7C', '\xC7E', '\x5', '\x1EE', 
		'\xF8', '\x2', '\xC7D', '\xC7C', '\x3', '\x2', '\x2', '\x2', '\xC7D', 
		'\xC7E', '\x3', '\x2', '\x2', '\x2', '\xC7E', '\xC7F', '\x3', '\x2', '\x2', 
		'\x2', '\xC7F', '\xC80', '\a', '\x2F2', '\x2', '\x2', '\xC80', '\xC87', 
		'\x5', '\x116', '\x8C', '\x2', '\xC81', '\xC84', '\x5', '\xFC', '\x7F', 
		'\x2', '\xC82', '\xC84', '\x5', '\x132', '\x9A', '\x2', '\xC83', '\xC81', 
		'\x3', '\x2', '\x2', '\x2', '\xC83', '\xC82', '\x3', '\x2', '\x2', '\x2', 
		'\xC84', '\xC85', '\x3', '\x2', '\x2', '\x2', '\xC85', '\xC83', '\x3', 
		'\x2', '\x2', '\x2', '\xC85', '\xC86', '\x3', '\x2', '\x2', '\x2', '\xC86', 
		'\xC88', '\x3', '\x2', '\x2', '\x2', '\xC87', '\xC83', '\x3', '\x2', '\x2', 
		'\x2', '\xC87', '\xC88', '\x3', '\x2', '\x2', '\x2', '\xC88', '\xC8A', 
		'\x3', '\x2', '\x2', '\x2', '\xC89', '\xC8B', '\x5', '\x138', '\x9D', 
		'\x2', '\xC8A', '\xC89', '\x3', '\x2', '\x2', '\x2', '\xC8A', '\xC8B', 
		'\x3', '\x2', '\x2', '\x2', '\xC8B', '\xC8D', '\x3', '\x2', '\x2', '\x2', 
		'\xC8C', '\xC8E', '\x5', '\x136', '\x9C', '\x2', '\xC8D', '\xC8C', '\x3', 
		'\x2', '\x2', '\x2', '\xC8D', '\xC8E', '\x3', '\x2', '\x2', '\x2', '\xC8E', 
		'\xCA1', '\x3', '\x2', '\x2', '\x2', '\xC8F', '\xC90', '\a', '\x2F8', 
		'\x2', '\x2', '\xC90', '\xC97', '\x5', '\x116', '\x8C', '\x2', '\xC91', 
		'\xC94', '\x5', '\xFC', '\x7F', '\x2', '\xC92', '\xC94', '\x5', '\x132', 
		'\x9A', '\x2', '\xC93', '\xC91', '\x3', '\x2', '\x2', '\x2', '\xC93', 
		'\xC92', '\x3', '\x2', '\x2', '\x2', '\xC94', '\xC95', '\x3', '\x2', '\x2', 
		'\x2', '\xC95', '\xC93', '\x3', '\x2', '\x2', '\x2', '\xC95', '\xC96', 
		'\x3', '\x2', '\x2', '\x2', '\xC96', '\xC98', '\x3', '\x2', '\x2', '\x2', 
		'\xC97', '\xC93', '\x3', '\x2', '\x2', '\x2', '\xC97', '\xC98', '\x3', 
		'\x2', '\x2', '\x2', '\xC98', '\xC9A', '\x3', '\x2', '\x2', '\x2', '\xC99', 
		'\xC9B', '\x5', '\x138', '\x9D', '\x2', '\xC9A', '\xC99', '\x3', '\x2', 
		'\x2', '\x2', '\xC9A', '\xC9B', '\x3', '\x2', '\x2', '\x2', '\xC9B', '\xC9D', 
		'\x3', '\x2', '\x2', '\x2', '\xC9C', '\xC9E', '\x5', '\x136', '\x9C', 
		'\x2', '\xC9D', '\xC9C', '\x3', '\x2', '\x2', '\x2', '\xC9D', '\xC9E', 
		'\x3', '\x2', '\x2', '\x2', '\xC9E', '\xCA0', '\x3', '\x2', '\x2', '\x2', 
		'\xC9F', '\xC8F', '\x3', '\x2', '\x2', '\x2', '\xCA0', '\xCA3', '\x3', 
		'\x2', '\x2', '\x2', '\xCA1', '\xC9F', '\x3', '\x2', '\x2', '\x2', '\xCA1', 
		'\xCA2', '\x3', '\x2', '\x2', '\x2', '\xCA2', '\xCA4', '\x3', '\x2', '\x2', 
		'\x2', '\xCA3', '\xCA1', '\x3', '\x2', '\x2', '\x2', '\xCA4', '\xCA5', 
		'\a', '\x2F3', '\x2', '\x2', '\xCA5', '\x10F', '\x3', '\x2', '\x2', '\x2', 
		'\xCA6', '\xCA7', '\a', '\xB0', '\x2', '\x2', '\xCA7', '\x111', '\x3', 
		'\x2', '\x2', '\x2', '\xCA8', '\xCA9', '\a', '\xB0', '\x2', '\x2', '\xCA9', 
		'\x113', '\x3', '\x2', '\x2', '\x2', '\xCAA', '\xCAB', '\a', '\x1B2', 
		'\x2', '\x2', '\xCAB', '\xCAC', '\x5', '\x42A', '\x216', '\x2', '\xCAC', 
		'\x115', '\x3', '\x2', '\x2', '\x2', '\xCAD', '\xCAF', '\a', '\x1B2', 
		'\x2', '\x2', '\xCAE', '\xCB0', '\x5', '\x42A', '\x216', '\x2', '\xCAF', 
		'\xCAE', '\x3', '\x2', '\x2', '\x2', '\xCAF', '\xCB0', '\x3', '\x2', '\x2', 
		'\x2', '\xCB0', '\x117', '\x3', '\x2', '\x2', '\x2', '\xCB1', '\xCB2', 
		'\a', '\x102', '\x2', '\x2', '\xCB2', '\xCB3', '\t', '#', '\x2', '\x2', 
		'\xCB3', '\x119', '\x3', '\x2', '\x2', '\x2', '\xCB4', '\xCC8', '\x5', 
		'\x1EC', '\xF7', '\x2', '\xCB5', '\xCB7', '\a', '\x1A9', '\x2', '\x2', 
		'\xCB6', '\xCB8', '\x5', '\x1EC', '\xF7', '\x2', '\xCB7', '\xCB6', '\x3', 
		'\x2', '\x2', '\x2', '\xCB7', '\xCB8', '\x3', '\x2', '\x2', '\x2', '\xCB8', 
		'\xCC8', '\x3', '\x2', '\x2', '\x2', '\xCB9', '\xCC8', '\x5', '\x12C', 
		'\x97', '\x2', '\xCBA', '\xCC8', '\x5', '\x12E', '\x98', '\x2', '\xCBB', 
		'\xCC8', '\x5', '\x120', '\x91', '\x2', '\xCBC', '\xCC8', '\x5', '\x134', 
		'\x9B', '\x2', '\xCBD', '\xCBE', '\a', '\x296', '\x2', '\x2', '\xCBE', 
		'\xCBF', '\x5', '\x13C', '\x9F', '\x2', '\xCBF', '\xCC0', '\a', '\x243', 
		'\x2', '\x2', '\xCC0', '\xCC2', '\a', '\x19', '\x2', '\x2', '\xCC1', '\xCC3', 
		'\t', '$', '\x2', '\x2', '\xCC2', '\xCC1', '\x3', '\x2', '\x2', '\x2', 
		'\xCC2', '\xCC3', '\x3', '\x2', '\x2', '\x2', '\xCC3', '\xCC4', '\x3', 
		'\x2', '\x2', '\x2', '\xCC4', '\xCC5', '\a', '\x136', '\x2', '\x2', '\xCC5', 
		'\xCC6', '\x5', '\x42E', '\x218', '\x2', '\xCC6', '\xCC8', '\x3', '\x2', 
		'\x2', '\x2', '\xCC7', '\xCB4', '\x3', '\x2', '\x2', '\x2', '\xCC7', '\xCB5', 
		'\x3', '\x2', '\x2', '\x2', '\xCC7', '\xCB9', '\x3', '\x2', '\x2', '\x2', 
		'\xCC7', '\xCBA', '\x3', '\x2', '\x2', '\x2', '\xCC7', '\xCBB', '\x3', 
		'\x2', '\x2', '\x2', '\xCC7', '\xCBC', '\x3', '\x2', '\x2', '\x2', '\xCC7', 
		'\xCBD', '\x3', '\x2', '\x2', '\x2', '\xCC8', '\xCC9', '\x3', '\x2', '\x2', 
		'\x2', '\xCC9', '\xCC7', '\x3', '\x2', '\x2', '\x2', '\xCC9', '\xCCA', 
		'\x3', '\x2', '\x2', '\x2', '\xCCA', '\x11B', '\x3', '\x2', '\x2', '\x2', 
		'\xCCB', '\xCCF', '\a', '\x10D', '\x2', '\x2', '\xCCC', '\xCCD', '\x5', 
		'\x122', '\x92', '\x2', '\xCCD', '\xCCE', '\x5', '\x11E', '\x90', '\x2', 
		'\xCCE', '\xCD0', '\x3', '\x2', '\x2', '\x2', '\xCCF', '\xCCC', '\x3', 
		'\x2', '\x2', '\x2', '\xCCF', '\xCD0', '\x3', '\x2', '\x2', '\x2', '\xCD0', 
		'\xCD4', '\x3', '\x2', '\x2', '\x2', '\xCD1', '\xCD2', '\a', '\x181', 
		'\x2', '\x2', '\xCD2', '\xCD4', '\a', '\x10D', '\x2', '\x2', '\xCD3', 
		'\xCCB', '\x3', '\x2', '\x2', '\x2', '\xCD3', '\xCD1', '\x3', '\x2', '\x2', 
		'\x2', '\xCD4', '\x11D', '\x3', '\x2', '\x2', '\x2', '\xCD5', '\xCD7', 
		'\a', '\x10D', '\x2', '\x2', '\xCD6', '\xCD8', '\x5', '\x124', '\x93', 
		'\x2', '\xCD7', '\xCD6', '\x3', '\x2', '\x2', '\x2', '\xCD7', '\xCD8', 
		'\x3', '\x2', '\x2', '\x2', '\xCD8', '\xCD9', '\x3', '\x2', '\x2', '\x2', 
		'\xCD9', '\xCDD', '\x5', '\x44A', '\x226', '\x2', '\xCDA', '\xCDB', '\a', 
		'\x181', '\x2', '\x2', '\xCDB', '\xCDD', '\a', '\x10D', '\x2', '\x2', 
		'\xCDC', '\xCD5', '\x3', '\x2', '\x2', '\x2', '\xCDC', '\xCDA', '\x3', 
		'\x2', '\x2', '\x2', '\xCDD', '\x11F', '\x3', '\x2', '\x2', '\x2', '\xCDE', 
		'\xCDF', '\a', '\x10D', '\x2', '\x2', '\xCDF', '\xCE3', '\x5', '\x122', 
		'\x92', '\x2', '\xCE0', '\xCE1', '\a', '\x181', '\x2', '\x2', '\xCE1', 
		'\xCE3', '\a', '\x10D', '\x2', '\x2', '\xCE2', '\xCDE', '\x3', '\x2', 
		'\x2', '\x2', '\xCE2', '\xCE0', '\x3', '\x2', '\x2', '\x2', '\xCE3', '\x121', 
		'\x3', '\x2', '\x2', '\x2', '\xCE4', '\xCE6', '\x5', '\x124', '\x93', 
		'\x2', '\xCE5', '\xCE4', '\x3', '\x2', '\x2', '\x2', '\xCE5', '\xCE6', 
		'\x3', '\x2', '\x2', '\x2', '\xCE6', '\xCF1', '\x3', '\x2', '\x2', '\x2', 
		'\xCE7', '\xCE9', '\x5', '\x126', '\x94', '\x2', '\xCE8', '\xCE7', '\x3', 
		'\x2', '\x2', '\x2', '\xCE8', '\xCE9', '\x3', '\x2', '\x2', '\x2', '\xCE9', 
		'\xCF1', '\x3', '\x2', '\x2', '\x2', '\xCEA', '\xCEC', '\x5', '\x128', 
		'\x95', '\x2', '\xCEB', '\xCEA', '\x3', '\x2', '\x2', '\x2', '\xCEB', 
		'\xCEC', '\x3', '\x2', '\x2', '\x2', '\xCEC', '\xCF1', '\x3', '\x2', '\x2', 
		'\x2', '\xCED', '\xCEF', '\x5', '\x12A', '\x96', '\x2', '\xCEE', '\xCED', 
		'\x3', '\x2', '\x2', '\x2', '\xCEE', '\xCEF', '\x3', '\x2', '\x2', '\x2', 
		'\xCEF', '\xCF1', '\x3', '\x2', '\x2', '\x2', '\xCF0', '\xCE5', '\x3', 
		'\x2', '\x2', '\x2', '\xCF0', '\xCE8', '\x3', '\x2', '\x2', '\x2', '\xCF0', 
		'\xCEB', '\x3', '\x2', '\x2', '\x2', '\xCF0', '\xCEE', '\x3', '\x2', '\x2', 
		'\x2', '\xCF1', '\x123', '\x3', '\x2', '\x2', '\x2', '\xCF2', '\xCF3', 
		'\a', '\x155', '\x2', '\x2', '\xCF3', '\xCF9', '\a', '\xDD', '\x2', '\x2', 
		'\xCF4', '\xCFA', '\a', '\xA2', '\x2', '\x2', '\xCF5', '\xCF7', '\t', 
		'%', '\x2', '\x2', '\xCF6', '\xCF8', '\t', '&', '\x2', '\x2', '\xCF7', 
		'\xCF6', '\x3', '\x2', '\x2', '\x2', '\xCF7', '\xCF8', '\x3', '\x2', '\x2', 
		'\x2', '\xCF8', '\xCFA', '\x3', '\x2', '\x2', '\x2', '\xCF9', '\xCF4', 
		'\x3', '\x2', '\x2', '\x2', '\xCF9', '\xCF5', '\x3', '\x2', '\x2', '\x2', 
		'\xCFA', '\xCFE', '\x3', '\x2', '\x2', '\x2', '\xCFB', '\xCFC', '\a', 
		'\x181', '\x2', '\x2', '\xCFC', '\xCFE', '\a', '\x155', '\x2', '\x2', 
		'\xCFD', '\xCF2', '\x3', '\x2', '\x2', '\x2', '\xCFD', '\xCFB', '\x3', 
		'\x2', '\x2', '\x2', '\xCFE', '\x125', '\x3', '\x2', '\x2', '\x2', '\xCFF', 
		'\xD00', '\a', '\x1D1', '\x2', '\x2', '\xD00', '\xD01', '\t', '\'', '\x2', 
		'\x2', '\xD01', '\x127', '\x3', '\x2', '\x2', '\x2', '\xD02', '\xD0B', 
		'\a', '\xA1', '\x2', '\x2', '\xD03', '\xD0C', '\a', '#', '\x2', '\x2', 
		'\xD04', '\xD09', '\a', '?', '\x2', '\x2', '\xD05', '\xD06', '\a', '\x207', 
		'\x2', '\x2', '\xD06', '\xD0A', '\a', '\x1DE', '\x2', '\x2', '\xD07', 
		'\xD0A', '\a', '\x1B2', '\x2', '\x2', '\xD08', '\xD0A', '\a', '\x247', 
		'\x2', '\x2', '\xD09', '\xD05', '\x3', '\x2', '\x2', '\x2', '\xD09', '\xD07', 
		'\x3', '\x2', '\x2', '\x2', '\xD09', '\xD08', '\x3', '\x2', '\x2', '\x2', 
		'\xD0A', '\xD0C', '\x3', '\x2', '\x2', '\x2', '\xD0B', '\xD03', '\x3', 
		'\x2', '\x2', '\x2', '\xD0B', '\xD04', '\x3', '\x2', '\x2', '\x2', '\xD0B', 
		'\xD0C', '\x3', '\x2', '\x2', '\x2', '\xD0C', '\x129', '\x3', '\x2', '\x2', 
		'\x2', '\xD0D', '\xD0F', '\a', '\xA7', '\x2', '\x2', '\xD0E', '\xD10', 
		'\a', '\xE', '\x2', '\x2', '\xD0F', '\xD0E', '\x3', '\x2', '\x2', '\x2', 
		'\xD0F', '\xD10', '\x3', '\x2', '\x2', '\x2', '\xD10', '\xD14', '\x3', 
		'\x2', '\x2', '\x2', '\xD11', '\xD12', '\a', '\x181', '\x2', '\x2', '\xD12', 
		'\xD14', '\a', '\xA7', '\x2', '\x2', '\xD13', '\xD0D', '\x3', '\x2', '\x2', 
		'\x2', '\xD13', '\xD11', '\x3', '\x2', '\x2', '\x2', '\xD14', '\x12B', 
		'\x3', '\x2', '\x2', '\x2', '\xD15', '\xD31', '\a', '`', '\x2', '\x2', 
		'\xD16', '\xD17', '\a', '\x209', '\x2', '\x2', '\xD17', '\xD18', '\a', 
		'\x243', '\x2', '\x2', '\xD18', '\xD1A', '\a', '`', '\x2', '\x2', '\xD19', 
		'\xD1B', '\t', '(', '\x2', '\x2', '\xD1A', '\xD19', '\x3', '\x2', '\x2', 
		'\x2', '\xD1A', '\xD1B', '\x3', '\x2', '\x2', '\x2', '\xD1B', '\xD31', 
		'\x3', '\x2', '\x2', '\x2', '\xD1C', '\xD1D', '\a', 'X', '\x2', '\x2', 
		'\xD1D', '\xD1E', '\a', '\x243', '\x2', '\x2', '\xD1E', '\xD24', '\a', 
		'`', '\x2', '\x2', '\xD1F', '\xD20', '\a', '\xDD', '\x2', '\x2', '\xD20', 
		'\xD22', '\t', ')', '\x2', '\x2', '\xD21', '\xD23', '\t', '&', '\x2', 
		'\x2', '\xD22', '\xD21', '\x3', '\x2', '\x2', '\x2', '\xD22', '\xD23', 
		'\x3', '\x2', '\x2', '\x2', '\xD23', '\xD25', '\x3', '\x2', '\x2', '\x2', 
		'\xD24', '\xD1F', '\x3', '\x2', '\x2', '\x2', '\xD24', '\xD25', '\x3', 
		'\x2', '\x2', '\x2', '\xD25', '\xD2C', '\x3', '\x2', '\x2', '\x2', '\xD26', 
		'\xD28', '\a', '\x181', '\x2', '\x2', '\xD27', '\xD26', '\x3', '\x2', 
		'\x2', '\x2', '\xD27', '\xD28', '\x3', '\x2', '\x2', '\x2', '\xD28', '\xD29', 
		'\x3', '\x2', '\x2', '\x2', '\xD29', '\xD2A', '\a', '\x209', '\x2', '\x2', 
		'\xD2A', '\xD2B', '\a', '\x12A', '\x2', '\x2', '\xD2B', '\xD2D', '\a', 
		'\x13C', '\x2', '\x2', '\xD2C', '\xD27', '\x3', '\x2', '\x2', '\x2', '\xD2C', 
		'\xD2D', '\x3', '\x2', '\x2', '\x2', '\xD2D', '\xD31', '\x3', '\x2', '\x2', 
		'\x2', '\xD2E', '\xD2F', '\a', '\x181', '\x2', '\x2', '\xD2F', '\xD31', 
		'\a', '`', '\x2', '\x2', '\xD30', '\xD15', '\x3', '\x2', '\x2', '\x2', 
		'\xD30', '\xD16', '\x3', '\x2', '\x2', '\x2', '\xD30', '\xD1C', '\x3', 
		'\x2', '\x2', '\x2', '\xD30', '\xD2E', '\x3', '\x2', '\x2', '\x2', '\xD31', 
		'\x12D', '\x3', '\x2', '\x2', '\x2', '\xD32', '\xD35', '\x5', '\x130', 
		'\x99', '\x2', '\xD33', '\xD35', '\x5', '\x132', '\x9A', '\x2', '\xD34', 
		'\xD32', '\x3', '\x2', '\x2', '\x2', '\xD34', '\xD33', '\x3', '\x2', '\x2', 
		'\x2', '\xD35', '\x12F', '\x3', '\x2', '\x2', '\x2', '\xD36', '\xD38', 
		'\a', '`', '\x2', '\x2', '\xD37', '\xD39', '\x5', '\x4A4', '\x253', '\x2', 
		'\xD38', '\xD37', '\x3', '\x2', '\x2', '\x2', '\xD38', '\xD39', '\x3', 
		'\x2', '\x2', '\x2', '\xD39', '\xD3C', '\x3', '\x2', '\x2', '\x2', '\xD3A', 
		'\xD3C', '\a', '\x174', '\x2', '\x2', '\xD3B', '\xD36', '\x3', '\x2', 
		'\x2', '\x2', '\xD3B', '\xD3A', '\x3', '\x2', '\x2', '\x2', '\xD3C', '\x131', 
		'\x3', '\x2', '\x2', '\x2', '\xD3D', '\xD3E', '\a', '`', '\x2', '\x2', 
		'\xD3E', '\xD3F', '\a', '\b', '\x2', '\x2', '\xD3F', '\xD42', '\a', '\x145', 
		'\x2', '\x2', '\xD40', '\xD42', '\a', '\x174', '\x2', '\x2', '\xD41', 
		'\xD3D', '\x3', '\x2', '\x2', '\x2', '\xD41', '\xD40', '\x3', '\x2', '\x2', 
		'\x2', '\xD42', '\x133', '\x3', '\x2', '\x2', '\x2', '\xD43', '\xD44', 
		'\a', '\x136', '\x2', '\x2', '\xD44', '\xD45', '\a', '\x2F2', '\x2', '\x2', 
		'\xD45', '\xD46', '\x5', '\x420', '\x211', '\x2', '\xD46', '\xD47', '\a', 
		'\x2F3', '\x2', '\x2', '\xD47', '\xD48', '\a', '\x243', '\x2', '\x2', 
		'\xD48', '\xD4A', '\a', '\x19', '\x2', '\x2', '\xD49', '\xD4B', '\t', 
		'$', '\x2', '\x2', '\xD4A', '\xD49', '\x3', '\x2', '\x2', '\x2', '\xD4A', 
		'\xD4B', '\x3', '\x2', '\x2', '\x2', '\xD4B', '\xD57', '\x3', '\x2', '\x2', 
		'\x2', '\xD4C', '\xD51', '\x5', '\x42E', '\x218', '\x2', '\xD4D', '\xD4E', 
		'\a', '\x2F2', '\x2', '\x2', '\xD4E', '\xD4F', '\x5', '\x1EC', '\xF7', 
		'\x2', '\xD4F', '\xD50', '\a', '\x2F3', '\x2', '\x2', '\xD50', '\xD52', 
		'\x3', '\x2', '\x2', '\x2', '\xD51', '\xD4D', '\x3', '\x2', '\x2', '\x2', 
		'\xD51', '\xD52', '\x3', '\x2', '\x2', '\x2', '\xD52', '\xD58', '\x3', 
		'\x2', '\x2', '\x2', '\xD53', '\xD54', '\a', '\x2F2', '\x2', '\x2', '\xD54', 
		'\xD55', '\x5', '\x1EC', '\xF7', '\x2', '\xD55', '\xD56', '\a', '\x2F3', 
		'\x2', '\x2', '\xD56', '\xD58', '\x3', '\x2', '\x2', '\x2', '\xD57', '\xD4C', 
		'\x3', '\x2', '\x2', '\x2', '\xD57', '\xD53', '\x3', '\x2', '\x2', '\x2', 
		'\xD57', '\xD58', '\x3', '\x2', '\x2', '\x2', '\xD58', '\x135', '\x3', 
		'\x2', '\x2', '\x2', '\xD59', '\xD78', '\x5', '\x1EE', '\xF8', '\x2', 
		'\xD5A', '\xD5B', '\a', '\x2F2', '\x2', '\x2', '\xD5B', '\xD5D', '\x5', 
		'\x116', '\x8C', '\x2', '\xD5C', '\xD5E', '\x5', '\x1EC', '\xF7', '\x2', 
		'\xD5D', '\xD5C', '\x3', '\x2', '\x2', '\x2', '\xD5D', '\xD5E', '\x3', 
		'\x2', '\x2', '\x2', '\xD5E', '\xD60', '\x3', '\x2', '\x2', '\x2', '\xD5F', 
		'\xD61', '\x5', '\x132', '\x9A', '\x2', '\xD60', '\xD5F', '\x3', '\x2', 
		'\x2', '\x2', '\xD60', '\xD61', '\x3', '\x2', '\x2', '\x2', '\xD61', '\xD63', 
		'\x3', '\x2', '\x2', '\x2', '\xD62', '\xD64', '\x5', '\x138', '\x9D', 
		'\x2', '\xD63', '\xD62', '\x3', '\x2', '\x2', '\x2', '\xD63', '\xD64', 
		'\x3', '\x2', '\x2', '\x2', '\xD64', '\xD72', '\x3', '\x2', '\x2', '\x2', 
		'\xD65', '\xD66', '\a', '\x2F8', '\x2', '\x2', '\xD66', '\xD68', '\x5', 
		'\x116', '\x8C', '\x2', '\xD67', '\xD69', '\x5', '\x1EC', '\xF7', '\x2', 
		'\xD68', '\xD67', '\x3', '\x2', '\x2', '\x2', '\xD68', '\xD69', '\x3', 
		'\x2', '\x2', '\x2', '\xD69', '\xD6B', '\x3', '\x2', '\x2', '\x2', '\xD6A', 
		'\xD6C', '\x5', '\x132', '\x9A', '\x2', '\xD6B', '\xD6A', '\x3', '\x2', 
		'\x2', '\x2', '\xD6B', '\xD6C', '\x3', '\x2', '\x2', '\x2', '\xD6C', '\xD6E', 
		'\x3', '\x2', '\x2', '\x2', '\xD6D', '\xD6F', '\x5', '\x138', '\x9D', 
		'\x2', '\xD6E', '\xD6D', '\x3', '\x2', '\x2', '\x2', '\xD6E', '\xD6F', 
		'\x3', '\x2', '\x2', '\x2', '\xD6F', '\xD71', '\x3', '\x2', '\x2', '\x2', 
		'\xD70', '\xD65', '\x3', '\x2', '\x2', '\x2', '\xD71', '\xD74', '\x3', 
		'\x2', '\x2', '\x2', '\xD72', '\xD70', '\x3', '\x2', '\x2', '\x2', '\xD72', 
		'\xD73', '\x3', '\x2', '\x2', '\x2', '\xD73', '\xD75', '\x3', '\x2', '\x2', 
		'\x2', '\xD74', '\xD72', '\x3', '\x2', '\x2', '\x2', '\xD75', '\xD76', 
		'\a', '\x2F3', '\x2', '\x2', '\xD76', '\xD78', '\x3', '\x2', '\x2', '\x2', 
		'\xD77', '\xD59', '\x3', '\x2', '\x2', '\x2', '\xD77', '\xD5A', '\x3', 
		'\x2', '\x2', '\x2', '\xD78', '\x137', '\x3', '\x2', '\x2', '\x2', '\xD79', 
		'\xD7A', '\t', '*', '\x2', '\x2', '\xD7A', '\x139', '\x3', '\x2', '\x2', 
		'\x2', '\xD7B', '\xD7C', '\a', '\x2EC', '\x2', '\x2', '\xD7C', '\x13B', 
		'\x3', '\x2', '\x2', '\x2', '\xD7D', '\xD7E', '\a', '\x310', '\x2', '\x2', 
		'\xD7E', '\x13D', '\x3', '\x2', '\x2', '\x2', '\xD7F', '\xD80', '\a', 
		'\x102', '\x2', '\x2', '\xD80', '\xD81', '\t', '+', '\x2', '\x2', '\xD81', 
		'\x13F', '\x3', '\x2', '\x2', '\x2', '\xD82', '\xD86', '\a', '\x184', 
		'\x2', '\x2', '\xD83', '\xD84', '\a', '\x1AE', '\x2', '\x2', '\xD84', 
		'\xD86', '\x5', '\x4A4', '\x253', '\x2', '\xD85', '\xD82', '\x3', '\x2', 
		'\x2', '\x2', '\xD85', '\xD83', '\x3', '\x2', '\x2', '\x2', '\xD86', '\x141', 
		'\x3', '\x2', '\x2', '\x2', '\xD87', '\xD89', '\x5', '\x406', '\x204', 
		'\x2', '\xD88', '\xD8A', '\x5', '\x144', '\xA3', '\x2', '\xD89', '\xD88', 
		'\x3', '\x2', '\x2', '\x2', '\xD89', '\xD8A', '\x3', '\x2', '\x2', '\x2', 
		'\xD8A', '\xD8C', '\x3', '\x2', '\x2', '\x2', '\xD8B', '\xD8D', '\x5', 
		'\x140', '\xA1', '\x2', '\xD8C', '\xD8B', '\x3', '\x2', '\x2', '\x2', 
		'\xD8C', '\xD8D', '\x3', '\x2', '\x2', '\x2', '\xD8D', '\xD93', '\x3', 
		'\x2', '\x2', '\x2', '\xD8E', '\xD8F', '\a', '\x1AF', '\x2', '\x2', '\xD8F', 
		'\xD90', '\a', '\x2F2', '\x2', '\x2', '\xD90', '\xD91', '\x5', '\x148', 
		'\xA5', '\x2', '\xD91', '\xD92', '\a', '\x2F3', '\x2', '\x2', '\xD92', 
		'\xD94', '\x3', '\x2', '\x2', '\x2', '\xD93', '\xD8E', '\x3', '\x2', '\x2', 
		'\x2', '\xD93', '\xD94', '\x3', '\x2', '\x2', '\x2', '\xD94', '\x143', 
		'\x3', '\x2', '\x2', '\x2', '\xD95', '\xD97', '\a', '\x138', '\x2', '\x2', 
		'\xD96', '\xD98', '\x5', '\x146', '\xA4', '\x2', '\xD97', '\xD96', '\x3', 
		'\x2', '\x2', '\x2', '\xD97', '\xD98', '\x3', '\x2', '\x2', '\x2', '\xD98', 
		'\xD9D', '\x3', '\x2', '\x2', '\x2', '\xD99', '\xD9A', '\a', '\x2F8', 
		'\x2', '\x2', '\xD9A', '\xD9C', '\x5', '\x146', '\xA4', '\x2', '\xD9B', 
		'\xD99', '\x3', '\x2', '\x2', '\x2', '\xD9C', '\xD9F', '\x3', '\x2', '\x2', 
		'\x2', '\xD9D', '\xD9B', '\x3', '\x2', '\x2', '\x2', '\xD9D', '\xD9E', 
		'\x3', '\x2', '\x2', '\x2', '\xD9E', '\x145', '\x3', '\x2', '\x2', '\x2', 
		'\xD9F', '\xD9D', '\x3', '\x2', '\x2', '\x2', '\xDA0', '\xDA1', '\a', 
		'\x2F2', '\x2', '\x2', '\xDA1', '\xDA2', '\a', '\x1B2', '\x2', '\x2', 
		'\xDA2', '\xDA8', '\x5', '\x42A', '\x216', '\x2', '\xDA3', '\xDA4', '\a', 
		'\x1AF', '\x2', '\x2', '\xDA4', '\xDA5', '\a', '\x2F2', '\x2', '\x2', 
		'\xDA5', '\xDA6', '\x5', '\x148', '\xA5', '\x2', '\xDA6', '\xDA7', '\a', 
		'\x2F3', '\x2', '\x2', '\xDA7', '\xDA9', '\x3', '\x2', '\x2', '\x2', '\xDA8', 
		'\xDA3', '\x3', '\x2', '\x2', '\x2', '\xDA8', '\xDA9', '\x3', '\x2', '\x2', 
		'\x2', '\xDA9', '\xDAA', '\x3', '\x2', '\x2', '\x2', '\xDAA', '\xDAB', 
		'\a', '\x2F3', '\x2', '\x2', '\xDAB', '\x147', '\x3', '\x2', '\x2', '\x2', 
		'\xDAC', '\xDAD', '\a', '\x2EE', '\x2', '\x2', '\xDAD', '\x149', '\x3', 
		'\x2', '\x2', '\x2', '\xDAE', '\xDAF', '\a', '\xC0', '\x2', '\x2', '\xDAF', 
		'\xDB0', '\a', '\x118', '\x2', '\x2', '\xDB0', '\xDB1', '\x5', '\x444', 
		'\x223', '\x2', '\xDB1', '\x14B', '\x3', '\x2', '\x2', '\x2', '\xDB2', 
		'\xDB4', '\a', 'r', '\x2', '\x2', '\xDB3', '\xDB5', '\t', ',', '\x2', 
		'\x2', '\xDB4', '\xDB3', '\x3', '\x2', '\x2', '\x2', '\xDB4', '\xDB5', 
		'\x3', '\x2', '\x2', '\x2', '\xDB5', '\xDB9', '\x3', '\x2', '\x2', '\x2', 
		'\xDB6', '\xDBA', '\x5', '\x14E', '\xA8', '\x2', '\xDB7', '\xDBA', '\x5', 
		'\x15A', '\xAE', '\x2', '\xDB8', '\xDBA', '\x5', '\x15E', '\xB0', '\x2', 
		'\xDB9', '\xDB6', '\x3', '\x2', '\x2', '\x2', '\xDB9', '\xDB7', '\x3', 
		'\x2', '\x2', '\x2', '\xDB9', '\xDB8', '\x3', '\x2', '\x2', '\x2', '\xDBA', 
		'\xDBB', '\x3', '\x2', '\x2', '\x2', '\xDBB', '\xDBC', '\a', '\x304', 
		'\x2', '\x2', '\xDBC', '\x14D', '\x3', '\x2', '\x2', '\x2', '\xDBD', '\xDBF', 
		'\x5', '\x1EC', '\xF7', '\x2', '\xDBE', '\xDC0', '\x5', '\x162', '\xB2', 
		'\x2', '\xDBF', '\xDBE', '\x3', '\x2', '\x2', '\x2', '\xDBF', '\xDC0', 
		'\x3', '\x2', '\x2', '\x2', '\xDC0', '\xDD2', '\x3', '\x2', '\x2', '\x2', 
		'\xDC1', '\xDC2', '\a', '\x159', '\x2', '\x2', '\xDC2', '\xDC3', '\a', 
		'\xC9', '\x2', '\x2', '\xDC3', '\xDD1', '\x5', '\x21C', '\x10F', '\x2', 
		'\xDC4', '\xDC5', '\a', '\x37', '\x2', '\x2', '\xDC5', '\xDD1', '\x5', 
		'\x21C', '\x10F', '\x2', '\xDC6', '\xDD1', '\x5', '\x152', '\xAA', '\x2', 
		'\xDC7', '\xDC8', '\a', '\xDB', '\x2', '\x2', '\xDC8', '\xDD1', '\a', 
		'\x13E', '\x2', '\x2', '\xDC9', '\xDD1', '\t', '-', '\x2', '\x2', '\xDCA', 
		'\xDCB', '\a', '\xB4', '\x2', '\x2', '\xDCB', '\xDD1', '\x5', '\x150', 
		'\xA9', '\x2', '\xDCC', '\xDD1', '\a', '\x8F', '\x2', '\x2', '\xDCD', 
		'\xDD1', '\x5', '\x154', '\xAB', '\x2', '\xDCE', '\xDD1', '\x5', '\x156', 
		'\xAC', '\x2', '\xDCF', '\xDD1', '\x5', '\x158', '\xAD', '\x2', '\xDD0', 
		'\xDC1', '\x3', '\x2', '\x2', '\x2', '\xDD0', '\xDC4', '\x3', '\x2', '\x2', 
		'\x2', '\xDD0', '\xDC6', '\x3', '\x2', '\x2', '\x2', '\xDD0', '\xDC7', 
		'\x3', '\x2', '\x2', '\x2', '\xDD0', '\xDC9', '\x3', '\x2', '\x2', '\x2', 
		'\xDD0', '\xDCA', '\x3', '\x2', '\x2', '\x2', '\xDD0', '\xDCC', '\x3', 
		'\x2', '\x2', '\x2', '\xDD0', '\xDCD', '\x3', '\x2', '\x2', '\x2', '\xDD0', 
		'\xDCE', '\x3', '\x2', '\x2', '\x2', '\xDD0', '\xDCF', '\x3', '\x2', '\x2', 
		'\x2', '\xDD1', '\xDD4', '\x3', '\x2', '\x2', '\x2', '\xDD2', '\xDD0', 
		'\x3', '\x2', '\x2', '\x2', '\xDD2', '\xDD3', '\x3', '\x2', '\x2', '\x2', 
		'\xDD3', '\x14F', '\x3', '\x2', '\x2', '\x2', '\xDD4', '\xDD2', '\x3', 
		'\x2', '\x2', '\x2', '\xDD5', '\xDD6', '\a', '\x28E', '\x2', '\x2', '\xDD6', 
		'\xDD7', '\a', '\x2EE', '\x2', '\x2', '\xDD7', '\x151', '\x3', '\x2', 
		'\x2', '\x2', '\xDD8', '\xDD9', '\t', '.', '\x2', '\x2', '\xDD9', '\x153', 
		'\x3', '\x2', '\x2', '\x2', '\xDDA', '\xDDB', '\a', '\xC9', '\x2', '\x2', 
		'\xDDB', '\xDDC', '\a', '\x148', '\x2', '\x2', '\xDDC', '\xDE3', '\a', 
		'\x138', '\x2', '\x2', '\xDDD', '\xDE4', '\a', '\"', '\x2', '\x2', '\xDDE', 
		'\xDE1', '\a', '\x27E', '\x2', '\x2', '\xDDF', '\xDE0', '\a', '\x22E', 
		'\x2', '\x2', '\xDE0', '\xDE2', '\x5', '\x21C', '\x10F', '\x2', '\xDE1', 
		'\xDDF', '\x3', '\x2', '\x2', '\x2', '\xDE1', '\xDE2', '\x3', '\x2', '\x2', 
		'\x2', '\xDE2', '\xDE4', '\x3', '\x2', '\x2', '\x2', '\xDE3', '\xDDD', 
		'\x3', '\x2', '\x2', '\x2', '\xDE3', '\xDDE', '\x3', '\x2', '\x2', '\x2', 
		'\xDE3', '\xDE4', '\x3', '\x2', '\x2', '\x2', '\xDE4', '\x155', '\x3', 
		'\x2', '\x2', '\x2', '\xDE5', '\xDE6', '\a', '\x219', '\x2', '\x2', '\xDE6', 
		'\xDE7', '\a', '\x236', '\x2', '\x2', '\xDE7', '\xDE8', '\a', '\x148', 
		'\x2', '\x2', '\xDE8', '\xDE9', '\t', '/', '\x2', '\x2', '\xDE9', '\x157', 
		'\x3', '\x2', '\x2', '\x2', '\xDEA', '\xDEB', '\a', '\xD4', '\x2', '\x2', 
		'\xDEB', '\xDEC', '\t', '#', '\x2', '\x2', '\xDEC', '\x159', '\x3', '\x2', 
		'\x2', '\x2', '\xDED', '\xDEE', '\a', '\x25B', '\x2', '\x2', '\xDEE', 
		'\xDF0', '\x5', '\x1EC', '\xF7', '\x2', '\xDEF', '\xDF1', '\x5', '\x164', 
		'\xB3', '\x2', '\xDF0', '\xDEF', '\x3', '\x2', '\x2', '\x2', '\xDF0', 
		'\xDF1', '\x3', '\x2', '\x2', '\x2', '\xDF1', '\xDF3', '\x3', '\x2', '\x2', 
		'\x2', '\xDF2', '\xDF4', '\x5', '\x15C', '\xAF', '\x2', '\xDF3', '\xDF2', 
		'\x3', '\x2', '\x2', '\x2', '\xDF3', '\xDF4', '\x3', '\x2', '\x2', '\x2', 
		'\xDF4', '\xDF6', '\x3', '\x2', '\x2', '\x2', '\xDF5', '\xDF7', '\x5', 
		'\x154', '\xAB', '\x2', '\xDF6', '\xDF5', '\x3', '\x2', '\x2', '\x2', 
		'\xDF6', '\xDF7', '\x3', '\x2', '\x2', '\x2', '\xDF7', '\x15B', '\x3', 
		'\x2', '\x2', '\x2', '\xDF8', '\xDF9', '\a', '\x256', '\x2', '\x2', '\xDF9', 
		'\xDFA', '\a', '\xE9', '\x2', '\x2', '\xDFA', '\xDFB', '\t', '\x30', '\x2', 
		'\x2', '\xDFB', '\x15D', '\x3', '\x2', '\x2', '\x2', '\xDFC', '\xDFD', 
		'\a', '\x27D', '\x2', '\x2', '\xDFD', '\xDFF', '\x5', '\x1EC', '\xF7', 
		'\x2', '\xDFE', '\xE00', '\x5', '\x162', '\xB2', '\x2', '\xDFF', '\xDFE', 
		'\x3', '\x2', '\x2', '\x2', '\xDFF', '\xE00', '\x3', '\x2', '\x2', '\x2', 
		'\xE00', '\xE02', '\x3', '\x2', '\x2', '\x2', '\xE01', '\xE03', '\x5', 
		'\x154', '\xAB', '\x2', '\xE02', '\xE01', '\x3', '\x2', '\x2', '\x2', 
		'\xE02', '\xE03', '\x3', '\x2', '\x2', '\x2', '\xE03', '\xE05', '\x3', 
		'\x2', '\x2', '\x2', '\xE04', '\xE06', '\x5', '\x160', '\xB1', '\x2', 
		'\xE05', '\xE04', '\x3', '\x2', '\x2', '\x2', '\xE05', '\xE06', '\x3', 
		'\x2', '\x2', '\x2', '\xE06', '\x15F', '\x3', '\x2', '\x2', '\x2', '\xE07', 
		'\xE08', '\a', '\x1FA', '\x2', '\x2', '\xE08', '\xE09', '\t', '\x31', 
		'\x2', '\x2', '\xE09', '\x161', '\x3', '\x2', '\x2', '\x2', '\xE0A', '\xE0C', 
		'\a', '\x7F', '\x2', '\x2', '\xE0B', '\xE0D', '\a', '\x2F8', '\x2', '\x2', 
		'\xE0C', '\xE0B', '\x3', '\x2', '\x2', '\x2', '\xE0C', '\xE0D', '\x3', 
		'\x2', '\x2', '\x2', '\xE0D', '\xE0E', '\x3', '\x2', '\x2', '\x2', '\xE0E', 
		'\xE0F', '\x5', '\x166', '\xB4', '\x2', '\xE0F', '\x163', '\x3', '\x2', 
		'\x2', '\x2', '\xE10', '\xE12', '\a', '\x259', '\x2', '\x2', '\xE11', 
		'\xE13', '\a', '\x2F8', '\x2', '\x2', '\xE12', '\xE11', '\x3', '\x2', 
		'\x2', '\x2', '\xE12', '\xE13', '\x3', '\x2', '\x2', '\x2', '\xE13', '\xE14', 
		'\x3', '\x2', '\x2', '\x2', '\xE14', '\xE15', '\x5', '\x166', '\xB4', 
		'\x2', '\xE15', '\x165', '\x3', '\x2', '\x2', '\x2', '\xE16', '\xE18', 
		'\a', '\x2EE', '\x2', '\x2', '\xE17', '\xE16', '\x3', '\x2', '\x2', '\x2', 
		'\xE17', '\xE18', '\x3', '\x2', '\x2', '\x2', '\xE18', '\xE1B', '\x3', 
		'\x2', '\x2', '\x2', '\xE19', '\xE1A', '\a', '\x22E', '\x2', '\x2', '\xE1A', 
		'\xE1C', '\x5', '\x21C', '\x10F', '\x2', '\xE1B', '\xE19', '\x3', '\x2', 
		'\x2', '\x2', '\xE1B', '\xE1C', '\x3', '\x2', '\x2', '\x2', '\xE1C', '\xE1E', 
		'\x3', '\x2', '\x2', '\x2', '\xE1D', '\xE1F', '\a', '\x1FD', '\x2', '\x2', 
		'\xE1E', '\xE1D', '\x3', '\x2', '\x2', '\x2', '\xE1E', '\xE1F', '\x3', 
		'\x2', '\x2', '\x2', '\xE1F', '\xE21', '\x3', '\x2', '\x2', '\x2', '\xE20', 
		'\xE22', '\x5', '\x16A', '\xB6', '\x2', '\xE21', '\xE20', '\x3', '\x2', 
		'\x2', '\x2', '\xE21', '\xE22', '\x3', '\x2', '\x2', '\x2', '\xE22', '\x167', 
		'\x3', '\x2', '\x2', '\x2', '\xE23', '\xE2F', '\a', '\x7F', '\x2', '\x2', 
		'\xE24', '\xE30', '\a', '\x2EE', '\x2', '\x2', '\xE25', '\xE2A', '\a', 
		'\x2F2', '\x2', '\x2', '\xE26', '\xE28', '\a', '\x2F8', '\x2', '\x2', 
		'\xE27', '\xE26', '\x3', '\x2', '\x2', '\x2', '\xE27', '\xE28', '\x3', 
		'\x2', '\x2', '\x2', '\xE28', '\xE29', '\x3', '\x2', '\x2', '\x2', '\xE29', 
		'\xE2B', '\a', '\x2EE', '\x2', '\x2', '\xE2A', '\xE27', '\x3', '\x2', 
		'\x2', '\x2', '\xE2B', '\xE2C', '\x3', '\x2', '\x2', '\x2', '\xE2C', '\xE2A', 
		'\x3', '\x2', '\x2', '\x2', '\xE2C', '\xE2D', '\x3', '\x2', '\x2', '\x2', 
		'\xE2D', '\xE2E', '\x3', '\x2', '\x2', '\x2', '\xE2E', '\xE30', '\a', 
		'\x2F3', '\x2', '\x2', '\xE2F', '\xE24', '\x3', '\x2', '\x2', '\x2', '\xE2F', 
		'\xE25', '\x3', '\x2', '\x2', '\x2', '\xE2F', '\xE30', '\x3', '\x2', '\x2', 
		'\x2', '\xE30', '\xE33', '\x3', '\x2', '\x2', '\x2', '\xE31', '\xE32', 
		'\a', '\x22E', '\x2', '\x2', '\xE32', '\xE34', '\x5', '\x21C', '\x10F', 
		'\x2', '\xE33', '\xE31', '\x3', '\x2', '\x2', '\x2', '\xE33', '\xE34', 
		'\x3', '\x2', '\x2', '\x2', '\xE34', '\xE37', '\x3', '\x2', '\x2', '\x2', 
		'\xE35', '\xE36', '\a', '\x37', '\x2', '\x2', '\xE36', '\xE38', '\x5', 
		'\x21C', '\x10F', '\x2', '\xE37', '\xE35', '\x3', '\x2', '\x2', '\x2', 
		'\xE37', '\xE38', '\x3', '\x2', '\x2', '\x2', '\xE38', '\xE3A', '\x3', 
		'\x2', '\x2', '\x2', '\xE39', '\xE3B', '\a', '\x1FD', '\x2', '\x2', '\xE3A', 
		'\xE39', '\x3', '\x2', '\x2', '\x2', '\xE3A', '\xE3B', '\x3', '\x2', '\x2', 
		'\x2', '\xE3B', '\x169', '\x3', '\x2', '\x2', '\x2', '\xE3C', '\xE46', 
		'\a', '$', '\x2', '\x2', '\xE3D', '\xE47', '\a', '\x194', '\x2', '\x2', 
		'\xE3E', '\xE41', '\a', '\x19B', '\x2', '\x2', '\xE3F', '\xE40', '\a', 
		'\x171', '\x2', '\x2', '\xE40', '\xE42', '\x5', '\x21C', '\x10F', '\x2', 
		'\xE41', '\xE3F', '\x3', '\x2', '\x2', '\x2', '\xE41', '\xE42', '\x3', 
		'\x2', '\x2', '\x2', '\xE42', '\xE44', '\x3', '\x2', '\x2', '\x2', '\xE43', 
		'\xE45', '\x5', '\x16C', '\xB7', '\x2', '\xE44', '\xE43', '\x3', '\x2', 
		'\x2', '\x2', '\xE44', '\xE45', '\x3', '\x2', '\x2', '\x2', '\xE45', '\xE47', 
		'\x3', '\x2', '\x2', '\x2', '\xE46', '\xE3D', '\x3', '\x2', '\x2', '\x2', 
		'\xE46', '\xE3E', '\x3', '\x2', '\x2', '\x2', '\xE47', '\x16B', '\x3', 
		'\x2', '\x2', '\x2', '\xE48', '\xE4B', '\a', '\x14E', '\x2', '\x2', '\xE49', 
		'\xE4C', '\a', '\x281', '\x2', '\x2', '\xE4A', '\xE4C', '\x5', '\x21C', 
		'\x10F', '\x2', '\xE4B', '\xE49', '\x3', '\x2', '\x2', '\x2', '\xE4B', 
		'\xE4A', '\x3', '\x2', '\x2', '\x2', '\xE4C', '\x16D', '\x3', '\x2', '\x2', 
		'\x2', '\xE4D', '\xE51', '\x5', '\x2CE', '\x168', '\x2', '\xE4E', '\xE50', 
		'\x5', '\x2D0', '\x169', '\x2', '\xE4F', '\xE4E', '\x3', '\x2', '\x2', 
		'\x2', '\xE50', '\xE53', '\x3', '\x2', '\x2', '\x2', '\xE51', '\xE4F', 
		'\x3', '\x2', '\x2', '\x2', '\xE51', '\xE52', '\x3', '\x2', '\x2', '\x2', 
		'\xE52', '\x16F', '\x3', '\x2', '\x2', '\x2', '\xE53', '\xE51', '\x3', 
		'\x2', '\x2', '\x2', '\xE54', '\xE57', '\a', 'r', '\x2', '\x2', '\xE55', 
		'\xE56', '\a', '\xE5', '\x2', '\x2', '\xE56', '\xE58', '\a', '\x25B', 
		'\x2', '\x2', '\xE57', '\xE55', '\x3', '\x2', '\x2', '\x2', '\xE57', '\xE58', 
		'\x3', '\x2', '\x2', '\x2', '\xE58', '\xE59', '\x3', '\x2', '\x2', '\x2', 
		'\xE59', '\xE5A', '\a', '\x258', '\x2', '\x2', '\xE5A', '\xE5B', '\x5', 
		'\x444', '\x223', '\x2', '\xE5B', '\xE5C', '\x5', '\x172', '\xBA', '\x2', 
		'\xE5C', '\x171', '\x3', '\x2', '\x2', '\x2', '\xE5D', '\xE5E', '\a', 
		'\x2F2', '\x2', '\x2', '\xE5E', '\xE5F', '\x5', '\x174', '\xBB', '\x2', 
		'\xE5F', '\xE60', '\a', '\x2F3', '\x2', '\x2', '\xE60', '\xE62', '\x3', 
		'\x2', '\x2', '\x2', '\xE61', '\xE5D', '\x3', '\x2', '\x2', '\x2', '\xE61', 
		'\xE62', '\x3', '\x2', '\x2', '\x2', '\xE62', '\xE69', '\x3', '\x2', '\x2', 
		'\x2', '\xE63', '\xE64', '\a', '\x19B', '\x2', '\x2', '\xE64', '\xE66', 
		'\a', '[', '\x2', '\x2', '\xE65', '\xE67', '\t', '\x32', '\x2', '\x2', 
		'\xE66', '\xE65', '\x3', '\x2', '\x2', '\x2', '\xE66', '\xE67', '\x3', 
		'\x2', '\x2', '\x2', '\xE67', '\xE68', '\x3', '\x2', '\x2', '\x2', '\xE68', 
		'\xE6A', '\a', '\x20A', '\x2', '\x2', '\xE69', '\xE63', '\x3', '\x2', 
		'\x2', '\x2', '\xE69', '\xE6A', '\x3', '\x2', '\x2', '\x2', '\xE6A', '\xE6C', 
		'\x3', '\x2', '\x2', '\x2', '\xE6B', '\xE6D', '\x5', '\x1DC', '\xEF', 
		'\x2', '\xE6C', '\xE6B', '\x3', '\x2', '\x2', '\x2', '\xE6C', '\xE6D', 
		'\x3', '\x2', '\x2', '\x2', '\xE6D', '\xE6E', '\x3', '\x2', '\x2', '\x2', 
		'\xE6E', '\xE6F', '\x5', '\x178', '\xBD', '\x2', '\xE6F', '\x173', '\x3', 
		'\x2', '\x2', '\x2', '\xE70', '\xE75', '\x5', '\x176', '\xBC', '\x2', 
		'\xE71', '\xE72', '\a', '\x2F8', '\x2', '\x2', '\xE72', '\xE74', '\x5', 
		'\x176', '\xBC', '\x2', '\xE73', '\xE71', '\x3', '\x2', '\x2', '\x2', 
		'\xE74', '\xE77', '\x3', '\x2', '\x2', '\x2', '\xE75', '\xE73', '\x3', 
		'\x2', '\x2', '\x2', '\xE75', '\xE76', '\x3', '\x2', '\x2', '\x2', '\xE76', 
		'\x175', '\x3', '\x2', '\x2', '\x2', '\xE77', '\xE75', '\x3', '\x2', '\x2', 
		'\x2', '\xE78', '\xE81', '\x5', '\x1FE', '\x100', '\x2', '\xE79', '\xE81', 
		'\x5', '\x200', '\x101', '\x2', '\xE7A', '\xE81', '\x5', '\x204', '\x103', 
		'\x2', '\xE7B', '\xE7E', '\x5', '\xEC', 'w', '\x2', '\xE7C', '\xE7E', 
		'\x5', '\x21A', '\x10E', '\x2', '\xE7D', '\xE7B', '\x3', '\x2', '\x2', 
		'\x2', '\xE7D', '\xE7C', '\x3', '\x2', '\x2', '\x2', '\xE7E', '\xE81', 
		'\x3', '\x2', '\x2', '\x2', '\xE7F', '\xE81', '\x5', '\x206', '\x104', 
		'\x2', '\xE80', '\xE78', '\x3', '\x2', '\x2', '\x2', '\xE80', '\xE79', 
		'\x3', '\x2', '\x2', '\x2', '\xE80', '\xE7A', '\x3', '\x2', '\x2', '\x2', 
		'\xE80', '\xE7D', '\x3', '\x2', '\x2', '\x2', '\xE80', '\xE7F', '\x3', 
		'\x2', '\x2', '\x2', '\xE81', '\x177', '\x3', '\x2', '\x2', '\x2', '\xE82', 
		'\xE84', '\x5', '\x194', '\xCB', '\x2', '\xE83', '\xE82', '\x3', '\x2', 
		'\x2', '\x2', '\xE83', '\xE84', '\x3', '\x2', '\x2', '\x2', '\xE84', '\xE86', 
		'\x3', '\x2', '\x2', '\x2', '\xE85', '\xE87', '\x5', '\x118', '\x8D', 
		'\x2', '\xE86', '\xE85', '\x3', '\x2', '\x2', '\x2', '\xE86', '\xE87', 
		'\x3', '\x2', '\x2', '\x2', '\xE87', '\xE89', '\x3', '\x2', '\x2', '\x2', 
		'\xE88', '\xE8A', '\x5', '\x18E', '\xC8', '\x2', '\xE89', '\xE88', '\x3', 
		'\x2', '\x2', '\x2', '\xE89', '\xE8A', '\x3', '\x2', '\x2', '\x2', '\xE8A', 
		'\xE8C', '\x3', '\x2', '\x2', '\x2', '\xE8B', '\xE8D', '\x5', '\x17E', 
		'\xC0', '\x2', '\xE8C', '\xE8B', '\x3', '\x2', '\x2', '\x2', '\xE8C', 
		'\xE8D', '\x3', '\x2', '\x2', '\x2', '\xE8D', '\xE8F', '\x3', '\x2', '\x2', 
		'\x2', '\xE8E', '\xE90', '\t', '\x33', '\x2', '\x2', '\xE8F', '\xE8E', 
		'\x3', '\x2', '\x2', '\x2', '\xE8F', '\xE90', '\x3', '\x2', '\x2', '\x2', 
		'\xE90', '\xE96', '\x3', '\x2', '\x2', '\x2', '\xE91', '\xE92', '\a', 
		'\x1F7', '\x2', '\x2', '\xE92', '\xE93', '\a', '\x2F2', '\x2', '\x2', 
		'\xE93', '\xE94', '\a', '\x160', '\x2', '\x2', '\xE94', '\xE95', '\t', 
		'\x34', '\x2', '\x2', '\xE95', '\xE97', '\a', '\x2F3', '\x2', '\x2', '\xE96', 
		'\xE91', '\x3', '\x2', '\x2', '\x2', '\xE96', '\xE97', '\x3', '\x2', '\x2', 
		'\x2', '\xE97', '\xE99', '\x3', '\x2', '\x2', '\x2', '\xE98', '\xE9A', 
		'\x5', '\x140', '\xA1', '\x2', '\xE99', '\xE98', '\x3', '\x2', '\x2', 
		'\x2', '\xE99', '\xE9A', '\x3', '\x2', '\x2', '\x2', '\xE9A', '\xE9C', 
		'\x3', '\x2', '\x2', '\x2', '\xE9B', '\xE9D', '\t', '\x35', '\x2', '\x2', 
		'\xE9C', '\xE9B', '\x3', '\x2', '\x2', '\x2', '\xE9C', '\xE9D', '\x3', 
		'\x2', '\x2', '\x2', '\xE9D', '\xEA1', '\x3', '\x2', '\x2', '\x2', '\xE9E', 
		'\xEA0', '\x5', '\x18C', '\xC7', '\x2', '\xE9F', '\xE9E', '\x3', '\x2', 
		'\x2', '\x2', '\xEA0', '\xEA3', '\x3', '\x2', '\x2', '\x2', '\xEA1', '\xE9F', 
		'\x3', '\x2', '\x2', '\x2', '\xEA1', '\xEA2', '\x3', '\x2', '\x2', '\x2', 
		'\xEA2', '\xEA5', '\x3', '\x2', '\x2', '\x2', '\xEA3', '\xEA1', '\x3', 
		'\x2', '\x2', '\x2', '\xEA4', '\xEA6', '\x5', '\x17C', '\xBF', '\x2', 
		'\xEA5', '\xEA4', '\x3', '\x2', '\x2', '\x2', '\xEA5', '\xEA6', '\x3', 
		'\x2', '\x2', '\x2', '\xEA6', '\xEA8', '\x3', '\x2', '\x2', '\x2', '\xEA7', 
		'\xEA9', '\x5', '\x17A', '\xBE', '\x2', '\xEA8', '\xEA7', '\x3', '\x2', 
		'\x2', '\x2', '\xEA8', '\xEA9', '\x3', '\x2', '\x2', '\x2', '\xEA9', '\xEAC', 
		'\x3', '\x2', '\x2', '\x2', '\xEAA', '\xEAB', '\a', '\x209', '\x2', '\x2', 
		'\xEAB', '\xEAD', '\a', '\x16', '\x2', '\x2', '\xEAC', '\xEAA', '\x3', 
		'\x2', '\x2', '\x2', '\xEAC', '\xEAD', '\x3', '\x2', '\x2', '\x2', '\xEAD', 
		'\xEB0', '\x3', '\x2', '\x2', '\x2', '\xEAE', '\xEAF', '\a', '\x19', '\x2', 
		'\x2', '\xEAF', '\xEB1', '\x5', '\x16E', '\xB8', '\x2', '\xEB0', '\xEAE', 
		'\x3', '\x2', '\x2', '\x2', '\xEB0', '\xEB1', '\x3', '\x2', '\x2', '\x2', 
		'\xEB1', '\x179', '\x3', '\x2', '\x2', '\x2', '\xEB2', '\xEB3', '\a', 
		'\xD4', '\x2', '\x2', '\xEB3', '\xEB5', '\a', '\x17', '\x2', '\x2', '\xEB4', 
		'\xEB6', '\x5', '\x41A', '\x20E', '\x2', '\xEB5', '\xEB4', '\x3', '\x2', 
		'\x2', '\x2', '\xEB5', '\xEB6', '\x3', '\x2', '\x2', '\x2', '\xEB6', '\xEBB', 
		'\x3', '\x2', '\x2', '\x2', '\xEB7', '\xEB8', '\a', '\x181', '\x2', '\x2', 
		'\xEB8', '\xEB9', '\a', '\xD4', '\x2', '\x2', '\xEB9', '\xEBB', '\a', 
		'\x17', '\x2', '\x2', '\xEBA', '\xEB2', '\x3', '\x2', '\x2', '\x2', '\xEBA', 
		'\xEB7', '\x3', '\x2', '\x2', '\x2', '\xEBB', '\x17B', '\x3', '\x2', '\x2', 
		'\x2', '\xEBC', '\xEBD', '\t', '\a', '\x2', '\x2', '\xEBD', '\xEBE', '\a', 
		'\x209', '\x2', '\x2', '\xEBE', '\xEBF', '\a', '\x165', '\x2', '\x2', 
		'\xEBF', '\x17D', '\x3', '\x2', '\x2', '\x2', '\xEC0', '\xEC2', '\a', 
		'U', '\x2', '\x2', '\xEC1', '\xEC3', '\x5', '\x180', '\xC1', '\x2', '\xEC2', 
		'\xEC1', '\x3', '\x2', '\x2', '\x2', '\xEC2', '\xEC3', '\x3', '\x2', '\x2', 
		'\x2', '\xEC3', '\xEC4', '\x3', '\x2', '\x2', '\x2', '\xEC4', '\xEC6', 
		'\x5', '\x182', '\xC2', '\x2', '\xEC5', '\xEC7', '\x5', '\x188', '\xC5', 
		'\x2', '\xEC6', '\xEC5', '\x3', '\x2', '\x2', '\x2', '\xEC6', '\xEC7', 
		'\x3', '\x2', '\x2', '\x2', '\xEC7', '\xEC8', '\x3', '\x2', '\x2', '\x2', 
		'\xEC8', '\xEC9', '\x5', '\x18A', '\xC6', '\x2', '\xEC9', '\x17F', '\x3', 
		'\x2', '\x2', '\x2', '\xECA', '\xECB', '\x5', '\x444', '\x223', '\x2', 
		'\xECB', '\xECC', '\a', '\x120', '\x2', '\x2', '\xECC', '\xECD', '\x5', 
		'\x444', '\x223', '\x2', '\xECD', '\x181', '\x3', '\x2', '\x2', '\x2', 
		'\xECE', '\xED0', '\a', '?', '\x2', '\x2', '\xECF', '\xED1', '\t', '\x36', 
		'\x2', '\x2', '\xED0', '\xECF', '\x3', '\x2', '\x2', '\x2', '\xED0', '\xED1', 
		'\x3', '\x2', '\x2', '\x2', '\xED1', '\xED2', '\x3', '\x2', '\x2', '\x2', 
		'\xED2', '\xED3', '\a', '\x1A1', '\x2', '\x2', '\xED3', '\xED4', '\x5', 
		'\x184', '\xC3', '\x2', '\xED4', '\x183', '\x3', '\x2', '\x2', '\x2', 
		'\xED5', '\xEE1', '\x5', '\x186', '\xC4', '\x2', '\xED6', '\xED7', '\a', 
		'\x2F2', '\x2', '\x2', '\xED7', '\xEDA', '\x5', '\x184', '\xC3', '\x2', 
		'\xED8', '\xED9', '\a', '\x2F8', '\x2', '\x2', '\xED9', '\xEDB', '\x5', 
		'\x184', '\xC3', '\x2', '\xEDA', '\xED8', '\x3', '\x2', '\x2', '\x2', 
		'\xEDB', '\xEDC', '\x3', '\x2', '\x2', '\x2', '\xEDC', '\xEDA', '\x3', 
		'\x2', '\x2', '\x2', '\xEDC', '\xEDD', '\x3', '\x2', '\x2', '\x2', '\xEDD', 
		'\xEDE', '\x3', '\x2', '\x2', '\x2', '\xEDE', '\xEDF', '\a', '\x2F3', 
		'\x2', '\x2', '\xEDF', '\xEE1', '\x3', '\x2', '\x2', '\x2', '\xEE0', '\xED5', 
		'\x3', '\x2', '\x2', '\x2', '\xEE0', '\xED6', '\x3', '\x2', '\x2', '\x2', 
		'\xEE1', '\x185', '\x3', '\x2', '\x2', '\x2', '\xEE2', '\xEE3', '\x5', 
		'\x44A', '\x226', '\x2', '\xEE3', '\x187', '\x3', '\x2', '\x2', '\x2', 
		'\xEE4', '\xEE5', '\t', '\x37', '\x2', '\x2', '\xEE5', '\xEE6', '\a', 
		'\x19B', '\x2', '\x2', '\xEE6', '\xEEC', '\a', '\x135', '\x2', '\x2', 
		'\xEE7', '\xEE8', '\t', '\x37', '\x2', '\x2', '\xEE8', '\xEE9', '\a', 
		'\x19B', '\x2', '\x2', '\xEE9', '\xEEA', '\a', '~', '\x2', '\x2', '\xEEA', 
		'\xEEC', '\a', '\x165', '\x2', '\x2', '\xEEB', '\xEE4', '\x3', '\x2', 
		'\x2', '\x2', '\xEEB', '\xEE7', '\x3', '\x2', '\x2', '\x2', '\xEEC', '\x189', 
		'\x3', '\x2', '\x2', '\x2', '\xEED', '\xEEE', '\a', '\x2A6', '\x2', '\x2', 
		'\xEEE', '\xEEF', '\a', '\x14D', '\x2', '\x2', '\xEEF', '\xEF0', '\a', 
		'\x2BE', '\x2', '\x2', '\xEF0', '\xEF1', '\a', '\x2F2', '\x2', '\x2', 
		'\xEF1', '\xEF2', '\x5', '\x41C', '\x20F', '\x2', '\xEF2', '\xEF3', '\a', 
		'\x2F3', '\x2', '\x2', '\xEF3', '\xEF8', '\x3', '\x2', '\x2', '\x2', '\xEF4', 
		'\xEF5', '\a', '\x2A5', '\x2', '\x2', '\xEF5', '\xEF6', '\a', '\x14D', 
		'\x2', '\x2', '\xEF6', '\xEF8', '\a', '\x2BE', '\x2', '\x2', '\xEF7', 
		'\xEED', '\x3', '\x2', '\x2', '\x2', '\xEF7', '\xEF4', '\x3', '\x2', '\x2', 
		'\x2', '\xEF8', '\x18B', '\x3', '\x2', '\x2', '\x2', '\xEF9', '\xEFB', 
		'\t', '\a', '\x2', '\x2', '\xEFA', '\xEFC', '\t', '!', '\x2', '\x2', '\xEFB', 
		'\xEFA', '\x3', '\x2', '\x2', '\x2', '\xEFB', '\xEFC', '\x3', '\x2', '\x2', 
		'\x2', '\xEFC', '\xF03', '\x3', '\x2', '\x2', '\x2', '\xEFD', '\xEFE', 
		'\a', '\x280', '\x2', '\x2', '\xEFE', '\xF04', '\x5', '\x44A', '\x226', 
		'\x2', '\xEFF', '\xF00', '\a', '\x1D0', '\x2', '\x2', '\xF00', '\xF04', 
		'\a', '\x123', '\x2', '\x2', '\xF01', '\xF02', '\a', '\x65', '\x2', '\x2', 
		'\xF02', '\xF04', '\x5', '\x40C', '\x207', '\x2', '\xF03', '\xEFD', '\x3', 
		'\x2', '\x2', '\x2', '\xF03', '\xEFF', '\x3', '\x2', '\x2', '\x2', '\xF03', 
		'\xF01', '\x3', '\x2', '\x2', '\x2', '\xF04', '\xF06', '\x3', '\x2', '\x2', 
		'\x2', '\xF05', '\xF07', '\x5', '\xF2', 'z', '\x2', '\xF06', '\xF05', 
		'\x3', '\x2', '\x2', '\x2', '\xF06', '\xF07', '\x3', '\x2', '\x2', '\x2', 
		'\xF07', '\xF08', '\x3', '\x2', '\x2', '\x2', '\xF08', '\xF0A', '\x5', 
		'\x14A', '\xA6', '\x2', '\xF09', '\xF0B', '\a', '\x45', '\x2', '\x2', 
		'\xF0A', '\xF09', '\x3', '\x2', '\x2', '\x2', '\xF0A', '\xF0B', '\x3', 
		'\x2', '\x2', '\x2', '\xF0B', '\xF0F', '\x3', '\x2', '\x2', '\x2', '\xF0C', 
		'\xF0D', '\a', '\x122', '\x2', '\x2', '\xF0D', '\xF10', '\a', '\x101', 
		'\x2', '\x2', '\xF0E', '\xF10', '\a', '\xA5', '\x2', '\x2', '\xF0F', '\xF0C', 
		'\x3', '\x2', '\x2', '\x2', '\xF0F', '\xF0E', '\x3', '\x2', '\x2', '\x2', 
		'\xF0F', '\xF10', '\x3', '\x2', '\x2', '\x2', '\xF10', '\x18D', '\x3', 
		'\x2', '\x2', '\x2', '\xF11', '\xF19', '\x5', '\x190', '\xC9', '\x2', 
		'\xF12', '\xF19', '\x5', '\x19C', '\xCF', '\x2', '\xF13', '\xF19', '\x5', 
		'\x192', '\xCA', '\x2', '\xF14', '\xF19', '\x5', '\x19E', '\xD0', '\x2', 
		'\xF15', '\xF19', '\x5', '\x1A2', '\xD2', '\x2', '\xF16', '\xF19', '\x5', 
		'\x1A0', '\xD1', '\x2', '\xF17', '\xF19', '\x5', '\x1BE', '\xE0', '\x2', 
		'\xF18', '\xF11', '\x3', '\x2', '\x2', '\x2', '\xF18', '\xF12', '\x3', 
		'\x2', '\x2', '\x2', '\xF18', '\xF13', '\x3', '\x2', '\x2', '\x2', '\xF18', 
		'\xF14', '\x3', '\x2', '\x2', '\x2', '\xF18', '\xF15', '\x3', '\x2', '\x2', 
		'\x2', '\xF18', '\xF16', '\x3', '\x2', '\x2', '\x2', '\xF18', '\xF17', 
		'\x3', '\x2', '\x2', '\x2', '\xF19', '\x18F', '\x3', '\x2', '\x2', '\x2', 
		'\xF1A', '\xF1B', '\a', '\x1B2', '\x2', '\x2', '\xF1B', '\xF1C', '\a', 
		'?', '\x2', '\x2', '\xF1C', '\xF1D', '\a', '\x1DE', '\x2', '\x2', '\xF1D', 
		'\xF2F', '\x5', '\x44A', '\x226', '\x2', '\xF1E', '\xF1F', '\a', '\x115', 
		'\x2', '\x2', '\xF1F', '\xF20', '\a', '\x2F2', '\x2', '\x2', '\xF20', 
		'\xF21', '\x5', '\x37E', '\x1C0', '\x2', '\xF21', '\xF22', '\a', '\x2F3', 
		'\x2', '\x2', '\xF22', '\xF23', '\a', '\x242', '\x2', '\x2', '\xF23', 
		'\xF24', '\a', '\x108', '\x2', '\x2', '\xF24', '\xF25', '\a', '\x2F2', 
		'\x2', '\x2', '\xF25', '\xF2A', '\x5', '\x426', '\x214', '\x2', '\xF26', 
		'\xF27', '\a', '\x2F8', '\x2', '\x2', '\xF27', '\xF29', '\x5', '\x426', 
		'\x214', '\x2', '\xF28', '\xF26', '\x3', '\x2', '\x2', '\x2', '\xF29', 
		'\xF2C', '\x3', '\x2', '\x2', '\x2', '\xF2A', '\xF28', '\x3', '\x2', '\x2', 
		'\x2', '\xF2A', '\xF2B', '\x3', '\x2', '\x2', '\x2', '\xF2B', '\xF2D', 
		'\x3', '\x2', '\x2', '\x2', '\xF2C', '\xF2A', '\x3', '\x2', '\x2', '\x2', 
		'\xF2D', '\xF2E', '\a', '\x2F3', '\x2', '\x2', '\xF2E', '\xF30', '\x3', 
		'\x2', '\x2', '\x2', '\xF2F', '\xF1E', '\x3', '\x2', '\x2', '\x2', '\xF2F', 
		'\xF30', '\x3', '\x2', '\x2', '\x2', '\xF30', '\xF31', '\x3', '\x2', '\x2', 
		'\x2', '\xF31', '\xF32', '\a', '\x2F2', '\x2', '\x2', '\xF32', '\xF34', 
		'\a', '\x1B2', '\x2', '\x2', '\xF33', '\xF35', '\x5', '\x42A', '\x216', 
		'\x2', '\xF34', '\xF33', '\x3', '\x2', '\x2', '\x2', '\xF34', '\xF35', 
		'\x3', '\x2', '\x2', '\x2', '\xF35', '\xF36', '\x3', '\x2', '\x2', '\x2', 
		'\xF36', '\xF37', '\x5', '\x1B2', '\xDA', '\x2', '\xF37', '\xF38', '\x5', 
		'\x1B0', '\xD9', '\x2', '\xF38', '\xF39', '\a', '\x2F3', '\x2', '\x2', 
		'\xF39', '\x191', '\x3', '\x2', '\x2', '\x2', '\xF3A', '\xF3B', '\a', 
		'\x1B2', '\x2', '\x2', '\xF3B', '\xF3C', '\a', '?', '\x2', '\x2', '\xF3C', 
		'\xF3D', '\a', '\xED', '\x2', '\x2', '\xF3D', '\xF40', '\x5', '\x44A', 
		'\x226', '\x2', '\xF3E', '\xF41', '\x5', '\xF8', '}', '\x2', '\xF3F', 
		'\xF41', '\x5', '\x13A', '\x9E', '\x2', '\xF40', '\xF3E', '\x3', '\x2', 
		'\x2', '\x2', '\xF40', '\xF3F', '\x3', '\x2', '\x2', '\x2', '\xF41', '\x193', 
		'\x3', '\x2', '\x2', '\x2', '\xF42', '\xF53', '\x5', '\x1C2', '\xE2', 
		'\x2', '\xF43', '\xF53', '\x5', '\x1C6', '\xE4', '\x2', '\xF44', '\xF47', 
		'\x5', '\x1CA', '\xE6', '\x2', '\xF45', '\xF47', '\x5', '\x1CE', '\xE8', 
		'\x2', '\xF46', '\xF44', '\x3', '\x2', '\x2', '\x2', '\xF46', '\xF45', 
		'\x3', '\x2', '\x2', '\x2', '\xF47', '\xF4E', '\x3', '\x2', '\x2', '\x2', 
		'\xF48', '\xF49', '\a', '\x2F2', '\x2', '\x2', '\xF49', '\xF4A', '\x5', 
		'\x134', '\x9B', '\x2', '\xF4A', '\xF4B', '\a', '\x2F3', '\x2', '\x2', 
		'\xF4B', '\xF4D', '\x3', '\x2', '\x2', '\x2', '\xF4C', '\xF48', '\x3', 
		'\x2', '\x2', '\x2', '\xF4D', '\xF50', '\x3', '\x2', '\x2', '\x2', '\xF4E', 
		'\xF4C', '\x3', '\x2', '\x2', '\x2', '\xF4E', '\xF4F', '\x3', '\x2', '\x2', 
		'\x2', '\xF4F', '\xF53', '\x3', '\x2', '\x2', '\x2', '\xF50', '\xF4E', 
		'\x3', '\x2', '\x2', '\x2', '\xF51', '\xF53', '\x5', '\x196', '\xCC', 
		'\x2', '\xF52', '\xF42', '\x3', '\x2', '\x2', '\x2', '\xF52', '\xF43', 
		'\x3', '\x2', '\x2', '\x2', '\xF52', '\xF46', '\x3', '\x2', '\x2', '\x2', 
		'\xF52', '\xF51', '\x3', '\x2', '\x2', '\x2', '\xF53', '\x195', '\x3', 
		'\x2', '\x2', '\x2', '\xF54', '\xF56', '\a', '\x2B8', '\x2', '\x2', '\xF55', 
		'\xF57', '\a', 'X', '\x2', '\x2', '\xF56', '\xF55', '\x3', '\x2', '\x2', 
		'\x2', '\xF56', '\xF57', '\x3', '\x2', '\x2', '\x2', '\xF57', '\xF58', 
		'\x3', '\x2', '\x2', '\x2', '\xF58', '\xF5A', '\x5', '\x490', '\x249', 
		'\x2', '\xF59', '\xF5B', '\x5', '\x198', '\xCD', '\x2', '\xF5A', '\xF59', 
		'\x3', '\x2', '\x2', '\x2', '\xF5A', '\xF5B', '\x3', '\x2', '\x2', '\x2', 
		'\xF5B', '\xF5C', '\x3', '\x2', '\x2', '\x2', '\xF5C', '\xF5D', '\x5', 
		'\x19A', '\xCE', '\x2', '\xF5D', '\x197', '\x3', '\x2', '\x2', '\x2', 
		'\xF5E', '\xF77', '\a', '\x243', '\x2', '\x2', '\xF5F', '\xF71', '\a', 
		'\x19', '\x2', '\x2', '\xF60', '\xF61', '\a', '\x192', '\x2', '\x2', '\xF61', 
		'\xF72', '\a', '\x1EC', '\x2', '\x2', '\xF62', '\xF64', '\t', '$', '\x2', 
		'\x2', '\xF63', '\xF62', '\x3', '\x2', '\x2', '\x2', '\xF63', '\xF64', 
		'\x3', '\x2', '\x2', '\x2', '\xF64', '\xF68', '\x3', '\x2', '\x2', '\x2', 
		'\xF65', '\xF69', '\a', 'R', '\x2', '\x2', '\xF66', '\xF67', '\a', '\x31', 
		'\x2', '\x2', '\xF67', '\xF69', '\a', '\x2B9', '\x2', '\x2', '\xF68', 
		'\xF65', '\x3', '\x2', '\x2', '\x2', '\xF68', '\xF66', '\x3', '\x2', '\x2', 
		'\x2', '\xF68', '\xF69', '\x3', '\x2', '\x2', '\x2', '\xF69', '\xF6F', 
		'\x3', '\x2', '\x2', '\x2', '\xF6A', '\xF6C', '\x5', '\x42E', '\x218', 
		'\x2', '\xF6B', '\xF6D', '\x5', '\x1D2', '\xEA', '\x2', '\xF6C', '\xF6B', 
		'\x3', '\x2', '\x2', '\x2', '\xF6C', '\xF6D', '\x3', '\x2', '\x2', '\x2', 
		'\xF6D', '\xF70', '\x3', '\x2', '\x2', '\x2', '\xF6E', '\xF70', '\x5', 
		'\x1D2', '\xEA', '\x2', '\xF6F', '\xF6A', '\x3', '\x2', '\x2', '\x2', 
		'\xF6F', '\xF6E', '\x3', '\x2', '\x2', '\x2', '\xF6F', '\xF70', '\x3', 
		'\x2', '\x2', '\x2', '\xF70', '\xF72', '\x3', '\x2', '\x2', '\x2', '\xF71', 
		'\xF60', '\x3', '\x2', '\x2', '\x2', '\xF71', '\xF63', '\x3', '\x2', '\x2', 
		'\x2', '\xF72', '\xF78', '\x3', '\x2', '\x2', '\x2', '\xF73', '\xF74', 
		'\a', '\xE', '\x2', '\x2', '\xF74', '\xF75', '\a', '\x295', '\x2', '\x2', 
		'\xF75', '\xF76', '\a', '\x19', '\x2', '\x2', '\xF76', '\xF78', '\t', 
		'\x38', '\x2', '\x2', '\xF77', '\xF5F', '\x3', '\x2', '\x2', '\x2', '\xF77', 
		'\xF73', '\x3', '\x2', '\x2', '\x2', '\xF78', '\x199', '\x3', '\x2', '\x2', 
		'\x2', '\xF79', '\xF7A', '\a', '\x2B5', '\x2', '\x2', '\xF7A', '\xF7C', 
		'\a', '\x2EE', '\x2', '\x2', '\xF7B', '\xF79', '\x3', '\x2', '\x2', '\x2', 
		'\xF7B', '\xF7C', '\x3', '\x2', '\x2', '\x2', '\xF7C', '\xF7D', '\x3', 
		'\x2', '\x2', '\x2', '\xF7D', '\xF82', '\a', '\xAD', '\x2', '\x2', '\xF7E', 
		'\xF83', '\x5', '\x418', '\x20D', '\x2', '\xF7F', '\xF80', '\a', '\x2EE', 
		'\x2', '\x2', '\xF80', '\xF81', '\a', '\x227', '\x2', '\x2', '\xF81', 
		'\xF83', '\x5', '\x418', '\x20D', '\x2', '\xF82', '\xF7E', '\x3', '\x2', 
		'\x2', '\x2', '\xF82', '\xF7F', '\x3', '\x2', '\x2', '\x2', '\xF83', '\xF89', 
		'\x3', '\x2', '\x2', '\x2', '\xF84', '\xF85', '\a', '\x243', '\x2', '\x2', 
		'\xF85', '\xF86', '\a', '\xE', '\x2', '\x2', '\xF86', '\xF87', '\a', '\x295', 
		'\x2', '\x2', '\xF87', '\xF88', '\a', '\x19', '\x2', '\x2', '\xF88', '\xF8A', 
		'\t', '\x38', '\x2', '\x2', '\xF89', '\xF84', '\x3', '\x2', '\x2', '\x2', 
		'\xF89', '\xF8A', '\x3', '\x2', '\x2', '\x2', '\xF8A', '\xF8D', '\x3', 
		'\x2', '\x2', '\x2', '\xF8B', '\xF8C', '\t', '\x39', '\x2', '\x2', '\xF8C', 
		'\xF8E', '\a', '\x182', '\x2', '\x2', '\xF8D', '\xF8B', '\x3', '\x2', 
		'\x2', '\x2', '\xF8D', '\xF8E', '\x3', '\x2', '\x2', '\x2', '\xF8E', '\xF91', 
		'\x3', '\x2', '\x2', '\x2', '\xF8F', '\xF90', '\t', '\x39', '\x2', '\x2', 
		'\xF90', '\xF92', '\a', '\x15', '\x2', '\x2', '\xF91', '\xF8F', '\x3', 
		'\x2', '\x2', '\x2', '\xF91', '\xF92', '\x3', '\x2', '\x2', '\x2', '\xF92', 
		'\x19B', '\x3', '\x2', '\x2', '\x2', '\xF93', '\xF94', '\a', '\x1B2', 
		'\x2', '\x2', '\xF94', '\xF95', '\a', '?', '\x2', '\x2', '\xF95', '\xF96', 
		'\a', '\x134', '\x2', '\x2', '\xF96', '\xF97', '\x5', '\x44A', '\x226', 
		'\x2', '\xF97', '\xF9F', '\a', '\x2F2', '\x2', '\x2', '\xF98', '\xF9A', 
		'\a', '\x1B2', '\x2', '\x2', '\xF99', '\xF9B', '\x5', '\x42A', '\x216', 
		'\x2', '\xF9A', '\xF99', '\x3', '\x2', '\x2', '\x2', '\xF9A', '\xF9B', 
		'\x3', '\x2', '\x2', '\x2', '\xF9B', '\xF9C', '\x3', '\x2', '\x2', '\x2', 
		'\xF9C', '\xF9D', '\x5', '\x1B4', '\xDB', '\x2', '\xF9D', '\xF9E', '\x5', 
		'\x1B0', '\xD9', '\x2', '\xF9E', '\xFA0', '\x3', '\x2', '\x2', '\x2', 
		'\xF9F', '\xF98', '\x3', '\x2', '\x2', '\x2', '\xFA0', '\xFA1', '\x3', 
		'\x2', '\x2', '\x2', '\xFA1', '\xF9F', '\x3', '\x2', '\x2', '\x2', '\xFA1', 
		'\xFA2', '\x3', '\x2', '\x2', '\x2', '\xFA2', '\xFA3', '\x3', '\x2', '\x2', 
		'\x2', '\xFA3', '\xFA4', '\a', '\x2F3', '\x2', '\x2', '\xFA4', '\x19D', 
		'\x3', '\x2', '\x2', '\x2', '\xFA5', '\xFA6', '\a', '\x1B2', '\x2', '\x2', 
		'\xFA6', '\xFA7', '\a', '?', '\x2', '\x2', '\xFA7', '\xFA8', '\a', '\x1DE', 
		'\x2', '\x2', '\xFA8', '\xFA9', '\x5', '\x44A', '\x226', '\x2', '\xFA9', 
		'\xFAA', '\a', '\x115', '\x2', '\x2', '\xFAA', '\xFAB', '\a', '\x2F2', 
		'\x2', '\x2', '\xFAB', '\xFAC', '\x5', '\x37E', '\x1C0', '\x2', '\xFAC', 
		'\xFAD', '\a', '\x2F3', '\x2', '\x2', '\xFAD', '\xFAE', '\a', '\x243', 
		'\x2', '\x2', '\xFAE', '\xFAF', '\a', '\x108', '\x2', '\x2', '\xFAF', 
		'\xFB0', '\a', '\x2F2', '\x2', '\x2', '\xFB0', '\xFB5', '\x5', '\x426', 
		'\x214', '\x2', '\xFB1', '\xFB2', '\a', '\x2F8', '\x2', '\x2', '\xFB2', 
		'\xFB4', '\x5', '\x426', '\x214', '\x2', '\xFB3', '\xFB1', '\x3', '\x2', 
		'\x2', '\x2', '\xFB4', '\xFB7', '\x3', '\x2', '\x2', '\x2', '\xFB5', '\xFB3', 
		'\x3', '\x2', '\x2', '\x2', '\xFB5', '\xFB6', '\x3', '\x2', '\x2', '\x2', 
		'\xFB6', '\xFB8', '\x3', '\x2', '\x2', '\x2', '\xFB7', '\xFB5', '\x3', 
		'\x2', '\x2', '\x2', '\xFB8', '\xFB9', '\a', '\x2F3', '\x2', '\x2', '\xFB9', 
		'\xFBD', '\x3', '\x2', '\x2', '\x2', '\xFBA', '\xFBE', '\x5', '\x1B6', 
		'\xDC', '\x2', '\xFBB', '\xFBE', '\x5', '\x1B8', '\xDD', '\x2', '\xFBC', 
		'\xFBE', '\x5', '\x1BA', '\xDE', '\x2', '\xFBD', '\xFBA', '\x3', '\x2', 
		'\x2', '\x2', '\xFBD', '\xFBB', '\x3', '\x2', '\x2', '\x2', '\xFBD', '\xFBC', 
		'\x3', '\x2', '\x2', '\x2', '\xFBE', '\xFBF', '\x3', '\x2', '\x2', '\x2', 
		'\xFBF', '\xFC0', '\a', '\x2F2', '\x2', '\x2', '\xFC0', '\xFC1', '\x5', 
		'\x1A4', '\xD3', '\x2', '\xFC1', '\xFC2', '\a', '\x2F3', '\x2', '\x2', 
		'\xFC2', '\x19F', '\x3', '\x2', '\x2', '\x2', '\xFC3', '\xFC4', '\a', 
		'\x1B2', '\x2', '\x2', '\xFC4', '\xFC5', '\a', '?', '\x2', '\x2', '\xFC5', 
		'\xFC6', '\a', '\xED', '\x2', '\x2', '\xFC6', '\xFCA', '\x5', '\x44A', 
		'\x226', '\x2', '\xFC7', '\xFCB', '\x5', '\x1B6', '\xDC', '\x2', '\xFC8', 
		'\xFCB', '\x5', '\x1B8', '\xDD', '\x2', '\xFC9', '\xFCB', '\x5', '\x1BA', 
		'\xDE', '\x2', '\xFCA', '\xFC7', '\x3', '\x2', '\x2', '\x2', '\xFCA', 
		'\xFC8', '\x3', '\x2', '\x2', '\x2', '\xFCA', '\xFC9', '\x3', '\x2', '\x2', 
		'\x2', '\xFCB', '\xFCE', '\x3', '\x2', '\x2', '\x2', '\xFCC', '\xFCF', 
		'\x5', '\xF8', '}', '\x2', '\xFCD', '\xFCF', '\x5', '\x104', '\x83', '\x2', 
		'\xFCE', '\xFCC', '\x3', '\x2', '\x2', '\x2', '\xFCE', '\xFCD', '\x3', 
		'\x2', '\x2', '\x2', '\xFCF', '\x1A1', '\x3', '\x2', '\x2', '\x2', '\xFD0', 
		'\xFD1', '\a', '\x1B2', '\x2', '\x2', '\xFD1', '\xFD2', '\a', '?', '\x2', 
		'\x2', '\xFD2', '\xFD3', '\a', '\x134', '\x2', '\x2', '\xFD3', '\xFD7', 
		'\x5', '\x44A', '\x226', '\x2', '\xFD4', '\xFD8', '\x5', '\x1B6', '\xDC', 
		'\x2', '\xFD5', '\xFD8', '\x5', '\x1B8', '\xDD', '\x2', '\xFD6', '\xFD8', 
		'\x5', '\x1BA', '\xDE', '\x2', '\xFD7', '\xFD4', '\x3', '\x2', '\x2', 
		'\x2', '\xFD7', '\xFD5', '\x3', '\x2', '\x2', '\x2', '\xFD7', '\xFD6', 
		'\x3', '\x2', '\x2', '\x2', '\xFD8', '\xFD9', '\x3', '\x2', '\x2', '\x2', 
		'\xFD9', '\xFDE', '\x5', '\x1A6', '\xD4', '\x2', '\xFDA', '\xFDB', '\a', 
		'\x2F8', '\x2', '\x2', '\xFDB', '\xFDD', '\x5', '\x1A6', '\xD4', '\x2', 
		'\xFDC', '\xFDA', '\x3', '\x2', '\x2', '\x2', '\xFDD', '\xFE0', '\x3', 
		'\x2', '\x2', '\x2', '\xFDE', '\xFDC', '\x3', '\x2', '\x2', '\x2', '\xFDE', 
		'\xFDF', '\x3', '\x2', '\x2', '\x2', '\xFDF', '\x1A3', '\x3', '\x2', '\x2', 
		'\x2', '\xFE0', '\xFDE', '\x3', '\x2', '\x2', '\x2', '\xFE1', '\xFE2', 
		'\a', '\x1B2', '\x2', '\x2', '\xFE2', '\xFE3', '\x5', '\x42A', '\x216', 
		'\x2', '\xFE3', '\xFE4', '\x5', '\x1B2', '\xDA', '\x2', '\xFE4', '\x1001', 
		'\x5', '\x1B0', '\xD9', '\x2', '\xFE5', '\xFE6', '\a', '\x2F2', '\x2', 
		'\x2', '\xFE6', '\xFEB', '\x5', '\x1A8', '\xD5', '\x2', '\xFE7', '\xFE8', 
		'\a', '\x2F8', '\x2', '\x2', '\xFE8', '\xFEA', '\x5', '\x1A8', '\xD5', 
		'\x2', '\xFE9', '\xFE7', '\x3', '\x2', '\x2', '\x2', '\xFEA', '\xFED', 
		'\x3', '\x2', '\x2', '\x2', '\xFEB', '\xFE9', '\x3', '\x2', '\x2', '\x2', 
		'\xFEB', '\xFEC', '\x3', '\x2', '\x2', '\x2', '\xFEC', '\x1002', '\x3', 
		'\x2', '\x2', '\x2', '\xFED', '\xFEB', '\x3', '\x2', '\x2', '\x2', '\xFEE', 
		'\xFF3', '\x5', '\x1AA', '\xD6', '\x2', '\xFEF', '\xFF0', '\a', '\x2F8', 
		'\x2', '\x2', '\xFF0', '\xFF2', '\x5', '\x1AA', '\xD6', '\x2', '\xFF1', 
		'\xFEF', '\x3', '\x2', '\x2', '\x2', '\xFF2', '\xFF5', '\x3', '\x2', '\x2', 
		'\x2', '\xFF3', '\xFF1', '\x3', '\x2', '\x2', '\x2', '\xFF3', '\xFF4', 
		'\x3', '\x2', '\x2', '\x2', '\xFF4', '\x1002', '\x3', '\x2', '\x2', '\x2', 
		'\xFF5', '\xFF3', '\x3', '\x2', '\x2', '\x2', '\xFF6', '\xFFB', '\x5', 
		'\x1AC', '\xD7', '\x2', '\xFF7', '\xFF8', '\a', '\x2F8', '\x2', '\x2', 
		'\xFF8', '\xFFA', '\x5', '\x1AC', '\xD7', '\x2', '\xFF9', '\xFF7', '\x3', 
		'\x2', '\x2', '\x2', '\xFFA', '\xFFD', '\x3', '\x2', '\x2', '\x2', '\xFFB', 
		'\xFF9', '\x3', '\x2', '\x2', '\x2', '\xFFB', '\xFFC', '\x3', '\x2', '\x2', 
		'\x2', '\xFFC', '\xFFE', '\x3', '\x2', '\x2', '\x2', '\xFFD', '\xFFB', 
		'\x3', '\x2', '\x2', '\x2', '\xFFE', '\xFFF', '\a', '\x2F3', '\x2', '\x2', 
		'\xFFF', '\x1002', '\x3', '\x2', '\x2', '\x2', '\x1000', '\x1002', '\x5', 
		'\x1AE', '\xD8', '\x2', '\x1001', '\xFE5', '\x3', '\x2', '\x2', '\x2', 
		'\x1001', '\xFEE', '\x3', '\x2', '\x2', '\x2', '\x1001', '\xFF6', '\x3', 
		'\x2', '\x2', '\x2', '\x1001', '\x1000', '\x3', '\x2', '\x2', '\x2', '\x1001', 
		'\x1002', '\x3', '\x2', '\x2', '\x2', '\x1002', '\x1A5', '\x3', '\x2', 
		'\x2', '\x2', '\x1003', '\x1004', '\a', '\x1B2', '\x2', '\x2', '\x1004', 
		'\x1005', '\x5', '\x42A', '\x216', '\x2', '\x1005', '\x1006', '\x5', '\x1B4', 
		'\xDB', '\x2', '\x1006', '\x1023', '\x5', '\x1B0', '\xD9', '\x2', '\x1007', 
		'\x1008', '\a', '\x2F2', '\x2', '\x2', '\x1008', '\x100D', '\x5', '\x1A8', 
		'\xD5', '\x2', '\x1009', '\x100A', '\a', '\x2F8', '\x2', '\x2', '\x100A', 
		'\x100C', '\x5', '\x1A8', '\xD5', '\x2', '\x100B', '\x1009', '\x3', '\x2', 
		'\x2', '\x2', '\x100C', '\x100F', '\x3', '\x2', '\x2', '\x2', '\x100D', 
		'\x100B', '\x3', '\x2', '\x2', '\x2', '\x100D', '\x100E', '\x3', '\x2', 
		'\x2', '\x2', '\x100E', '\x1024', '\x3', '\x2', '\x2', '\x2', '\x100F', 
		'\x100D', '\x3', '\x2', '\x2', '\x2', '\x1010', '\x1015', '\x5', '\x1AA', 
		'\xD6', '\x2', '\x1011', '\x1012', '\a', '\x2F8', '\x2', '\x2', '\x1012', 
		'\x1014', '\x5', '\x1AA', '\xD6', '\x2', '\x1013', '\x1011', '\x3', '\x2', 
		'\x2', '\x2', '\x1014', '\x1017', '\x3', '\x2', '\x2', '\x2', '\x1015', 
		'\x1013', '\x3', '\x2', '\x2', '\x2', '\x1015', '\x1016', '\x3', '\x2', 
		'\x2', '\x2', '\x1016', '\x1024', '\x3', '\x2', '\x2', '\x2', '\x1017', 
		'\x1015', '\x3', '\x2', '\x2', '\x2', '\x1018', '\x101D', '\x5', '\x1AC', 
		'\xD7', '\x2', '\x1019', '\x101A', '\a', '\x2F8', '\x2', '\x2', '\x101A', 
		'\x101C', '\x5', '\x1AC', '\xD7', '\x2', '\x101B', '\x1019', '\x3', '\x2', 
		'\x2', '\x2', '\x101C', '\x101F', '\x3', '\x2', '\x2', '\x2', '\x101D', 
		'\x101B', '\x3', '\x2', '\x2', '\x2', '\x101D', '\x101E', '\x3', '\x2', 
		'\x2', '\x2', '\x101E', '\x1020', '\x3', '\x2', '\x2', '\x2', '\x101F', 
		'\x101D', '\x3', '\x2', '\x2', '\x2', '\x1020', '\x1021', '\a', '\x2F3', 
		'\x2', '\x2', '\x1021', '\x1024', '\x3', '\x2', '\x2', '\x2', '\x1022', 
		'\x1024', '\x5', '\x1AE', '\xD8', '\x2', '\x1023', '\x1007', '\x3', '\x2', 
		'\x2', '\x2', '\x1023', '\x1010', '\x3', '\x2', '\x2', '\x2', '\x1023', 
		'\x1018', '\x3', '\x2', '\x2', '\x2', '\x1023', '\x1022', '\x3', '\x2', 
		'\x2', '\x2', '\x1023', '\x1024', '\x3', '\x2', '\x2', '\x2', '\x1024', 
		'\x1A7', '\x3', '\x2', '\x2', '\x2', '\x1025', '\x1027', '\a', '\x247', 
		'\x2', '\x2', '\x1026', '\x1028', '\x5', '\x41E', '\x210', '\x2', '\x1027', 
		'\x1026', '\x3', '\x2', '\x2', '\x2', '\x1027', '\x1028', '\x3', '\x2', 
		'\x2', '\x2', '\x1028', '\x1029', '\x3', '\x2', '\x2', '\x2', '\x1029', 
		'\x102B', '\x5', '\x1B2', '\xDA', '\x2', '\x102A', '\x102C', '\x5', '\x118', 
		'\x8D', '\x2', '\x102B', '\x102A', '\x3', '\x2', '\x2', '\x2', '\x102B', 
		'\x102C', '\x3', '\x2', '\x2', '\x2', '\x102C', '\x102E', '\x3', '\x2', 
		'\x2', '\x2', '\x102D', '\x102F', '\x5', '\x11A', '\x8E', '\x2', '\x102E', 
		'\x102D', '\x3', '\x2', '\x2', '\x2', '\x102E', '\x102F', '\x3', '\x2', 
		'\x2', '\x2', '\x102F', '\x1A9', '\x3', '\x2', '\x2', '\x2', '\x1030', 
		'\x1032', '\a', '\x247', '\x2', '\x2', '\x1031', '\x1033', '\x5', '\x41E', 
		'\x210', '\x2', '\x1032', '\x1031', '\x3', '\x2', '\x2', '\x2', '\x1032', 
		'\x1033', '\x3', '\x2', '\x2', '\x2', '\x1033', '\x1034', '\x3', '\x2', 
		'\x2', '\x2', '\x1034', '\x1036', '\x5', '\x1B4', '\xDB', '\x2', '\x1035', 
		'\x1037', '\x5', '\x118', '\x8D', '\x2', '\x1036', '\x1035', '\x3', '\x2', 
		'\x2', '\x2', '\x1036', '\x1037', '\x3', '\x2', '\x2', '\x2', '\x1037', 
		'\x1039', '\x3', '\x2', '\x2', '\x2', '\x1038', '\x103A', '\x5', '\x11A', 
		'\x8E', '\x2', '\x1039', '\x1038', '\x3', '\x2', '\x2', '\x2', '\x1039', 
		'\x103A', '\x3', '\x2', '\x2', '\x2', '\x103A', '\x1AB', '\x3', '\x2', 
		'\x2', '\x2', '\x103B', '\x103D', '\a', '\x247', '\x2', '\x2', '\x103C', 
		'\x103E', '\x5', '\x41E', '\x210', '\x2', '\x103D', '\x103C', '\x3', '\x2', 
		'\x2', '\x2', '\x103D', '\x103E', '\x3', '\x2', '\x2', '\x2', '\x103E', 
		'\x1040', '\x3', '\x2', '\x2', '\x2', '\x103F', '\x1041', '\x5', '\x118', 
		'\x8D', '\x2', '\x1040', '\x103F', '\x3', '\x2', '\x2', '\x2', '\x1040', 
		'\x1041', '\x3', '\x2', '\x2', '\x2', '\x1041', '\x1043', '\x3', '\x2', 
		'\x2', '\x2', '\x1042', '\x1044', '\x5', '\x11A', '\x8E', '\x2', '\x1043', 
		'\x1042', '\x3', '\x2', '\x2', '\x2', '\x1043', '\x1044', '\x3', '\x2', 
		'\x2', '\x2', '\x1044', '\x1AD', '\x3', '\x2', '\x2', '\x2', '\x1045', 
		'\x1046', '\a', '\x247', '\x2', '\x2', '\x1046', '\x1054', '\x5', '\x4A4', 
		'\x253', '\x2', '\x1047', '\x1048', '\a', '\x243', '\x2', '\x2', '\x1048', 
		'\x1049', '\a', '\x108', '\x2', '\x2', '\x1049', '\x104A', '\a', '\x2F2', 
		'\x2', '\x2', '\x104A', '\x104F', '\x5', '\x426', '\x214', '\x2', '\x104B', 
		'\x104C', '\a', '\x2F8', '\x2', '\x2', '\x104C', '\x104E', '\x5', '\x426', 
		'\x214', '\x2', '\x104D', '\x104B', '\x3', '\x2', '\x2', '\x2', '\x104E', 
		'\x1051', '\x3', '\x2', '\x2', '\x2', '\x104F', '\x104D', '\x3', '\x2', 
		'\x2', '\x2', '\x104F', '\x1050', '\x3', '\x2', '\x2', '\x2', '\x1050', 
		'\x1052', '\x3', '\x2', '\x2', '\x2', '\x1051', '\x104F', '\x3', '\x2', 
		'\x2', '\x2', '\x1052', '\x1053', '\a', '\x2F3', '\x2', '\x2', '\x1053', 
		'\x1055', '\x3', '\x2', '\x2', '\x2', '\x1054', '\x1047', '\x3', '\x2', 
		'\x2', '\x2', '\x1054', '\x1055', '\x3', '\x2', '\x2', '\x2', '\x1055', 
		'\x1AF', '\x3', '\x2', '\x2', '\x2', '\x1056', '\x1058', '\x5', '\x1EA', 
		'\xF6', '\x2', '\x1057', '\x1056', '\x3', '\x2', '\x2', '\x2', '\x1057', 
		'\x1058', '\x3', '\x2', '\x2', '\x2', '\x1058', '\x105A', '\x3', '\x2', 
		'\x2', '\x2', '\x1059', '\x105B', '\x5', '\x118', '\x8D', '\x2', '\x105A', 
		'\x1059', '\x3', '\x2', '\x2', '\x2', '\x105A', '\x105B', '\x3', '\x2', 
		'\x2', '\x2', '\x105B', '\x105D', '\x3', '\x2', '\x2', '\x2', '\x105C', 
		'\x105E', '\x5', '\xFC', '\x7F', '\x2', '\x105D', '\x105C', '\x3', '\x2', 
		'\x2', '\x2', '\x105D', '\x105E', '\x3', '\x2', '\x2', '\x2', '\x105E', 
		'\x1061', '\x3', '\x2', '\x2', '\x2', '\x105F', '\x1062', '\x5', '\x12C', 
		'\x97', '\x2', '\x1060', '\x1062', '\x5', '\x130', '\x99', '\x2', '\x1061', 
		'\x105F', '\x3', '\x2', '\x2', '\x2', '\x1061', '\x1060', '\x3', '\x2', 
		'\x2', '\x2', '\x1061', '\x1062', '\x3', '\x2', '\x2', '\x2', '\x1062', 
		'\x1064', '\x3', '\x2', '\x2', '\x2', '\x1063', '\x1065', '\x5', '\x120', 
		'\x91', '\x2', '\x1064', '\x1063', '\x3', '\x2', '\x2', '\x2', '\x1064', 
		'\x1065', '\x3', '\x2', '\x2', '\x2', '\x1065', '\x1067', '\x3', '\x2', 
		'\x2', '\x2', '\x1066', '\x1068', '\x5', '\x1F0', '\xF9', '\x2', '\x1067', 
		'\x1066', '\x3', '\x2', '\x2', '\x2', '\x1067', '\x1068', '\x3', '\x2', 
		'\x2', '\x2', '\x1068', '\x106D', '\x3', '\x2', '\x2', '\x2', '\x1069', 
		'\x106B', '\a', '\x1A9', '\x2', '\x2', '\x106A', '\x106C', '\x5', '\xFC', 
		'\x7F', '\x2', '\x106B', '\x106A', '\x3', '\x2', '\x2', '\x2', '\x106B', 
		'\x106C', '\x3', '\x2', '\x2', '\x2', '\x106C', '\x106E', '\x3', '\x2', 
		'\x2', '\x2', '\x106D', '\x1069', '\x3', '\x2', '\x2', '\x2', '\x106D', 
		'\x106E', '\x3', '\x2', '\x2', '\x2', '\x106E', '\x1074', '\x3', '\x2', 
		'\x2', '\x2', '\x106F', '\x1073', '\x5', '\x1CE', '\xE8', '\x2', '\x1070', 
		'\x1073', '\x5', '\x1CA', '\xE6', '\x2', '\x1071', '\x1073', '\x5', '\x1C6', 
		'\xE4', '\x2', '\x1072', '\x106F', '\x3', '\x2', '\x2', '\x2', '\x1072', 
		'\x1070', '\x3', '\x2', '\x2', '\x2', '\x1072', '\x1071', '\x3', '\x2', 
		'\x2', '\x2', '\x1073', '\x1076', '\x3', '\x2', '\x2', '\x2', '\x1074', 
		'\x1072', '\x3', '\x2', '\x2', '\x2', '\x1074', '\x1075', '\x3', '\x2', 
		'\x2', '\x2', '\x1075', '\x1B1', '\x3', '\x2', '\x2', '\x2', '\x1076', 
		'\x1074', '\x3', '\x2', '\x2', '\x2', '\x1077', '\x1078', '\a', '\x290', 
		'\x2', '\x2', '\x1078', '\x1079', '\a', '\x129', '\x2', '\x2', '\x1079', 
		'\x107A', '\a', '\x25C', '\x2', '\x2', '\x107A', '\x1084', '\a', '\x2F2', 
		'\x2', '\x2', '\x107B', '\x1080', '\x5', '\x468', '\x235', '\x2', '\x107C', 
		'\x107D', '\a', '\x2F8', '\x2', '\x2', '\x107D', '\x107F', '\x5', '\x468', 
		'\x235', '\x2', '\x107E', '\x107C', '\x3', '\x2', '\x2', '\x2', '\x107F', 
		'\x1082', '\x3', '\x2', '\x2', '\x2', '\x1080', '\x107E', '\x3', '\x2', 
		'\x2', '\x2', '\x1080', '\x1081', '\x3', '\x2', '\x2', '\x2', '\x1081', 
		'\x1085', '\x3', '\x2', '\x2', '\x2', '\x1082', '\x1080', '\x3', '\x2', 
		'\x2', '\x2', '\x1083', '\x1085', '\a', '\x150', '\x2', '\x2', '\x1084', 
		'\x107B', '\x3', '\x2', '\x2', '\x2', '\x1084', '\x1083', '\x3', '\x2', 
		'\x2', '\x2', '\x1085', '\x1086', '\x3', '\x2', '\x2', '\x2', '\x1086', 
		'\x1087', '\a', '\x2F3', '\x2', '\x2', '\x1087', '\x1B3', '\x3', '\x2', 
		'\x2', '\x2', '\x1088', '\x1089', '\a', '\x290', '\x2', '\x2', '\x1089', 
		'\x1093', '\a', '\x2F2', '\x2', '\x2', '\x108A', '\x108F', '\x5', '\x468', 
		'\x235', '\x2', '\x108B', '\x108C', '\a', '\x2F8', '\x2', '\x2', '\x108C', 
		'\x108E', '\x5', '\x468', '\x235', '\x2', '\x108D', '\x108B', '\x3', '\x2', 
		'\x2', '\x2', '\x108E', '\x1091', '\x3', '\x2', '\x2', '\x2', '\x108F', 
		'\x108D', '\x3', '\x2', '\x2', '\x2', '\x108F', '\x1090', '\x3', '\x2', 
		'\x2', '\x2', '\x1090', '\x1094', '\x3', '\x2', '\x2', '\x2', '\x1091', 
		'\x108F', '\x3', '\x2', '\x2', '\x2', '\x1092', '\x1094', '\a', '\x18D', 
		'\x2', '\x2', '\x1093', '\x108A', '\x3', '\x2', '\x2', '\x2', '\x1093', 
		'\x1092', '\x3', '\x2', '\x2', '\x2', '\x1094', '\x1098', '\x3', '\x2', 
		'\x2', '\x2', '\x1095', '\x1096', '\a', '\x8F', '\x2', '\x2', '\x1096', 
		'\x1098', '\a', '\x2F3', '\x2', '\x2', '\x1097', '\x1088', '\x3', '\x2', 
		'\x2', '\x2', '\x1097', '\x1095', '\x3', '\x2', '\x2', '\x2', '\x1098', 
		'\x1B5', '\x3', '\x2', '\x2', '\x2', '\x1099', '\x109A', '\a', '\x247', 
		'\x2', '\x2', '\x109A', '\x109B', '\a', '?', '\x2', '\x2', '\x109B', '\x109C', 
		'\a', '\x1DE', '\x2', '\x2', '\x109C', '\x109D', '\x5', '\x44A', '\x226', 
		'\x2', '\x109D', '\x109E', '\x5', '\x1BC', '\xDF', '\x2', '\x109E', '\x1B7', 
		'\x3', '\x2', '\x2', '\x2', '\x109F', '\x10A0', '\a', '\x247', '\x2', 
		'\x2', '\x10A0', '\x10A1', '\a', '?', '\x2', '\x2', '\x10A1', '\x10A2', 
		'\a', '\x134', '\x2', '\x2', '\x10A2', '\x10A3', '\x5', '\x44A', '\x226', 
		'\x2', '\x10A3', '\x10A4', '\x5', '\x1BC', '\xDF', '\x2', '\x10A4', '\x1B9', 
		'\x3', '\x2', '\x2', '\x2', '\x10A5', '\x10A6', '\a', '\x247', '\x2', 
		'\x2', '\x10A6', '\x10A7', '\a', '?', '\x2', '\x2', '\x10A7', '\x10A8', 
		'\a', '\xED', '\x2', '\x2', '\x10A8', '\x10A9', '\x5', '\x44A', '\x226', 
		'\x2', '\x10A9', '\x10AA', '\a', '\x246', '\x2', '\x2', '\x10AA', '\x10AB', 
		'\x5', '\x4A4', '\x253', '\x2', '\x10AB', '\x10AC', '\a', '\x243', '\x2', 
		'\x2', '\x10AC', '\x10AD', '\a', '\x108', '\x2', '\x2', '\x10AD', '\x10AE', 
		'\a', '\x2F2', '\x2', '\x2', '\x10AE', '\x10B3', '\x5', '\x426', '\x214', 
		'\x2', '\x10AF', '\x10B0', '\a', '\x2F8', '\x2', '\x2', '\x10B0', '\x10B2', 
		'\x5', '\x426', '\x214', '\x2', '\x10B1', '\x10AF', '\x3', '\x2', '\x2', 
		'\x2', '\x10B2', '\x10B5', '\x3', '\x2', '\x2', '\x2', '\x10B3', '\x10B1', 
		'\x3', '\x2', '\x2', '\x2', '\x10B3', '\x10B4', '\x3', '\x2', '\x2', '\x2', 
		'\x10B4', '\x10B6', '\x3', '\x2', '\x2', '\x2', '\x10B5', '\x10B3', '\x3', 
		'\x2', '\x2', '\x2', '\x10B6', '\x10B7', '\a', '\x2F3', '\x2', '\x2', 
		'\x10B7', '\x10B8', '\x3', '\x2', '\x2', '\x2', '\x10B8', '\x10B9', '\x5', 
		'\x1BC', '\xDF', '\x2', '\x10B9', '\x1BB', '\x3', '\x2', '\x2', '\x2', 
		'\x10BA', '\x10BB', '\a', '\x247', '\x2', '\x2', '\x10BB', '\x10D8', '\a', 
		'\x25A', '\x2', '\x2', '\x10BC', '\x10BD', '\a', '\x2F2', '\x2', '\x2', 
		'\x10BD', '\x10C2', '\x5', '\x1A8', '\xD5', '\x2', '\x10BE', '\x10BF', 
		'\a', '\x2F8', '\x2', '\x2', '\x10BF', '\x10C1', '\x5', '\x1A8', '\xD5', 
		'\x2', '\x10C0', '\x10BE', '\x3', '\x2', '\x2', '\x2', '\x10C1', '\x10C4', 
		'\x3', '\x2', '\x2', '\x2', '\x10C2', '\x10C0', '\x3', '\x2', '\x2', '\x2', 
		'\x10C2', '\x10C3', '\x3', '\x2', '\x2', '\x2', '\x10C3', '\x10D9', '\x3', 
		'\x2', '\x2', '\x2', '\x10C4', '\x10C2', '\x3', '\x2', '\x2', '\x2', '\x10C5', 
		'\x10CA', '\x5', '\x1AA', '\xD6', '\x2', '\x10C6', '\x10C7', '\a', '\x2F8', 
		'\x2', '\x2', '\x10C7', '\x10C9', '\x5', '\x1AA', '\xD6', '\x2', '\x10C8', 
		'\x10C6', '\x3', '\x2', '\x2', '\x2', '\x10C9', '\x10CC', '\x3', '\x2', 
		'\x2', '\x2', '\x10CA', '\x10C8', '\x3', '\x2', '\x2', '\x2', '\x10CA', 
		'\x10CB', '\x3', '\x2', '\x2', '\x2', '\x10CB', '\x10D9', '\x3', '\x2', 
		'\x2', '\x2', '\x10CC', '\x10CA', '\x3', '\x2', '\x2', '\x2', '\x10CD', 
		'\x10D2', '\x5', '\x1AC', '\xD7', '\x2', '\x10CE', '\x10CF', '\a', '\x2F8', 
		'\x2', '\x2', '\x10CF', '\x10D1', '\x5', '\x1AC', '\xD7', '\x2', '\x10D0', 
		'\x10CE', '\x3', '\x2', '\x2', '\x2', '\x10D1', '\x10D4', '\x3', '\x2', 
		'\x2', '\x2', '\x10D2', '\x10D0', '\x3', '\x2', '\x2', '\x2', '\x10D2', 
		'\x10D3', '\x3', '\x2', '\x2', '\x2', '\x10D3', '\x10D5', '\x3', '\x2', 
		'\x2', '\x2', '\x10D4', '\x10D2', '\x3', '\x2', '\x2', '\x2', '\x10D5', 
		'\x10D6', '\a', '\x2F3', '\x2', '\x2', '\x10D6', '\x10D9', '\x3', '\x2', 
		'\x2', '\x2', '\x10D7', '\x10D9', '\x5', '\x13A', '\x9E', '\x2', '\x10D8', 
		'\x10BC', '\x3', '\x2', '\x2', '\x2', '\x10D8', '\x10C5', '\x3', '\x2', 
		'\x2', '\x2', '\x10D8', '\x10CD', '\x3', '\x2', '\x2', '\x2', '\x10D8', 
		'\x10D7', '\x3', '\x2', '\x2', '\x2', '\x10D9', '\x1BD', '\x3', '\x2', 
		'\x2', '\x2', '\x10DA', '\x10DB', '\a', '\x1B2', '\x2', '\x2', '\x10DB', 
		'\x10DC', '\a', '?', '\x2', '\x2', '\x10DC', '\x10DD', '\a', '\x1E6', 
		'\x2', '\x2', '\x10DD', '\x10DE', '\a', '\x2F2', '\x2', '\x2', '\x10DE', 
		'\x10DF', '\x5', '\xE8', 'u', '\x2', '\x10DF', '\x10E8', '\a', '\x2F3', 
		'\x2', '\x2', '\x10E0', '\x10E1', '\a', '\x2F2', '\x2', '\x2', '\x10E1', 
		'\x10E4', '\x5', '\x1C0', '\xE1', '\x2', '\x10E2', '\x10E3', '\a', '\x2F8', 
		'\x2', '\x2', '\x10E3', '\x10E5', '\x5', '\x1C0', '\xE1', '\x2', '\x10E4', 
		'\x10E2', '\x3', '\x2', '\x2', '\x2', '\x10E4', '\x10E5', '\x3', '\x2', 
		'\x2', '\x2', '\x10E5', '\x10E6', '\x3', '\x2', '\x2', '\x2', '\x10E6', 
		'\x10E7', '\a', '\x2F3', '\x2', '\x2', '\x10E7', '\x10E9', '\x3', '\x2', 
		'\x2', '\x2', '\x10E8', '\x10E0', '\x3', '\x2', '\x2', '\x2', '\x10E8', 
		'\x10E9', '\x3', '\x2', '\x2', '\x2', '\x10E9', '\x1BF', '\x3', '\x2', 
		'\x2', '\x2', '\x10EA', '\x10EB', '\a', '\x1B2', '\x2', '\x2', '\x10EB', 
		'\x10EC', '\a', '?', '\x2', '\x2', '\x10EC', '\x10F6', '\a', '\x255', 
		'\x2', '\x2', '\x10ED', '\x10EE', '\a', '\x1B3', '\x2', '\x2', '\x10EE', 
		'\x10F7', '\x5', '\x4A4', '\x253', '\x2', '\x10EF', '\x10F2', '\x5', '\x1C0', 
		'\xE1', '\x2', '\x10F0', '\x10F1', '\a', '\x2F8', '\x2', '\x2', '\x10F1', 
		'\x10F3', '\x5', '\x1C0', '\xE1', '\x2', '\x10F2', '\x10F0', '\x3', '\x2', 
		'\x2', '\x2', '\x10F3', '\x10F4', '\x3', '\x2', '\x2', '\x2', '\x10F4', 
		'\x10F2', '\x3', '\x2', '\x2', '\x2', '\x10F4', '\x10F5', '\x3', '\x2', 
		'\x2', '\x2', '\x10F5', '\x10F7', '\x3', '\x2', '\x2', '\x2', '\x10F6', 
		'\x10ED', '\x3', '\x2', '\x2', '\x2', '\x10F6', '\x10EF', '\x3', '\x2', 
		'\x2', '\x2', '\x10F6', '\x10F7', '\x3', '\x2', '\x2', '\x2', '\x10F7', 
		'\x1C1', '\x3', '\x2', '\x2', '\x2', '\x10F8', '\x10F9', '\a', 'X', '\x2', 
		'\x2', '\x10F9', '\x10FA', '\x5', '\x490', '\x249', '\x2', '\x10FA', '\x10FB', 
		'\x5', '\x1C4', '\xE3', '\x2', '\x10FB', '\x1C3', '\x3', '\x2', '\x2', 
		'\x2', '\x10FC', '\x10FE', '\a', '\xAD', '\x2', '\x2', '\x10FD', '\x10FC', 
		'\x3', '\x2', '\x2', '\x2', '\x10FD', '\x10FE', '\x3', '\x2', '\x2', '\x2', 
		'\x10FE', '\x10FF', '\x3', '\x2', '\x2', '\x2', '\x10FF', '\x1100', '\a', 
		'\x11B', '\x2', '\x2', '\x1100', '\x1102', '\a', '\x195', '\x2', '\x2', 
		'\x1101', '\x1103', '\a', '\x27A', '\x2', '\x2', '\x1102', '\x1101', '\x3', 
		'\x2', '\x2', '\x2', '\x1102', '\x1103', '\x3', '\x2', '\x2', '\x2', '\x1103', 
		'\x1104', '\x3', '\x2', '\x2', '\x2', '\x1104', '\x1105', '\a', '\x2F2', 
		'\x2', '\x2', '\x1105', '\x1106', '\a', '\x19A', '\x2', '\x2', '\x1106', 
		'\x1107', '\x5', '\x496', '\x24C', '\x2', '\x1107', '\x1108', '\a', '\x2F3', 
		'\x2', '\x2', '\x1108', '\x1111', '\x3', '\x2', '\x2', '\x2', '\x1109', 
		'\x110B', '\a', '\x18A', '\x2', '\x2', '\x110A', '\x1109', '\x3', '\x2', 
		'\x2', '\x2', '\x110A', '\x110B', '\x3', '\x2', '\x2', '\x2', '\x110B', 
		'\x110C', '\x3', '\x2', '\x2', '\x2', '\x110C', '\x110D', '\a', '\x248', 
		'\x2', '\x2', '\x110D', '\x110E', '\a', '\x1C', '\x2', '\x2', '\x110E', 
		'\x110F', '\a', '\xE', '\x2', '\x2', '\x110F', '\x1111', '\a', '\x12B', 
		'\x2', '\x2', '\x1110', '\x10FD', '\x3', '\x2', '\x2', '\x2', '\x1110', 
		'\x110A', '\x3', '\x2', '\x2', '\x2', '\x1111', '\x1C5', '\x3', '\x2', 
		'\x2', '\x2', '\x1112', '\x1113', '\a', '\x16F', '\x2', '\x2', '\x1113', 
		'\x1117', '\a', '\x258', '\x2', '\x2', '\x1114', '\x1118', '\x5', '\x440', 
		'\x221', '\x2', '\x1115', '\x1116', '\a', 'X', '\x2', '\x2', '\x1116', 
		'\x1118', '\a', '\x291', '\x2', '\x2', '\x1117', '\x1114', '\x3', '\x2', 
		'\x2', '\x2', '\x1117', '\x1115', '\x3', '\x2', '\x2', '\x2', '\x1118', 
		'\x111A', '\x3', '\x2', '\x2', '\x2', '\x1119', '\x111B', '\x5', '\x1C4', 
		'\xE3', '\x2', '\x111A', '\x1119', '\x3', '\x2', '\x2', '\x2', '\x111A', 
		'\x111B', '\x3', '\x2', '\x2', '\x2', '\x111B', '\x111E', '\x3', '\x2', 
		'\x2', '\x2', '\x111C', '\x111D', '\a', '\x138', '\x2', '\x2', '\x111D', 
		'\x111F', '\a', '\xE5', '\x2', '\x2', '\x111E', '\x111C', '\x3', '\x2', 
		'\x2', '\x2', '\x111E', '\x111F', '\x3', '\x2', '\x2', '\x2', '\x111F', 
		'\x1120', '\x3', '\x2', '\x2', '\x2', '\x1120', '\x1121', '\a', '\x243', 
		'\x2', '\x2', '\x1121', '\x1122', '\a', '\x19', '\x2', '\x2', '\x1122', 
		'\x1130', '\x5', '\x444', '\x223', '\x2', '\x1123', '\x112A', '\a', '\x2F2', 
		'\x2', '\x2', '\x1124', '\x1125', '\a', '\x2F2', '\x2', '\x2', '\x1125', 
		'\x1126', '\x5', '\x1C8', '\xE5', '\x2', '\x1126', '\x1127', '\a', '\x2F3', 
		'\x2', '\x2', '\x1127', '\x112B', '\x3', '\x2', '\x2', '\x2', '\x1128', 
		'\x112B', '\x5', '\x1DC', '\xEF', '\x2', '\x1129', '\x112B', '\x5', '\x194', 
		'\xCB', '\x2', '\x112A', '\x1124', '\x3', '\x2', '\x2', '\x2', '\x112A', 
		'\x1128', '\x3', '\x2', '\x2', '\x2', '\x112A', '\x1129', '\x3', '\x2', 
		'\x2', '\x2', '\x112B', '\x112C', '\x3', '\x2', '\x2', '\x2', '\x112C', 
		'\x112A', '\x3', '\x2', '\x2', '\x2', '\x112C', '\x112D', '\x3', '\x2', 
		'\x2', '\x2', '\x112D', '\x112E', '\x3', '\x2', '\x2', '\x2', '\x112E', 
		'\x112F', '\a', '\x2F3', '\x2', '\x2', '\x112F', '\x1131', '\x3', '\x2', 
		'\x2', '\x2', '\x1130', '\x1123', '\x3', '\x2', '\x2', '\x2', '\x1130', 
		'\x1131', '\x3', '\x2', '\x2', '\x2', '\x1131', '\x1132', '\x3', '\x2', 
		'\x2', '\x2', '\x1132', '\x1133', '\a', '\x1FC', '\x2', '\x2', '\x1133', 
		'\x1134', '\a', '\x19', '\x2', '\x2', '\x1134', '\x1135', '\t', ':', '\x2', 
		'\x2', '\x1135', '\x1C7', '\x3', '\x2', '\x2', '\x2', '\x1136', '\x1139', 
		'\x5', '\x490', '\x249', '\x2', '\x1137', '\x1139', '\x5', '\x47A', '\x23E', 
		'\x2', '\x1138', '\x1136', '\x3', '\x2', '\x2', '\x2', '\x1138', '\x1137', 
		'\x3', '\x2', '\x2', '\x2', '\x1139', '\x113C', '\x3', '\x2', '\x2', '\x2', 
		'\x113A', '\x113B', '\a', '\x8F', '\x2', '\x2', '\x113B', '\x113D', '\x5', 
		'\x37E', '\x1C0', '\x2', '\x113C', '\x113A', '\x3', '\x2', '\x2', '\x2', 
		'\x113C', '\x113D', '\x3', '\x2', '\x2', '\x2', '\x113D', '\x1144', '\x3', 
		'\x2', '\x2', '\x2', '\x113E', '\x1140', '\x5', '\xEA', 'v', '\x2', '\x113F', 
		'\x113E', '\x3', '\x2', '\x2', '\x2', '\x1140', '\x1141', '\x3', '\x2', 
		'\x2', '\x2', '\x1141', '\x113F', '\x3', '\x2', '\x2', '\x2', '\x1141', 
		'\x1142', '\x3', '\x2', '\x2', '\x2', '\x1142', '\x1145', '\x3', '\x2', 
		'\x2', '\x2', '\x1143', '\x1145', '\x5', '\x218', '\x10D', '\x2', '\x1144', 
		'\x113F', '\x3', '\x2', '\x2', '\x2', '\x1144', '\x1143', '\x3', '\x2', 
		'\x2', '\x2', '\x1144', '\x1145', '\x3', '\x2', '\x2', '\x2', '\x1145', 
		'\x114C', '\x3', '\x2', '\x2', '\x2', '\x1146', '\x114A', '\x5', '\xEC', 
		'w', '\x2', '\x1147', '\x114A', '\x5', '\x21A', '\x10E', '\x2', '\x1148', 
		'\x114A', '\x5', '\x206', '\x104', '\x2', '\x1149', '\x1146', '\x3', '\x2', 
		'\x2', '\x2', '\x1149', '\x1147', '\x3', '\x2', '\x2', '\x2', '\x1149', 
		'\x1148', '\x3', '\x2', '\x2', '\x2', '\x114A', '\x114C', '\x3', '\x2', 
		'\x2', '\x2', '\x114B', '\x1138', '\x3', '\x2', '\x2', '\x2', '\x114B', 
		'\x1149', '\x3', '\x2', '\x2', '\x2', '\x114C', '\x1C9', '\x3', '\x2', 
		'\x2', '\x2', '\x114D', '\x114E', '\a', '\x296', '\x2', '\x2', '\x114E', 
		'\x1154', '\x5', '\x13C', '\x9F', '\x2', '\x114F', '\x1151', '\x5', '\x1C4', 
		'\xE3', '\x2', '\x1150', '\x114F', '\x3', '\x2', '\x2', '\x2', '\x1150', 
		'\x1151', '\x3', '\x2', '\x2', '\x2', '\x1151', '\x1152', '\x3', '\x2', 
		'\x2', '\x2', '\x1152', '\x1155', '\x5', '\x1CC', '\xE7', '\x2', '\x1153', 
		'\x1155', '\x5', '\x1C4', '\xE3', '\x2', '\x1154', '\x1150', '\x3', '\x2', 
		'\x2', '\x2', '\x1154', '\x1153', '\x3', '\x2', '\x2', '\x2', '\x1155', 
		'\x1CB', '\x3', '\x2', '\x2', '\x2', '\x1156', '\x1157', '\a', '\x243', 
		'\x2', '\x2', '\x1157', '\x1159', '\a', '\x19', '\x2', '\x2', '\x1158', 
		'\x115A', '\t', '$', '\x2', '\x2', '\x1159', '\x1158', '\x3', '\x2', '\x2', 
		'\x2', '\x1159', '\x115A', '\x3', '\x2', '\x2', '\x2', '\x115A', '\x115B', 
		'\x3', '\x2', '\x2', '\x2', '\x115B', '\x1164', '\a', '\x136', '\x2', 
		'\x2', '\x115C', '\x115E', '\x5', '\x42E', '\x218', '\x2', '\x115D', '\x115C', 
		'\x3', '\x2', '\x2', '\x2', '\x115D', '\x115E', '\x3', '\x2', '\x2', '\x2', 
		'\x115E', '\x115F', '\x3', '\x2', '\x2', '\x2', '\x115F', '\x1160', '\a', 
		'\x2F2', '\x2', '\x2', '\x1160', '\x1161', '\x5', '\x1D0', '\xE9', '\x2', 
		'\x1161', '\x1162', '\a', '\x2F3', '\x2', '\x2', '\x1162', '\x1165', '\x3', 
		'\x2', '\x2', '\x2', '\x1163', '\x1165', '\x5', '\x1D0', '\xE9', '\x2', 
		'\x1164', '\x115D', '\x3', '\x2', '\x2', '\x2', '\x1164', '\x1163', '\x3', 
		'\x2', '\x2', '\x2', '\x1165', '\x1CD', '\x3', '\x2', '\x2', '\x2', '\x1166', 
		'\x118E', '\a', '\x136', '\x2', '\x2', '\x1167', '\x1168', '\a', '\x2F2', 
		'\x2', '\x2', '\x1168', '\x116D', '\x5', '\x420', '\x211', '\x2', '\x1169', 
		'\x116A', '\a', '\x2F8', '\x2', '\x2', '\x116A', '\x116C', '\x5', '\x420', 
		'\x211', '\x2', '\x116B', '\x1169', '\x3', '\x2', '\x2', '\x2', '\x116C', 
		'\x116F', '\x3', '\x2', '\x2', '\x2', '\x116D', '\x116B', '\x3', '\x2', 
		'\x2', '\x2', '\x116D', '\x116E', '\x3', '\x2', '\x2', '\x2', '\x116E', 
		'\x1170', '\x3', '\x2', '\x2', '\x2', '\x116F', '\x116D', '\x3', '\x2', 
		'\x2', '\x2', '\x1170', '\x1171', '\a', '\x2F3', '\x2', '\x2', '\x1171', 
		'\x1172', '\a', '\x243', '\x2', '\x2', '\x1172', '\x1178', '\a', '\x19', 
		'\x2', '\x2', '\x1173', '\x1179', '\t', '$', '\x2', '\x2', '\x1174', '\x1175', 
		'\a', '\x2F2', '\x2', '\x2', '\x1175', '\x1176', '\x5', '\x1D0', '\xE9', 
		'\x2', '\x1176', '\x1177', '\a', '\x2F3', '\x2', '\x2', '\x1177', '\x1179', 
		'\x3', '\x2', '\x2', '\x2', '\x1178', '\x1173', '\x3', '\x2', '\x2', '\x2', 
		'\x1178', '\x1174', '\x3', '\x2', '\x2', '\x2', '\x1179', '\x118F', '\x3', 
		'\x2', '\x2', '\x2', '\x117A', '\x117B', '\a', '\x2F2', '\x2', '\x2', 
		'\x117B', '\x1180', '\x5', '\x420', '\x211', '\x2', '\x117C', '\x117D', 
		'\a', '\x2F8', '\x2', '\x2', '\x117D', '\x117F', '\x5', '\x420', '\x211', 
		'\x2', '\x117E', '\x117C', '\x3', '\x2', '\x2', '\x2', '\x117F', '\x1182', 
		'\x3', '\x2', '\x2', '\x2', '\x1180', '\x117E', '\x3', '\x2', '\x2', '\x2', 
		'\x1180', '\x1181', '\x3', '\x2', '\x2', '\x2', '\x1181', '\x1183', '\x3', 
		'\x2', '\x2', '\x2', '\x1182', '\x1180', '\x3', '\x2', '\x2', '\x2', '\x1183', 
		'\x1184', '\a', '\x2F3', '\x2', '\x2', '\x1184', '\x1185', '\a', '\x243', 
		'\x2', '\x2', '\x1185', '\x118C', '\a', '\x19', '\x2', '\x2', '\x1186', 
		'\x118D', '\t', '$', '\x2', '\x2', '\x1187', '\x118D', '\x5', '\x42E', 
		'\x218', '\x2', '\x1188', '\x1189', '\a', '\x2F2', '\x2', '\x2', '\x1189', 
		'\x118A', '\x5', '\x1D0', '\xE9', '\x2', '\x118A', '\x118B', '\a', '\x2F3', 
		'\x2', '\x2', '\x118B', '\x118D', '\x3', '\x2', '\x2', '\x2', '\x118C', 
		'\x1186', '\x3', '\x2', '\x2', '\x2', '\x118C', '\x1187', '\x3', '\x2', 
		'\x2', '\x2', '\x118C', '\x1188', '\x3', '\x2', '\x2', '\x2', '\x118D', 
		'\x118F', '\x3', '\x2', '\x2', '\x2', '\x118E', '\x1167', '\x3', '\x2', 
		'\x2', '\x2', '\x118E', '\x117A', '\x3', '\x2', '\x2', '\x2', '\x118F', 
		'\x1CF', '\x3', '\x2', '\x2', '\x2', '\x1190', '\x119A', '\x5', '\x1EC', 
		'\xF7', '\x2', '\x1191', '\x1193', '\x5', '\x1D4', '\xEB', '\x2', '\x1192', 
		'\x1191', '\x3', '\x2', '\x2', '\x2', '\x1193', '\x1194', '\x3', '\x2', 
		'\x2', '\x2', '\x1194', '\x1192', '\x3', '\x2', '\x2', '\x2', '\x1194', 
		'\x1195', '\x3', '\x2', '\x2', '\x2', '\x1195', '\x1197', '\x3', '\x2', 
		'\x2', '\x2', '\x1196', '\x1198', '\x5', '\x1FC', '\xFF', '\x2', '\x1197', 
		'\x1196', '\x3', '\x2', '\x2', '\x2', '\x1197', '\x1198', '\x3', '\x2', 
		'\x2', '\x2', '\x1198', '\x119A', '\x3', '\x2', '\x2', '\x2', '\x1199', 
		'\x1190', '\x3', '\x2', '\x2', '\x2', '\x1199', '\x1192', '\x3', '\x2', 
		'\x2', '\x2', '\x119A', '\x119D', '\x3', '\x2', '\x2', '\x2', '\x119B', 
		'\x119D', '\x5', '\x1FC', '\xFF', '\x2', '\x119C', '\x1199', '\x3', '\x2', 
		'\x2', '\x2', '\x119C', '\x119B', '\x3', '\x2', '\x2', '\x2', '\x119D', 
		'\x1D1', '\x3', '\x2', '\x2', '\x2', '\x119E', '\x119F', '\a', '\x2F2', 
		'\x2', '\x2', '\x119F', '\x11A0', '\x5', '\x1D4', '\xEB', '\x2', '\x11A0', 
		'\x11A1', '\a', '\x2F3', '\x2', '\x2', '\x11A1', '\x1D3', '\x3', '\x2', 
		'\x2', '\x2', '\x11A2', '\x11A3', '\t', '\a', '\x2', '\x2', '\x11A3', 
		'\x11A4', '\a', '\x242', '\x2', '\x2', '\x11A4', '\x11A5', '\a', '\x108', 
		'\x2', '\x2', '\x11A5', '\x11BC', '\a', '\x209', '\x2', '\x2', '\x11A6', 
		'\x11A7', '\a', 'O', '\x2', '\x2', '\x11A7', '\x11BC', '\x5', '\x4A4', 
		'\x253', '\x2', '\x11A8', '\x11A9', '\a', '\x1BB', '\x2', '\x2', '\x11A9', 
		'\x11BC', '\x5', '\x4A4', '\x253', '\x2', '\x11AA', '\x11AB', '\a', '\xE0', 
		'\x2', '\x2', '\x11AB', '\x11BC', '\x5', '\x4A4', '\x253', '\x2', '\x11AC', 
		'\x11BC', '\x5', '\x1D6', '\xEC', '\x2', '\x11AD', '\x11BC', '\x5', '\x1D8', 
		'\xED', '\x2', '\x11AE', '\x11BC', '\x5', '\x1DA', '\xEE', '\x2', '\x11AF', 
		'\x11B0', '\a', '\xB3', '\x2', '\x2', '\x11B0', '\x11B3', '\x5', '\x216', 
		'\x10C', '\x2', '\x11B1', '\x11B3', '\a', '\x8D', '\x2', '\x2', '\x11B2', 
		'\x11AF', '\x3', '\x2', '\x2', '\x2', '\x11B2', '\x11B1', '\x3', '\x2', 
		'\x2', '\x2', '\x11B3', '\x11BC', '\x3', '\x2', '\x2', '\x2', '\x11B4', 
		'\x11B9', '\a', '\x41', '\x2', '\x2', '\x11B5', '\x11B9', '\a', '\x173', 
		'\x2', '\x2', '\x11B6', '\x11B7', '\a', '\x41', '\x2', '\x2', '\x11B7', 
		'\x11B9', '\a', '\x1E1', '\x2', '\x2', '\x11B8', '\x11B4', '\x3', '\x2', 
		'\x2', '\x2', '\x11B8', '\x11B5', '\x3', '\x2', '\x2', '\x2', '\x11B8', 
		'\x11B6', '\x3', '\x2', '\x2', '\x2', '\x11B9', '\x11BA', '\x3', '\x2', 
		'\x2', '\x2', '\x11BA', '\x11BC', '\x5', '\x152', '\xAA', '\x2', '\x11BB', 
		'\x11A2', '\x3', '\x2', '\x2', '\x2', '\x11BB', '\x11A6', '\x3', '\x2', 
		'\x2', '\x2', '\x11BB', '\x11A8', '\x3', '\x2', '\x2', '\x2', '\x11BB', 
		'\x11AA', '\x3', '\x2', '\x2', '\x2', '\x11BB', '\x11AC', '\x3', '\x2', 
		'\x2', '\x2', '\x11BB', '\x11AD', '\x3', '\x2', '\x2', '\x2', '\x11BB', 
		'\x11AE', '\x3', '\x2', '\x2', '\x2', '\x11BB', '\x11B2', '\x3', '\x2', 
		'\x2', '\x2', '\x11BB', '\x11B8', '\x3', '\x2', '\x2', '\x2', '\x11BC', 
		'\x1D5', '\x3', '\x2', '\x2', '\x2', '\x11BD', '\x11C3', '\a', '\x1FA', 
		'\x2', '\x2', '\x11BE', '\x11C4', '\a', '\x2D3', '\x2', '\x2', '\x11BF', 
		'\x11C0', '\a', '\x2D5', '\x2', '\x2', '\x11C0', '\x11C4', '\x5', '\x4A4', 
		'\x253', '\x2', '\x11C1', '\x11C4', '\a', '#', '\x2', '\x2', '\x11C2', 
		'\x11C4', '\a', '\x180', '\x2', '\x2', '\x11C3', '\x11BE', '\x3', '\x2', 
		'\x2', '\x2', '\x11C3', '\x11BF', '\x3', '\x2', '\x2', '\x2', '\x11C3', 
		'\x11C1', '\x3', '\x2', '\x2', '\x2', '\x11C3', '\x11C2', '\x3', '\x2', 
		'\x2', '\x2', '\x11C3', '\x11C4', '\x3', '\x2', '\x2', '\x2', '\x11C4', 
		'\x1D7', '\x3', '\x2', '\x2', '\x2', '\x11C5', '\x11C6', '\t', ';', '\x2', 
		'\x2', '\x11C6', '\x1D9', '\x3', '\x2', '\x2', '\x2', '\x11C7', '\x11C9', 
		'\a', '`', '\x2', '\x2', '\x11C8', '\x11CA', '\t', '<', '\x2', '\x2', 
		'\x11C9', '\x11C8', '\x3', '\x2', '\x2', '\x2', '\x11C9', '\x11CA', '\x3', 
		'\x2', '\x2', '\x2', '\x11CA', '\x11CD', '\x3', '\x2', '\x2', '\x2', '\x11CB', 
		'\x11CD', '\a', '\x174', '\x2', '\x2', '\x11CC', '\x11C7', '\x3', '\x2', 
		'\x2', '\x2', '\x11CC', '\x11CB', '\x3', '\x2', '\x2', '\x2', '\x11CD', 
		'\x1DB', '\x3', '\x2', '\x2', '\x2', '\x11CE', '\x11D0', '\x5', '\x1EA', 
		'\xF6', '\x2', '\x11CF', '\x11CE', '\x3', '\x2', '\x2', '\x2', '\x11CF', 
		'\x11D0', '\x3', '\x2', '\x2', '\x2', '\x11D0', '\x11D1', '\x3', '\x2', 
		'\x2', '\x2', '\x11D1', '\x11D3', '\x5', '\xFC', '\x7F', '\x2', '\x11D2', 
		'\x11D4', '\x5', '\x12C', '\x97', '\x2', '\x11D3', '\x11D2', '\x3', '\x2', 
		'\x2', '\x2', '\x11D3', '\x11D4', '\x3', '\x2', '\x2', '\x2', '\x11D4', 
		'\x11D6', '\x3', '\x2', '\x2', '\x2', '\x11D5', '\x11D7', '\x5', '\x11C', 
		'\x8F', '\x2', '\x11D6', '\x11D5', '\x3', '\x2', '\x2', '\x2', '\x11D6', 
		'\x11D7', '\x3', '\x2', '\x2', '\x2', '\x11D7', '\x11D8', '\x3', '\x2', 
		'\x2', '\x2', '\x11D8', '\x11D9', '\x5', '\x1F0', '\xF9', '\x2', '\x11D9', 
		'\x11F5', '\x3', '\x2', '\x2', '\x2', '\x11DA', '\x11DC', '\x5', '\x1EA', 
		'\xF6', '\x2', '\x11DB', '\x11DA', '\x3', '\x2', '\x2', '\x2', '\x11DB', 
		'\x11DC', '\x3', '\x2', '\x2', '\x2', '\x11DC', '\x11DD', '\x3', '\x2', 
		'\x2', '\x2', '\x11DD', '\x11F2', '\a', '\x1A3', '\x2', '\x2', '\x11DE', 
		'\x11E0', '\a', '\xEF', '\x2', '\x2', '\x11DF', '\x11E1', '\x5', '\xFC', 
		'\x7F', '\x2', '\x11E0', '\x11DF', '\x3', '\x2', '\x2', '\x2', '\x11E0', 
		'\x11E1', '\x3', '\x2', '\x2', '\x2', '\x11E1', '\x11E3', '\x3', '\x2', 
		'\x2', '\x2', '\x11E2', '\x11E4', '\x5', '\x12C', '\x97', '\x2', '\x11E3', 
		'\x11E2', '\x3', '\x2', '\x2', '\x2', '\x11E3', '\x11E4', '\x3', '\x2', 
		'\x2', '\x2', '\x11E4', '\x11E6', '\x3', '\x2', '\x2', '\x2', '\x11E5', 
		'\x11E7', '\x5', '\x11C', '\x8F', '\x2', '\x11E6', '\x11E5', '\x3', '\x2', 
		'\x2', '\x2', '\x11E6', '\x11E7', '\x3', '\x2', '\x2', '\x2', '\x11E7', 
		'\x11E9', '\x3', '\x2', '\x2', '\x2', '\x11E8', '\x11EA', '\x5', '\x1F0', 
		'\xF9', '\x2', '\x11E9', '\x11E8', '\x3', '\x2', '\x2', '\x2', '\x11E9', 
		'\x11EA', '\x3', '\x2', '\x2', '\x2', '\x11EA', '\x11F3', '\x3', '\x2', 
		'\x2', '\x2', '\x11EB', '\x11ED', '\a', '\x101', '\x2', '\x2', '\x11EC', 
		'\x11EE', '\x5', '\xFC', '\x7F', '\x2', '\x11ED', '\x11EC', '\x3', '\x2', 
		'\x2', '\x2', '\x11ED', '\x11EE', '\x3', '\x2', '\x2', '\x2', '\x11EE', 
		'\x11EF', '\x3', '\x2', '\x2', '\x2', '\x11EF', '\x11F3', '\x5', '\x1E4', 
		'\xF3', '\x2', '\x11F0', '\x11F1', '\a', '\xCA', '\x2', '\x2', '\x11F1', 
		'\x11F3', '\x5', '\x1DE', '\xF0', '\x2', '\x11F2', '\x11DE', '\x3', '\x2', 
		'\x2', '\x2', '\x11F2', '\x11EB', '\x3', '\x2', '\x2', '\x2', '\x11F2', 
		'\x11F0', '\x3', '\x2', '\x2', '\x2', '\x11F3', '\x11F5', '\x3', '\x2', 
		'\x2', '\x2', '\x11F4', '\x11CF', '\x3', '\x2', '\x2', '\x2', '\x11F4', 
		'\x11DB', '\x3', '\x2', '\x2', '\x2', '\x11F5', '\x1DD', '\x3', '\x2', 
		'\x2', '\x2', '\x11F6', '\x11F8', '\a', '\x2F2', '\x2', '\x2', '\x11F7', 
		'\x11F9', '\a', '\x27A', '\x2', '\x2', '\x11F8', '\x11F7', '\x3', '\x2', 
		'\x2', '\x2', '\x11F8', '\x11F9', '\x3', '\x2', '\x2', '\x2', '\x11F9', 
		'\x11FA', '\x3', '\x2', '\x2', '\x2', '\x11FA', '\x11FB', '\x5', '\x1E0', 
		'\xF1', '\x2', '\x11FB', '\x1202', '\a', '\x2F3', '\x2', '\x2', '\x11FC', 
		'\x11FD', '\a', '\x1EB', '\x2', '\x2', '\x11FD', '\x1200', '\a', '\x131', 
		'\x2', '\x2', '\x11FE', '\x1201', '\x5', '\x4A4', '\x253', '\x2', '\x11FF', 
		'\x1201', '\a', '\x281', '\x2', '\x2', '\x1200', '\x11FE', '\x3', '\x2', 
		'\x2', '\x2', '\x1200', '\x11FF', '\x3', '\x2', '\x2', '\x2', '\x1201', 
		'\x1203', '\x3', '\x2', '\x2', '\x2', '\x1202', '\x11FC', '\x3', '\x2', 
		'\x2', '\x2', '\x1202', '\x1203', '\x3', '\x2', '\x2', '\x2', '\x1203', 
		'\x1DF', '\x3', '\x2', '\x2', '\x2', '\x1204', '\x1205', '\a', '\x8F', 
		'\x2', '\x2', '\x1205', '\x1206', '\a', '\x9B', '\x2', '\x2', '\x1206', 
		'\x1207', '\x5', '\x432', '\x21A', '\x2', '\x1207', '\x1208', '\a', '\x3', 
		'\x2', '\x2', '\x1208', '\x120E', '\a', '\x1AF', '\x2', '\x2', '\x1209', 
		'\x120A', '\a', '\x2F2', '\x2', '\x2', '\x120A', '\x120F', '\a', '\x2F3', 
		'\x2', '\x2', '\x120B', '\x120C', '\a', '\x28E', '\x2', '\x2', '\x120C', 
		'\x120D', '\a', 'R', '\x2', '\x2', '\x120D', '\x120F', '\x5', '\x16E', 
		'\xB8', '\x2', '\x120E', '\x1209', '\x3', '\x2', '\x2', '\x2', '\x120E', 
		'\x120B', '\x3', '\x2', '\x2', '\x2', '\x120F', '\x1210', '\x3', '\x2', 
		'\x2', '\x2', '\x1210', '\x1211', '\a', '\x139', '\x2', '\x2', '\x1211', 
		'\x1212', '\a', '\x2F2', '\x2', '\x2', '\x1212', '\x1215', '\x5', '\x1E2', 
		'\xF2', '\x2', '\x1213', '\x1214', '\a', '\x2F8', '\x2', '\x2', '\x1214', 
		'\x1216', '\x5', '\x1E2', '\xF2', '\x2', '\x1215', '\x1213', '\x3', '\x2', 
		'\x2', '\x2', '\x1216', '\x1217', '\x3', '\x2', '\x2', '\x2', '\x1217', 
		'\x1215', '\x3', '\x2', '\x2', '\x2', '\x1217', '\x1218', '\x3', '\x2', 
		'\x2', '\x2', '\x1218', '\x1219', '\x3', '\x2', '\x2', '\x2', '\x1219', 
		'\x121A', '\a', '\x2F3', '\x2', '\x2', '\x121A', '\x1E1', '\x3', '\x2', 
		'\x2', '\x2', '\x121B', '\x121D', '\x5', '\x432', '\x21A', '\x2', '\x121C', 
		'\x121B', '\x3', '\x2', '\x2', '\x2', '\x121C', '\x121D', '\x3', '\x2', 
		'\x2', '\x2', '\x121D', '\x121E', '\x3', '\x2', '\x2', '\x2', '\x121E', 
		'\x1220', '\a', '\x303', '\x2', '\x2', '\x121F', '\x121C', '\x3', '\x2', 
		'\x2', '\x2', '\x121F', '\x1220', '\x3', '\x2', '\x2', '\x2', '\x1220', 
		'\x1221', '\x3', '\x2', '\x2', '\x2', '\x1221', '\x1222', '\a', '\x2EE', 
		'\x2', '\x2', '\x1222', '\x1E3', '\x3', '\x2', '\x2', '\x2', '\x1223', 
		'\x1228', '\x5', '\x1E6', '\xF4', '\x2', '\x1224', '\x1225', '\a', '\x1B9', 
		'\x2', '\x2', '\x1225', '\x1228', '\x5', '\x4A4', '\x253', '\x2', '\x1226', 
		'\x1228', '\x5', '\x130', '\x99', '\x2', '\x1227', '\x1223', '\x3', '\x2', 
		'\x2', '\x2', '\x1227', '\x1224', '\x3', '\x2', '\x2', '\x2', '\x1227', 
		'\x1226', '\x3', '\x2', '\x2', '\x2', '\x1227', '\x1228', '\x3', '\x2', 
		'\x2', '\x2', '\x1228', '\x1229', '\x3', '\x2', '\x2', '\x2', '\x1229', 
		'\x122A', '\x5', '\x1E8', '\xF5', '\x2', '\x122A', '\x1E5', '\x3', '\x2', 
		'\x2', '\x2', '\x122B', '\x122C', '\a', '\x14B', '\x2', '\x2', '\x122C', 
		'\x122F', '\a', '\x258', '\x2', '\x2', '\x122D', '\x122F', '\a', '\x17C', 
		'\x2', '\x2', '\x122E', '\x122B', '\x3', '\x2', '\x2', '\x2', '\x122E', 
		'\x122D', '\x3', '\x2', '\x2', '\x2', '\x122F', '\x1E7', '\x3', '\x2', 
		'\x2', '\x2', '\x1230', '\x1231', '\a', '\xFD', '\x2', '\x2', '\x1231', 
		'\x1233', '\x5', '\x490', '\x249', '\x2', '\x1232', '\x1230', '\x3', '\x2', 
		'\x2', '\x2', '\x1232', '\x1233', '\x3', '\x2', '\x2', '\x2', '\x1233', 
		'\x1234', '\x3', '\x2', '\x2', '\x2', '\x1234', '\x1236', '\a', '\x1A9', 
		'\x2', '\x2', '\x1235', '\x1237', '\x5', '\xFC', '\x7F', '\x2', '\x1236', 
		'\x1235', '\x3', '\x2', '\x2', '\x2', '\x1236', '\x1237', '\x3', '\x2', 
		'\x2', '\x2', '\x1237', '\x1E9', '\x3', '\x2', '\x2', '\x2', '\x1238', 
		'\x1239', '\a', '\x219', '\x2', '\x2', '\x1239', '\x123A', '\a', 's', 
		'\x2', '\x2', '\x123A', '\x123B', '\t', '\x1F', '\x2', '\x2', '\x123B', 
		'\x1EB', '\x3', '\x2', '\x2', '\x2', '\x123C', '\x123D', '\a', '\x256', 
		'\x2', '\x2', '\x123D', '\x123E', '\x5', '\x426', '\x214', '\x2', '\x123E', 
		'\x1ED', '\x3', '\x2', '\x2', '\x2', '\x123F', '\x1240', '\a', '\x243', 
		'\x2', '\x2', '\x1240', '\x1241', '\a', '\x108', '\x2', '\x2', '\x1241', 
		'\x1242', '\a', '\x2F2', '\x2', '\x2', '\x1242', '\x1247', '\x5', '\x426', 
		'\x214', '\x2', '\x1243', '\x1244', '\a', '\x2F8', '\x2', '\x2', '\x1244', 
		'\x1246', '\x5', '\x426', '\x214', '\x2', '\x1245', '\x1243', '\x3', '\x2', 
		'\x2', '\x2', '\x1246', '\x1249', '\x3', '\x2', '\x2', '\x2', '\x1247', 
		'\x1245', '\x3', '\x2', '\x2', '\x2', '\x1247', '\x1248', '\x3', '\x2', 
		'\x2', '\x2', '\x1248', '\x124A', '\x3', '\x2', '\x2', '\x2', '\x1249', 
		'\x1247', '\x3', '\x2', '\x2', '\x2', '\x124A', '\x124B', '\a', '\x2F3', 
		'\x2', '\x2', '\x124B', '\x1EF', '\x3', '\x2', '\x2', '\x2', '\x124C', 
		'\x124D', '\a', '\xFA', '\x2', '\x2', '\x124D', '\x124E', '\a', '\x5', 
		'\x2', '\x2', '\x124E', '\x124F', '\a', '\x1C8', '\x2', '\x2', '\x124F', 
		'\x125C', '\x5', '\x1F2', '\xFA', '\x2', '\x1250', '\x1251', '\t', '=', 
		'\x2', '\x2', '\x1251', '\x1252', '\a', '\x1C8', '\x2', '\x2', '\x1252', 
		'\x125C', '\x5', '\x430', '\x219', '\x2', '\x1253', '\x1254', '\a', '\x95', 
		'\x2', '\x2', '\x1254', '\x125A', '\a', '\xE', '\x2', '\x2', '\x1255', 
		'\x1256', '\a', '\xB1', '\x2', '\x2', '\x1256', '\x125A', '\a', '\xE', 
		'\x2', '\x2', '\x1257', '\x1258', '\a', '\x9C', '\x2', '\x2', '\x1258', 
		'\x125A', '\a', '\xE', '\x2', '\x2', '\x1259', '\x1253', '\x3', '\x2', 
		'\x2', '\x2', '\x1259', '\x1255', '\x3', '\x2', '\x2', '\x2', '\x1259', 
		'\x1257', '\x3', '\x2', '\x2', '\x2', '\x125A', '\x125C', '\x3', '\x2', 
		'\x2', '\x2', '\x125B', '\x124C', '\x3', '\x2', '\x2', '\x2', '\x125B', 
		'\x1250', '\x3', '\x2', '\x2', '\x2', '\x125B', '\x1259', '\x3', '\x2', 
		'\x2', '\x2', '\x125C', '\x1F1', '\x3', '\x2', '\x2', '\x2', '\x125D', 
		'\x1260', '\x5', '\x1F4', '\xFB', '\x2', '\x125E', '\x1260', '\x5', '\x1F6', 
		'\xFC', '\x2', '\x125F', '\x125D', '\x3', '\x2', '\x2', '\x2', '\x125F', 
		'\x125E', '\x3', '\x2', '\x2', '\x2', '\x1260', '\x1F3', '\x3', '\x2', 
		'\x2', '\x2', '\x1261', '\x1262', '\x5', '\x12C', '\x97', '\x2', '\x1262', 
		'\x126F', '\t', '>', '\x2', '\x2', '\x1263', '\x1264', '\a', '\n', '\x2', 
		'\x2', '\x1264', '\x1265', '\x5', '\x1F8', '\xFD', '\x2', '\x1265', '\x126B', 
		'\a', '\x195', '\x2', '\x2', '\x1266', '\x1267', '\a', '\x181', '\x2', 
		'\x2', '\x1267', '\x126C', '\a', '\x3', '\x2', '\x2', '\x1268', '\x1269', 
		'\a', '\x181', '\x2', '\x2', '\x1269', '\x126C', '\a', '\x161', '\x2', 
		'\x2', '\x126A', '\x126C', '\a', 's', '\x2', '\x2', '\x126B', '\x1266', 
		'\x3', '\x2', '\x2', '\x2', '\x126B', '\x1268', '\x3', '\x2', '\x2', '\x2', 
		'\x126B', '\x126A', '\x3', '\x2', '\x2', '\x2', '\x126C', '\x1270', '\x3', 
		'\x2', '\x2', '\x2', '\x126D', '\x126E', '\a', '\x19B', '\x2', '\x2', 
		'\x126E', '\x1270', '\x5', '\x43A', '\x21E', '\x2', '\x126F', '\x1263', 
		'\x3', '\x2', '\x2', '\x2', '\x126F', '\x126D', '\x3', '\x2', '\x2', '\x2', 
		'\x1270', '\x127D', '\x3', '\x2', '\x2', '\x2', '\x1271', '\x1272', '\a', 
		'\x209', '\x2', '\x2', '\x1272', '\x1273', '\a', '\x243', '\x2', '\x2', 
		'\x1273', '\x1274', '\a', '`', '\x2', '\x2', '\x1274', '\x1275', '\a', 
		'\b', '\x2', '\x2', '\x1275', '\x1276', '\a', '\x209', '\x2', '\x2', '\x1276', 
		'\x1277', '\a', '\n', '\x2', '\x2', '\x1277', '\x1278', '\x5', '\x1F8', 
		'\xFD', '\x2', '\x1278', '\x1279', '\a', '\x195', '\x2', '\x2', '\x1279', 
		'\x127A', '\a', '\x181', '\x2', '\x2', '\x127A', '\x127B', '\a', '\x161', 
		'\x2', '\x2', '\x127B', '\x127D', '\x3', '\x2', '\x2', '\x2', '\x127C', 
		'\x1261', '\x3', '\x2', '\x2', '\x2', '\x127C', '\x1271', '\x3', '\x2', 
		'\x2', '\x2', '\x127D', '\x1F5', '\x3', '\x2', '\x2', '\x2', '\x127E', 
		'\x127F', '\a', '\x260', '\x2', '\x2', '\x127F', '\x1280', '\a', '\x26E', 
		'\x2', '\x2', '\x1280', '\x1282', '\x5', '\x426', '\x214', '\x2', '\x1281', 
		'\x1283', '\t', '>', '\x2', '\x2', '\x1282', '\x1281', '\x3', '\x2', '\x2', 
		'\x2', '\x1282', '\x1283', '\x3', '\x2', '\x2', '\x2', '\x1283', '\x1284', 
		'\x3', '\x2', '\x2', '\x2', '\x1284', '\x1285', '\a', '\x19B', '\x2', 
		'\x2', '\x1285', '\x1286', '\x5', '\x43A', '\x21E', '\x2', '\x1286', '\x129E', 
		'\x3', '\x2', '\x2', '\x2', '\x1287', '\x1288', '\a', '\x260', '\x2', 
		'\x2', '\x1288', '\x1289', '\a', '\x26E', '\x2', '\x2', '\x1289', '\x128A', 
		'\x5', '\x426', '\x214', '\x2', '\x128A', '\x128B', '\a', '\x1E0', '\x2', 
		'\x2', '\x128B', '\x128D', '\a', '\x19A', '\x2', '\x2', '\x128C', '\x128E', 
		'\t', '>', '\x2', '\x2', '\x128D', '\x128C', '\x3', '\x2', '\x2', '\x2', 
		'\x128D', '\x128E', '\x3', '\x2', '\x2', '\x2', '\x128E', '\x129B', '\x3', 
		'\x2', '\x2', '\x2', '\x128F', '\x1290', '\a', '\n', '\x2', '\x2', '\x1290', 
		'\x1291', '\x5', '\x1F8', '\xFD', '\x2', '\x1291', '\x1297', '\a', '\x195', 
		'\x2', '\x2', '\x1292', '\x1293', '\a', '\x181', '\x2', '\x2', '\x1293', 
		'\x1298', '\a', '\x3', '\x2', '\x2', '\x1294', '\x1295', '\a', '\x181', 
		'\x2', '\x2', '\x1295', '\x1298', '\a', '\x161', '\x2', '\x2', '\x1296', 
		'\x1298', '\a', 's', '\x2', '\x2', '\x1297', '\x1292', '\x3', '\x2', '\x2', 
		'\x2', '\x1297', '\x1294', '\x3', '\x2', '\x2', '\x2', '\x1297', '\x1296', 
		'\x3', '\x2', '\x2', '\x2', '\x1298', '\x129C', '\x3', '\x2', '\x2', '\x2', 
		'\x1299', '\x129A', '\a', '\x19B', '\x2', '\x2', '\x129A', '\x129C', '\x5', 
		'\x43A', '\x21E', '\x2', '\x129B', '\x128F', '\x3', '\x2', '\x2', '\x2', 
		'\x129B', '\x1299', '\x3', '\x2', '\x2', '\x2', '\x129C', '\x129E', '\x3', 
		'\x2', '\x2', '\x2', '\x129D', '\x127E', '\x3', '\x2', '\x2', '\x2', '\x129D', 
		'\x1287', '\x3', '\x2', '\x2', '\x2', '\x129E', '\x1F7', '\x3', '\x2', 
		'\x2', '\x2', '\x129F', '\x12A0', '\x5', '\x4A4', '\x253', '\x2', '\x12A0', 
		'\x12A1', '\t', '?', '\x2', '\x2', '\x12A1', '\x1F9', '\x3', '\x2', '\x2', 
		'\x2', '\x12A2', '\x12A3', '\a', '\x242', '\x2', '\x2', '\x12A3', '\x12A5', 
		'\a', '\x2F2', '\x2', '\x2', '\x12A4', '\x12A6', '\x5', '\x1FC', '\xFF', 
		'\x2', '\x12A5', '\x12A4', '\x3', '\x2', '\x2', '\x2', '\x12A6', '\x12A7', 
		'\x3', '\x2', '\x2', '\x2', '\x12A7', '\x12A5', '\x3', '\x2', '\x2', '\x2', 
		'\x12A7', '\x12A8', '\x3', '\x2', '\x2', '\x2', '\x12A8', '\x12A9', '\x3', 
		'\x2', '\x2', '\x2', '\x12A9', '\x12AA', '\a', '\x2F3', '\x2', '\x2', 
		'\x12AA', '\x1FB', '\x3', '\x2', '\x2', '\x2', '\x12AB', '\x12AC', '\a', 
		'\x109', '\x2', '\x2', '\x12AC', '\x12C3', '\x5', '\x21C', '\x10F', '\x2', 
		'\x12AD', '\x12AE', '\a', '\x171', '\x2', '\x2', '\x12AE', '\x12C3', '\x5', 
		'\x21C', '\x10F', '\x2', '\x12AF', '\x12B0', '\a', '\x157', '\x2', '\x2', 
		'\x12B0', '\x12C3', '\t', '@', '\x2', '\x2', '\x12B1', '\x12B2', '\a', 
		'\x1B8', '\x2', '\x2', '\x12B2', '\x12C3', '\a', '\x2EC', '\x2', '\x2', 
		'\x12B3', '\x12B4', '\a', '\xDF', '\x2', '\x2', '\x12B4', '\x12C3', '\a', 
		'\x2EC', '\x2', '\x2', '\x12B5', '\x12B6', '\a', '\xDE', '\x2', '\x2', 
		'\x12B6', '\x12B7', '\a', '\xEB', '\x2', '\x2', '\x12B7', '\x12C3', '\a', 
		'\x2EC', '\x2', '\x2', '\x12B8', '\x12BB', '\a', '\x19E', '\x2', '\x2', 
		'\x12B9', '\x12BC', '\x5', '\x21C', '\x10F', '\x2', '\x12BA', '\x12BC', 
		'\a', '\x18D', '\x2', '\x2', '\x12BB', '\x12B9', '\x3', '\x2', '\x2', 
		'\x2', '\x12BB', '\x12BA', '\x3', '\x2', '\x2', '\x2', '\x12BC', '\x12C3', 
		'\x3', '\x2', '\x2', '\x2', '\x12BD', '\x12BE', '\a', '<', '\x2', '\x2', 
		'\x12BE', '\x12C3', '\t', '\x41', '\x2', '\x2', '\x12BF', '\x12C0', '\a', 
		'\xD5', '\x2', '\x2', '\x12C0', '\x12C3', '\t', '\x42', '\x2', '\x2', 
		'\x12C1', '\x12C3', '\a', '\xB3', '\x2', '\x2', '\x12C2', '\x12AB', '\x3', 
		'\x2', '\x2', '\x2', '\x12C2', '\x12AD', '\x3', '\x2', '\x2', '\x2', '\x12C2', 
		'\x12AF', '\x3', '\x2', '\x2', '\x2', '\x12C2', '\x12B1', '\x3', '\x2', 
		'\x2', '\x2', '\x12C2', '\x12B3', '\x3', '\x2', '\x2', '\x2', '\x12C2', 
		'\x12B5', '\x3', '\x2', '\x2', '\x2', '\x12C2', '\x12B8', '\x3', '\x2', 
		'\x2', '\x2', '\x12C2', '\x12BD', '\x3', '\x2', '\x2', '\x2', '\x12C2', 
		'\x12BF', '\x3', '\x2', '\x2', '\x2', '\x12C2', '\x12C1', '\x3', '\x2', 
		'\x2', '\x2', '\x12C3', '\x1FD', '\x3', '\x2', '\x2', '\x2', '\x12C4', 
		'\x12C6', '\x5', '\x490', '\x249', '\x2', '\x12C5', '\x12C7', '\x5', '\x456', 
		'\x22C', '\x2', '\x12C6', '\x12C5', '\x3', '\x2', '\x2', '\x2', '\x12C6', 
		'\x12C7', '\x3', '\x2', '\x2', '\x2', '\x12C7', '\x12C9', '\x3', '\x2', 
		'\x2', '\x2', '\x12C8', '\x12CA', '\a', '\x234', '\x2', '\x2', '\x12C9', 
		'\x12C8', '\x3', '\x2', '\x2', '\x2', '\x12C9', '\x12CA', '\x3', '\x2', 
		'\x2', '\x2', '\x12CA', '\x12CC', '\x3', '\x2', '\x2', '\x2', '\x12CB', 
		'\x12CD', '\t', '\x1D', '\x2', '\x2', '\x12CC', '\x12CB', '\x3', '\x2', 
		'\x2', '\x2', '\x12CC', '\x12CD', '\x3', '\x2', '\x2', '\x2', '\x12CD', 
		'\x12E6', '\x3', '\x2', '\x2', '\x2', '\x12CE', '\x12D1', '\a', '\x8F', 
		'\x2', '\x2', '\x12CF', '\x12D0', '\a', '\x19B', '\x2', '\x2', '\x12D0', 
		'\x12D2', '\a', '\x18D', '\x2', '\x2', '\x12D1', '\x12CF', '\x3', '\x2', 
		'\x2', '\x2', '\x12D1', '\x12D2', '\x3', '\x2', '\x2', '\x2', '\x12D2', 
		'\x12D3', '\x3', '\x2', '\x2', '\x2', '\x12D3', '\x12E7', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x12D4', '\x12DC', '\a', '\xE4', '\x2', '\x2', '\x12D5', 
		'\x12DD', '\a', '\x11', '\x2', '\x2', '\x12D6', '\x12D7', '\a', '?', '\x2', 
		'\x2', '\x12D7', '\x12DA', '\a', '\x8F', '\x2', '\x2', '\x12D8', '\x12D9', 
		'\a', '\x19B', '\x2', '\x2', '\x12D9', '\x12DB', '\a', '\x18D', '\x2', 
		'\x2', '\x12DA', '\x12D8', '\x3', '\x2', '\x2', '\x2', '\x12DA', '\x12DB', 
		'\x3', '\x2', '\x2', '\x2', '\x12DB', '\x12DD', '\x3', '\x2', '\x2', '\x2', 
		'\x12DC', '\x12D5', '\x3', '\x2', '\x2', '\x2', '\x12DC', '\x12D6', '\x3', 
		'\x2', '\x2', '\x2', '\x12DC', '\x12DD', '\x3', '\x2', '\x2', '\x2', '\x12DD', 
		'\x12DE', '\x3', '\x2', '\x2', '\x2', '\x12DE', '\x12DF', '\a', '\x19', 
		'\x2', '\x2', '\x12DF', '\x12E4', '\a', '\xF6', '\x2', '\x2', '\x12E0', 
		'\x12E1', '\a', '\x2F2', '\x2', '\x2', '\x12E1', '\x12E2', '\x5', '\x214', 
		'\x10B', '\x2', '\x12E2', '\x12E3', '\a', '\x2F3', '\x2', '\x2', '\x12E3', 
		'\x12E5', '\x3', '\x2', '\x2', '\x2', '\x12E4', '\x12E0', '\x3', '\x2', 
		'\x2', '\x2', '\x12E4', '\x12E5', '\x3', '\x2', '\x2', '\x2', '\x12E5', 
		'\x12E7', '\x3', '\x2', '\x2', '\x2', '\x12E6', '\x12CE', '\x3', '\x2', 
		'\x2', '\x2', '\x12E6', '\x12D4', '\x3', '\x2', '\x2', '\x2', '\x12E6', 
		'\x12E7', '\x3', '\x2', '\x2', '\x2', '\x12E7', '\x12EA', '\x3', '\x2', 
		'\x2', '\x2', '\x12E8', '\x12E9', '\a', '\xB3', '\x2', '\x2', '\x12E9', 
		'\x12EB', '\x5', '\x216', '\x10C', '\x2', '\x12EA', '\x12E8', '\x3', '\x2', 
		'\x2', '\x2', '\x12EA', '\x12EB', '\x3', '\x2', '\x2', '\x2', '\x12EB', 
		'\x12F2', '\x3', '\x2', '\x2', '\x2', '\x12EC', '\x12EE', '\x5', '\xEA', 
		'v', '\x2', '\x12ED', '\x12EC', '\x3', '\x2', '\x2', '\x2', '\x12EE', 
		'\x12EF', '\x3', '\x2', '\x2', '\x2', '\x12EF', '\x12ED', '\x3', '\x2', 
		'\x2', '\x2', '\x12EF', '\x12F0', '\x3', '\x2', '\x2', '\x2', '\x12F0', 
		'\x12F3', '\x3', '\x2', '\x2', '\x2', '\x12F1', '\x12F3', '\x5', '\x218', 
		'\x10D', '\x2', '\x12F2', '\x12ED', '\x3', '\x2', '\x2', '\x2', '\x12F2', 
		'\x12F1', '\x3', '\x2', '\x2', '\x2', '\x12F2', '\x12F3', '\x3', '\x2', 
		'\x2', '\x2', '\x12F3', '\x1FF', '\x3', '\x2', '\x2', '\x2', '\x12F4', 
		'\x12F6', '\x5', '\x490', '\x249', '\x2', '\x12F5', '\x12F7', '\x5', '\x456', 
		'\x22C', '\x2', '\x12F6', '\x12F5', '\x3', '\x2', '\x2', '\x2', '\x12F6', 
		'\x12F7', '\x3', '\x2', '\x2', '\x2', '\x12F7', '\x12F9', '\x3', '\x2', 
		'\x2', '\x2', '\x12F8', '\x12FA', '\a', '\x234', '\x2', '\x2', '\x12F9', 
		'\x12F8', '\x3', '\x2', '\x2', '\x2', '\x12F9', '\x12FA', '\x3', '\x2', 
		'\x2', '\x2', '\x12FA', '\x12FC', '\x3', '\x2', '\x2', '\x2', '\x12FB', 
		'\x12FD', '\t', '\x1D', '\x2', '\x2', '\x12FC', '\x12FB', '\x3', '\x2', 
		'\x2', '\x2', '\x12FC', '\x12FD', '\x3', '\x2', '\x2', '\x2', '\x12FD', 
		'\x1300', '\x3', '\x2', '\x2', '\x2', '\x12FE', '\x12FF', '\a', '\xE4', 
		'\x2', '\x2', '\x12FF', '\x1301', '\a', '\x11', '\x2', '\x2', '\x1300', 
		'\x12FE', '\x3', '\x2', '\x2', '\x2', '\x1300', '\x1301', '\x3', '\x2', 
		'\x2', '\x2', '\x1301', '\x1302', '\x3', '\x2', '\x2', '\x2', '\x1302', 
		'\x1303', '\a', '\x19', '\x2', '\x2', '\x1303', '\x1304', '\a', '\x2F2', 
		'\x2', '\x2', '\x1304', '\x1305', '\x5', '\x202', '\x102', '\x2', '\x1305', 
		'\x1307', '\a', '\x2F3', '\x2', '\x2', '\x1306', '\x1308', '\a', '\x29B', 
		'\x2', '\x2', '\x1307', '\x1306', '\x3', '\x2', '\x2', '\x2', '\x1307', 
		'\x1308', '\x3', '\x2', '\x2', '\x2', '\x1308', '\x130A', '\x3', '\x2', 
		'\x2', '\x2', '\x1309', '\x130B', '\x5', '\x20E', '\x108', '\x2', '\x130A', 
		'\x1309', '\x3', '\x2', '\x2', '\x2', '\x130A', '\x130B', '\x3', '\x2', 
		'\x2', '\x2', '\x130B', '\x130D', '\x3', '\x2', '\x2', '\x2', '\x130C', 
		'\x130E', '\x5', '\x212', '\x10A', '\x2', '\x130D', '\x130C', '\x3', '\x2', 
		'\x2', '\x2', '\x130D', '\x130E', '\x3', '\x2', '\x2', '\x2', '\x130E', 
		'\x1312', '\x3', '\x2', '\x2', '\x2', '\x130F', '\x1311', '\x5', '\xEA', 
		'v', '\x2', '\x1310', '\x130F', '\x3', '\x2', '\x2', '\x2', '\x1311', 
		'\x1314', '\x3', '\x2', '\x2', '\x2', '\x1312', '\x1310', '\x3', '\x2', 
		'\x2', '\x2', '\x1312', '\x1313', '\x3', '\x2', '\x2', '\x2', '\x1313', 
		'\x201', '\x3', '\x2', '\x2', '\x2', '\x1314', '\x1312', '\x3', '\x2', 
		'\x2', '\x2', '\x1315', '\x1318', '\x5', '\x38A', '\x1C6', '\x2', '\x1316', 
		'\x1318', '\x5', '\x388', '\x1C5', '\x2', '\x1317', '\x1315', '\x3', '\x2', 
		'\x2', '\x2', '\x1317', '\x1316', '\x3', '\x2', '\x2', '\x2', '\x1318', 
		'\x203', '\x3', '\x2', '\x2', '\x2', '\x1319', '\x131A', '\a', '\x2EB', 
		'\x2', '\x2', '\x131A', '\x131B', '\a', '\xDD', '\x2', '\x2', '\x131B', 
		'\x1320', '\x5', '\x490', '\x249', '\x2', '\x131C', '\x131D', '\x5', '\x490', 
		'\x249', '\x2', '\x131D', '\x131E', '\a', '\x2F8', '\x2', '\x2', '\x131E', 
		'\x131F', '\x5', '\x490', '\x249', '\x2', '\x131F', '\x1321', '\x3', '\x2', 
		'\x2', '\x2', '\x1320', '\x131C', '\x3', '\x2', '\x2', '\x2', '\x1320', 
		'\x1321', '\x3', '\x2', '\x2', '\x2', '\x1321', '\x205', '\x3', '\x2', 
		'\x2', '\x2', '\x1322', '\x1323', '\a', '\x24B', '\x2', '\x2', '\x1323', 
		'\x1326', '\a', '\x13F', '\x2', '\x2', '\x1324', '\x1327', '\x5', '\x208', 
		'\x105', '\x2', '\x1325', '\x1327', '\x5', '\x20A', '\x106', '\x2', '\x1326', 
		'\x1324', '\x3', '\x2', '\x2', '\x2', '\x1326', '\x1325', '\x3', '\x2', 
		'\x2', '\x2', '\x1327', '\x207', '\x3', '\x2', '\x2', '\x2', '\x1328', 
		'\x1329', '\a', '\xE9', '\x2', '\x2', '\x1329', '\x132A', '\x5', '\x488', 
		'\x245', '\x2', '\x132A', '\x132B', '\a', '\x2F2', '\x2', '\x2', '\x132B', 
		'\x1330', '\x5', '\x20C', '\x107', '\x2', '\x132C', '\x132D', '\a', '\x2F8', 
		'\x2', '\x2', '\x132D', '\x132F', '\x5', '\x20C', '\x107', '\x2', '\x132E', 
		'\x132C', '\x3', '\x2', '\x2', '\x2', '\x132F', '\x1332', '\x3', '\x2', 
		'\x2', '\x2', '\x1330', '\x132E', '\x3', '\x2', '\x2', '\x2', '\x1330', 
		'\x1331', '\x3', '\x2', '\x2', '\x2', '\x1331', '\x1333', '\x3', '\x2', 
		'\x2', '\x2', '\x1332', '\x1330', '\x3', '\x2', '\x2', '\x2', '\x1333', 
		'\x1335', '\a', '\x2F3', '\x2', '\x2', '\x1334', '\x1336', '\a', '\x11', 
		'\x2', '\x2', '\x1335', '\x1334', '\x3', '\x2', '\x2', '\x2', '\x1335', 
		'\x1336', '\x3', '\x2', '\x2', '\x2', '\x1336', '\x209', '\x3', '\x2', 
		'\x2', '\x2', '\x1337', '\x1338', '\a', '~', '\x2', '\x2', '\x1338', '\x133F', 
		'\a', '\x2F2', '\x2', '\x2', '\x1339', '\x1340', '\a', '\xE', '\x2', '\x2', 
		'\x133A', '\x133B', '\a', '\x1D0', '\x2', '\x2', '\x133B', '\x1340', '\a', 
		'\x123', '\x2', '\x2', '\x133C', '\x1340', '\a', '\x280', '\x2', '\x2', 
		'\x133D', '\x133E', '\a', '\xDC', '\x2', '\x2', '\x133E', '\x1340', '\a', 
		'\x123', '\x2', '\x2', '\x133F', '\x1339', '\x3', '\x2', '\x2', '\x2', 
		'\x133F', '\x133A', '\x3', '\x2', '\x2', '\x2', '\x133F', '\x133C', '\x3', 
		'\x2', '\x2', '\x2', '\x133F', '\x133D', '\x3', '\x2', '\x2', '\x2', '\x1340', 
		'\x1341', '\x3', '\x2', '\x2', '\x2', '\x1341', '\x133F', '\x3', '\x2', 
		'\x2', '\x2', '\x1341', '\x1342', '\x3', '\x2', '\x2', '\x2', '\x1342', 
		'\x1343', '\x3', '\x2', '\x2', '\x2', '\x1343', '\x1344', '\a', '\x2F3', 
		'\x2', '\x2', '\x1344', '\x1345', '\a', 'Y', '\x2', '\x2', '\x1345', '\x20B', 
		'\x3', '\x2', '\x2', '\x2', '\x1346', '\x1349', '\x5', '\x490', '\x249', 
		'\x2', '\x1347', '\x1348', '\a', '\x181', '\x2', '\x2', '\x1348', '\x134A', 
		'\a', '\x13F', '\x2', '\x2', '\x1349', '\x1347', '\x3', '\x2', '\x2', 
		'\x2', '\x1349', '\x134A', '\x3', '\x2', '\x2', '\x2', '\x134A', '\x20D', 
		'\x3', '\x2', '\x2', '\x2', '\x134B', '\x134C', '\a', '\xBC', '\x2', '\x2', 
		'\x134C', '\x1353', '\a', '\x28E', '\x2', '\x2', '\x134D', '\x134E', '\a', 
		'w', '\x2', '\x2', '\x134E', '\x1354', '\a', '\xAA', '\x2', '\x2', '\x134F', 
		'\x1350', '\a', '\xAA', '\x2', '\x2', '\x1350', '\x1354', '\x5', '\x210', 
		'\x109', '\x2', '\x1351', '\x1352', '\a', '\x18D', '\x2', '\x2', '\x1352', 
		'\x1354', '\a', '\xAA', '\x2', '\x2', '\x1353', '\x134D', '\x3', '\x2', 
		'\x2', '\x2', '\x1353', '\x134F', '\x3', '\x2', '\x2', '\x2', '\x1353', 
		'\x1351', '\x3', '\x2', '\x2', '\x2', '\x1354', '\x20F', '\x3', '\x2', 
		'\x2', '\x2', '\x1355', '\x1356', '\x5', '\x46E', '\x238', '\x2', '\x1356', 
		'\x211', '\x3', '\x2', '\x2', '\x2', '\x1357', '\x1358', '\a', '\x285', 
		'\x2', '\x2', '\x1358', '\x135D', '\a', ',', '\x2', '\x2', '\x1359', '\x135A', 
		'\a', 'w', '\x2', '\x2', '\x135A', '\x135E', '\a', '\xAA', '\x2', '\x2', 
		'\x135B', '\x135C', '\a', '\xAA', '\x2', '\x2', '\x135C', '\x135E', '\x5', 
		'\x210', '\x109', '\x2', '\x135D', '\x1359', '\x3', '\x2', '\x2', '\x2', 
		'\x135D', '\x135B', '\x3', '\x2', '\x2', '\x2', '\x135E', '\x213', '\x3', 
		'\x2', '\x2', '\x2', '\x135F', '\x1360', '\a', '\xFE', '\x2', '\x2', '\x1360', 
		'\x1364', '\a', '?', '\x2', '\x2', '\x1361', '\x1362', '\a', '\x23C', 
		'\x2', '\x2', '\x1362', '\x1364', '\a', '\x2A6', '\x2', '\x2', '\x1363', 
		'\x135F', '\x3', '\x2', '\x2', '\x2', '\x1363', '\x1361', '\x3', '\x2', 
		'\x2', '\x2', '\x1364', '\x1365', '\x3', '\x2', '\x2', '\x2', '\x1365', 
		'\x1378', '\a', '\x2EC', '\x2', '\x2', '\x1366', '\x1367', '\a', '\x150', 
		'\x2', '\x2', '\x1367', '\x136A', '\a', '\x2EC', '\x2', '\x2', '\x1368', 
		'\x136A', '\a', '\x17D', '\x2', '\x2', '\x1369', '\x1366', '\x3', '\x2', 
		'\x2', '\x2', '\x1369', '\x1368', '\x3', '\x2', '\x2', '\x2', '\x136A', 
		'\x1378', '\x3', '\x2', '\x2', '\x2', '\x136B', '\x136C', '\a', '\x15D', 
		'\x2', '\x2', '\x136C', '\x136F', '\a', '\x2EC', '\x2', '\x2', '\x136D', 
		'\x136F', '\a', '\x17E', '\x2', '\x2', '\x136E', '\x136B', '\x3', '\x2', 
		'\x2', '\x2', '\x136E', '\x136D', '\x3', '\x2', '\x2', '\x2', '\x136F', 
		'\x1378', '\x3', '\x2', '\x2', '\x2', '\x1370', '\x1378', '\t', '\x13', 
		'\x2', '\x2', '\x1371', '\x1372', '\a', '\x41', '\x2', '\x2', '\x1372', 
		'\x1375', '\a', '\x2EC', '\x2', '\x2', '\x1373', '\x1375', '\a', '\x173', 
		'\x2', '\x2', '\x1374', '\x1371', '\x3', '\x2', '\x2', '\x2', '\x1374', 
		'\x1373', '\x3', '\x2', '\x2', '\x2', '\x1375', '\x1378', '\x3', '\x2', 
		'\x2', '\x2', '\x1376', '\x1378', '\t', '\x14', '\x2', '\x2', '\x1377', 
		'\x1363', '\x3', '\x2', '\x2', '\x2', '\x1377', '\x1369', '\x3', '\x2', 
		'\x2', '\x2', '\x1377', '\x136E', '\x3', '\x2', '\x2', '\x2', '\x1377', 
		'\x1370', '\x3', '\x2', '\x2', '\x2', '\x1377', '\x1374', '\x3', '\x2', 
		'\x2', '\x2', '\x1377', '\x1376', '\x3', '\x2', '\x2', '\x2', '\x1378', 
		'\x215', '\x3', '\x2', '\x2', '\x2', '\x1379', '\x137A', '\a', '\x28E', 
		'\x2', '\x2', '\x137A', '\x137C', '\a', '\x2EE', '\x2', '\x2', '\x137B', 
		'\x1379', '\x3', '\x2', '\x2', '\x2', '\x137B', '\x137C', '\x3', '\x2', 
		'\x2', '\x2', '\x137C', '\x1380', '\x3', '\x2', '\x2', '\x2', '\x137D', 
		'\x137E', '\a', '\xF4', '\x2', '\x2', '\x137E', '\x137F', '\a', '?', '\x2', 
		'\x2', '\x137F', '\x1381', '\a', '\x2EE', '\x2', '\x2', '\x1380', '\x137D', 
		'\x3', '\x2', '\x2', '\x2', '\x1380', '\x1381', '\x3', '\x2', '\x2', '\x2', 
		'\x1381', '\x1383', '\x3', '\x2', '\x2', '\x2', '\x1382', '\x1384', '\a', 
		'\x2EE', '\x2', '\x2', '\x1383', '\x1382', '\x3', '\x2', '\x2', '\x2', 
		'\x1383', '\x1384', '\x3', '\x2', '\x2', '\x2', '\x1384', '\x1389', '\x3', 
		'\x2', '\x2', '\x2', '\x1385', '\x1387', '\a', '\x181', '\x2', '\x2', 
		'\x1386', '\x1385', '\x3', '\x2', '\x2', '\x2', '\x1386', '\x1387', '\x3', 
		'\x2', '\x2', '\x2', '\x1387', '\x1388', '\x3', '\x2', '\x2', '\x2', '\x1388', 
		'\x138A', '\a', '\x20C', '\x2', '\x2', '\x1389', '\x1386', '\x3', '\x2', 
		'\x2', '\x2', '\x1389', '\x138A', '\x3', '\x2', '\x2', '\x2', '\x138A', 
		'\x217', '\x3', '\x2', '\x2', '\x2', '\x138B', '\x138C', '\a', '\x214', 
		'\x2', '\x2', '\x138C', '\x138D', '\a', '\x11B', '\x2', '\x2', '\x138D', 
		'\x1399', '\x5', '\x444', '\x223', '\x2', '\x138E', '\x138F', '\a', '\x2A6', 
		'\x2', '\x2', '\x138F', '\x1399', '\a', '\x207', '\x2', '\x2', '\x1390', 
		'\x1392', '\a', '\x65', '\x2', '\x2', '\x1391', '\x1393', '\x5', '\x40C', 
		'\x207', '\x2', '\x1392', '\x1391', '\x3', '\x2', '\x2', '\x2', '\x1392', 
		'\x1393', '\x3', '\x2', '\x2', '\x2', '\x1393', '\x1394', '\x3', '\x2', 
		'\x2', '\x2', '\x1394', '\x1396', '\x5', '\x234', '\x11B', '\x2', '\x1395', 
		'\x1397', '\x5', '\xF0', 'y', '\x2', '\x1396', '\x1395', '\x3', '\x2', 
		'\x2', '\x2', '\x1396', '\x1397', '\x3', '\x2', '\x2', '\x2', '\x1397', 
		'\x1399', '\x3', '\x2', '\x2', '\x2', '\x1398', '\x138B', '\x3', '\x2', 
		'\x2', '\x2', '\x1398', '\x138E', '\x3', '\x2', '\x2', '\x2', '\x1398', 
		'\x1390', '\x3', '\x2', '\x2', '\x2', '\x1399', '\x219', '\x3', '\x2', 
		'\x2', '\x2', '\x139A', '\x139B', '\a', '\x214', '\x2', '\x2', '\x139B', 
		'\x139C', '\a', '\xDD', '\x2', '\x2', '\x139C', '\x139D', '\a', '\x2F2', 
		'\x2', '\x2', '\x139D', '\x139E', '\x5', '\x490', '\x249', '\x2', '\x139E', 
		'\x139F', '\a', '\x2F3', '\x2', '\x2', '\x139F', '\x13A0', '\a', '\x11B', 
		'\x2', '\x2', '\x13A0', '\x13A1', '\x5', '\x444', '\x223', '\x2', '\x13A1', 
		'\x13B5', '\x3', '\x2', '\x2', '\x2', '\x13A2', '\x13A3', '\a', '\x1E9', 
		'\x2', '\x2', '\x13A3', '\x13A4', '\a', '\x2F2', '\x2', '\x2', '\x13A4', 
		'\x13A5', '\x5', '\x490', '\x249', '\x2', '\x13A5', '\x13A6', '\a', '\x2F3', 
		'\x2', '\x2', '\x13A6', '\x13A7', '\a', '\x2A6', '\x2', '\x2', '\x13A7', 
		'\x13A8', '\a', '\x207', '\x2', '\x2', '\x13A8', '\x13B5', '\x3', '\x2', 
		'\x2', '\x2', '\x13A9', '\x13AB', '\a', '\x65', '\x2', '\x2', '\x13AA', 
		'\x13AC', '\x5', '\x40C', '\x207', '\x2', '\x13AB', '\x13AA', '\x3', '\x2', 
		'\x2', '\x2', '\x13AB', '\x13AC', '\x3', '\x2', '\x2', '\x2', '\x13AC', 
		'\x13AD', '\x3', '\x2', '\x2', '\x2', '\x13AD', '\x13AE', '\a', '\xDC', 
		'\x2', '\x2', '\x13AE', '\x13AF', '\a', '\x123', '\x2', '\x2', '\x13AF', 
		'\x13B0', '\x5', '\x44A', '\x226', '\x2', '\x13B0', '\x13B2', '\x5', '\x234', 
		'\x11B', '\x2', '\x13B1', '\x13B3', '\x5', '\xF0', 'y', '\x2', '\x13B2', 
		'\x13B1', '\x3', '\x2', '\x2', '\x2', '\x13B2', '\x13B3', '\x3', '\x2', 
		'\x2', '\x2', '\x13B3', '\x13B5', '\x3', '\x2', '\x2', '\x2', '\x13B4', 
		'\x139A', '\x3', '\x2', '\x2', '\x2', '\x13B4', '\x13A2', '\x3', '\x2', 
		'\x2', '\x2', '\x13B4', '\x13A9', '\x3', '\x2', '\x2', '\x2', '\x13B5', 
		'\x21B', '\x3', '\x2', '\x2', '\x2', '\x13B6', '\x13B8', '\a', '\x2EC', 
		'\x2', '\x2', '\x13B7', '\x13B9', '\a', '\x310', '\x2', '\x2', '\x13B8', 
		'\x13B7', '\x3', '\x2', '\x2', '\x2', '\x13B8', '\x13B9', '\x3', '\x2', 
		'\x2', '\x2', '\x13B9', '\x21D', '\x3', '\x2', '\x2', '\x2', '\x13BA', 
		'\x13BB', '\a', '\xA5', '\x2', '\x2', '\x13BB', '\x13BC', '\a', '\x258', 
		'\x2', '\x2', '\x13BC', '\x13BD', '\x5', '\x416', '\x20C', '\x2', '\x13BD', 
		'\x13BE', '\a', '\x304', '\x2', '\x2', '\x13BE', '\x21F', '\x3', '\x2', 
		'\x2', '\x2', '\x13BF', '\x13C0', '\a', 'Z', '\x2', '\x2', '\x13C0', '\x13C1', 
		'\a', '\x19B', '\x2', '\x2', '\x13C1', '\x13C2', '\a', 'X', '\x2', '\x2', 
		'\x13C2', '\x13C3', '\x5', '\x416', '\x20C', '\x2', '\x13C3', '\x13C4', 
		'\a', '\x2EB', '\x2', '\x2', '\x13C4', '\x13C5', '\x5', '\x490', '\x249', 
		'\x2', '\x13C5', '\x13C6', '\a', '\x11B', '\x2', '\x2', '\x13C6', '\x13C7', 
		'\x5', '\x4AA', '\x256', '\x2', '\x13C7', '\x221', '\x3', '\x2', '\x2', 
		'\x2', '\x13C8', '\x13CB', '\a', 'r', '\x2', '\x2', '\x13C9', '\x13CA', 
		'\a', '\x1A4', '\x2', '\x2', '\x13CA', '\x13CC', '\a', '\x1F1', '\x2', 
		'\x2', '\x13CB', '\x13C9', '\x3', '\x2', '\x2', '\x2', '\x13CB', '\x13CC', 
		'\x3', '\x2', '\x2', '\x2', '\x13CC', '\x13CE', '\x3', '\x2', '\x2', '\x2', 
		'\x13CD', '\x13CF', '\t', '\x43', '\x2', '\x2', '\x13CE', '\x13CD', '\x3', 
		'\x2', '\x2', '\x2', '\x13CE', '\x13CF', '\x3', '\x2', '\x2', '\x2', '\x13CF', 
		'\x13D1', '\x3', '\x2', '\x2', '\x2', '\x13D0', '\x13D2', '\a', '\x1D9', 
		'\x2', '\x2', '\x13D1', '\x13D0', '\x3', '\x2', '\x2', '\x2', '\x13D1', 
		'\x13D2', '\x3', '\x2', '\x2', '\x2', '\x13D2', '\x13D3', '\x3', '\x2', 
		'\x2', '\x2', '\x13D3', '\x13D7', '\a', '\x24D', '\x2', '\x2', '\x13D4', 
		'\x13D5', '\x5', '\x482', '\x242', '\x2', '\x13D5', '\x13D6', '\a', '\x2EB', 
		'\x2', '\x2', '\x13D6', '\x13D8', '\x3', '\x2', '\x2', '\x2', '\x13D7', 
		'\x13D4', '\x3', '\x2', '\x2', '\x2', '\x13D7', '\x13D8', '\x3', '\x2', 
		'\x2', '\x2', '\x13D8', '\x13D9', '\x3', '\x2', '\x2', '\x2', '\x13D9', 
		'\x13DA', '\x5', '\x470', '\x239', '\x2', '\x13DA', '\x13DE', '\a', '\xDD', 
		'\x2', '\x2', '\x13DB', '\x13DC', '\x5', '\x482', '\x242', '\x2', '\x13DC', 
		'\x13DD', '\a', '\x2EB', '\x2', '\x2', '\x13DD', '\x13DF', '\x3', '\x2', 
		'\x2', '\x2', '\x13DE', '\x13DB', '\x3', '\x2', '\x2', '\x2', '\x13DE', 
		'\x13DF', '\x3', '\x2', '\x2', '\x2', '\x13DF', '\x13E0', '\x3', '\x2', 
		'\x2', '\x2', '\x13E0', '\x13E3', '\x5', '\x42C', '\x217', '\x2', '\x13E1', 
		'\x13E2', '\a', '\x2FA', '\x2', '\x2', '\x13E2', '\x13E4', '\x5', '\x414', 
		'\x20B', '\x2', '\x13E3', '\x13E1', '\x3', '\x2', '\x2', '\x2', '\x13E3', 
		'\x13E4', '\x3', '\x2', '\x2', '\x2', '\x13E4', '\x223', '\x3', '\x2', 
		'\x2', '\x2', '\x13E5', '\x13E6', '\a', 'Z', '\x2', '\x2', '\x13E6', '\x13E7', 
		'\a', '\x19B', '\x2', '\x2', '\x13E7', '\x13E8', '\a', '\x258', '\x2', 
		'\x2', '\x13E8', '\x13E9', '\x5', '\x416', '\x20C', '\x2', '\x13E9', '\x13EA', 
		'\a', '\x11B', '\x2', '\x2', '\x13EA', '\x13EB', '\x5', '\x4AA', '\x256', 
		'\x2', '\x13EB', '\x225', '\x3', '\x2', '\x2', '\x2', '\x13EC', '\x13ED', 
		'\a', '\x10', '\x2', '\x2', '\x13ED', '\x13EE', '\a', '\x258', '\x2', 
		'\x2', '\x13EE', '\x13F3', '\x5', '\x416', '\x20C', '\x2', '\x13EF', '\x13F4', 
		'\x5', '\x228', '\x115', '\x2', '\x13F0', '\x13F4', '\x5', '\x22C', '\x117', 
		'\x2', '\x13F1', '\x13F4', '\x5', '\x22E', '\x118', '\x2', '\x13F2', '\x13F4', 
		'\x5', '\x230', '\x119', '\x2', '\x13F3', '\x13EF', '\x3', '\x2', '\x2', 
		'\x2', '\x13F3', '\x13F0', '\x3', '\x2', '\x2', '\x2', '\x13F3', '\x13F1', 
		'\x3', '\x2', '\x2', '\x2', '\x13F3', '\x13F2', '\x3', '\x2', '\x2', '\x2', 
		'\x13F4', '\x227', '\x3', '\x2', '\x2', '\x2', '\x13F5', '\x13F8', '\a', 
		'\x5', '\x2', '\x2', '\x13F6', '\x13F7', '\a', '\x65', '\x2', '\x2', '\x13F7', 
		'\x13F9', '\x5', '\x40C', '\x207', '\x2', '\x13F8', '\x13F6', '\x3', '\x2', 
		'\x2', '\x2', '\x13F8', '\x13F9', '\x3', '\x2', '\x2', '\x2', '\x13F9', 
		'\x13FE', '\x3', '\x2', '\x2', '\x2', '\x13FA', '\x13FF', '\x5', '\x238', 
		'\x11D', '\x2', '\x13FB', '\x13FF', '\x5', '\x232', '\x11A', '\x2', '\x13FC', 
		'\x13FF', '\x5', '\x236', '\x11C', '\x2', '\x13FD', '\x13FF', '\x5', '\x22A', 
		'\x116', '\x2', '\x13FE', '\x13FA', '\x3', '\x2', '\x2', '\x2', '\x13FE', 
		'\x13FB', '\x3', '\x2', '\x2', '\x2', '\x13FE', '\x13FC', '\x3', '\x2', 
		'\x2', '\x2', '\x13FE', '\x13FD', '\x3', '\x2', '\x2', '\x2', '\x13FF', 
		'\x229', '\x3', '\x2', '\x2', '\x2', '\x1400', '\x1401', '\a', 'M', '\x2', 
		'\x2', '\x1401', '\x1402', '\a', '\x2F2', '\x2', '\x2', '\x1402', '\x1403', 
		'\x5', '\x37A', '\x1BE', '\x2', '\x1403', '\x1405', '\a', '\x2F3', '\x2', 
		'\x2', '\x1404', '\x1406', '\a', '\x9C', '\x2', '\x2', '\x1405', '\x1404', 
		'\x3', '\x2', '\x2', '\x2', '\x1405', '\x1406', '\x3', '\x2', '\x2', '\x2', 
		'\x1406', '\x22B', '\x3', '\x2', '\x2', '\x2', '\x1407', '\x1408', '\a', 
		'\xA5', '\x2', '\x2', '\x1408', '\x1409', '\a', '\x65', '\x2', '\x2', 
		'\x1409', '\x140A', '\x5', '\x40C', '\x207', '\x2', '\x140A', '\x22D', 
		'\x3', '\x2', '\x2', '\x2', '\x140B', '\x140C', '\a', '\xB1', '\x2', '\x2', 
		'\x140C', '\x140D', '\a', '\x65', '\x2', '\x2', '\x140D', '\x140E', '\x5', 
		'\x40C', '\x207', '\x2', '\x140E', '\x22F', '\x3', '\x2', '\x2', '\x2', 
		'\x140F', '\x1410', '\a', '\x9C', '\x2', '\x2', '\x1410', '\x1411', '\a', 
		'\x65', '\x2', '\x2', '\x1411', '\x1412', '\x5', '\x40C', '\x207', '\x2', 
		'\x1412', '\x231', '\x3', '\x2', '\x2', '\x2', '\x1413', '\x1414', '\a', 
		'\xDC', '\x2', '\x2', '\x1414', '\x1415', '\a', '\x123', '\x2', '\x2', 
		'\x1415', '\x1416', '\x5', '\x44A', '\x226', '\x2', '\x1416', '\x1417', 
		'\x5', '\x234', '\x11B', '\x2', '\x1417', '\x233', '\x3', '\x2', '\x2', 
		'\x2', '\x1418', '\x1419', '\a', '\x1E7', '\x2', '\x2', '\x1419', '\x141A', 
		'\x5', '\x416', '\x20C', '\x2', '\x141A', '\x1422', '\x5', '\x44A', '\x226', 
		'\x2', '\x141B', '\x141C', '\a', '\x19B', '\x2', '\x2', '\x141C', '\x1420', 
		'\a', '\x95', '\x2', '\x2', '\x141D', '\x1421', '\a', '\x45', '\x2', '\x2', 
		'\x141E', '\x141F', '\a', '\x223', '\x2', '\x2', '\x141F', '\x1421', '\a', 
		'\x18D', '\x2', '\x2', '\x1420', '\x141D', '\x3', '\x2', '\x2', '\x2', 
		'\x1420', '\x141E', '\x3', '\x2', '\x2', '\x2', '\x1421', '\x1423', '\x3', 
		'\x2', '\x2', '\x2', '\x1422', '\x141B', '\x3', '\x2', '\x2', '\x2', '\x1422', 
		'\x1423', '\x3', '\x2', '\x2', '\x2', '\x1423', '\x235', '\x3', '\x2', 
		'\x2', '\x2', '\x1424', '\x1425', '\a', '\x280', '\x2', '\x2', '\x1425', 
		'\x1426', '\x5', '\x44A', '\x226', '\x2', '\x1426', '\x237', '\x3', '\x2', 
		'\x2', '\x2', '\x1427', '\x1428', '\a', '\x1D0', '\x2', '\x2', '\x1428', 
		'\x1429', '\a', '\x123', '\x2', '\x2', '\x1429', '\x142A', '\x5', '\x44A', 
		'\x226', '\x2', '\x142A', '\x239', '\x3', '\x2', '\x2', '\x2', '\x142B', 
		'\x142C', '\a', '\x8A', '\x2', '\x2', '\x142C', '\x142E', '\x5', '\x24E', 
		'\x128', '\x2', '\x142D', '\x142B', '\x3', '\x2', '\x2', '\x2', '\x142D', 
		'\x142E', '\x3', '\x2', '\x2', '\x2', '\x142E', '\x142F', '\x3', '\x2', 
		'\x2', '\x2', '\x142F', '\x1430', '\a', '-', '\x2', '\x2', '\x1430', '\x1437', 
		'\x5', '\x26C', '\x137', '\x2', '\x1431', '\x1433', '\a', '\xBE', '\x2', 
		'\x2', '\x1432', '\x1434', '\x5', '\x29C', '\x14F', '\x2', '\x1433', '\x1432', 
		'\x3', '\x2', '\x2', '\x2', '\x1434', '\x1435', '\x3', '\x2', '\x2', '\x2', 
		'\x1435', '\x1433', '\x3', '\x2', '\x2', '\x2', '\x1435', '\x1436', '\x3', 
		'\x2', '\x2', '\x2', '\x1436', '\x1438', '\x3', '\x2', '\x2', '\x2', '\x1437', 
		'\x1431', '\x3', '\x2', '\x2', '\x2', '\x1437', '\x1438', '\x3', '\x2', 
		'\x2', '\x2', '\x1438', '\x1439', '\x3', '\x2', '\x2', '\x2', '\x1439', 
		'\x143A', '\a', '\xB5', '\x2', '\x2', '\x143A', '\x143B', '\a', '\x304', 
		'\x2', '\x2', '\x143B', '\x23B', '\x3', '\x2', '\x2', '\x2', '\x143C', 
		'\x143D', '\a', '!', '\x2', '\x2', '\x143D', '\x143E', '\t', '\x44', '\x2', 
		'\x2', '\x143E', '\x23D', '\x3', '\x2', '\x2', '\x2', '\x143F', '\x1440', 
		'\x5', '\x46E', '\x238', '\x2', '\x1440', '\x1441', '\a', '\x306', '\x2', 
		'\x2', '\x1441', '\x1442', '\x5', '\x37E', '\x1C0', '\x2', '\x1442', '\x23F', 
		'\x3', '\x2', '\x2', '\x2', '\x1443', '\x1446', '\a', '\x124', '\x2', 
		'\x2', '\x1444', '\x1447', '\x5', '\x242', '\x122', '\x2', '\x1445', '\x1447', 
		'\x5', '\x244', '\x123', '\x2', '\x1446', '\x1444', '\x3', '\x2', '\x2', 
		'\x2', '\x1446', '\x1445', '\x3', '\x2', '\x2', '\x2', '\x1447', '\x241', 
		'\x3', '\x2', '\x2', '\x2', '\x1448', '\x1449', '\a', '\x11E', '\x2', 
		'\x2', '\x1449', '\x144A', '\a', '\x167', '\x2', '\x2', '\x144A', '\x144B', 
		'\a', '\x2EE', '\x2', '\x2', '\x144B', '\x243', '\x3', '\x2', '\x2', '\x2', 
		'\x144C', '\x144F', '\a', 'Q', '\x2', '\x2', '\x144D', '\x144E', '\a', 
		'\x167', '\x2', '\x2', '\x144E', '\x1450', '\a', '\x2EE', '\x2', '\x2', 
		'\x144F', '\x144D', '\x3', '\x2', '\x2', '\x2', '\x144F', '\x1450', '\x3', 
		'\x2', '\x2', '\x2', '\x1450', '\x1451', '\x3', '\x2', '\x2', '\x2', '\x1451', 
		'\x1452', '\a', '\x12C', '\x2', '\x2', '\x1452', '\x1454', '\x5', '\x46E', 
		'\x238', '\x2', '\x1453', '\x1455', '\x5', '\x246', '\x124', '\x2', '\x1454', 
		'\x1453', '\x3', '\x2', '\x2', '\x2', '\x1454', '\x1455', '\x3', '\x2', 
		'\x2', '\x2', '\x1455', '\x1458', '\x3', '\x2', '\x2', '\x2', '\x1456', 
		'\x1457', '\a', '\x2A6', '\x2', '\x2', '\x1457', '\x1459', '\a', 'k', 
		'\x2', '\x2', '\x1458', '\x1456', '\x3', '\x2', '\x2', '\x2', '\x1458', 
		'\x1459', '\x3', '\x2', '\x2', '\x2', '\x1459', '\x145B', '\x3', '\x2', 
		'\x2', '\x2', '\x145A', '\x145C', '\x5', '\x248', '\x125', '\x2', '\x145B', 
		'\x145A', '\x3', '\x2', '\x2', '\x2', '\x145B', '\x145C', '\x3', '\x2', 
		'\x2', '\x2', '\x145C', '\x245', '\x3', '\x2', '\x2', '\x2', '\x145D', 
		'\x145E', '\a', '\v', '\x2', '\x2', '\x145E', '\x145F', '\a', '\x108', 
		'\x2', '\x2', '\x145F', '\x1460', '\a', '\x2F2', '\x2', '\x2', '\x1460', 
		'\x1461', '\x5', '\x37C', '\x1BF', '\x2', '\x1461', '\x1462', '\a', '\x2F3', 
		'\x2', '\x2', '\x1462', '\x247', '\x3', '\x2', '\x2', '\x2', '\x1463', 
		'\x1464', '\a', '\x1AF', '\x2', '\x2', '\x1464', '\x1469', '\a', '\x2F2', 
		'\x2', '\x2', '\x1465', '\x146A', '\x5', '\x37C', '\x1BF', '\x2', '\x1466', 
		'\x1467', '\a', '\x2EB', '\x2', '\x2', '\x1467', '\x1468', '\a', '\x2EB', 
		'\x2', '\x2', '\x1468', '\x146A', '\a', '\x2EB', '\x2', '\x2', '\x1469', 
		'\x1465', '\x3', '\x2', '\x2', '\x2', '\x1469', '\x1466', '\x3', '\x2', 
		'\x2', '\x2', '\x146A', '\x146B', '\x3', '\x2', '\x2', '\x2', '\x146B', 
		'\x146C', '\a', '\x2F3', '\x2', '\x2', '\x146C', '\x249', '\x3', '\x2', 
		'\x2', '\x2', '\x146D', '\x1471', '\x5', '\x474', '\x23B', '\x2', '\x146E', 
		'\x1470', '\t', '\x45', '\x2', '\x2', '\x146F', '\x146E', '\x3', '\x2', 
		'\x2', '\x2', '\x1470', '\x1473', '\x3', '\x2', '\x2', '\x2', '\x1471', 
		'\x146F', '\x3', '\x2', '\x2', '\x2', '\x1471', '\x1472', '\x3', '\x2', 
		'\x2', '\x2', '\x1472', '\x1475', '\x3', '\x2', '\x2', '\x2', '\x1473', 
		'\x1471', '\x3', '\x2', '\x2', '\x2', '\x1474', '\x1476', '\x5', '\x454', 
		'\x22B', '\x2', '\x1475', '\x1474', '\x3', '\x2', '\x2', '\x2', '\x1475', 
		'\x1476', '\x3', '\x2', '\x2', '\x2', '\x1476', '\x1478', '\x3', '\x2', 
		'\x2', '\x2', '\x1477', '\x1479', '\x5', '\x24C', '\x127', '\x2', '\x1478', 
		'\x1477', '\x3', '\x2', '\x2', '\x2', '\x1478', '\x1479', '\x3', '\x2', 
		'\x2', '\x2', '\x1479', '\x24B', '\x3', '\x2', '\x2', '\x2', '\x147A', 
		'\x147B', '\t', '\x46', '\x2', '\x2', '\x147B', '\x147C', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x147C', '\x24D', '\x3', '\x2', '\x2', '\x2', '\x147D', 
		'\x147F', '\x5', '\x250', '\x129', '\x2', '\x147E', '\x147D', '\x3', '\x2', 
		'\x2', '\x2', '\x147F', '\x1480', '\x3', '\x2', '\x2', '\x2', '\x1480', 
		'\x147E', '\x3', '\x2', '\x2', '\x2', '\x1480', '\x1481', '\x3', '\x2', 
		'\x2', '\x2', '\x1481', '\x24F', '\x3', '\x2', '\x2', '\x2', '\x1482', 
		'\x148D', '\x5', '\x252', '\x12A', '\x2', '\x1483', '\x148D', '\x5', '\x254', 
		'\x12B', '\x2', '\x1484', '\x148D', '\x5', '\x256', '\x12C', '\x2', '\x1485', 
		'\x148D', '\x5', '\x25A', '\x12E', '\x2', '\x1486', '\x148D', '\x5', '\x25C', 
		'\x12F', '\x2', '\x1487', '\x148D', '\x5', '\x25E', '\x130', '\x2', '\x1488', 
		'\x148D', '\x5', ' ', '\x11', '\x2', '\x1489', '\x148D', '\x5', '\"', 
		'\x12', '\x2', '\x148A', '\x148D', '\x5', ',', '\x17', '\x2', '\x148B', 
		'\x148D', '\x5', '*', '\x16', '\x2', '\x148C', '\x1482', '\x3', '\x2', 
		'\x2', '\x2', '\x148C', '\x1483', '\x3', '\x2', '\x2', '\x2', '\x148C', 
		'\x1484', '\x3', '\x2', '\x2', '\x2', '\x148C', '\x1485', '\x3', '\x2', 
		'\x2', '\x2', '\x148C', '\x1486', '\x3', '\x2', '\x2', '\x2', '\x148C', 
		'\x1487', '\x3', '\x2', '\x2', '\x2', '\x148C', '\x1488', '\x3', '\x2', 
		'\x2', '\x2', '\x148C', '\x1489', '\x3', '\x2', '\x2', '\x2', '\x148C', 
		'\x148A', '\x3', '\x2', '\x2', '\x2', '\x148C', '\x148B', '\x3', '\x2', 
		'\x2', '\x2', '\x148D', '\x251', '\x3', '\x2', '\x2', '\x2', '\x148E', 
		'\x1490', '\x5', '\x46E', '\x238', '\x2', '\x148F', '\x1491', '\a', '\x64', 
		'\x2', '\x2', '\x1490', '\x148F', '\x3', '\x2', '\x2', '\x2', '\x1490', 
		'\x1491', '\x3', '\x2', '\x2', '\x2', '\x1491', '\x1492', '\x3', '\x2', 
		'\x2', '\x2', '\x1492', '\x1495', '\x5', '\x454', '\x22B', '\x2', '\x1493', 
		'\x1494', '\a', '\x18A', '\x2', '\x2', '\x1494', '\x1496', '\a', '\x18D', 
		'\x2', '\x2', '\x1495', '\x1493', '\x3', '\x2', '\x2', '\x2', '\x1495', 
		'\x1496', '\x3', '\x2', '\x2', '\x2', '\x1496', '\x1498', '\x3', '\x2', 
		'\x2', '\x2', '\x1497', '\x1499', '\x5', '\x24C', '\x127', '\x2', '\x1498', 
		'\x1497', '\x3', '\x2', '\x2', '\x2', '\x1498', '\x1499', '\x3', '\x2', 
		'\x2', '\x2', '\x1499', '\x149A', '\x3', '\x2', '\x2', '\x2', '\x149A', 
		'\x149B', '\a', '\x304', '\x2', '\x2', '\x149B', '\x253', '\x3', '\x2', 
		'\x2', '\x2', '\x149C', '\x149D', '\a', '\x249', '\x2', '\x2', '\x149D', 
		'\x149E', '\x5', '\x46E', '\x238', '\x2', '\x149E', '\x149F', '\a', '\x11B', 
		'\x2', '\x2', '\x149F', '\x14A5', '\x5', '\x454', '\x22B', '\x2', '\x14A0', 
		'\x14A1', '\a', '\x1DE', '\x2', '\x2', '\x14A1', '\x14A2', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x14A2', '\x14A3', '\a', '\x2EA', '\x2', '\x2', '\x14A3', 
		'\x14A4', '\x5', '\x37E', '\x1C0', '\x2', '\x14A4', '\x14A6', '\x3', '\x2', 
		'\x2', '\x2', '\x14A5', '\x14A0', '\x3', '\x2', '\x2', '\x2', '\x14A5', 
		'\x14A6', '\x3', '\x2', '\x2', '\x2', '\x14A6', '\x14A9', '\x3', '\x2', 
		'\x2', '\x2', '\x14A7', '\x14A8', '\a', '\x18A', '\x2', '\x2', '\x14A8', 
		'\x14AA', '\a', '\x18D', '\x2', '\x2', '\x14A9', '\x14A7', '\x3', '\x2', 
		'\x2', '\x2', '\x14A9', '\x14AA', '\x3', '\x2', '\x2', '\x2', '\x14AA', 
		'\x14AB', '\x3', '\x2', '\x2', '\x2', '\x14AB', '\x14AC', '\a', '\x304', 
		'\x2', '\x2', '\x14AC', '\x255', '\x3', '\x2', '\x2', '\x2', '\x14AD', 
		'\x14AE', '\a', 'z', '\x2', '\x2', '\x14AE', '\x14BA', '\x5', '\x46E', 
		'\x238', '\x2', '\x14AF', '\x14B4', '\a', '\x2F2', '\x2', '\x2', '\x14B0', 
		'\x14B2', '\a', '\x2F8', '\x2', '\x2', '\x14B1', '\x14B0', '\x3', '\x2', 
		'\x2', '\x2', '\x14B1', '\x14B2', '\x3', '\x2', '\x2', '\x2', '\x14B2', 
		'\x14B3', '\x3', '\x2', '\x2', '\x2', '\x14B3', '\x14B5', '\x5', '\x258', 
		'\x12D', '\x2', '\x14B4', '\x14B1', '\x3', '\x2', '\x2', '\x2', '\x14B5', 
		'\x14B6', '\x3', '\x2', '\x2', '\x2', '\x14B6', '\x14B4', '\x3', '\x2', 
		'\x2', '\x2', '\x14B6', '\x14B7', '\x3', '\x2', '\x2', '\x2', '\x14B7', 
		'\x14B8', '\x3', '\x2', '\x2', '\x2', '\x14B8', '\x14B9', '\a', '\x2F3', 
		'\x2', '\x2', '\x14B9', '\x14BB', '\x3', '\x2', '\x2', '\x2', '\x14BA', 
		'\x14AF', '\x3', '\x2', '\x2', '\x2', '\x14BA', '\x14BB', '\x3', '\x2', 
		'\x2', '\x2', '\x14BB', '\x14BE', '\x3', '\x2', '\x2', '\x2', '\x14BC', 
		'\x14BD', '\a', '\x1FC', '\x2', '\x2', '\x14BD', '\x14BF', '\x5', '\x454', 
		'\x22B', '\x2', '\x14BE', '\x14BC', '\x3', '\x2', '\x2', '\x2', '\x14BE', 
		'\x14BF', '\x3', '\x2', '\x2', '\x2', '\x14BF', '\x14C2', '\x3', '\x2', 
		'\x2', '\x2', '\x14C0', '\x14C1', '\a', '\x11B', '\x2', '\x2', '\x14C1', 
		'\x14C3', '\x5', '\x2C4', '\x163', '\x2', '\x14C2', '\x14C0', '\x3', '\x2', 
		'\x2', '\x2', '\x14C2', '\x14C3', '\x3', '\x2', '\x2', '\x2', '\x14C3', 
		'\x14C4', '\x3', '\x2', '\x2', '\x2', '\x14C4', '\x14C5', '\a', '\x304', 
		'\x2', '\x2', '\x14C5', '\x257', '\x3', '\x2', '\x2', '\x2', '\x14C6', 
		'\x14CB', '\x5', '\x474', '\x23B', '\x2', '\x14C7', '\x14C9', '\a', '\x108', 
		'\x2', '\x2', '\x14C8', '\x14C7', '\x3', '\x2', '\x2', '\x2', '\x14C8', 
		'\x14C9', '\x3', '\x2', '\x2', '\x2', '\x14C9', '\x14CA', '\x3', '\x2', 
		'\x2', '\x2', '\x14CA', '\x14CC', '\x5', '\x454', '\x22B', '\x2', '\x14CB', 
		'\x14C8', '\x3', '\x2', '\x2', '\x2', '\x14CB', '\x14CC', '\x3', '\x2', 
		'\x2', '\x2', '\x14CC', '\x14CE', '\x3', '\x2', '\x2', '\x2', '\x14CD', 
		'\x14CF', '\x5', '\x24C', '\x127', '\x2', '\x14CE', '\x14CD', '\x3', '\x2', 
		'\x2', '\x2', '\x14CE', '\x14CF', '\x3', '\x2', '\x2', '\x2', '\x14CF', 
		'\x259', '\x3', '\x2', '\x2', '\x2', '\x14D0', '\x14D1', '\x5', '\x46E', 
		'\x238', '\x2', '\x14D1', '\x14D2', '\a', '\xBE', '\x2', '\x2', '\x14D2', 
		'\x14D3', '\a', '\x304', '\x2', '\x2', '\x14D3', '\x25B', '\x3', '\x2', 
		'\x2', '\x2', '\x14D4', '\x14F3', '\a', '\x1CB', '\x2', '\x2', '\x14D5', 
		'\x14F4', '\a', '\x21F', '\x2', '\x2', '\x14D6', '\x14F4', '\a', '&', 
		'\x2', '\x2', '\x14D7', '\x14D8', '\a', '\xBF', '\x2', '\x2', '\x14D8', 
		'\x14D9', '\a', '\x2F2', '\x2', '\x2', '\x14D9', '\x14DA', '\x5', '\x48E', 
		'\x248', '\x2', '\x14DA', '\x14DB', '\a', '\x2F8', '\x2', '\x2', '\x14DB', 
		'\x14DC', '\x5', '\x4A8', '\x255', '\x2', '\x14DC', '\x14DD', '\a', '\x2F3', 
		'\x2', '\x2', '\x14DD', '\x14F4', '\x3', '\x2', '\x2', '\x2', '\x14DE', 
		'\x14DF', '\a', '\x10C', '\x2', '\x2', '\x14DF', '\x14E0', '\a', '\x2F2', 
		'\x2', '\x2', '\x14E0', '\x14E1', '\x5', '\x46E', '\x238', '\x2', '\x14E1', 
		'\x14E2', '\a', '\x2F8', '\x2', '\x2', '\x14E2', '\x14E3', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x14E3', '\x14E4', '\a', '\x2F3', '\x2', '\x2', '\x14E4', 
		'\x14F4', '\x3', '\x2', '\x2', '\x2', '\x14E5', '\x14E6', '\a', '\x1F6', 
		'\x2', '\x2', '\x14E6', '\x14E9', '\a', '\x2F2', '\x2', '\x2', '\x14E7', 
		'\x14EA', '\x5', '\x46E', '\x238', '\x2', '\x14E8', '\x14EA', '\a', '\x8F', 
		'\x2', '\x2', '\x14E9', '\x14E7', '\x3', '\x2', '\x2', '\x2', '\x14E9', 
		'\x14E8', '\x3', '\x2', '\x2', '\x2', '\x14EA', '\x14ED', '\x3', '\x2', 
		'\x2', '\x2', '\x14EB', '\x14EC', '\a', '\x2F8', '\x2', '\x2', '\x14EC', 
		'\x14EE', '\x5', '\x46E', '\x238', '\x2', '\x14ED', '\x14EB', '\x3', '\x2', 
		'\x2', '\x2', '\x14EE', '\x14EF', '\x3', '\x2', '\x2', '\x2', '\x14EF', 
		'\x14ED', '\x3', '\x2', '\x2', '\x2', '\x14EF', '\x14F0', '\x3', '\x2', 
		'\x2', '\x2', '\x14F0', '\x14F1', '\x3', '\x2', '\x2', '\x2', '\x14F1', 
		'\x14F2', '\a', '\x2F3', '\x2', '\x2', '\x14F2', '\x14F4', '\x3', '\x2', 
		'\x2', '\x2', '\x14F3', '\x14D5', '\x3', '\x2', '\x2', '\x2', '\x14F3', 
		'\x14D6', '\x3', '\x2', '\x2', '\x2', '\x14F3', '\x14D7', '\x3', '\x2', 
		'\x2', '\x2', '\x14F3', '\x14DE', '\x3', '\x2', '\x2', '\x2', '\x14F3', 
		'\x14E5', '\x3', '\x2', '\x2', '\x2', '\x14F4', '\x14F5', '\x3', '\x2', 
		'\x2', '\x2', '\x14F5', '\x14F6', '\a', '\x304', '\x2', '\x2', '\x14F6', 
		'\x25D', '\x3', '\x2', '\x2', '\x2', '\x14F7', '\x14F8', '\a', '\x27A', 
		'\x2', '\x2', '\x14F8', '\x14F9', '\x5', '\x46E', '\x238', '\x2', '\x14F9', 
		'\x14FE', '\a', '\x11B', '\x2', '\x2', '\x14FA', '\x14FF', '\x5', '\x262', 
		'\x132', '\x2', '\x14FB', '\x14FF', '\x5', '\x266', '\x134', '\x2', '\x14FC', 
		'\x14FF', '\x5', '\x268', '\x135', '\x2', '\x14FD', '\x14FF', '\x5', '\x260', 
		'\x131', '\x2', '\x14FE', '\x14FA', '\x3', '\x2', '\x2', '\x2', '\x14FE', 
		'\x14FB', '\x3', '\x2', '\x2', '\x2', '\x14FE', '\x14FC', '\x3', '\x2', 
		'\x2', '\x2', '\x14FE', '\x14FD', '\x3', '\x2', '\x2', '\x2', '\x14FF', 
		'\x1500', '\x3', '\x2', '\x2', '\x2', '\x1500', '\x1501', '\a', '\x304', 
		'\x2', '\x2', '\x1501', '\x25F', '\x3', '\x2', '\x2', '\x2', '\x1502', 
		'\x1503', '\a', '\x1E9', '\x2', '\x2', '\x1503', '\x1506', '\a', 'z', 
		'\x2', '\x2', '\x1504', '\x1505', '\a', '\x1FC', '\x2', '\x2', '\x1505', 
		'\x1507', '\x5', '\x454', '\x22B', '\x2', '\x1506', '\x1504', '\x3', '\x2', 
		'\x2', '\x2', '\x1506', '\x1507', '\x3', '\x2', '\x2', '\x2', '\x1507', 
		'\x261', '\x3', '\x2', '\x2', '\x2', '\x1508', '\x1509', '\a', '\x258', 
		'\x2', '\x2', '\x1509', '\x150A', '\a', '\x195', '\x2', '\x2', '\x150A', 
		'\x150C', '\x5', '\x454', '\x22B', '\x2', '\x150B', '\x150D', '\x5', '\x264', 
		'\x133', '\x2', '\x150C', '\x150B', '\x3', '\x2', '\x2', '\x2', '\x150C', 
		'\x150D', '\x3', '\x2', '\x2', '\x2', '\x150D', '\x1510', '\x3', '\x2', 
		'\x2', '\x2', '\x150E', '\x150F', '\a', '\x18A', '\x2', '\x2', '\x150F', 
		'\x1511', '\a', '\x18D', '\x2', '\x2', '\x1510', '\x150E', '\x3', '\x2', 
		'\x2', '\x2', '\x1510', '\x1511', '\x3', '\x2', '\x2', '\x2', '\x1511', 
		'\x263', '\x3', '\x2', '\x2', '\x2', '\x1512', '\x1513', '\t', 'G', '\x2', 
		'\x2', '\x1513', '\x1514', '\a', '?', '\x2', '\x2', '\x1514', '\x1515', 
		'\x5', '\x454', '\x22B', '\x2', '\x1515', '\x265', '\x3', '\x2', '\x2', 
		'\x2', '\x1516', '\x151A', '\a', '\x296', '\x2', '\x2', '\x1517', '\x1518', 
		'\a', '\x297', '\x2', '\x2', '\x1518', '\x151A', '\a', '\x18', '\x2', 
		'\x2', '\x1519', '\x1516', '\x3', '\x2', '\x2', '\x2', '\x1519', '\x1517', 
		'\x3', '\x2', '\x2', '\x2', '\x151A', '\x151B', '\x3', '\x2', '\x2', '\x2', 
		'\x151B', '\x151C', '\a', '\x2F2', '\x2', '\x2', '\x151C', '\x151D', '\x5', 
		'\x37E', '\x1C0', '\x2', '\x151D', '\x151E', '\a', '\x2F3', '\x2', '\x2', 
		'\x151E', '\x151F', '\a', '\x195', '\x2', '\x2', '\x151F', '\x1522', '\x5', 
		'\x454', '\x22B', '\x2', '\x1520', '\x1521', '\a', '\x18A', '\x2', '\x2', 
		'\x1521', '\x1523', '\a', '\x18D', '\x2', '\x2', '\x1522', '\x1520', '\x3', 
		'\x2', '\x2', '\x2', '\x1522', '\x1523', '\x3', '\x2', '\x2', '\x2', '\x1523', 
		'\x267', '\x3', '\x2', '\x2', '\x2', '\x1524', '\x1525', '\a', '\x1E3', 
		'\x2', '\x2', '\x1525', '\x152A', '\a', '\x2F2', '\x2', '\x2', '\x1526', 
		'\x1528', '\a', '\x2F8', '\x2', '\x2', '\x1527', '\x1526', '\x3', '\x2', 
		'\x2', '\x2', '\x1527', '\x1528', '\x3', '\x2', '\x2', '\x2', '\x1528', 
		'\x1529', '\x3', '\x2', '\x2', '\x2', '\x1529', '\x152B', '\x5', '\x26A', 
		'\x136', '\x2', '\x152A', '\x1527', '\x3', '\x2', '\x2', '\x2', '\x152B', 
		'\x152C', '\x3', '\x2', '\x2', '\x2', '\x152C', '\x152A', '\x3', '\x2', 
		'\x2', '\x2', '\x152C', '\x152D', '\x3', '\x2', '\x2', '\x2', '\x152D', 
		'\x152E', '\x3', '\x2', '\x2', '\x2', '\x152E', '\x152F', '\a', '\x2F3', 
		'\x2', '\x2', '\x152F', '\x269', '\x3', '\x2', '\x2', '\x2', '\x1530', 
		'\x1532', '\x5', '\x490', '\x249', '\x2', '\x1531', '\x1533', '\x5', '\x454', 
		'\x22B', '\x2', '\x1532', '\x1531', '\x3', '\x2', '\x2', '\x2', '\x1532', 
		'\x1533', '\x3', '\x2', '\x2', '\x2', '\x1533', '\x1536', '\x3', '\x2', 
		'\x2', '\x2', '\x1534', '\x1535', '\a', '\x18A', '\x2', '\x2', '\x1535', 
		'\x1537', '\a', '\x18D', '\x2', '\x2', '\x1536', '\x1534', '\x3', '\x2', 
		'\x2', '\x2', '\x1536', '\x1537', '\x3', '\x2', '\x2', '\x2', '\x1537', 
		'\x1539', '\x3', '\x2', '\x2', '\x2', '\x1538', '\x153A', '\x5', '\x24C', 
		'\x127', '\x2', '\x1539', '\x1538', '\x3', '\x2', '\x2', '\x2', '\x1539', 
		'\x153A', '\x3', '\x2', '\x2', '\x2', '\x153A', '\x26B', '\x3', '\x2', 
		'\x2', '\x2', '\x153B', '\x153C', '\x5', '\x270', '\x139', '\x2', '\x153C', 
		'\x153D', '\t', 'H', '\x2', '\x2', '\x153D', '\x1540', '\x3', '\x2', '\x2', 
		'\x2', '\x153E', '\x1540', '\x5', '\x26E', '\x138', '\x2', '\x153F', '\x153B', 
		'\x3', '\x2', '\x2', '\x2', '\x153F', '\x153E', '\x3', '\x2', '\x2', '\x2', 
		'\x1540', '\x1541', '\x3', '\x2', '\x2', '\x2', '\x1541', '\x153F', '\x3', 
		'\x2', '\x2', '\x2', '\x1541', '\x1542', '\x3', '\x2', '\x2', '\x2', '\x1542', 
		'\x26D', '\x3', '\x2', '\x2', '\x2', '\x1543', '\x1544', '\a', '\x302', 
		'\x2', '\x2', '\x1544', '\x1545', '\a', '\x302', '\x2', '\x2', '\x1545', 
		'\x1546', '\x5', '\x428', '\x215', '\x2', '\x1546', '\x1547', '\a', '\x301', 
		'\x2', '\x2', '\x1547', '\x1548', '\a', '\x301', '\x2', '\x2', '\x1548', 
		'\x26F', '\x3', '\x2', '\x2', '\x2', '\x1549', '\x154A', '\a', 'r', '\x2', 
		'\x2', '\x154A', '\x155E', '\x5', '\x272', '\x13A', '\x2', '\x154B', '\x154C', 
		'\a', '\x277', '\x2', '\x2', '\x154C', '\x155E', '\x5', '\x272', '\x13A', 
		'\x2', '\x154D', '\x155E', '\x5', '\x29A', '\x14E', '\x2', '\x154E', '\x155E', 
		'\x5', '\x2A0', '\x151', '\x2', '\x154F', '\x155E', '\x5', '\x274', '\x13B', 
		'\x2', '\x1550', '\x155E', '\x5', '\x276', '\x13C', '\x2', '\x1551', '\x155E', 
		'\x5', '\x278', '\x13D', '\x2', '\x1552', '\x155E', '\x5', '\x27A', '\x13E', 
		'\x2', '\x1553', '\x155E', '\x5', '\x27C', '\x13F', '\x2', '\x1554', '\x155E', 
		'\x5', '\x282', '\x142', '\x2', '\x1555', '\x155E', '\x5', '\x286', '\x144', 
		'\x2', '\x1556', '\x155E', '\x5', '\x290', '\x149', '\x2', '\x1557', '\x155E', 
		'\x5', '\x292', '\x14A', '\x2', '\x1558', '\x155E', '\x5', '\x294', '\x14B', 
		'\x2', '\x1559', '\x155E', '\x5', '\x3A0', '\x1D1', '\x2', '\x155A', '\x155E', 
		'\x5', '\x2A2', '\x152', '\x2', '\x155B', '\x155E', '\x5', '\x296', '\x14C', 
		'\x2', '\x155C', '\x155E', '\x5', '\x298', '\x14D', '\x2', '\x155D', '\x1549', 
		'\x3', '\x2', '\x2', '\x2', '\x155D', '\x154B', '\x3', '\x2', '\x2', '\x2', 
		'\x155D', '\x154D', '\x3', '\x2', '\x2', '\x2', '\x155D', '\x154E', '\x3', 
		'\x2', '\x2', '\x2', '\x155D', '\x154F', '\x3', '\x2', '\x2', '\x2', '\x155D', 
		'\x1550', '\x3', '\x2', '\x2', '\x2', '\x155D', '\x1551', '\x3', '\x2', 
		'\x2', '\x2', '\x155D', '\x1552', '\x3', '\x2', '\x2', '\x2', '\x155D', 
		'\x1553', '\x3', '\x2', '\x2', '\x2', '\x155D', '\x1554', '\x3', '\x2', 
		'\x2', '\x2', '\x155D', '\x1555', '\x3', '\x2', '\x2', '\x2', '\x155D', 
		'\x1556', '\x3', '\x2', '\x2', '\x2', '\x155D', '\x1557', '\x3', '\x2', 
		'\x2', '\x2', '\x155D', '\x1558', '\x3', '\x2', '\x2', '\x2', '\x155D', 
		'\x1559', '\x3', '\x2', '\x2', '\x2', '\x155D', '\x155A', '\x3', '\x2', 
		'\x2', '\x2', '\x155D', '\x155B', '\x3', '\x2', '\x2', '\x2', '\x155D', 
		'\x155C', '\x3', '\x2', '\x2', '\x2', '\x155E', '\x271', '\x3', '\x2', 
		'\x2', '\x2', '\x155F', '\x1561', '\n', 'I', '\x2', '\x2', '\x1560', '\x155F', 
		'\x3', '\x2', '\x2', '\x2', '\x1561', '\x1562', '\x3', '\x2', '\x2', '\x2', 
		'\x1562', '\x1560', '\x3', '\x2', '\x2', '\x2', '\x1562', '\x1563', '\x3', 
		'\x2', '\x2', '\x2', '\x1563', '\x273', '\x3', '\x2', '\x2', '\x2', '\x1564', 
		'\x1567', '\x5', '\x45E', '\x230', '\x2', '\x1565', '\x1567', '\x5', '\x45C', 
		'\x22F', '\x2', '\x1566', '\x1564', '\x3', '\x2', '\x2', '\x2', '\x1566', 
		'\x1565', '\x3', '\x2', '\x2', '\x2', '\x1567', '\x1568', '\x3', '\x2', 
		'\x2', '\x2', '\x1568', '\x1569', '\a', '\x2FB', '\x2', '\x2', '\x1569', 
		'\x156A', '\x5', '\x37E', '\x1C0', '\x2', '\x156A', '\x275', '\x3', '\x2', 
		'\x2', '\x2', '\x156B', '\x156D', '\a', 'l', '\x2', '\x2', '\x156C', '\x156E', 
		'\x5', '\x428', '\x215', '\x2', '\x156D', '\x156C', '\x3', '\x2', '\x2', 
		'\x2', '\x156D', '\x156E', '\x3', '\x2', '\x2', '\x2', '\x156E', '\x1571', 
		'\x3', '\x2', '\x2', '\x2', '\x156F', '\x1570', '\a', '\x2A1', '\x2', 
		'\x2', '\x1570', '\x1572', '\x5', '\x37A', '\x1BE', '\x2', '\x1571', '\x156F', 
		'\x3', '\x2', '\x2', '\x2', '\x1571', '\x1572', '\x3', '\x2', '\x2', '\x2', 
		'\x1572', '\x277', '\x3', '\x2', '\x2', '\x2', '\x1573', '\x1575', '\a', 
		'\xC6', '\x2', '\x2', '\x1574', '\x1576', '\x5', '\x428', '\x215', '\x2', 
		'\x1575', '\x1574', '\x3', '\x2', '\x2', '\x2', '\x1575', '\x1576', '\x3', 
		'\x2', '\x2', '\x2', '\x1576', '\x1579', '\x3', '\x2', '\x2', '\x2', '\x1577', 
		'\x1578', '\a', '\x2A1', '\x2', '\x2', '\x1578', '\x157A', '\x5', '\x37A', 
		'\x1BE', '\x2', '\x1579', '\x1577', '\x3', '\x2', '\x2', '\x2', '\x1579', 
		'\x157A', '\x3', '\x2', '\x2', '\x2', '\x157A', '\x279', '\x3', '\x2', 
		'\x2', '\x2', '\x157B', '\x157C', '\a', '\xE7', '\x2', '\x2', '\x157C', 
		'\x157D', '\x5', '\x428', '\x215', '\x2', '\x157D', '\x27B', '\x3', '\x2', 
		'\x2', '\x2', '\x157E', '\x157F', '\a', '\xF8', '\x2', '\x2', '\x157F', 
		'\x1580', '\x5', '\x37A', '\x1BE', '\x2', '\x1580', '\x1581', '\a', '\x25D', 
		'\x2', '\x2', '\x1581', '\x1585', '\x5', '\x26C', '\x137', '\x2', '\x1582', 
		'\x1584', '\x5', '\x27E', '\x140', '\x2', '\x1583', '\x1582', '\x3', '\x2', 
		'\x2', '\x2', '\x1584', '\x1587', '\x3', '\x2', '\x2', '\x2', '\x1585', 
		'\x1583', '\x3', '\x2', '\x2', '\x2', '\x1585', '\x1586', '\x3', '\x2', 
		'\x2', '\x2', '\x1586', '\x1589', '\x3', '\x2', '\x2', '\x2', '\x1587', 
		'\x1585', '\x3', '\x2', '\x2', '\x2', '\x1588', '\x158A', '\x5', '\x280', 
		'\x141', '\x2', '\x1589', '\x1588', '\x3', '\x2', '\x2', '\x2', '\x1589', 
		'\x158A', '\x3', '\x2', '\x2', '\x2', '\x158A', '\x158B', '\x3', '\x2', 
		'\x2', '\x2', '\x158B', '\x158C', '\a', '\xB5', '\x2', '\x2', '\x158C', 
		'\x158D', '\a', '\xF8', '\x2', '\x2', '\x158D', '\x27D', '\x3', '\x2', 
		'\x2', '\x2', '\x158E', '\x158F', '\a', '\xAF', '\x2', '\x2', '\x158F', 
		'\x1590', '\x5', '\x37A', '\x1BE', '\x2', '\x1590', '\x1591', '\a', '\x25D', 
		'\x2', '\x2', '\x1591', '\x1592', '\x5', '\x26C', '\x137', '\x2', '\x1592', 
		'\x27F', '\x3', '\x2', '\x2', '\x2', '\x1593', '\x1594', '\a', '\xAE', 
		'\x2', '\x2', '\x1594', '\x1595', '\x5', '\x26C', '\x137', '\x2', '\x1595', 
		'\x281', '\x3', '\x2', '\x2', '\x2', '\x1596', '\x1598', '\x5', '\x26E', 
		'\x138', '\x2', '\x1597', '\x1596', '\x3', '\x2', '\x2', '\x2', '\x1597', 
		'\x1598', '\x3', '\x2', '\x2', '\x2', '\x1598', '\x159D', '\x3', '\x2', 
		'\x2', '\x2', '\x1599', '\x159A', '\a', '\x2A3', '\x2', '\x2', '\x159A', 
		'\x159E', '\x5', '\x37A', '\x1BE', '\x2', '\x159B', '\x159C', '\a', '\xDD', 
		'\x2', '\x2', '\x159C', '\x159E', '\x5', '\x284', '\x143', '\x2', '\x159D', 
		'\x1599', '\x3', '\x2', '\x2', '\x2', '\x159D', '\x159B', '\x3', '\x2', 
		'\x2', '\x2', '\x159D', '\x159E', '\x3', '\x2', '\x2', '\x2', '\x159E', 
		'\x159F', '\x3', '\x2', '\x2', '\x2', '\x159F', '\x15A0', '\a', '\x144', 
		'\x2', '\x2', '\x15A0', '\x15A1', '\x5', '\x26C', '\x137', '\x2', '\x15A1', 
		'\x15A2', '\a', '\xB5', '\x2', '\x2', '\x15A2', '\x15A4', '\a', '\x144', 
		'\x2', '\x2', '\x15A3', '\x15A5', '\x5', '\x428', '\x215', '\x2', '\x15A4', 
		'\x15A3', '\x3', '\x2', '\x2', '\x2', '\x15A4', '\x15A5', '\x3', '\x2', 
		'\x2', '\x2', '\x15A5', '\x283', '\x3', '\x2', '\x2', '\x2', '\x15A6', 
		'\x15A7', '\x5', '\x442', '\x222', '\x2', '\x15A7', '\x15A9', '\a', '\x108', 
		'\x2', '\x2', '\x15A8', '\x15AA', '\a', '\x1FE', '\x2', '\x2', '\x15A9', 
		'\x15A8', '\x3', '\x2', '\x2', '\x2', '\x15A9', '\x15AA', '\x3', '\x2', 
		'\x2', '\x2', '\x15AA', '\x15AB', '\x3', '\x2', '\x2', '\x2', '\x15AB', 
		'\x15AC', '\x5', '\x28C', '\x147', '\x2', '\x15AC', '\x15AD', '\a', '\x2EA', 
		'\x2', '\x2', '\x15AD', '\x15AE', '\x5', '\x28E', '\x148', '\x2', '\x15AE', 
		'\x15C0', '\x3', '\x2', '\x2', '\x2', '\x15AF', '\x15B0', '\x5', '\x412', 
		'\x20A', '\x2', '\x15B0', '\x15BD', '\a', '\x108', '\x2', '\x2', '\x15B1', 
		'\x15B7', '\x5', '\x410', '\x209', '\x2', '\x15B2', '\x15B4', '\a', '\x2F2', 
		'\x2', '\x2', '\x15B3', '\x15B5', '\x5', '\x37C', '\x1BF', '\x2', '\x15B4', 
		'\x15B3', '\x3', '\x2', '\x2', '\x2', '\x15B4', '\x15B5', '\x3', '\x2', 
		'\x2', '\x2', '\x15B5', '\x15B6', '\x3', '\x2', '\x2', '\x2', '\x15B6', 
		'\x15B8', '\a', '\x2F3', '\x2', '\x2', '\x15B7', '\x15B2', '\x3', '\x2', 
		'\x2', '\x2', '\x15B7', '\x15B8', '\x3', '\x2', '\x2', '\x2', '\x15B8', 
		'\x15BE', '\x3', '\x2', '\x2', '\x2', '\x15B9', '\x15BA', '\a', '\x2F2', 
		'\x2', '\x2', '\x15BA', '\x15BB', '\x5', '\x2C4', '\x163', '\x2', '\x15BB', 
		'\x15BC', '\a', '\x2F3', '\x2', '\x2', '\x15BC', '\x15BE', '\x3', '\x2', 
		'\x2', '\x2', '\x15BD', '\x15B1', '\x3', '\x2', '\x2', '\x2', '\x15BD', 
		'\x15B9', '\x3', '\x2', '\x2', '\x2', '\x15BE', '\x15C0', '\x3', '\x2', 
		'\x2', '\x2', '\x15BF', '\x15A6', '\x3', '\x2', '\x2', '\x2', '\x15BF', 
		'\x15AF', '\x3', '\x2', '\x2', '\x2', '\x15C0', '\x285', '\x3', '\x2', 
		'\x2', '\x2', '\x15C1', '\x15C2', '\a', '\xDA', '\x2', '\x2', '\x15C2', 
		'\x15C3', '\x5', '\x442', '\x222', '\x2', '\x15C3', '\x15C4', '\a', '\x108', 
		'\x2', '\x2', '\x15C4', '\x15C5', '\x5', '\x288', '\x145', '\x2', '\x15C5', 
		'\x15C8', '\x5', '\x2A2', '\x152', '\x2', '\x15C6', '\x15C7', '\a', '\x20F', 
		'\x2', '\x2', '\x15C7', '\x15C9', '\a', '\xC0', '\x2', '\x2', '\x15C8', 
		'\x15C6', '\x3', '\x2', '\x2', '\x2', '\x15C8', '\x15C9', '\x3', '\x2', 
		'\x2', '\x2', '\x15C9', '\x287', '\x3', '\x2', '\x2', '\x2', '\x15CA', 
		'\x15CB', '\x5', '\x28C', '\x147', '\x2', '\x15CB', '\x15CC', '\a', '\x2EA', 
		'\x2', '\x2', '\x15CC', '\x15CD', '\x5', '\x28E', '\x148', '\x2', '\x15CD', 
		'\x15D8', '\x3', '\x2', '\x2', '\x2', '\x15CE', '\x15CF', '\a', '\x105', 
		'\x2', '\x2', '\x15CF', '\x15D0', '\a', '\x195', '\x2', '\x2', '\x15D0', 
		'\x15D2', '\x5', '\x440', '\x221', '\x2', '\x15D1', '\x15D3', '\x5', '\x28A', 
		'\x146', '\x2', '\x15D2', '\x15D1', '\x3', '\x2', '\x2', '\x2', '\x15D2', 
		'\x15D3', '\x3', '\x2', '\x2', '\x2', '\x15D3', '\x15D8', '\x3', '\x2', 
		'\x2', '\x2', '\x15D4', '\x15D5', '\a', '\x290', '\x2', '\x2', '\x15D5', 
		'\x15D6', '\a', '\x195', '\x2', '\x2', '\x15D6', '\x15D8', '\x5', '\x442', 
		'\x222', '\x2', '\x15D7', '\x15CA', '\x3', '\x2', '\x2', '\x2', '\x15D7', 
		'\x15CE', '\x3', '\x2', '\x2', '\x2', '\x15D7', '\x15D4', '\x3', '\x2', 
		'\x2', '\x2', '\x15D8', '\x289', '\x3', '\x2', '\x2', '\x2', '\x15D9', 
		'\x15DA', '\a', '.', '\x2', '\x2', '\x15DA', '\x15DB', '\x5', '\x28C', 
		'\x147', '\x2', '\x15DB', '\x15DC', '\a', '\x13', '\x2', '\x2', '\x15DC', 
		'\x15DD', '\x5', '\x28E', '\x148', '\x2', '\x15DD', '\x28B', '\x3', '\x2', 
		'\x2', '\x2', '\x15DE', '\x15DF', '\x5', '\x38C', '\x1C7', '\x2', '\x15DF', 
		'\x28D', '\x3', '\x2', '\x2', '\x2', '\x15E0', '\x15E1', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x15E1', '\x28F', '\x3', '\x2', '\x2', '\x2', '\x15E2', 
		'\x15E3', '\a', '\x18D', '\x2', '\x2', '\x15E3', '\x291', '\x3', '\x2', 
		'\x2', '\x2', '\x15E4', '\x15E6', '\a', '\x1DD', '\x2', '\x2', '\x15E5', 
		'\x15E7', '\x5', '\x48E', '\x248', '\x2', '\x15E6', '\x15E5', '\x3', '\x2', 
		'\x2', '\x2', '\x15E6', '\x15E7', '\x3', '\x2', '\x2', '\x2', '\x15E7', 
		'\x293', '\x3', '\x2', '\x2', '\x2', '\x15E8', '\x15EA', '\a', '\x1FC', 
		'\x2', '\x2', '\x15E9', '\x15EB', '\x5', '\x37E', '\x1C0', '\x2', '\x15EA', 
		'\x15E9', '\x3', '\x2', '\x2', '\x2', '\x15EA', '\x15EB', '\x3', '\x2', 
		'\x2', '\x2', '\x15EB', '\x295', '\x3', '\x2', '\x2', '\x2', '\x15EC', 
		'\x15EE', '\a', '\x42', '\x2', '\x2', '\x15ED', '\x15EC', '\x3', '\x2', 
		'\x2', '\x2', '\x15ED', '\x15EE', '\x3', '\x2', '\x2', '\x2', '\x15EE', 
		'\x15EF', '\x3', '\x2', '\x2', '\x2', '\x15EF', '\x15F1', '\x5', '\x404', 
		'\x203', '\x2', '\x15F0', '\x15F2', '\x5', '\x3F0', '\x1F9', '\x2', '\x15F1', 
		'\x15F0', '\x3', '\x2', '\x2', '\x2', '\x15F1', '\x15F2', '\x3', '\x2', 
		'\x2', '\x2', '\x15F2', '\x15F4', '\x3', '\x2', '\x2', '\x2', '\x15F3', 
		'\x15F5', '\x5', '\x44C', '\x227', '\x2', '\x15F4', '\x15F3', '\x3', '\x2', 
		'\x2', '\x2', '\x15F4', '\x15F5', '\x3', '\x2', '\x2', '\x2', '\x15F5', 
		'\x297', '\x3', '\x2', '\x2', '\x2', '\x15F6', '\x15F7', '\a', '\x1C3', 
		'\x2', '\x2', '\x15F7', '\x15F8', '\a', '\x209', '\x2', '\x2', '\x15F8', 
		'\x15F9', '\a', '\x2F2', '\x2', '\x2', '\x15F9', '\x15FA', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x15FA', '\x15FB', '\a', '\x2F3', '\x2', '\x2', '\x15FB', 
		'\x299', '\x3', '\x2', '\x2', '\x2', '\x15FC', '\x15FD', '\a', '-', '\x2', 
		'\x2', '\x15FD', '\x1604', '\x5', '\x26C', '\x137', '\x2', '\x15FE', '\x1600', 
		'\a', '\xBE', '\x2', '\x2', '\x15FF', '\x1601', '\x5', '\x29C', '\x14F', 
		'\x2', '\x1600', '\x15FF', '\x3', '\x2', '\x2', '\x2', '\x1601', '\x1602', 
		'\x3', '\x2', '\x2', '\x2', '\x1602', '\x1600', '\x3', '\x2', '\x2', '\x2', 
		'\x1602', '\x1603', '\x3', '\x2', '\x2', '\x2', '\x1603', '\x1605', '\x3', 
		'\x2', '\x2', '\x2', '\x1604', '\x15FE', '\x3', '\x2', '\x2', '\x2', '\x1604', 
		'\x1605', '\x3', '\x2', '\x2', '\x2', '\x1605', '\x1606', '\x3', '\x2', 
		'\x2', '\x2', '\x1606', '\x1608', '\a', '\xB5', '\x2', '\x2', '\x1607', 
		'\x1609', '\x5', '\x428', '\x215', '\x2', '\x1608', '\x1607', '\x3', '\x2', 
		'\x2', '\x2', '\x1608', '\x1609', '\x3', '\x2', '\x2', '\x2', '\x1609', 
		'\x29B', '\x3', '\x2', '\x2', '\x2', '\x160A', '\x160B', '\a', '\x2A1', 
		'\x2', '\x2', '\x160B', '\x1610', '\x5', '\x48E', '\x248', '\x2', '\x160C', 
		'\x160D', '\a', '\x1A4', '\x2', '\x2', '\x160D', '\x160F', '\x5', '\x48E', 
		'\x248', '\x2', '\x160E', '\x160C', '\x3', '\x2', '\x2', '\x2', '\x160F', 
		'\x1612', '\x3', '\x2', '\x2', '\x2', '\x1610', '\x160E', '\x3', '\x2', 
		'\x2', '\x2', '\x1610', '\x1611', '\x3', '\x2', '\x2', '\x2', '\x1611', 
		'\x1613', '\x3', '\x2', '\x2', '\x2', '\x1612', '\x1610', '\x3', '\x2', 
		'\x2', '\x2', '\x1613', '\x1614', '\a', '\x25D', '\x2', '\x2', '\x1614', 
		'\x1615', '\x5', '\x26C', '\x137', '\x2', '\x1615', '\x29D', '\x3', '\x2', 
		'\x2', '\x2', '\x1616', '\x1618', '\a', '\x8A', '\x2', '\x2', '\x1617', 
		'\x1616', '\x3', '\x2', '\x2', '\x2', '\x1617', '\x1618', '\x3', '\x2', 
		'\x2', '\x2', '\x1618', '\x161A', '\x3', '\x2', '\x2', '\x2', '\x1619', 
		'\x161B', '\x5', '\x250', '\x129', '\x2', '\x161A', '\x1619', '\x3', '\x2', 
		'\x2', '\x2', '\x161B', '\x161C', '\x3', '\x2', '\x2', '\x2', '\x161C', 
		'\x161A', '\x3', '\x2', '\x2', '\x2', '\x161C', '\x161D', '\x3', '\x2', 
		'\x2', '\x2', '\x161D', '\x161F', '\x3', '\x2', '\x2', '\x2', '\x161E', 
		'\x1617', '\x3', '\x2', '\x2', '\x2', '\x161E', '\x161F', '\x3', '\x2', 
		'\x2', '\x2', '\x161F', '\x1620', '\x3', '\x2', '\x2', '\x2', '\x1620', 
		'\x1621', '\x5', '\x29A', '\x14E', '\x2', '\x1621', '\x29F', '\x3', '\x2', 
		'\x2', '\x2', '\x1622', '\x1624', '\a', '\x8A', '\x2', '\x2', '\x1623', 
		'\x1622', '\x3', '\x2', '\x2', '\x2', '\x1623', '\x1624', '\x3', '\x2', 
		'\x2', '\x2', '\x1624', '\x1626', '\x3', '\x2', '\x2', '\x2', '\x1625', 
		'\x1627', '\x5', '\x250', '\x129', '\x2', '\x1626', '\x1625', '\x3', '\x2', 
		'\x2', '\x2', '\x1627', '\x1628', '\x3', '\x2', '\x2', '\x2', '\x1628', 
		'\x1626', '\x3', '\x2', '\x2', '\x2', '\x1628', '\x1629', '\x3', '\x2', 
		'\x2', '\x2', '\x1629', '\x162A', '\x3', '\x2', '\x2', '\x2', '\x162A', 
		'\x162B', '\x5', '\x29A', '\x14E', '\x2', '\x162B', '\x2A1', '\x3', '\x2', 
		'\x2', '\x2', '\x162C', '\x1631', '\x5', '\x2A4', '\x153', '\x2', '\x162D', 
		'\x1631', '\x5', '\x2A8', '\x155', '\x2', '\x162E', '\x1631', '\x5', '\x2AA', 
		'\x156', '\x2', '\x162F', '\x1631', '\x5', '\x2B4', '\x15B', '\x2', '\x1630', 
		'\x162C', '\x3', '\x2', '\x2', '\x2', '\x1630', '\x162D', '\x3', '\x2', 
		'\x2', '\x2', '\x1630', '\x162E', '\x3', '\x2', '\x2', '\x2', '\x1630', 
		'\x162F', '\x3', '\x2', '\x2', '\x2', '\x1631', '\x2A3', '\x3', '\x2', 
		'\x2', '\x2', '\x1632', '\x1633', '\a', '\xC3', '\x2', '\x2', '\x1633', 
		'\x1634', '\a', '\xFB', '\x2', '\x2', '\x1634', '\x163E', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1635', '\x1637', '\x5', '\x400', '\x201', '\x2', '\x1636', 
		'\x1638', '\x5', '\x3CA', '\x1E6', '\x2', '\x1637', '\x1636', '\x3', '\x2', 
		'\x2', '\x2', '\x1637', '\x1638', '\x3', '\x2', '\x2', '\x2', '\x1638', 
		'\x163F', '\x3', '\x2', '\x2', '\x2', '\x1639', '\x163B', '\x5', '\x3CA', 
		'\x1E6', '\x2', '\x163A', '\x163C', '\x5', '\x2A6', '\x154', '\x2', '\x163B', 
		'\x163A', '\x3', '\x2', '\x2', '\x2', '\x163B', '\x163C', '\x3', '\x2', 
		'\x2', '\x2', '\x163C', '\x163F', '\x3', '\x2', '\x2', '\x2', '\x163D', 
		'\x163F', '\x5', '\x2A6', '\x154', '\x2', '\x163E', '\x1635', '\x3', '\x2', 
		'\x2', '\x2', '\x163E', '\x1639', '\x3', '\x2', '\x2', '\x2', '\x163E', 
		'\x163D', '\x3', '\x2', '\x2', '\x2', '\x163E', '\x163F', '\x3', '\x2', 
		'\x2', '\x2', '\x163F', '\x2A5', '\x3', '\x2', '\x2', '\x2', '\x1640', 
		'\x1641', '\t', 'J', '\x2', '\x2', '\x1641', '\x1642', '\x5', '\x400', 
		'\x201', '\x2', '\x1642', '\x2A7', '\x3', '\x2', '\x2', '\x2', '\x1643', 
		'\x164A', '\x5', '\x352', '\x1AA', '\x2', '\x1644', '\x164A', '\x5', '\x35E', 
		'\x1B0', '\x2', '\x1645', '\x164A', '\x5', '\x2C4', '\x163', '\x2', '\x1646', 
		'\x164A', '\x5', '\x338', '\x19D', '\x2', '\x1647', '\x164A', '\x5', '\x33E', 
		'\x1A0', '\x2', '\x1648', '\x164A', '\x5', '\x340', '\x1A1', '\x2', '\x1649', 
		'\x1643', '\x3', '\x2', '\x2', '\x2', '\x1649', '\x1644', '\x3', '\x2', 
		'\x2', '\x2', '\x1649', '\x1645', '\x3', '\x2', '\x2', '\x2', '\x1649', 
		'\x1646', '\x3', '\x2', '\x2', '\x2', '\x1649', '\x1647', '\x3', '\x2', 
		'\x2', '\x2', '\x1649', '\x1648', '\x3', '\x2', '\x2', '\x2', '\x164A', 
		'\x2A9', '\x3', '\x2', '\x2', '\x2', '\x164B', '\x1650', '\x5', '\x2AC', 
		'\x157', '\x2', '\x164C', '\x1650', '\x5', '\x2AE', '\x158', '\x2', '\x164D', 
		'\x1650', '\x5', '\x2B0', '\x159', '\x2', '\x164E', '\x1650', '\x5', '\x2B2', 
		'\x15A', '\x2', '\x164F', '\x164B', '\x3', '\x2', '\x2', '\x2', '\x164F', 
		'\x164C', '\x3', '\x2', '\x2', '\x2', '\x164F', '\x164D', '\x3', '\x2', 
		'\x2', '\x2', '\x164F', '\x164E', '\x3', '\x2', '\x2', '\x2', '\x1650', 
		'\x2AB', '\x3', '\x2', '\x2', '\x2', '\x1651', '\x1652', '\a', 'S', '\x2', 
		'\x2', '\x1652', '\x1653', '\x5', '\x410', '\x209', '\x2', '\x1653', '\x2AD', 
		'\x3', '\x2', '\x2', '\x2', '\x1654', '\x1655', '\a', '\x19C', '\x2', 
		'\x2', '\x1655', '\x165B', '\x5', '\x410', '\x209', '\x2', '\x1656', '\x1658', 
		'\a', '\x2F2', '\x2', '\x2', '\x1657', '\x1659', '\x5', '\x37C', '\x1BF', 
		'\x2', '\x1658', '\x1657', '\x3', '\x2', '\x2', '\x2', '\x1658', '\x1659', 
		'\x3', '\x2', '\x2', '\x2', '\x1659', '\x165A', '\x3', '\x2', '\x2', '\x2', 
		'\x165A', '\x165C', '\a', '\x2F3', '\x2', '\x2', '\x165B', '\x1656', '\x3', 
		'\x2', '\x2', '\x2', '\x165B', '\x165C', '\x3', '\x2', '\x2', '\x2', '\x165C', 
		'\x2AF', '\x3', '\x2', '\x2', '\x2', '\x165D', '\x165E', '\a', '\xCF', 
		'\x2', '\x2', '\x165E', '\x1673', '\x5', '\x410', '\x209', '\x2', '\x165F', 
		'\x1664', '\a', '\x118', '\x2', '\x2', '\x1660', '\x1662', '\a', '\x2F8', 
		'\x2', '\x2', '\x1661', '\x1660', '\x3', '\x2', '\x2', '\x2', '\x1661', 
		'\x1662', '\x3', '\x2', '\x2', '\x2', '\x1662', '\x1663', '\x3', '\x2', 
		'\x2', '\x2', '\x1663', '\x1665', '\x5', '\x40E', '\x208', '\x2', '\x1664', 
		'\x1661', '\x3', '\x2', '\x2', '\x2', '\x1665', '\x1666', '\x3', '\x2', 
		'\x2', '\x2', '\x1666', '\x1664', '\x3', '\x2', '\x2', '\x2', '\x1666', 
		'\x1667', '\x3', '\x2', '\x2', '\x2', '\x1667', '\x1674', '\x3', '\x2', 
		'\x2', '\x2', '\x1668', '\x1669', '\a', '>', '\x2', '\x2', '\x1669', '\x166A', 
		'\a', 'W', '\x2', '\x2', '\x166A', '\x166F', '\a', '\x118', '\x2', '\x2', 
		'\x166B', '\x166D', '\a', '\x2F8', '\x2', '\x2', '\x166C', '\x166B', '\x3', 
		'\x2', '\x2', '\x2', '\x166C', '\x166D', '\x3', '\x2', '\x2', '\x2', '\x166D', 
		'\x166E', '\x3', '\x2', '\x2', '\x2', '\x166E', '\x1670', '\x5', '\x40E', 
		'\x208', '\x2', '\x166F', '\x166C', '\x3', '\x2', '\x2', '\x2', '\x1670', 
		'\x1671', '\x3', '\x2', '\x2', '\x2', '\x1671', '\x166F', '\x3', '\x2', 
		'\x2', '\x2', '\x1671', '\x1672', '\x3', '\x2', '\x2', '\x2', '\x1672', 
		'\x1674', '\x3', '\x2', '\x2', '\x2', '\x1673', '\x165F', '\x3', '\x2', 
		'\x2', '\x2', '\x1673', '\x1668', '\x3', '\x2', '\x2', '\x2', '\x1674', 
		'\x2B1', '\x3', '\x2', '\x2', '\x2', '\x1675', '\x1676', '\a', '\x19C', 
		'\x2', '\x2', '\x1676', '\x1677', '\x5', '\x40E', '\x208', '\x2', '\x1677', 
		'\x167A', '\a', '\xDD', '\x2', '\x2', '\x1678', '\x167B', '\x5', '\x2C4', 
		'\x163', '\x2', '\x1679', '\x167B', '\x5', '\x37E', '\x1C0', '\x2', '\x167A', 
		'\x1678', '\x3', '\x2', '\x2', '\x2', '\x167A', '\x1679', '\x3', '\x2', 
		'\x2', '\x2', '\x167B', '\x167D', '\x3', '\x2', '\x2', '\x2', '\x167C', 
		'\x167E', '\x5', '\x3CA', '\x1E6', '\x2', '\x167D', '\x167C', '\x3', '\x2', 
		'\x2', '\x2', '\x167D', '\x167E', '\x3', '\x2', '\x2', '\x2', '\x167E', 
		'\x2B3', '\x3', '\x2', '\x2', '\x2', '\x167F', '\x1685', '\x5', '\x2B6', 
		'\x15C', '\x2', '\x1680', '\x1685', '\x5', '\x2B8', '\x15D', '\x2', '\x1681', 
		'\x1685', '\x5', '\x2BA', '\x15E', '\x2', '\x1682', '\x1685', '\x5', '\x2BE', 
		'\x160', '\x2', '\x1683', '\x1685', '\x5', '\x2C0', '\x161', '\x2', '\x1684', 
		'\x167F', '\x3', '\x2', '\x2', '\x2', '\x1684', '\x1680', '\x3', '\x2', 
		'\x2', '\x2', '\x1684', '\x1681', '\x3', '\x2', '\x2', '\x2', '\x1684', 
		'\x1682', '\x3', '\x2', '\x2', '\x2', '\x1684', '\x1683', '\x3', '\x2', 
		'\x2', '\x2', '\x1685', '\x2B5', '\x3', '\x2', '\x2', '\x2', '\x1686', 
		'\x1687', '\a', '\x223', '\x2', '\x2', '\x1687', '\x1695', '\a', '\x271', 
		'\x2', '\x2', '\x1688', '\x1689', '\a', '\x1E0', '\x2', '\x2', '\x1689', 
		'\x1696', '\t', 'K', '\x2', '\x2', '\x168A', '\x168B', '\a', '\x11C', 
		'\x2', '\x2', '\x168B', '\x168F', '\a', '\x12A', '\x2', '\x2', '\x168C', 
		'\x1690', '\a', '\x21E', '\x2', '\x2', '\x168D', '\x168E', '\a', '\x1E0', 
		'\x2', '\x2', '\x168E', '\x1690', '\a', '\\', '\x2', '\x2', '\x168F', 
		'\x168C', '\x3', '\x2', '\x2', '\x2', '\x168F', '\x168D', '\x3', '\x2', 
		'\x2', '\x2', '\x1690', '\x1696', '\x3', '\x2', '\x2', '\x2', '\x1691', 
		'\x1692', '\a', '\x28D', '\x2', '\x2', '\x1692', '\x1693', '\a', '\x204', 
		'\x2', '\x2', '\x1693', '\x1694', '\a', '\x219', '\x2', '\x2', '\x1694', 
		'\x1696', '\x5', '\x47E', '\x240', '\x2', '\x1695', '\x1688', '\x3', '\x2', 
		'\x2', '\x2', '\x1695', '\x168A', '\x3', '\x2', '\x2', '\x2', '\x1695', 
		'\x1691', '\x3', '\x2', '\x2', '\x2', '\x1695', '\x1696', '\x3', '\x2', 
		'\x2', '\x2', '\x1696', '\x1699', '\x3', '\x2', '\x2', '\x2', '\x1697', 
		'\x1698', '\a', '\x167', '\x2', '\x2', '\x1698', '\x169A', '\x5', '\x4AA', 
		'\x256', '\x2', '\x1699', '\x1697', '\x3', '\x2', '\x2', '\x2', '\x1699', 
		'\x169A', '\x3', '\x2', '\x2', '\x2', '\x169A', '\x2B7', '\x3', '\x2', 
		'\x2', '\x2', '\x169B', '\x169C', '\a', '\x223', '\x2', '\x2', '\x169C', 
		'\x16A6', '\t', 'L', '\x2', '\x2', '\x169D', '\x16A7', '\a', '\xE', '\x2', 
		'\x2', '\x169E', '\x16A0', '\a', '\x2F8', '\x2', '\x2', '\x169F', '\x169E', 
		'\x3', '\x2', '\x2', '\x2', '\x169F', '\x16A0', '\x3', '\x2', '\x2', '\x2', 
		'\x16A0', '\x16A1', '\x3', '\x2', '\x2', '\x2', '\x16A1', '\x16A3', '\x5', 
		'\x40C', '\x207', '\x2', '\x16A2', '\x169F', '\x3', '\x2', '\x2', '\x2', 
		'\x16A3', '\x16A4', '\x3', '\x2', '\x2', '\x2', '\x16A4', '\x16A2', '\x3', 
		'\x2', '\x2', '\x2', '\x16A4', '\x16A5', '\x3', '\x2', '\x2', '\x2', '\x16A5', 
		'\x16A7', '\x3', '\x2', '\x2', '\x2', '\x16A6', '\x169D', '\x3', '\x2', 
		'\x2', '\x2', '\x16A6', '\x16A2', '\x3', '\x2', '\x2', '\x2', '\x16A7', 
		'\x16A8', '\x3', '\x2', '\x2', '\x2', '\x16A8', '\x16A9', '\t', '\x1F', 
		'\x2', '\x2', '\x16A9', '\x2B9', '\x3', '\x2', '\x2', '\x2', '\x16AA', 
		'\x16AC', '\a', '[', '\x2', '\x2', '\x16AB', '\x16AD', '\a', '\x2A7', 
		'\x2', '\x2', '\x16AC', '\x16AB', '\x3', '\x2', '\x2', '\x2', '\x16AC', 
		'\x16AD', '\x3', '\x2', '\x2', '\x2', '\x16AD', '\x16BB', '\x3', '\x2', 
		'\x2', '\x2', '\x16AE', '\x16AF', '\a', 'Z', '\x2', '\x2', '\x16AF', '\x16BC', 
		'\x5', '\x37E', '\x1C0', '\x2', '\x16B0', '\x16B9', '\a', '\xDB', '\x2', 
		'\x2', '\x16B1', '\x16B2', '\a', 'o', '\x2', '\x2', '\x16B2', '\x16BA', 
		'\x5', '\x37E', '\x1C0', '\x2', '\x16B3', '\x16BA', '\a', 'n', '\x2', 
		'\x2', '\x16B4', '\x16B7', '\x5', '\x37E', '\x1C0', '\x2', '\x16B5', '\x16B6', 
		'\a', '\x2F8', '\x2', '\x2', '\x16B6', '\x16B8', '\x5', '\x37E', '\x1C0', 
		'\x2', '\x16B7', '\x16B5', '\x3', '\x2', '\x2', '\x2', '\x16B7', '\x16B8', 
		'\x3', '\x2', '\x2', '\x2', '\x16B8', '\x16BA', '\x3', '\x2', '\x2', '\x2', 
		'\x16B9', '\x16B1', '\x3', '\x2', '\x2', '\x2', '\x16B9', '\x16B3', '\x3', 
		'\x2', '\x2', '\x2', '\x16B9', '\x16B4', '\x3', '\x2', '\x2', '\x2', '\x16BA', 
		'\x16BC', '\x3', '\x2', '\x2', '\x2', '\x16BB', '\x16AE', '\x3', '\x2', 
		'\x2', '\x2', '\x16BB', '\x16B0', '\x3', '\x2', '\x2', '\x2', '\x16BB', 
		'\x16BC', '\x3', '\x2', '\x2', '\x2', '\x16BC', '\x16BE', '\x3', '\x2', 
		'\x2', '\x2', '\x16BD', '\x16BF', '\x5', '\x2BC', '\x15F', '\x2', '\x16BE', 
		'\x16BD', '\x3', '\x2', '\x2', '\x2', '\x16BE', '\x16BF', '\x3', '\x2', 
		'\x2', '\x2', '\x16BF', '\x2BB', '\x3', '\x2', '\x2', '\x2', '\x16C0', 
		'\x16C2', '\a', '\x2A8', '\x2', '\x2', '\x16C1', '\x16C3', '\t', 'M', 
		'\x2', '\x2', '\x16C2', '\x16C1', '\x3', '\x2', '\x2', '\x2', '\x16C2', 
		'\x16C3', '\x3', '\x2', '\x2', '\x2', '\x16C3', '\x16C5', '\x3', '\x2', 
		'\x2', '\x2', '\x16C4', '\x16C6', '\t', 'N', '\x2', '\x2', '\x16C5', '\x16C4', 
		'\x3', '\x2', '\x2', '\x2', '\x16C5', '\x16C6', '\x3', '\x2', '\x2', '\x2', 
		'\x16C6', '\x2BD', '\x3', '\x2', '\x2', '\x2', '\x16C7', '\x16C9', '\a', 
		'\x204', '\x2', '\x2', '\x16C8', '\x16CA', '\a', '\x2A7', '\x2', '\x2', 
		'\x16C9', '\x16C8', '\x3', '\x2', '\x2', '\x2', '\x16C9', '\x16CA', '\x3', 
		'\x2', '\x2', '\x2', '\x16CA', '\x16D2', '\x3', '\x2', '\x2', '\x2', '\x16CB', 
		'\x16CD', '\a', '\x26E', '\x2', '\x2', '\x16CC', '\x16CE', '\a', '\x20E', 
		'\x2', '\x2', '\x16CD', '\x16CC', '\x3', '\x2', '\x2', '\x2', '\x16CD', 
		'\x16CE', '\x3', '\x2', '\x2', '\x2', '\x16CE', '\x16CF', '\x3', '\x2', 
		'\x2', '\x2', '\x16CF', '\x16D3', '\x5', '\x47C', '\x23F', '\x2', '\x16D0', 
		'\x16D1', '\a', '\xDB', '\x2', '\x2', '\x16D1', '\x16D3', '\x5', '\x4AA', 
		'\x256', '\x2', '\x16D2', '\x16CB', '\x3', '\x2', '\x2', '\x2', '\x16D2', 
		'\x16D0', '\x3', '\x2', '\x2', '\x2', '\x16D2', '\x16D3', '\x3', '\x2', 
		'\x2', '\x2', '\x16D3', '\x2BF', '\x3', '\x2', '\x2', '\x2', '\x16D4', 
		'\x16D5', '\a', '\x20E', '\x2', '\x2', '\x16D5', '\x16D6', '\x5', '\x47C', 
		'\x23F', '\x2', '\x16D6', '\x2C1', '\x3', '\x2', '\x2', '\x2', '\x16D7', 
		'\x16D8', '\a', '\xC8', '\x2', '\x2', '\x16D8', '\x16DD', '\a', '\x1C5', 
		'\x2', '\x2', '\x16D9', '\x16DA', '\a', '\x223', '\x2', '\x2', '\x16DA', 
		'\x16DB', '\a', '\x23E', '\x2', '\x2', '\x16DB', '\x16DC', '\a', '\x306', 
		'\x2', '\x2', '\x16DC', '\x16DE', '\x5', '\x4AA', '\x256', '\x2', '\x16DD', 
		'\x16D9', '\x3', '\x2', '\x2', '\x2', '\x16DD', '\x16DE', '\x3', '\x2', 
		'\x2', '\x2', '\x16DE', '\x16E1', '\x3', '\x2', '\x2', '\x2', '\x16DF', 
		'\x16E0', '\a', '\x118', '\x2', '\x2', '\x16E0', '\x16E2', '\x5', '\x416', 
		'\x20C', '\x2', '\x16E1', '\x16DF', '\x3', '\x2', '\x2', '\x2', '\x16E1', 
		'\x16E2', '\x3', '\x2', '\x2', '\x2', '\x16E2', '\x16E3', '\x3', '\x2', 
		'\x2', '\x2', '\x16E3', '\x16E9', '\a', '\xDD', '\x2', '\x2', '\x16E4', 
		'\x16EA', '\x5', '\x2C4', '\x163', '\x2', '\x16E5', '\x16EA', '\x5', '\x338', 
		'\x19D', '\x2', '\x16E6', '\x16EA', '\x5', '\x33E', '\x1A0', '\x2', '\x16E7', 
		'\x16EA', '\x5', '\x340', '\x1A1', '\x2', '\x16E8', '\x16EA', '\x5', '\x352', 
		'\x1AA', '\x2', '\x16E9', '\x16E4', '\x3', '\x2', '\x2', '\x2', '\x16E9', 
		'\x16E5', '\x3', '\x2', '\x2', '\x2', '\x16E9', '\x16E6', '\x3', '\x2', 
		'\x2', '\x2', '\x16E9', '\x16E7', '\x3', '\x2', '\x2', '\x2', '\x16E9', 
		'\x16E8', '\x3', '\x2', '\x2', '\x2', '\x16EA', '\x2C3', '\x3', '\x2', 
		'\x2', '\x2', '\x16EB', '\x16ED', '\x5', '\x2C6', '\x164', '\x2', '\x16EC', 
		'\x16EB', '\x3', '\x2', '\x2', '\x2', '\x16EC', '\x16ED', '\x3', '\x2', 
		'\x2', '\x2', '\x16ED', '\x16EE', '\x3', '\x2', '\x2', '\x2', '\x16EE', 
		'\x16F3', '\x5', '\x16E', '\xB8', '\x2', '\x16EF', '\x16F2', '\x5', '\x332', 
		'\x19A', '\x2', '\x16F0', '\x16F2', '\x5', '\x32E', '\x198', '\x2', '\x16F1', 
		'\x16EF', '\x3', '\x2', '\x2', '\x2', '\x16F1', '\x16F0', '\x3', '\x2', 
		'\x2', '\x2', '\x16F2', '\x16F5', '\x3', '\x2', '\x2', '\x2', '\x16F3', 
		'\x16F1', '\x3', '\x2', '\x2', '\x2', '\x16F3', '\x16F4', '\x3', '\x2', 
		'\x2', '\x2', '\x16F4', '\x2C5', '\x3', '\x2', '\x2', '\x2', '\x16F5', 
		'\x16F3', '\x3', '\x2', '\x2', '\x2', '\x16F6', '\x16FB', '\a', '\x2A6', 
		'\x2', '\x2', '\x16F7', '\x16F9', '\a', '\x2F8', '\x2', '\x2', '\x16F8', 
		'\x16F7', '\x3', '\x2', '\x2', '\x2', '\x16F8', '\x16F9', '\x3', '\x2', 
		'\x2', '\x2', '\x16F9', '\x16FA', '\x3', '\x2', '\x2', '\x2', '\x16FA', 
		'\x16FC', '\x5', '\x2C8', '\x165', '\x2', '\x16FB', '\x16F8', '\x3', '\x2', 
		'\x2', '\x2', '\x16FC', '\x16FD', '\x3', '\x2', '\x2', '\x2', '\x16FD', 
		'\x16FB', '\x3', '\x2', '\x2', '\x2', '\x16FD', '\x16FE', '\x3', '\x2', 
		'\x2', '\x2', '\x16FE', '\x2C7', '\x3', '\x2', '\x2', '\x2', '\x16FF', 
		'\x1701', '\x5', '\x486', '\x244', '\x2', '\x1700', '\x1702', '\x5', '\x44A', 
		'\x226', '\x2', '\x1701', '\x1700', '\x3', '\x2', '\x2', '\x2', '\x1701', 
		'\x1702', '\x3', '\x2', '\x2', '\x2', '\x1702', '\x1703', '\x3', '\x2', 
		'\x2', '\x2', '\x1703', '\x1704', '\a', '\x19', '\x2', '\x2', '\x1704', 
		'\x1705', '\a', '\x2F2', '\x2', '\x2', '\x1705', '\x1707', '\x5', '\x16E', 
		'\xB8', '\x2', '\x1706', '\x1708', '\x5', '\x32E', '\x198', '\x2', '\x1707', 
		'\x1706', '\x3', '\x2', '\x2', '\x2', '\x1707', '\x1708', '\x3', '\x2', 
		'\x2', '\x2', '\x1708', '\x1709', '\x3', '\x2', '\x2', '\x2', '\x1709', 
		'\x170B', '\a', '\x2F3', '\x2', '\x2', '\x170A', '\x170C', '\x5', '\x2CA', 
		'\x166', '\x2', '\x170B', '\x170A', '\x3', '\x2', '\x2', '\x2', '\x170B', 
		'\x170C', '\x3', '\x2', '\x2', '\x2', '\x170C', '\x170E', '\x3', '\x2', 
		'\x2', '\x2', '\x170D', '\x170F', '\x5', '\x2CC', '\x167', '\x2', '\x170E', 
		'\x170D', '\x3', '\x2', '\x2', '\x2', '\x170E', '\x170F', '\x3', '\x2', 
		'\x2', '\x2', '\x170F', '\x2C9', '\x3', '\x2', '\x2', '\x2', '\x1710', 
		'\x1711', '\a', '\x215', '\x2', '\x2', '\x1711', '\x1712', '\t', 'O', 
		'\x2', '\x2', '\x1712', '\x1713', '\a', '\xD2', '\x2', '\x2', '\x1713', 
		'\x1714', '\a', '?', '\x2', '\x2', '\x1714', '\x1716', '\x5', '\x490', 
		'\x249', '\x2', '\x1715', '\x1717', '\a', '\x1A', '\x2', '\x2', '\x1716', 
		'\x1715', '\x3', '\x2', '\x2', '\x2', '\x1716', '\x1717', '\x3', '\x2', 
		'\x2', '\x2', '\x1717', '\x1719', '\x3', '\x2', '\x2', '\x2', '\x1718', 
		'\x171A', '\a', '\x97', '\x2', '\x2', '\x1719', '\x1718', '\x3', '\x2', 
		'\x2', '\x2', '\x1719', '\x171A', '\x3', '\x2', '\x2', '\x2', '\x171A', 
		'\x171D', '\x3', '\x2', '\x2', '\x2', '\x171B', '\x171C', '\a', '\x18E', 
		'\x2', '\x2', '\x171C', '\x171E', '\a', '\xD2', '\x2', '\x2', '\x171D', 
		'\x171B', '\x3', '\x2', '\x2', '\x2', '\x171D', '\x171E', '\x3', '\x2', 
		'\x2', '\x2', '\x171E', '\x1721', '\x3', '\x2', '\x2', '\x2', '\x171F', 
		'\x1720', '\a', '\x18E', '\x2', '\x2', '\x1720', '\x1722', '\a', '\x125', 
		'\x2', '\x2', '\x1721', '\x171F', '\x3', '\x2', '\x2', '\x2', '\x1721', 
		'\x1722', '\x3', '\x2', '\x2', '\x2', '\x1722', '\x1735', '\x3', '\x2', 
		'\x2', '\x2', '\x1723', '\x1724', '\a', '\x2F8', '\x2', '\x2', '\x1724', 
		'\x1726', '\x5', '\x490', '\x249', '\x2', '\x1725', '\x1727', '\a', '\x1A', 
		'\x2', '\x2', '\x1726', '\x1725', '\x3', '\x2', '\x2', '\x2', '\x1726', 
		'\x1727', '\x3', '\x2', '\x2', '\x2', '\x1727', '\x1729', '\x3', '\x2', 
		'\x2', '\x2', '\x1728', '\x172A', '\a', '\x97', '\x2', '\x2', '\x1729', 
		'\x1728', '\x3', '\x2', '\x2', '\x2', '\x1729', '\x172A', '\x3', '\x2', 
		'\x2', '\x2', '\x172A', '\x172D', '\x3', '\x2', '\x2', '\x2', '\x172B', 
		'\x172C', '\a', '\x18E', '\x2', '\x2', '\x172C', '\x172E', '\a', '\xD2', 
		'\x2', '\x2', '\x172D', '\x172B', '\x3', '\x2', '\x2', '\x2', '\x172D', 
		'\x172E', '\x3', '\x2', '\x2', '\x2', '\x172E', '\x1731', '\x3', '\x2', 
		'\x2', '\x2', '\x172F', '\x1730', '\a', '\x18E', '\x2', '\x2', '\x1730', 
		'\x1732', '\a', '\x125', '\x2', '\x2', '\x1731', '\x172F', '\x3', '\x2', 
		'\x2', '\x2', '\x1731', '\x1732', '\x3', '\x2', '\x2', '\x2', '\x1732', 
		'\x1734', '\x3', '\x2', '\x2', '\x2', '\x1733', '\x1723', '\x3', '\x2', 
		'\x2', '\x2', '\x1734', '\x1737', '\x3', '\x2', '\x2', '\x2', '\x1735', 
		'\x1733', '\x3', '\x2', '\x2', '\x2', '\x1735', '\x1736', '\x3', '\x2', 
		'\x2', '\x2', '\x1736', '\x1738', '\x3', '\x2', '\x2', '\x2', '\x1737', 
		'\x1735', '\x3', '\x2', '\x2', '\x2', '\x1738', '\x1739', '\a', '\x223', 
		'\x2', '\x2', '\x1739', '\x173A', '\x5', '\x490', '\x249', '\x2', '\x173A', 
		'\x2CB', '\x3', '\x2', '\x2', '\x2', '\x173B', '\x173C', '\a', '|', '\x2', 
		'\x2', '\x173C', '\x173D', '\x5', '\x448', '\x225', '\x2', '\x173D', '\x173E', 
		'\a', '\x223', '\x2', '\x2', '\x173E', '\x173F', '\x5', '\x490', '\x249', 
		'\x2', '\x173F', '\x1740', '\a', '\x26E', '\x2', '\x2', '\x1740', '\x1741', 
		'\x5', '\x37E', '\x1C0', '\x2', '\x1741', '\x1742', '\a', '\x8F', '\x2', 
		'\x2', '\x1742', '\x1743', '\x5', '\x37E', '\x1C0', '\x2', '\x1743', '\x2CD', 
		'\x3', '\x2', '\x2', '\x2', '\x1744', '\x174A', '\x5', '\x2D2', '\x16A', 
		'\x2', '\x1745', '\x1746', '\a', '\x2F2', '\x2', '\x2', '\x1746', '\x1747', 
		'\x5', '\x16E', '\xB8', '\x2', '\x1747', '\x1748', '\a', '\x2F3', '\x2', 
		'\x2', '\x1748', '\x174A', '\x3', '\x2', '\x2', '\x2', '\x1749', '\x1744', 
		'\x3', '\x2', '\x2', '\x2', '\x1749', '\x1745', '\x3', '\x2', '\x2', '\x2', 
		'\x174A', '\x2CF', '\x3', '\x2', '\x2', '\x2', '\x174B', '\x174D', '\a', 
		'\x27F', '\x2', '\x2', '\x174C', '\x174E', '\a', '\xE', '\x2', '\x2', 
		'\x174D', '\x174C', '\x3', '\x2', '\x2', '\x2', '\x174D', '\x174E', '\x3', 
		'\x2', '\x2', '\x2', '\x174E', '\x1752', '\x3', '\x2', '\x2', '\x2', '\x174F', 
		'\x1752', '\a', '\x114', '\x2', '\x2', '\x1750', '\x1752', '\a', '\x15B', 
		'\x2', '\x2', '\x1751', '\x174B', '\x3', '\x2', '\x2', '\x2', '\x1751', 
		'\x174F', '\x3', '\x2', '\x2', '\x2', '\x1751', '\x1750', '\x3', '\x2', 
		'\x2', '\x2', '\x1752', '\x1753', '\x3', '\x2', '\x2', '\x2', '\x1753', 
		'\x1754', '\x5', '\x2CE', '\x168', '\x2', '\x1754', '\x2D1', '\x3', '\x2', 
		'\x2', '\x2', '\x1755', '\x1757', '\a', '\x21A', '\x2', '\x2', '\x1756', 
		'\x1758', '\t', 'P', '\x2', '\x2', '\x1757', '\x1756', '\x3', '\x2', '\x2', 
		'\x2', '\x1757', '\x1758', '\x3', '\x2', '\x2', '\x2', '\x1758', '\x1762', 
		'\x3', '\x2', '\x2', '\x2', '\x1759', '\x1763', '\a', '\x2F5', '\x2', 
		'\x2', '\x175A', '\x175C', '\a', '\x2F8', '\x2', '\x2', '\x175B', '\x175A', 
		'\x3', '\x2', '\x2', '\x2', '\x175B', '\x175C', '\x3', '\x2', '\x2', '\x2', 
		'\x175C', '\x175D', '\x3', '\x2', '\x2', '\x2', '\x175D', '\x175F', '\x5', 
		'\x2D4', '\x16B', '\x2', '\x175E', '\x175B', '\x3', '\x2', '\x2', '\x2', 
		'\x175F', '\x1760', '\x3', '\x2', '\x2', '\x2', '\x1760', '\x175E', '\x3', 
		'\x2', '\x2', '\x2', '\x1760', '\x1761', '\x3', '\x2', '\x2', '\x2', '\x1761', 
		'\x1763', '\x3', '\x2', '\x2', '\x2', '\x1762', '\x1759', '\x3', '\x2', 
		'\x2', '\x2', '\x1762', '\x175E', '\x3', '\x2', '\x2', '\x2', '\x1763', 
		'\x1765', '\x3', '\x2', '\x2', '\x2', '\x1764', '\x1766', '\x5', '\x400', 
		'\x201', '\x2', '\x1765', '\x1764', '\x3', '\x2', '\x2', '\x2', '\x1765', 
		'\x1766', '\x3', '\x2', '\x2', '\x2', '\x1766', '\x1767', '\x3', '\x2', 
		'\x2', '\x2', '\x1767', '\x1769', '\x5', '\x2D6', '\x16C', '\x2', '\x1768', 
		'\x176A', '\x5', '\x3FE', '\x200', '\x2', '\x1769', '\x1768', '\x3', '\x2', 
		'\x2', '\x2', '\x1769', '\x176A', '\x3', '\x2', '\x2', '\x2', '\x176A', 
		'\x176C', '\x3', '\x2', '\x2', '\x2', '\x176B', '\x176D', '\x5', '\x300', 
		'\x181', '\x2', '\x176C', '\x176B', '\x3', '\x2', '\x2', '\x2', '\x176C', 
		'\x176D', '\x3', '\x2', '\x2', '\x2', '\x176D', '\x176F', '\x3', '\x2', 
		'\x2', '\x2', '\x176E', '\x1770', '\x5', '\x304', '\x183', '\x2', '\x176F', 
		'\x176E', '\x3', '\x2', '\x2', '\x2', '\x176F', '\x1770', '\x3', '\x2', 
		'\x2', '\x2', '\x1770', '\x1772', '\x3', '\x2', '\x2', '\x2', '\x1771', 
		'\x1773', '\x5', '\x310', '\x189', '\x2', '\x1772', '\x1771', '\x3', '\x2', 
		'\x2', '\x2', '\x1772', '\x1773', '\x3', '\x2', '\x2', '\x2', '\x1773', 
		'\x2D3', '\x3', '\x2', '\x2', '\x2', '\x1774', '\x1776', '\x5', '\x2D8', 
		'\x16D', '\x2', '\x1775', '\x1777', '\x5', '\x3FA', '\x1FE', '\x2', '\x1776', 
		'\x1775', '\x3', '\x2', '\x2', '\x2', '\x1776', '\x1777', '\x3', '\x2', 
		'\x2', '\x2', '\x1777', '\x2D5', '\x3', '\x2', '\x2', '\x2', '\x1778', 
		'\x1779', '\a', '\xE1', '\x2', '\x2', '\x1779', '\x177A', '\x5', '\x2DA', 
		'\x16E', '\x2', '\x177A', '\x2D7', '\x3', '\x2', '\x2', '\x2', '\x177B', 
		'\x177C', '\x5', '\x416', '\x20C', '\x2', '\x177C', '\x177D', '\a', '\x2EB', 
		'\x2', '\x2', '\x177D', '\x177E', '\a', '\x2F5', '\x2', '\x2', '\x177E', 
		'\x1786', '\x3', '\x2', '\x2', '\x2', '\x177F', '\x1780', '\x5', '\x49E', 
		'\x250', '\x2', '\x1780', '\x1781', '\a', '\x2EB', '\x2', '\x2', '\x1781', 
		'\x1783', '\x3', '\x2', '\x2', '\x2', '\x1782', '\x177F', '\x3', '\x2', 
		'\x2', '\x2', '\x1782', '\x1783', '\x3', '\x2', '\x2', '\x2', '\x1783', 
		'\x1784', '\x3', '\x2', '\x2', '\x2', '\x1784', '\x1786', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1785', '\x177B', '\x3', '\x2', '\x2', '\x2', '\x1785', 
		'\x1782', '\x3', '\x2', '\x2', '\x2', '\x1786', '\x2D9', '\x3', '\x2', 
		'\x2', '\x2', '\x1787', '\x1789', '\a', '\x2F8', '\x2', '\x2', '\x1788', 
		'\x1787', '\x3', '\x2', '\x2', '\x2', '\x1788', '\x1789', '\x3', '\x2', 
		'\x2', '\x2', '\x1789', '\x178A', '\x3', '\x2', '\x2', '\x2', '\x178A', 
		'\x178C', '\x5', '\x2DC', '\x16F', '\x2', '\x178B', '\x1788', '\x3', '\x2', 
		'\x2', '\x2', '\x178C', '\x178D', '\x3', '\x2', '\x2', '\x2', '\x178D', 
		'\x178B', '\x3', '\x2', '\x2', '\x2', '\x178D', '\x178E', '\x3', '\x2', 
		'\x2', '\x2', '\x178E', '\x2DB', '\x3', '\x2', '\x2', '\x2', '\x178F', 
		'\x1793', '\x5', '\x2DE', '\x170', '\x2', '\x1790', '\x1792', '\x5', '\x2E2', 
		'\x172', '\x2', '\x1791', '\x1790', '\x3', '\x2', '\x2', '\x2', '\x1792', 
		'\x1795', '\x3', '\x2', '\x2', '\x2', '\x1793', '\x1791', '\x3', '\x2', 
		'\x2', '\x2', '\x1793', '\x1794', '\x3', '\x2', '\x2', '\x2', '\x1794', 
		'\x1798', '\x3', '\x2', '\x2', '\x2', '\x1795', '\x1793', '\x3', '\x2', 
		'\x2', '\x2', '\x1796', '\x1799', '\x5', '\x2EE', '\x178', '\x2', '\x1797', 
		'\x1799', '\x5', '\x2FA', '\x17E', '\x2', '\x1798', '\x1796', '\x3', '\x2', 
		'\x2', '\x2', '\x1798', '\x1797', '\x3', '\x2', '\x2', '\x2', '\x1798', 
		'\x1799', '\x3', '\x2', '\x2', '\x2', '\x1799', '\x2DD', '\x3', '\x2', 
		'\x2', '\x2', '\x179A', '\x179E', '\x5', '\x2E0', '\x171', '\x2', '\x179B', 
		'\x179D', '\x5', '\x2EC', '\x177', '\x2', '\x179C', '\x179B', '\x3', '\x2', 
		'\x2', '\x2', '\x179D', '\x17A0', '\x3', '\x2', '\x2', '\x2', '\x179E', 
		'\x179C', '\x3', '\x2', '\x2', '\x2', '\x179E', '\x179F', '\x3', '\x2', 
		'\x2', '\x2', '\x179F', '\x17A2', '\x3', '\x2', '\x2', '\x2', '\x17A0', 
		'\x179E', '\x3', '\x2', '\x2', '\x2', '\x17A1', '\x17A3', '\x5', '\x3FC', 
		'\x1FF', '\x2', '\x17A2', '\x17A1', '\x3', '\x2', '\x2', '\x2', '\x17A2', 
		'\x17A3', '\x3', '\x2', '\x2', '\x2', '\x17A3', '\x2DF', '\x3', '\x2', 
		'\x2', '\x2', '\x17A4', '\x17A7', '\x5', '\x370', '\x1B9', '\x2', '\x17A5', 
		'\x17A8', '\x5', '\x2EE', '\x178', '\x2', '\x17A6', '\x17A8', '\x5', '\x2FA', 
		'\x17E', '\x2', '\x17A7', '\x17A5', '\x3', '\x2', '\x2', '\x2', '\x17A7', 
		'\x17A6', '\x3', '\x2', '\x2', '\x2', '\x17A7', '\x17A8', '\x3', '\x2', 
		'\x2', '\x2', '\x17A8', '\x17BC', '\x3', '\x2', '\x2', '\x2', '\x17A9', 
		'\x17AA', '\a', '\x2F2', '\x2', '\x2', '\x17AA', '\x17AE', '\x5', '\x2DC', 
		'\x16F', '\x2', '\x17AB', '\x17AD', '\x5', '\x2D0', '\x169', '\x2', '\x17AC', 
		'\x17AB', '\x3', '\x2', '\x2', '\x2', '\x17AD', '\x17B0', '\x3', '\x2', 
		'\x2', '\x2', '\x17AE', '\x17AC', '\x3', '\x2', '\x2', '\x2', '\x17AE', 
		'\x17AF', '\x3', '\x2', '\x2', '\x2', '\x17AF', '\x17B1', '\x3', '\x2', 
		'\x2', '\x2', '\x17B0', '\x17AE', '\x3', '\x2', '\x2', '\x2', '\x17B1', 
		'\x17B4', '\a', '\x2F3', '\x2', '\x2', '\x17B2', '\x17B5', '\x5', '\x2EE', 
		'\x178', '\x2', '\x17B3', '\x17B5', '\x5', '\x2FA', '\x17E', '\x2', '\x17B4', 
		'\x17B2', '\x3', '\x2', '\x2', '\x2', '\x17B4', '\x17B3', '\x3', '\x2', 
		'\x2', '\x2', '\x17B4', '\x17B5', '\x3', '\x2', '\x2', '\x2', '\x17B5', 
		'\x17BC', '\x3', '\x2', '\x2', '\x2', '\x17B6', '\x17B7', '\a', '\x19A', 
		'\x2', '\x2', '\x17B7', '\x17B8', '\a', '\x2F2', '\x2', '\x2', '\x17B8', 
		'\x17B9', '\x5', '\x370', '\x1B9', '\x2', '\x17B9', '\x17BA', '\a', '\x2F3', 
		'\x2', '\x2', '\x17BA', '\x17BC', '\x3', '\x2', '\x2', '\x2', '\x17BB', 
		'\x17A4', '\x3', '\x2', '\x2', '\x2', '\x17BB', '\x17A9', '\x3', '\x2', 
		'\x2', '\x2', '\x17BB', '\x17B6', '\x3', '\x2', '\x2', '\x2', '\x17BC', 
		'\x2E1', '\x3', '\x2', '\x2', '\x2', '\x17BD', '\x17BF', '\x5', '\x2EA', 
		'\x176', '\x2', '\x17BE', '\x17BD', '\x3', '\x2', '\x2', '\x2', '\x17BE', 
		'\x17BF', '\x3', '\x2', '\x2', '\x2', '\x17BF', '\x17C1', '\x3', '\x2', 
		'\x2', '\x2', '\x17C0', '\x17C2', '\t', 'Q', '\x2', '\x2', '\x17C1', '\x17C0', 
		'\x3', '\x2', '\x2', '\x2', '\x17C1', '\x17C2', '\x3', '\x2', '\x2', '\x2', 
		'\x17C2', '\x17C5', '\x3', '\x2', '\x2', '\x2', '\x17C3', '\x17C6', '\a', 
		'\x10E', '\x2', '\x2', '\x17C4', '\x17C6', '\x5', '\x2E8', '\x175', '\x2', 
		'\x17C5', '\x17C3', '\x3', '\x2', '\x2', '\x2', '\x17C5', '\x17C4', '\x3', 
		'\x2', '\x2', '\x2', '\x17C5', '\x17C6', '\x3', '\x2', '\x2', '\x2', '\x17C6', 
		'\x17C7', '\x3', '\x2', '\x2', '\x2', '\x17C7', '\x17C8', '\a', '\x120', 
		'\x2', '\x2', '\x17C8', '\x17CA', '\x5', '\x2DE', '\x170', '\x2', '\x17C9', 
		'\x17CB', '\x5', '\x2EA', '\x176', '\x2', '\x17CA', '\x17C9', '\x3', '\x2', 
		'\x2', '\x2', '\x17CA', '\x17CB', '\x3', '\x2', '\x2', '\x2', '\x17CB', 
		'\x17D0', '\x3', '\x2', '\x2', '\x2', '\x17CC', '\x17CF', '\x5', '\x2E4', 
		'\x173', '\x2', '\x17CD', '\x17CF', '\x5', '\x2E6', '\x174', '\x2', '\x17CE', 
		'\x17CC', '\x3', '\x2', '\x2', '\x2', '\x17CE', '\x17CD', '\x3', '\x2', 
		'\x2', '\x2', '\x17CF', '\x17D2', '\x3', '\x2', '\x2', '\x2', '\x17D0', 
		'\x17CE', '\x3', '\x2', '\x2', '\x2', '\x17D0', '\x17D1', '\x3', '\x2', 
		'\x2', '\x2', '\x17D1', '\x2E3', '\x3', '\x2', '\x2', '\x2', '\x17D2', 
		'\x17D0', '\x3', '\x2', '\x2', '\x2', '\x17D3', '\x17D4', '\a', '\x19B', 
		'\x2', '\x2', '\x17D4', '\x17D5', '\x5', '\x37A', '\x1BE', '\x2', '\x17D5', 
		'\x2E5', '\x3', '\x2', '\x2', '\x2', '\x17D6', '\x17D7', '\a', '\x28E', 
		'\x2', '\x2', '\x17D7', '\x17D8', '\x5', '\x44A', '\x226', '\x2', '\x17D8', 
		'\x2E7', '\x3', '\x2', '\x2', '\x2', '\x17D9', '\x17DB', '\t', 'R', '\x2', 
		'\x2', '\x17DA', '\x17DC', '\a', '\x1A6', '\x2', '\x2', '\x17DB', '\x17DA', 
		'\x3', '\x2', '\x2', '\x2', '\x17DB', '\x17DC', '\x3', '\x2', '\x2', '\x2', 
		'\x17DC', '\x2E9', '\x3', '\x2', '\x2', '\x2', '\x17DD', '\x17DE', '\a', 
		'\x1B2', '\x2', '\x2', '\x17DE', '\x17E6', '\a', '?', '\x2', '\x2', '\x17DF', 
		'\x17E2', '\a', '\x2F2', '\x2', '\x2', '\x17E0', '\x17E3', '\x5', '\x16E', 
		'\xB8', '\x2', '\x17E1', '\x17E3', '\x5', '\x37C', '\x1BF', '\x2', '\x17E2', 
		'\x17E0', '\x3', '\x2', '\x2', '\x2', '\x17E2', '\x17E1', '\x3', '\x2', 
		'\x2', '\x2', '\x17E2', '\x17E3', '\x3', '\x2', '\x2', '\x2', '\x17E3', 
		'\x17E4', '\x3', '\x2', '\x2', '\x2', '\x17E4', '\x17E7', '\a', '\x2F3', 
		'\x2', '\x2', '\x17E5', '\x17E7', '\x5', '\x37C', '\x1BF', '\x2', '\x17E6', 
		'\x17DF', '\x3', '\x2', '\x2', '\x2', '\x17E6', '\x17E5', '\x3', '\x2', 
		'\x2', '\x2', '\x17E7', '\x2EB', '\x3', '\x2', '\x2', '\x2', '\x17E8', 
		'\x17E9', '\a', '\x298', '\x2', '\x2', '\x17E9', '\x17EA', '\a', '.', 
		'\x2', '\x2', '\x17EA', '\x17EB', '\t', 'S', '\x2', '\x2', '\x17EB', '\x17F1', 
		'\x5', '\x37E', '\x1C0', '\x2', '\x17EC', '\x17ED', '\a', '\x19', '\x2', 
		'\x2', '\x17ED', '\x17EE', '\a', '\x195', '\x2', '\x2', '\x17EE', '\x17EF', 
		'\t', 'T', '\x2', '\x2', '\x17EF', '\x17F1', '\x5', '\x37E', '\x1C0', 
		'\x2', '\x17F0', '\x17E8', '\x3', '\x2', '\x2', '\x2', '\x17F0', '\x17EC', 
		'\x3', '\x2', '\x2', '\x2', '\x17F1', '\x2ED', '\x3', '\x2', '\x2', '\x2', 
		'\x17F2', '\x17F4', '\a', '\x1C4', '\x2', '\x2', '\x17F3', '\x17F5', '\a', 
		'\x2B9', '\x2', '\x2', '\x17F4', '\x17F3', '\x3', '\x2', '\x2', '\x2', 
		'\x17F4', '\x17F5', '\x3', '\x2', '\x2', '\x2', '\x17F5', '\x17F6', '\x3', 
		'\x2', '\x2', '\x2', '\x17F6', '\x17FB', '\a', '\x2F2', '\x2', '\x2', 
		'\x17F7', '\x17F9', '\a', '\x2F8', '\x2', '\x2', '\x17F8', '\x17F7', '\x3', 
		'\x2', '\x2', '\x2', '\x17F8', '\x17F9', '\x3', '\x2', '\x2', '\x2', '\x17F9', 
		'\x17FA', '\x3', '\x2', '\x2', '\x2', '\x17FA', '\x17FC', '\x5', '\x2F0', 
		'\x179', '\x2', '\x17FB', '\x17F8', '\x3', '\x2', '\x2', '\x2', '\x17FC', 
		'\x17FD', '\x3', '\x2', '\x2', '\x2', '\x17FD', '\x17FB', '\x3', '\x2', 
		'\x2', '\x2', '\x17FD', '\x17FE', '\x3', '\x2', '\x2', '\x2', '\x17FE', 
		'\x17FF', '\x3', '\x2', '\x2', '\x2', '\x17FF', '\x1800', '\x5', '\x2F2', 
		'\x17A', '\x2', '\x1800', '\x1801', '\x5', '\x2F4', '\x17B', '\x2', '\x1801', 
		'\x1802', '\a', '\x2F3', '\x2', '\x2', '\x1802', '\x2EF', '\x3', '\x2', 
		'\x2', '\x2', '\x1803', '\x1804', '\x5', '\x48C', '\x247', '\x2', '\x1804', 
		'\x1805', '\a', '\x2F2', '\x2', '\x2', '\x1805', '\x1806', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1806', '\x1808', '\a', '\x2F3', '\x2', '\x2', '\x1807', 
		'\x1809', '\x5', '\x3FA', '\x1FE', '\x2', '\x1808', '\x1807', '\x3', '\x2', 
		'\x2', '\x2', '\x1808', '\x1809', '\x3', '\x2', '\x2', '\x2', '\x1809', 
		'\x2F1', '\x3', '\x2', '\x2', '\x2', '\x180A', '\x180D', '\a', '\xDD', 
		'\x2', '\x2', '\x180B', '\x180E', '\x5', '\x490', '\x249', '\x2', '\x180C', 
		'\x180E', '\x5', '\x44A', '\x226', '\x2', '\x180D', '\x180B', '\x3', '\x2', 
		'\x2', '\x2', '\x180D', '\x180C', '\x3', '\x2', '\x2', '\x2', '\x180E', 
		'\x2F3', '\x3', '\x2', '\x2', '\x2', '\x180F', '\x1810', '\a', '\x108', 
		'\x2', '\x2', '\x1810', '\x1822', '\a', '\x2F2', '\x2', '\x2', '\x1811', 
		'\x1823', '\x5', '\x16E', '\xB8', '\x2', '\x1812', '\x1814', '\a', '\x2F8', 
		'\x2', '\x2', '\x1813', '\x1812', '\x3', '\x2', '\x2', '\x2', '\x1813', 
		'\x1814', '\x3', '\x2', '\x2', '\x2', '\x1814', '\x1815', '\x3', '\x2', 
		'\x2', '\x2', '\x1815', '\x1817', '\a', '\x14', '\x2', '\x2', '\x1816', 
		'\x1813', '\x3', '\x2', '\x2', '\x2', '\x1817', '\x1818', '\x3', '\x2', 
		'\x2', '\x2', '\x1818', '\x1816', '\x3', '\x2', '\x2', '\x2', '\x1818', 
		'\x1819', '\x3', '\x2', '\x2', '\x2', '\x1819', '\x1823', '\x3', '\x2', 
		'\x2', '\x2', '\x181A', '\x181C', '\a', '\x2F8', '\x2', '\x2', '\x181B', 
		'\x181A', '\x3', '\x2', '\x2', '\x2', '\x181B', '\x181C', '\x3', '\x2', 
		'\x2', '\x2', '\x181C', '\x181D', '\x3', '\x2', '\x2', '\x2', '\x181D', 
		'\x181F', '\x5', '\x2F6', '\x17C', '\x2', '\x181E', '\x181B', '\x3', '\x2', 
		'\x2', '\x2', '\x181F', '\x1820', '\x3', '\x2', '\x2', '\x2', '\x1820', 
		'\x181E', '\x3', '\x2', '\x2', '\x2', '\x1820', '\x1821', '\x3', '\x2', 
		'\x2', '\x2', '\x1821', '\x1823', '\x3', '\x2', '\x2', '\x2', '\x1822', 
		'\x1811', '\x3', '\x2', '\x2', '\x2', '\x1822', '\x1816', '\x3', '\x2', 
		'\x2', '\x2', '\x1822', '\x181E', '\x3', '\x2', '\x2', '\x2', '\x1823', 
		'\x1824', '\x3', '\x2', '\x2', '\x2', '\x1824', '\x1825', '\a', '\x2F3', 
		'\x2', '\x2', '\x1825', '\x2F5', '\x3', '\x2', '\x2', '\x2', '\x1826', 
		'\x1828', '\x5', '\x2F8', '\x17D', '\x2', '\x1827', '\x1829', '\x5', '\x3FA', 
		'\x1FE', '\x2', '\x1828', '\x1827', '\x3', '\x2', '\x2', '\x2', '\x1828', 
		'\x1829', '\x3', '\x2', '\x2', '\x2', '\x1829', '\x2F7', '\x3', '\x2', 
		'\x2', '\x2', '\x182A', '\x1831', '\x5', '\x37E', '\x1C0', '\x2', '\x182B', 
		'\x182D', '\a', '\x2F2', '\x2', '\x2', '\x182C', '\x182E', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x182D', '\x182C', '\x3', '\x2', '\x2', '\x2', '\x182D', 
		'\x182E', '\x3', '\x2', '\x2', '\x2', '\x182E', '\x182F', '\x3', '\x2', 
		'\x2', '\x2', '\x182F', '\x1831', '\a', '\x2F3', '\x2', '\x2', '\x1830', 
		'\x182A', '\x3', '\x2', '\x2', '\x2', '\x1830', '\x182B', '\x3', '\x2', 
		'\x2', '\x2', '\x1831', '\x2F9', '\x3', '\x2', '\x2', '\x2', '\x1832', 
		'\x1835', '\a', '\x283', '\x2', '\x2', '\x1833', '\x1834', '\t', 'U', 
		'\x2', '\x2', '\x1834', '\x1836', '\a', '\x18E', '\x2', '\x2', '\x1835', 
		'\x1833', '\x3', '\x2', '\x2', '\x2', '\x1835', '\x1836', '\x3', '\x2', 
		'\x2', '\x2', '\x1836', '\x1837', '\x3', '\x2', '\x2', '\x2', '\x1837', 
		'\x183A', '\a', '\x2F2', '\x2', '\x2', '\x1838', '\x183B', '\x5', '\x490', 
		'\x249', '\x2', '\x1839', '\x183B', '\x5', '\x44A', '\x226', '\x2', '\x183A', 
		'\x1838', '\x3', '\x2', '\x2', '\x2', '\x183A', '\x1839', '\x3', '\x2', 
		'\x2', '\x2', '\x183B', '\x183C', '\x3', '\x2', '\x2', '\x2', '\x183C', 
		'\x183D', '\x5', '\x2F2', '\x17A', '\x2', '\x183D', '\x183E', '\x5', '\x2FC', 
		'\x17F', '\x2', '\x183E', '\x183F', '\a', '\x2F3', '\x2', '\x2', '\x183F', 
		'\x2FB', '\x3', '\x2', '\x2', '\x2', '\x1840', '\x1841', '\a', '\x108', 
		'\x2', '\x2', '\x1841', '\x1846', '\a', '\x2F2', '\x2', '\x2', '\x1842', 
		'\x1844', '\a', '\x2F8', '\x2', '\x2', '\x1843', '\x1842', '\x3', '\x2', 
		'\x2', '\x2', '\x1843', '\x1844', '\x3', '\x2', '\x2', '\x2', '\x1844', 
		'\x1845', '\x3', '\x2', '\x2', '\x2', '\x1845', '\x1847', '\x5', '\x2FE', 
		'\x180', '\x2', '\x1846', '\x1843', '\x3', '\x2', '\x2', '\x2', '\x1847', 
		'\x1848', '\x3', '\x2', '\x2', '\x2', '\x1848', '\x1846', '\x3', '\x2', 
		'\x2', '\x2', '\x1848', '\x1849', '\x3', '\x2', '\x2', '\x2', '\x1849', 
		'\x184A', '\x3', '\x2', '\x2', '\x2', '\x184A', '\x184B', '\a', '\x2F3', 
		'\x2', '\x2', '\x184B', '\x2FD', '\x3', '\x2', '\x2', '\x2', '\x184C', 
		'\x184F', '\x5', '\x490', '\x249', '\x2', '\x184D', '\x184F', '\x5', '\x44A', 
		'\x226', '\x2', '\x184E', '\x184C', '\x3', '\x2', '\x2', '\x2', '\x184E', 
		'\x184D', '\x3', '\x2', '\x2', '\x2', '\x184F', '\x185F', '\x3', '\x2', 
		'\x2', '\x2', '\x1850', '\x185D', '\a', '\x19', '\x2', '\x2', '\x1851', 
		'\x185E', '\x5', '\x46C', '\x237', '\x2', '\x1852', '\x1857', '\a', '\x2F2', 
		'\x2', '\x2', '\x1853', '\x1855', '\a', '\x2F8', '\x2', '\x2', '\x1854', 
		'\x1853', '\x3', '\x2', '\x2', '\x2', '\x1854', '\x1855', '\x3', '\x2', 
		'\x2', '\x2', '\x1855', '\x1856', '\x3', '\x2', '\x2', '\x2', '\x1856', 
		'\x1858', '\x5', '\x46C', '\x237', '\x2', '\x1857', '\x1854', '\x3', '\x2', 
		'\x2', '\x2', '\x1858', '\x1859', '\x3', '\x2', '\x2', '\x2', '\x1859', 
		'\x1857', '\x3', '\x2', '\x2', '\x2', '\x1859', '\x185A', '\x3', '\x2', 
		'\x2', '\x2', '\x185A', '\x185B', '\x3', '\x2', '\x2', '\x2', '\x185B', 
		'\x185C', '\a', '\x2F3', '\x2', '\x2', '\x185C', '\x185E', '\x3', '\x2', 
		'\x2', '\x2', '\x185D', '\x1851', '\x3', '\x2', '\x2', '\x2', '\x185D', 
		'\x1852', '\x3', '\x2', '\x2', '\x2', '\x185E', '\x1860', '\x3', '\x2', 
		'\x2', '\x2', '\x185F', '\x1850', '\x3', '\x2', '\x2', '\x2', '\x185F', 
		'\x1860', '\x3', '\x2', '\x2', '\x2', '\x1860', '\x2FF', '\x3', '\x2', 
		'\x2', '\x2', '\x1861', '\x1862', '\a', '\x63', '\x2', '\x2', '\x1862', 
		'\x1864', '\a', '?', '\x2', '\x2', '\x1863', '\x1865', '\a', '\x176', 
		'\x2', '\x2', '\x1864', '\x1863', '\x3', '\x2', '\x2', '\x2', '\x1864', 
		'\x1865', '\x3', '\x2', '\x2', '\x2', '\x1865', '\x1866', '\x3', '\x2', 
		'\x2', '\x2', '\x1866', '\x1868', '\x5', '\x37A', '\x1BE', '\x2', '\x1867', 
		'\x1869', '\x5', '\x302', '\x182', '\x2', '\x1868', '\x1867', '\x3', '\x2', 
		'\x2', '\x2', '\x1868', '\x1869', '\x3', '\x2', '\x2', '\x2', '\x1869', 
		'\x1873', '\x3', '\x2', '\x2', '\x2', '\x186A', '\x186B', '\x5', '\x302', 
		'\x182', '\x2', '\x186B', '\x186C', '\a', '\x63', '\x2', '\x2', '\x186C', 
		'\x186E', '\a', '?', '\x2', '\x2', '\x186D', '\x186F', '\a', '\x176', 
		'\x2', '\x2', '\x186E', '\x186D', '\x3', '\x2', '\x2', '\x2', '\x186E', 
		'\x186F', '\x3', '\x2', '\x2', '\x2', '\x186F', '\x1870', '\x3', '\x2', 
		'\x2', '\x2', '\x1870', '\x1871', '\x5', '\x37A', '\x1BE', '\x2', '\x1871', 
		'\x1873', '\x3', '\x2', '\x2', '\x2', '\x1872', '\x1861', '\x3', '\x2', 
		'\x2', '\x2', '\x1872', '\x186A', '\x3', '\x2', '\x2', '\x2', '\x1873', 
		'\x301', '\x3', '\x2', '\x2', '\x2', '\x1874', '\x1875', '\a', '\x23C', 
		'\x2', '\x2', '\x1875', '\x1876', '\a', '\x2A6', '\x2', '\x2', '\x1876', 
		'\x1877', '\x5', '\x37A', '\x1BE', '\x2', '\x1877', '\x303', '\x3', '\x2', 
		'\x2', '\x2', '\x1878', '\x1879', '\a', '\xE9', '\x2', '\x2', '\x1879', 
		'\x187E', '\a', '?', '\x2', '\x2', '\x187A', '\x187C', '\a', '\x2F8', 
		'\x2', '\x2', '\x187B', '\x187A', '\x3', '\x2', '\x2', '\x2', '\x187B', 
		'\x187C', '\x3', '\x2', '\x2', '\x2', '\x187C', '\x187D', '\x3', '\x2', 
		'\x2', '\x2', '\x187D', '\x187F', '\x5', '\x306', '\x184', '\x2', '\x187E', 
		'\x187B', '\x3', '\x2', '\x2', '\x2', '\x187F', '\x1880', '\x3', '\x2', 
		'\x2', '\x2', '\x1880', '\x187E', '\x3', '\x2', '\x2', '\x2', '\x1880', 
		'\x1881', '\x3', '\x2', '\x2', '\x2', '\x1881', '\x1883', '\x3', '\x2', 
		'\x2', '\x2', '\x1882', '\x1884', '\x5', '\x30E', '\x188', '\x2', '\x1883', 
		'\x1882', '\x3', '\x2', '\x2', '\x2', '\x1883', '\x1884', '\x3', '\x2', 
		'\x2', '\x2', '\x1884', '\x1893', '\x3', '\x2', '\x2', '\x2', '\x1885', 
		'\x1890', '\x5', '\x30E', '\x188', '\x2', '\x1886', '\x1887', '\a', '\xE9', 
		'\x2', '\x2', '\x1887', '\x188C', '\a', '?', '\x2', '\x2', '\x1888', '\x188A', 
		'\a', '\x2F8', '\x2', '\x2', '\x1889', '\x1888', '\x3', '\x2', '\x2', 
		'\x2', '\x1889', '\x188A', '\x3', '\x2', '\x2', '\x2', '\x188A', '\x188B', 
		'\x3', '\x2', '\x2', '\x2', '\x188B', '\x188D', '\x5', '\x306', '\x184', 
		'\x2', '\x188C', '\x1889', '\x3', '\x2', '\x2', '\x2', '\x188D', '\x188E', 
		'\x3', '\x2', '\x2', '\x2', '\x188E', '\x188C', '\x3', '\x2', '\x2', '\x2', 
		'\x188E', '\x188F', '\x3', '\x2', '\x2', '\x2', '\x188F', '\x1891', '\x3', 
		'\x2', '\x2', '\x2', '\x1890', '\x1886', '\x3', '\x2', '\x2', '\x2', '\x1890', 
		'\x1891', '\x3', '\x2', '\x2', '\x2', '\x1891', '\x1893', '\x3', '\x2', 
		'\x2', '\x2', '\x1892', '\x1878', '\x3', '\x2', '\x2', '\x2', '\x1892', 
		'\x1885', '\x3', '\x2', '\x2', '\x2', '\x1893', '\x305', '\x3', '\x2', 
		'\x2', '\x2', '\x1894', '\x1898', '\x5', '\x30A', '\x186', '\x2', '\x1895', 
		'\x1898', '\x5', '\x308', '\x185', '\x2', '\x1896', '\x1898', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1897', '\x1894', '\x3', '\x2', '\x2', '\x2', '\x1897', 
		'\x1895', '\x3', '\x2', '\x2', '\x2', '\x1897', '\x1896', '\x3', '\x2', 
		'\x2', '\x2', '\x1898', '\x307', '\x3', '\x2', '\x2', '\x2', '\x1899', 
		'\x189A', '\t', 'V', '\x2', '\x2', '\x189A', '\x189F', '\a', '\x2F2', 
		'\x2', '\x2', '\x189B', '\x189D', '\a', '\x2F8', '\x2', '\x2', '\x189C', 
		'\x189B', '\x3', '\x2', '\x2', '\x2', '\x189C', '\x189D', '\x3', '\x2', 
		'\x2', '\x2', '\x189D', '\x189E', '\x3', '\x2', '\x2', '\x2', '\x189E', 
		'\x18A0', '\x5', '\x30C', '\x187', '\x2', '\x189F', '\x189C', '\x3', '\x2', 
		'\x2', '\x2', '\x18A0', '\x18A1', '\x3', '\x2', '\x2', '\x2', '\x18A1', 
		'\x189F', '\x3', '\x2', '\x2', '\x2', '\x18A1', '\x18A2', '\x3', '\x2', 
		'\x2', '\x2', '\x18A2', '\x18A3', '\x3', '\x2', '\x2', '\x2', '\x18A3', 
		'\x18A4', '\a', '\x2F3', '\x2', '\x2', '\x18A4', '\x309', '\x3', '\x2', 
		'\x2', '\x2', '\x18A5', '\x18A6', '\a', '\xEA', '\x2', '\x2', '\x18A6', 
		'\x18A7', '\a', '\x224', '\x2', '\x2', '\x18A7', '\x18AC', '\a', '\x2F2', 
		'\x2', '\x2', '\x18A8', '\x18AA', '\a', '\x2F8', '\x2', '\x2', '\x18A9', 
		'\x18A8', '\x3', '\x2', '\x2', '\x2', '\x18A9', '\x18AA', '\x3', '\x2', 
		'\x2', '\x2', '\x18AA', '\x18AB', '\x3', '\x2', '\x2', '\x2', '\x18AB', 
		'\x18AD', '\x5', '\x30C', '\x187', '\x2', '\x18AC', '\x18A9', '\x3', '\x2', 
		'\x2', '\x2', '\x18AD', '\x18AE', '\x3', '\x2', '\x2', '\x2', '\x18AE', 
		'\x18AC', '\x3', '\x2', '\x2', '\x2', '\x18AE', '\x18AF', '\x3', '\x2', 
		'\x2', '\x2', '\x18AF', '\x18B0', '\x3', '\x2', '\x2', '\x2', '\x18B0', 
		'\x18B1', '\a', '\x2F3', '\x2', '\x2', '\x18B1', '\x30B', '\x3', '\x2', 
		'\x2', '\x2', '\x18B2', '\x18BA', '\x5', '\x308', '\x185', '\x2', '\x18B3', 
		'\x18B5', '\a', '\x2F2', '\x2', '\x2', '\x18B4', '\x18B6', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x18B5', '\x18B4', '\x3', '\x2', '\x2', '\x2', '\x18B5', 
		'\x18B6', '\x3', '\x2', '\x2', '\x2', '\x18B6', '\x18B7', '\x3', '\x2', 
		'\x2', '\x2', '\x18B7', '\x18BA', '\a', '\x2F3', '\x2', '\x2', '\x18B8', 
		'\x18BA', '\x5', '\x37E', '\x1C0', '\x2', '\x18B9', '\x18B2', '\x3', '\x2', 
		'\x2', '\x2', '\x18B9', '\x18B3', '\x3', '\x2', '\x2', '\x2', '\x18B9', 
		'\x18B8', '\x3', '\x2', '\x2', '\x2', '\x18BA', '\x30D', '\x3', '\x2', 
		'\x2', '\x2', '\x18BB', '\x18BC', '\a', '\xEE', '\x2', '\x2', '\x18BC', 
		'\x18BD', '\x5', '\x37A', '\x1BE', '\x2', '\x18BD', '\x30F', '\x3', '\x2', 
		'\x2', '\x2', '\x18BE', '\x18C2', '\a', '\x15F', '\x2', '\x2', '\x18BF', 
		'\x18C1', '\x5', '\x312', '\x18A', '\x2', '\x18C0', '\x18BF', '\x3', '\x2', 
		'\x2', '\x2', '\x18C1', '\x18C4', '\x3', '\x2', '\x2', '\x2', '\x18C2', 
		'\x18C0', '\x3', '\x2', '\x2', '\x2', '\x18C2', '\x18C3', '\x3', '\x2', 
		'\x2', '\x2', '\x18C3', '\x18C6', '\x3', '\x2', '\x2', '\x2', '\x18C4', 
		'\x18C2', '\x3', '\x2', '\x2', '\x2', '\x18C5', '\x18C7', '\x5', '\x314', 
		'\x18B', '\x2', '\x18C6', '\x18C5', '\x3', '\x2', '\x2', '\x2', '\x18C6', 
		'\x18C7', '\x3', '\x2', '\x2', '\x2', '\x18C7', '\x18CB', '\x3', '\x2', 
		'\x2', '\x2', '\x18C8', '\x18CA', '\x5', '\x316', '\x18C', '\x2', '\x18C9', 
		'\x18C8', '\x3', '\x2', '\x2', '\x2', '\x18CA', '\x18CD', '\x3', '\x2', 
		'\x2', '\x2', '\x18CB', '\x18C9', '\x3', '\x2', '\x2', '\x2', '\x18CB', 
		'\x18CC', '\x3', '\x2', '\x2', '\x2', '\x18CC', '\x18CE', '\x3', '\x2', 
		'\x2', '\x2', '\x18CD', '\x18CB', '\x3', '\x2', '\x2', '\x2', '\x18CE', 
		'\x18CF', '\x5', '\x318', '\x18D', '\x2', '\x18CF', '\x311', '\x3', '\x2', 
		'\x2', '\x2', '\x18D0', '\x18D1', '\t', 'W', '\x2', '\x2', '\x18D1', '\x18D9', 
		'\a', '\x16B', '\x2', '\x2', '\x18D2', '\x18D6', '\a', '\x280', '\x2', 
		'\x2', '\x18D3', '\x18D7', '\a', '\x9A', '\x2', '\x2', '\x18D4', '\x18D5', 
		'\a', '\x22D', '\x2', '\x2', '\x18D5', '\x18D7', '\a', '\x1E6', '\x2', 
		'\x2', '\x18D6', '\x18D3', '\x3', '\x2', '\x2', '\x2', '\x18D6', '\x18D4', 
		'\x3', '\x2', '\x2', '\x2', '\x18D7', '\x18D9', '\x3', '\x2', '\x2', '\x2', 
		'\x18D8', '\x18D0', '\x3', '\x2', '\x2', '\x2', '\x18D8', '\x18D2', '\x3', 
		'\x2', '\x2', '\x2', '\x18D9', '\x313', '\x3', '\x2', '\x2', '\x2', '\x18DA', 
		'\x18DB', '\a', '\x1FC', '\x2', '\x2', '\x18DB', '\x18DC', '\t', 'X', 
		'\x2', '\x2', '\x18DC', '\x18DD', '\a', '\x20A', '\x2', '\x2', '\x18DD', 
		'\x315', '\x3', '\x2', '\x2', '\x2', '\x18DE', '\x18DF', '\a', '\x1E6', 
		'\x2', '\x2', '\x18DF', '\x18E0', '\x5', '\x476', '\x23C', '\x2', '\x18E0', 
		'\x18E1', '\a', '\x19B', '\x2', '\x2', '\x18E1', '\x18E2', '\a', '\x2F2', 
		'\x2', '\x2', '\x18E2', '\x18E3', '\x5', '\x16E', '\xB8', '\x2', '\x18E3', 
		'\x18E4', '\a', '\x2F3', '\x2', '\x2', '\x18E4', '\x18E8', '\x5', '\x31A', 
		'\x18E', '\x2', '\x18E5', '\x18E7', '\x5', '\x312', '\x18A', '\x2', '\x18E6', 
		'\x18E5', '\x3', '\x2', '\x2', '\x2', '\x18E7', '\x18EA', '\x3', '\x2', 
		'\x2', '\x2', '\x18E8', '\x18E6', '\x3', '\x2', '\x2', '\x2', '\x18E8', 
		'\x18E9', '\x3', '\x2', '\x2', '\x2', '\x18E9', '\x317', '\x3', '\x2', 
		'\x2', '\x2', '\x18EA', '\x18E8', '\x3', '\x2', '\x2', '\x2', '\x18EB', 
		'\x18EC', '\a', '\x146', '\x2', '\x2', '\x18EC', '\x18EE', '\x5', '\x484', 
		'\x243', '\x2', '\x18ED', '\x18EB', '\x3', '\x2', '\x2', '\x2', '\x18ED', 
		'\x18EE', '\x3', '\x2', '\x2', '\x2', '\x18EE', '\x18EF', '\x3', '\x2', 
		'\x2', '\x2', '\x18EF', '\x18F3', '\x5', '\x31A', '\x18E', '\x2', '\x18F0', 
		'\x18F2', '\x5', '\x312', '\x18A', '\x2', '\x18F1', '\x18F0', '\x3', '\x2', 
		'\x2', '\x2', '\x18F2', '\x18F5', '\x3', '\x2', '\x2', '\x2', '\x18F3', 
		'\x18F1', '\x3', '\x2', '\x2', '\x2', '\x18F3', '\x18F4', '\x3', '\x2', 
		'\x2', '\x2', '\x18F4', '\x18F6', '\x3', '\x2', '\x2', '\x2', '\x18F5', 
		'\x18F3', '\x3', '\x2', '\x2', '\x2', '\x18F6', '\x18F7', '\x5', '\x322', 
		'\x192', '\x2', '\x18F7', '\x319', '\x3', '\x2', '\x2', '\x2', '\x18F8', 
		'\x18FA', '\x5', '\x31C', '\x18F', '\x2', '\x18F9', '\x18F8', '\x3', '\x2', 
		'\x2', '\x2', '\x18F9', '\x18FA', '\x3', '\x2', '\x2', '\x2', '\x18FA', 
		'\x18FB', '\x3', '\x2', '\x2', '\x2', '\x18FB', '\x18FC', '\a', '\x9A', 
		'\x2', '\x2', '\x18FC', '\x18FD', '\a', '?', '\x2', '\x2', '\x18FD', '\x18FE', 
		'\x5', '\x31E', '\x190', '\x2', '\x18FE', '\x18FF', '\a', '\x152', '\x2', 
		'\x2', '\x18FF', '\x1900', '\x5', '\x31E', '\x190', '\x2', '\x1900', '\x31B', 
		'\x3', '\x2', '\x2', '\x2', '\x1901', '\x1902', '\a', '\x1B2', '\x2', 
		'\x2', '\x1902', '\x1903', '\a', '?', '\x2', '\x2', '\x1903', '\x1904', 
		'\x5', '\x31E', '\x190', '\x2', '\x1904', '\x31D', '\x3', '\x2', '\x2', 
		'\x2', '\x1905', '\x190A', '\a', '\x2F2', '\x2', '\x2', '\x1906', '\x1908', 
		'\a', '\x2F8', '\x2', '\x2', '\x1907', '\x1906', '\x3', '\x2', '\x2', 
		'\x2', '\x1907', '\x1908', '\x3', '\x2', '\x2', '\x2', '\x1908', '\x1909', 
		'\x3', '\x2', '\x2', '\x2', '\x1909', '\x190B', '\x5', '\x320', '\x191', 
		'\x2', '\x190A', '\x1907', '\x3', '\x2', '\x2', '\x2', '\x190B', '\x190C', 
		'\x3', '\x2', '\x2', '\x2', '\x190C', '\x190A', '\x3', '\x2', '\x2', '\x2', 
		'\x190C', '\x190D', '\x3', '\x2', '\x2', '\x2', '\x190D', '\x190E', '\x3', 
		'\x2', '\x2', '\x2', '\x190E', '\x190F', '\a', '\x2F3', '\x2', '\x2', 
		'\x190F', '\x31F', '\x3', '\x2', '\x2', '\x2', '\x1910', '\x1913', '\x5', 
		'\x37E', '\x1C0', '\x2', '\x1911', '\x1913', '\x5', '\x2D2', '\x16A', 
		'\x2', '\x1912', '\x1910', '\x3', '\x2', '\x2', '\x2', '\x1912', '\x1911', 
		'\x3', '\x2', '\x2', '\x2', '\x1913', '\x1915', '\x3', '\x2', '\x2', '\x2', 
		'\x1914', '\x1916', '\x5', '\x3FA', '\x1FE', '\x2', '\x1915', '\x1914', 
		'\x3', '\x2', '\x2', '\x2', '\x1915', '\x1916', '\x3', '\x2', '\x2', '\x2', 
		'\x1916', '\x321', '\x3', '\x2', '\x2', '\x2', '\x1917', '\x1919', '\x5', 
		'\x324', '\x193', '\x2', '\x1918', '\x1917', '\x3', '\x2', '\x2', '\x2', 
		'\x1918', '\x1919', '\x3', '\x2', '\x2', '\x2', '\x1919', '\x191A', '\x3', 
		'\x2', '\x2', '\x2', '\x191A', '\x1921', '\a', '\x2F2', '\x2', '\x2', 
		'\x191B', '\x191D', '\a', '\x2F8', '\x2', '\x2', '\x191C', '\x191B', '\x3', 
		'\x2', '\x2', '\x2', '\x191C', '\x191D', '\x3', '\x2', '\x2', '\x2', '\x191D', 
		'\x191E', '\x3', '\x2', '\x2', '\x2', '\x191E', '\x1920', '\x5', '\x326', 
		'\x194', '\x2', '\x191F', '\x191C', '\x3', '\x2', '\x2', '\x2', '\x1920', 
		'\x1923', '\x3', '\x2', '\x2', '\x2', '\x1921', '\x191F', '\x3', '\x2', 
		'\x2', '\x2', '\x1921', '\x1922', '\x3', '\x2', '\x2', '\x2', '\x1922', 
		'\x1924', '\x3', '\x2', '\x2', '\x2', '\x1923', '\x1921', '\x3', '\x2', 
		'\x2', '\x2', '\x1924', '\x1925', '\a', '\x2F3', '\x2', '\x2', '\x1925', 
		'\x323', '\x3', '\x2', '\x2', '\x2', '\x1926', '\x192C', '\a', '\x20B', 
		'\x2', '\x2', '\x1927', '\x192D', '\a', '\x287', '\x2', '\x2', '\x1928', 
		'\x192A', '\a', '\x288', '\x2', '\x2', '\x1929', '\x192B', '\a', '\xE', 
		'\x2', '\x2', '\x192A', '\x1929', '\x3', '\x2', '\x2', '\x2', '\x192A', 
		'\x192B', '\x3', '\x2', '\x2', '\x2', '\x192B', '\x192D', '\x3', '\x2', 
		'\x2', '\x2', '\x192C', '\x1927', '\x3', '\x2', '\x2', '\x2', '\x192C', 
		'\x1928', '\x3', '\x2', '\x2', '\x2', '\x192C', '\x192D', '\x3', '\x2', 
		'\x2', '\x2', '\x192D', '\x1930', '\x3', '\x2', '\x2', '\x2', '\x192E', 
		'\x192F', '\t', 'Y', '\x2', '\x2', '\x192F', '\x1931', '\a', '\x1A1', 
		'\x2', '\x2', '\x1930', '\x192E', '\x3', '\x2', '\x2', '\x2', '\x1930', 
		'\x1931', '\x3', '\x2', '\x2', '\x2', '\x1931', '\x1933', '\x3', '\x2', 
		'\x2', '\x2', '\x1932', '\x1934', '\x5', '\x32A', '\x196', '\x2', '\x1933', 
		'\x1932', '\x3', '\x2', '\x2', '\x2', '\x1933', '\x1934', '\x3', '\x2', 
		'\x2', '\x2', '\x1934', '\x325', '\x3', '\x2', '\x2', '\x2', '\x1935', 
		'\x193B', '\a', '\x287', '\x2', '\x2', '\x1936', '\x1938', '\a', '\x288', 
		'\x2', '\x2', '\x1937', '\x1939', '\a', '\xE', '\x2', '\x2', '\x1938', 
		'\x1937', '\x3', '\x2', '\x2', '\x2', '\x1938', '\x1939', '\x3', '\x2', 
		'\x2', '\x2', '\x1939', '\x193B', '\x3', '\x2', '\x2', '\x2', '\x193A', 
		'\x1935', '\x3', '\x2', '\x2', '\x2', '\x193A', '\x1936', '\x3', '\x2', 
		'\x2', '\x2', '\x193A', '\x193B', '\x3', '\x2', '\x2', '\x2', '\x193B', 
		'\x193C', '\x3', '\x2', '\x2', '\x2', '\x193C', '\x193E', '\x5', '\x328', 
		'\x195', '\x2', '\x193D', '\x193F', '\x5', '\x32E', '\x198', '\x2', '\x193E', 
		'\x193D', '\x3', '\x2', '\x2', '\x2', '\x193E', '\x193F', '\x3', '\x2', 
		'\x2', '\x2', '\x193F', '\x1940', '\x3', '\x2', '\x2', '\x2', '\x1940', 
		'\x1941', '\a', '\x306', '\x2', '\x2', '\x1941', '\x1942', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1942', '\x327', '\x3', '\x2', '\x2', '\x2', '\x1943', 
		'\x1944', '\x5', '\x390', '\x1C9', '\x2', '\x1944', '\x329', '\x3', '\x2', 
		'\x2', '\x2', '\x1945', '\x1946', '\a', '\x11D', '\x2', '\x2', '\x1946', 
		'\x1947', '\a', '\x2F2', '\x2', '\x2', '\x1947', '\x1948', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1948', '\x194A', '\a', '\x2F3', '\x2', '\x2', '\x1949', 
		'\x194B', '\x5', '\x32C', '\x197', '\x2', '\x194A', '\x1949', '\x3', '\x2', 
		'\x2', '\x2', '\x194A', '\x194B', '\x3', '\x2', '\x2', '\x2', '\x194B', 
		'\x32B', '\x3', '\x2', '\x2', '\x2', '\x194C', '\x194D', '\a', '\x284', 
		'\x2', '\x2', '\x194D', '\x194E', '\a', '\x2F2', '\x2', '\x2', '\x194E', 
		'\x194F', '\x5', '\x37A', '\x1BE', '\x2', '\x194F', '\x1950', '\a', '\x2F3', 
		'\x2', '\x2', '\x1950', '\x32D', '\x3', '\x2', '\x2', '\x2', '\x1951', 
		'\x1953', '\a', '\x1A1', '\x2', '\x2', '\x1952', '\x1954', '\a', '\x22A', 
		'\x2', '\x2', '\x1953', '\x1952', '\x3', '\x2', '\x2', '\x2', '\x1953', 
		'\x1954', '\x3', '\x2', '\x2', '\x2', '\x1954', '\x1955', '\x3', '\x2', 
		'\x2', '\x2', '\x1955', '\x195A', '\a', '?', '\x2', '\x2', '\x1956', '\x1958', 
		'\a', '\x2F8', '\x2', '\x2', '\x1957', '\x1956', '\x3', '\x2', '\x2', 
		'\x2', '\x1957', '\x1958', '\x3', '\x2', '\x2', '\x2', '\x1958', '\x1959', 
		'\x3', '\x2', '\x2', '\x2', '\x1959', '\x195B', '\x5', '\x330', '\x199', 
		'\x2', '\x195A', '\x1957', '\x3', '\x2', '\x2', '\x2', '\x195B', '\x195C', 
		'\x3', '\x2', '\x2', '\x2', '\x195C', '\x195A', '\x3', '\x2', '\x2', '\x2', 
		'\x195C', '\x195D', '\x3', '\x2', '\x2', '\x2', '\x195D', '\x32F', '\x3', 
		'\x2', '\x2', '\x2', '\x195E', '\x1960', '\x5', '\x37E', '\x1C0', '\x2', 
		'\x195F', '\x1961', '\t', 'Z', '\x2', '\x2', '\x1960', '\x195F', '\x3', 
		'\x2', '\x2', '\x2', '\x1960', '\x1961', '\x3', '\x2', '\x2', '\x2', '\x1961', 
		'\x1964', '\x3', '\x2', '\x2', '\x2', '\x1962', '\x1963', '\a', '\x18E', 
		'\x2', '\x2', '\x1963', '\x1965', '\t', '[', '\x2', '\x2', '\x1964', '\x1962', 
		'\x3', '\x2', '\x2', '\x2', '\x1964', '\x1965', '\x3', '\x2', '\x2', '\x2', 
		'\x1965', '\x331', '\x3', '\x2', '\x2', '\x2', '\x1966', '\x1967', '\a', 
		'\xDD', '\x2', '\x2', '\x1967', '\x1969', '\a', '\x287', '\x2', '\x2', 
		'\x1968', '\x196A', '\x5', '\x334', '\x19B', '\x2', '\x1969', '\x1968', 
		'\x3', '\x2', '\x2', '\x2', '\x1969', '\x196A', '\x3', '\x2', '\x2', '\x2', 
		'\x196A', '\x196C', '\x3', '\x2', '\x2', '\x2', '\x196B', '\x196D', '\x5', 
		'\x336', '\x19C', '\x2', '\x196C', '\x196B', '\x3', '\x2', '\x2', '\x2', 
		'\x196C', '\x196D', '\x3', '\x2', '\x2', '\x2', '\x196D', '\x333', '\x3', 
		'\x2', '\x2', '\x2', '\x196E', '\x196F', '\a', '\x195', '\x2', '\x2', 
		'\x196F', '\x1970', '\x5', '\x448', '\x225', '\x2', '\x1970', '\x335', 
		'\x3', '\x2', '\x2', '\x2', '\x1971', '\x1972', '\a', '\x22F', '\x2', 
		'\x2', '\x1972', '\x1977', '\a', '\x13B', '\x2', '\x2', '\x1973', '\x1977', 
		'\a', '\x18C', '\x2', '\x2', '\x1974', '\x1975', '\a', '\x29D', '\x2', 
		'\x2', '\x1975', '\x1977', '\x5', '\x37E', '\x1C0', '\x2', '\x1976', '\x1971', 
		'\x3', '\x2', '\x2', '\x2', '\x1976', '\x1973', '\x3', '\x2', '\x2', '\x2', 
		'\x1976', '\x1974', '\x3', '\x2', '\x2', '\x2', '\x1977', '\x337', '\x3', 
		'\x2', '\x2', '\x2', '\x1978', '\x1979', '\a', '\x287', '\x2', '\x2', 
		'\x1979', '\x197A', '\x5', '\x366', '\x1B4', '\x2', '\x197A', '\x197C', 
		'\x5', '\x33A', '\x19E', '\x2', '\x197B', '\x197D', '\x5', '\x3FE', '\x200', 
		'\x2', '\x197C', '\x197B', '\x3', '\x2', '\x2', '\x2', '\x197C', '\x197D', 
		'\x3', '\x2', '\x2', '\x2', '\x197D', '\x197F', '\x3', '\x2', '\x2', '\x2', 
		'\x197E', '\x1980', '\x5', '\x368', '\x1B5', '\x2', '\x197F', '\x197E', 
		'\x3', '\x2', '\x2', '\x2', '\x197F', '\x1980', '\x3', '\x2', '\x2', '\x2', 
		'\x1980', '\x1982', '\x3', '\x2', '\x2', '\x2', '\x1981', '\x1983', '\x5', 
		'\x36A', '\x1B6', '\x2', '\x1982', '\x1981', '\x3', '\x2', '\x2', '\x2', 
		'\x1982', '\x1983', '\x3', '\x2', '\x2', '\x2', '\x1983', '\x339', '\x3', 
		'\x2', '\x2', '\x2', '\x1984', '\x1994', '\a', '\x223', '\x2', '\x2', 
		'\x1985', '\x1987', '\a', '\x2F8', '\x2', '\x2', '\x1986', '\x1985', '\x3', 
		'\x2', '\x2', '\x2', '\x1986', '\x1987', '\x3', '\x2', '\x2', '\x2', '\x1987', 
		'\x1988', '\x3', '\x2', '\x2', '\x2', '\x1988', '\x198A', '\x5', '\x33C', 
		'\x19F', '\x2', '\x1989', '\x1986', '\x3', '\x2', '\x2', '\x2', '\x198A', 
		'\x198B', '\x3', '\x2', '\x2', '\x2', '\x198B', '\x1989', '\x3', '\x2', 
		'\x2', '\x2', '\x198B', '\x198C', '\x3', '\x2', '\x2', '\x2', '\x198C', 
		'\x1995', '\x3', '\x2', '\x2', '\x2', '\x198D', '\x198E', '\a', '\x291', 
		'\x2', '\x2', '\x198E', '\x198F', '\a', '\x2F2', '\x2', '\x2', '\x198F', 
		'\x1990', '\x5', '\x46E', '\x238', '\x2', '\x1990', '\x1991', '\a', '\x2F3', 
		'\x2', '\x2', '\x1991', '\x1992', '\a', '\x306', '\x2', '\x2', '\x1992', 
		'\x1993', '\x5', '\x37E', '\x1C0', '\x2', '\x1993', '\x1995', '\x3', '\x2', 
		'\x2', '\x2', '\x1994', '\x1989', '\x3', '\x2', '\x2', '\x2', '\x1994', 
		'\x198D', '\x3', '\x2', '\x2', '\x2', '\x1995', '\x33B', '\x3', '\x2', 
		'\x2', '\x2', '\x1996', '\x1997', '\x5', '\x490', '\x249', '\x2', '\x1997', 
		'\x1998', '\a', '\x306', '\x2', '\x2', '\x1998', '\x1999', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1999', '\x199F', '\x3', '\x2', '\x2', '\x2', '\x199A', 
		'\x199B', '\x5', '\x44A', '\x226', '\x2', '\x199B', '\x199C', '\a', '\x306', 
		'\x2', '\x2', '\x199C', '\x199D', '\x5', '\x16E', '\xB8', '\x2', '\x199D', 
		'\x199F', '\x3', '\x2', '\x2', '\x2', '\x199E', '\x1996', '\x3', '\x2', 
		'\x2', '\x2', '\x199E', '\x199A', '\x3', '\x2', '\x2', '\x2', '\x199F', 
		'\x33D', '\x3', '\x2', '\x2', '\x2', '\x19A0', '\x19A2', '\a', '\x95', 
		'\x2', '\x2', '\x19A1', '\x19A3', '\a', '\xE1', '\x2', '\x2', '\x19A2', 
		'\x19A1', '\x3', '\x2', '\x2', '\x2', '\x19A2', '\x19A3', '\x3', '\x2', 
		'\x2', '\x2', '\x19A3', '\x19A4', '\x3', '\x2', '\x2', '\x2', '\x19A4', 
		'\x19A6', '\x5', '\x366', '\x1B4', '\x2', '\x19A5', '\x19A7', '\x5', '\x3FE', 
		'\x200', '\x2', '\x19A6', '\x19A5', '\x3', '\x2', '\x2', '\x2', '\x19A6', 
		'\x19A7', '\x3', '\x2', '\x2', '\x2', '\x19A7', '\x19A9', '\x3', '\x2', 
		'\x2', '\x2', '\x19A8', '\x19AA', '\x5', '\x368', '\x1B5', '\x2', '\x19A9', 
		'\x19A8', '\x3', '\x2', '\x2', '\x2', '\x19A9', '\x19AA', '\x3', '\x2', 
		'\x2', '\x2', '\x19AA', '\x19AC', '\x3', '\x2', '\x2', '\x2', '\x19AB', 
		'\x19AD', '\x5', '\x36A', '\x1B6', '\x2', '\x19AC', '\x19AB', '\x3', '\x2', 
		'\x2', '\x2', '\x19AC', '\x19AD', '\x3', '\x2', '\x2', '\x2', '\x19AD', 
		'\x33F', '\x3', '\x2', '\x2', '\x2', '\x19AE', '\x19B1', '\a', '\x110', 
		'\x2', '\x2', '\x19AF', '\x19B2', '\x5', '\x342', '\x1A2', '\x2', '\x19B0', 
		'\x19B2', '\x5', '\x344', '\x1A3', '\x2', '\x19B1', '\x19AF', '\x3', '\x2', 
		'\x2', '\x2', '\x19B1', '\x19B0', '\x3', '\x2', '\x2', '\x2', '\x19B2', 
		'\x341', '\x3', '\x2', '\x2', '\x2', '\x19B3', '\x19B9', '\x5', '\x34E', 
		'\x1A8', '\x2', '\x19B4', '\x19B6', '\x5', '\x350', '\x1A9', '\x2', '\x19B5', 
		'\x19B7', '\x5', '\x368', '\x1B5', '\x2', '\x19B6', '\x19B5', '\x3', '\x2', 
		'\x2', '\x2', '\x19B6', '\x19B7', '\x3', '\x2', '\x2', '\x2', '\x19B7', 
		'\x19BA', '\x3', '\x2', '\x2', '\x2', '\x19B8', '\x19BA', '\x5', '\x2C4', 
		'\x163', '\x2', '\x19B9', '\x19B4', '\x3', '\x2', '\x2', '\x2', '\x19B9', 
		'\x19B8', '\x3', '\x2', '\x2', '\x2', '\x19BA', '\x19BC', '\x3', '\x2', 
		'\x2', '\x2', '\x19BB', '\x19BD', '\x5', '\x36A', '\x1B6', '\x2', '\x19BC', 
		'\x19BB', '\x3', '\x2', '\x2', '\x2', '\x19BC', '\x19BD', '\x3', '\x2', 
		'\x2', '\x2', '\x19BD', '\x343', '\x3', '\x2', '\x2', '\x2', '\x19BE', 
		'\x19C0', '\a', '\xE', '\x2', '\x2', '\x19BF', '\x19C1', '\x5', '\x346', 
		'\x1A4', '\x2', '\x19C0', '\x19BF', '\x3', '\x2', '\x2', '\x2', '\x19C1', 
		'\x19C2', '\x3', '\x2', '\x2', '\x2', '\x19C2', '\x19C0', '\x3', '\x2', 
		'\x2', '\x2', '\x19C2', '\x19C3', '\x3', '\x2', '\x2', '\x2', '\x19C3', 
		'\x19C6', '\x3', '\x2', '\x2', '\x2', '\x19C4', '\x19C6', '\x5', '\x348', 
		'\x1A5', '\x2', '\x19C5', '\x19BE', '\x3', '\x2', '\x2', '\x2', '\x19C5', 
		'\x19C4', '\x3', '\x2', '\x2', '\x2', '\x19C6', '\x19C7', '\x3', '\x2', 
		'\x2', '\x2', '\x19C7', '\x19C8', '\x5', '\x2C4', '\x163', '\x2', '\x19C8', 
		'\x345', '\x3', '\x2', '\x2', '\x2', '\x19C9', '\x19CB', '\x5', '\x34E', 
		'\x1A8', '\x2', '\x19CA', '\x19CC', '\x5', '\x350', '\x1A9', '\x2', '\x19CB', 
		'\x19CA', '\x3', '\x2', '\x2', '\x2', '\x19CB', '\x19CC', '\x3', '\x2', 
		'\x2', '\x2', '\x19CC', '\x19CE', '\x3', '\x2', '\x2', '\x2', '\x19CD', 
		'\x19CF', '\x5', '\x36A', '\x1B6', '\x2', '\x19CE', '\x19CD', '\x3', '\x2', 
		'\x2', '\x2', '\x19CE', '\x19CF', '\x3', '\x2', '\x2', '\x2', '\x19CF', 
		'\x347', '\x3', '\x2', '\x2', '\x2', '\x19D0', '\x19D2', '\t', '\\', '\x2', 
		'\x2', '\x19D1', '\x19D0', '\x3', '\x2', '\x2', '\x2', '\x19D1', '\x19D2', 
		'\x3', '\x2', '\x2', '\x2', '\x19D2', '\x19D4', '\x3', '\x2', '\x2', '\x2', 
		'\x19D3', '\x19D5', '\x5', '\x34A', '\x1A6', '\x2', '\x19D4', '\x19D3', 
		'\x3', '\x2', '\x2', '\x2', '\x19D5', '\x19D6', '\x3', '\x2', '\x2', '\x2', 
		'\x19D6', '\x19D4', '\x3', '\x2', '\x2', '\x2', '\x19D6', '\x19D7', '\x3', 
		'\x2', '\x2', '\x2', '\x19D7', '\x19D9', '\x3', '\x2', '\x2', '\x2', '\x19D8', 
		'\x19DA', '\x5', '\x34C', '\x1A7', '\x2', '\x19D9', '\x19D8', '\x3', '\x2', 
		'\x2', '\x2', '\x19D9', '\x19DA', '\x3', '\x2', '\x2', '\x2', '\x19DA', 
		'\x349', '\x3', '\x2', '\x2', '\x2', '\x19DB', '\x19DC', '\a', '\x2A1', 
		'\x2', '\x2', '\x19DC', '\x19DD', '\x5', '\x37A', '\x1BE', '\x2', '\x19DD', 
		'\x19DF', '\a', '\x25D', '\x2', '\x2', '\x19DE', '\x19E0', '\x5', '\x346', 
		'\x1A4', '\x2', '\x19DF', '\x19DE', '\x3', '\x2', '\x2', '\x2', '\x19E0', 
		'\x19E1', '\x3', '\x2', '\x2', '\x2', '\x19E1', '\x19DF', '\x3', '\x2', 
		'\x2', '\x2', '\x19E1', '\x19E2', '\x3', '\x2', '\x2', '\x2', '\x19E2', 
		'\x34B', '\x3', '\x2', '\x2', '\x2', '\x19E3', '\x19E5', '\a', '\xAE', 
		'\x2', '\x2', '\x19E4', '\x19E6', '\x5', '\x346', '\x1A4', '\x2', '\x19E5', 
		'\x19E4', '\x3', '\x2', '\x2', '\x2', '\x19E6', '\x19E7', '\x3', '\x2', 
		'\x2', '\x2', '\x19E7', '\x19E5', '\x3', '\x2', '\x2', '\x2', '\x19E7', 
		'\x19E8', '\x3', '\x2', '\x2', '\x2', '\x19E8', '\x34D', '\x3', '\x2', 
		'\x2', '\x2', '\x19E9', '\x19EA', '\a', '\x118', '\x2', '\x2', '\x19EA', 
		'\x19EC', '\x5', '\x366', '\x1B4', '\x2', '\x19EB', '\x19ED', '\x5', '\x44A', 
		'\x226', '\x2', '\x19EC', '\x19EB', '\x3', '\x2', '\x2', '\x2', '\x19EC', 
		'\x19ED', '\x3', '\x2', '\x2', '\x2', '\x19ED', '\x34F', '\x3', '\x2', 
		'\x2', '\x2', '\x19EE', '\x19EF', '\a', '\x290', '\x2', '\x2', '\x19EF', 
		'\x19F1', '\a', '\x2F2', '\x2', '\x2', '\x19F0', '\x19F2', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x19F1', '\x19F0', '\x3', '\x2', '\x2', '\x2', '\x19F1', 
		'\x19F2', '\x3', '\x2', '\x2', '\x2', '\x19F2', '\x19F3', '\x3', '\x2', 
		'\x2', '\x2', '\x19F3', '\x19F4', '\a', '\x2F3', '\x2', '\x2', '\x19F4', 
		'\x351', '\x3', '\x2', '\x2', '\x2', '\x19F5', '\x19F6', '\a', '\x156', 
		'\x2', '\x2', '\x19F6', '\x19F7', '\a', '\x118', '\x2', '\x2', '\x19F7', 
		'\x19F9', '\x5', '\x416', '\x20C', '\x2', '\x19F8', '\x19FA', '\x5', '\x3FC', 
		'\x1FF', '\x2', '\x19F9', '\x19F8', '\x3', '\x2', '\x2', '\x2', '\x19F9', 
		'\x19FA', '\x3', '\x2', '\x2', '\x2', '\x19FA', '\x19FB', '\x3', '\x2', 
		'\x2', '\x2', '\x19FB', '\x19FC', '\a', '\x28E', '\x2', '\x2', '\x19FC', 
		'\x19FD', '\x5', '\x35C', '\x1AF', '\x2', '\x19FD', '\x19FE', '\a', '\x19B', 
		'\x2', '\x2', '\x19FE', '\x19FF', '\a', '\x2F2', '\x2', '\x2', '\x19FF', 
		'\x1A00', '\x5', '\x37A', '\x1BE', '\x2', '\x1A00', '\x1A09', '\a', '\x2F3', 
		'\x2', '\x2', '\x1A01', '\x1A03', '\x5', '\x354', '\x1AB', '\x2', '\x1A02', 
		'\x1A04', '\x5', '\x35A', '\x1AE', '\x2', '\x1A03', '\x1A02', '\x3', '\x2', 
		'\x2', '\x2', '\x1A03', '\x1A04', '\x3', '\x2', '\x2', '\x2', '\x1A04', 
		'\x1A0A', '\x3', '\x2', '\x2', '\x2', '\x1A05', '\x1A07', '\x5', '\x35A', 
		'\x1AE', '\x2', '\x1A06', '\x1A08', '\x5', '\x354', '\x1AB', '\x2', '\x1A07', 
		'\x1A06', '\x3', '\x2', '\x2', '\x2', '\x1A07', '\x1A08', '\x3', '\x2', 
		'\x2', '\x2', '\x1A08', '\x1A0A', '\x3', '\x2', '\x2', '\x2', '\x1A09', 
		'\x1A01', '\x3', '\x2', '\x2', '\x2', '\x1A09', '\x1A05', '\x3', '\x2', 
		'\x2', '\x2', '\x1A09', '\x1A0A', '\x3', '\x2', '\x2', '\x2', '\x1A0A', 
		'\x1A0C', '\x3', '\x2', '\x2', '\x2', '\x1A0B', '\x1A0D', '\x5', '\x36A', 
		'\x1B6', '\x2', '\x1A0C', '\x1A0B', '\x3', '\x2', '\x2', '\x2', '\x1A0C', 
		'\x1A0D', '\x3', '\x2', '\x2', '\x2', '\x1A0D', '\x353', '\x3', '\x2', 
		'\x2', '\x2', '\x1A0E', '\x1A0F', '\a', '\x2A1', '\x2', '\x2', '\x1A0F', 
		'\x1A10', '\a', '\x14C', '\x2', '\x2', '\x1A10', '\x1A11', '\a', '\x25D', 
		'\x2', '\x2', '\x1A11', '\x1A12', '\a', '\x287', '\x2', '\x2', '\x1A12', 
		'\x1A13', '\a', '\x223', '\x2', '\x2', '\x1A13', '\x1A18', '\x5', '\x356', 
		'\x1AC', '\x2', '\x1A14', '\x1A15', '\a', '\x2F8', '\x2', '\x2', '\x1A15', 
		'\x1A17', '\x5', '\x356', '\x1AC', '\x2', '\x1A16', '\x1A14', '\x3', '\x2', 
		'\x2', '\x2', '\x1A17', '\x1A1A', '\x3', '\x2', '\x2', '\x2', '\x1A18', 
		'\x1A16', '\x3', '\x2', '\x2', '\x2', '\x1A18', '\x1A19', '\x3', '\x2', 
		'\x2', '\x2', '\x1A19', '\x1A1C', '\x3', '\x2', '\x2', '\x2', '\x1A1A', 
		'\x1A18', '\x3', '\x2', '\x2', '\x2', '\x1A1B', '\x1A1D', '\x5', '\x3FE', 
		'\x200', '\x2', '\x1A1C', '\x1A1B', '\x3', '\x2', '\x2', '\x2', '\x1A1C', 
		'\x1A1D', '\x3', '\x2', '\x2', '\x2', '\x1A1D', '\x1A1F', '\x3', '\x2', 
		'\x2', '\x2', '\x1A1E', '\x1A20', '\x5', '\x358', '\x1AD', '\x2', '\x1A1F', 
		'\x1A1E', '\x3', '\x2', '\x2', '\x2', '\x1A1F', '\x1A20', '\x3', '\x2', 
		'\x2', '\x2', '\x1A20', '\x355', '\x3', '\x2', '\x2', '\x2', '\x1A21', 
		'\x1A22', '\x5', '\x490', '\x249', '\x2', '\x1A22', '\x1A23', '\a', '\x306', 
		'\x2', '\x2', '\x1A23', '\x1A24', '\x5', '\x37E', '\x1C0', '\x2', '\x1A24', 
		'\x357', '\x3', '\x2', '\x2', '\x2', '\x1A25', '\x1A26', '\a', '\x95', 
		'\x2', '\x2', '\x1A26', '\x1A27', '\x5', '\x3FE', '\x200', '\x2', '\x1A27', 
		'\x359', '\x3', '\x2', '\x2', '\x2', '\x1A28', '\x1A29', '\a', '\x2A1', 
		'\x2', '\x2', '\x1A29', '\x1A2A', '\a', '\x18A', '\x2', '\x2', '\x1A2A', 
		'\x1A2B', '\a', '\x14C', '\x2', '\x2', '\x1A2B', '\x1A2C', '\a', '\x25D', 
		'\x2', '\x2', '\x1A2C', '\x1A2E', '\a', '\x110', '\x2', '\x2', '\x1A2D', 
		'\x1A2F', '\x5', '\x44A', '\x226', '\x2', '\x1A2E', '\x1A2D', '\x3', '\x2', 
		'\x2', '\x2', '\x1A2E', '\x1A2F', '\x3', '\x2', '\x2', '\x2', '\x1A2F', 
		'\x1A30', '\x3', '\x2', '\x2', '\x2', '\x1A30', '\x1A31', '\a', '\x290', 
		'\x2', '\x2', '\x1A31', '\x1A33', '\a', '\x2F2', '\x2', '\x2', '\x1A32', 
		'\x1A34', '\x5', '\x37C', '\x1BF', '\x2', '\x1A33', '\x1A32', '\x3', '\x2', 
		'\x2', '\x2', '\x1A33', '\x1A34', '\x3', '\x2', '\x2', '\x2', '\x1A34', 
		'\x1A35', '\x3', '\x2', '\x2', '\x2', '\x1A35', '\x1A37', '\a', '\x2F3', 
		'\x2', '\x2', '\x1A36', '\x1A38', '\x5', '\x3FE', '\x200', '\x2', '\x1A37', 
		'\x1A36', '\x3', '\x2', '\x2', '\x2', '\x1A37', '\x1A38', '\x3', '\x2', 
		'\x2', '\x2', '\x1A38', '\x35B', '\x3', '\x2', '\x2', '\x2', '\x1A39', 
		'\x1A3F', '\x5', '\x416', '\x20C', '\x2', '\x1A3A', '\x1A3B', '\a', '\x2F2', 
		'\x2', '\x2', '\x1A3B', '\x1A3C', '\x5', '\x2C4', '\x163', '\x2', '\x1A3C', 
		'\x1A3D', '\a', '\x2F3', '\x2', '\x2', '\x1A3D', '\x1A3F', '\x3', '\x2', 
		'\x2', '\x2', '\x1A3E', '\x1A39', '\x3', '\x2', '\x2', '\x2', '\x1A3E', 
		'\x1A3A', '\x3', '\x2', '\x2', '\x2', '\x1A3F', '\x1A41', '\x3', '\x2', 
		'\x2', '\x2', '\x1A40', '\x1A42', '\x5', '\x3FC', '\x1FF', '\x2', '\x1A41', 
		'\x1A40', '\x3', '\x2', '\x2', '\x2', '\x1A41', '\x1A42', '\x3', '\x2', 
		'\x2', '\x2', '\x1A42', '\x35D', '\x3', '\x2', '\x2', '\x2', '\x1A43', 
		'\x1A44', '\a', '\x13D', '\x2', '\x2', '\x1A44', '\x1A45', '\a', '\x258', 
		'\x2', '\x2', '\x1A45', '\x1A4A', '\x5', '\x362', '\x1B2', '\x2', '\x1A46', 
		'\x1A47', '\a', '\x2F8', '\x2', '\x2', '\x1A47', '\x1A49', '\x5', '\x362', 
		'\x1B2', '\x2', '\x1A48', '\x1A46', '\x3', '\x2', '\x2', '\x2', '\x1A49', 
		'\x1A4C', '\x3', '\x2', '\x2', '\x2', '\x1A4A', '\x1A48', '\x3', '\x2', 
		'\x2', '\x2', '\x1A4A', '\x1A4B', '\x3', '\x2', '\x2', '\x2', '\x1A4B', 
		'\x1A4D', '\x3', '\x2', '\x2', '\x2', '\x1A4C', '\x1A4A', '\x3', '\x2', 
		'\x2', '\x2', '\x1A4D', '\x1A4E', '\a', '\x108', '\x2', '\x2', '\x1A4E', 
		'\x1A4F', '\x5', '\x364', '\x1B3', '\x2', '\x1A4F', '\x1A51', '\a', '\x160', 
		'\x2', '\x2', '\x1A50', '\x1A52', '\x5', '\x360', '\x1B1', '\x2', '\x1A51', 
		'\x1A50', '\x3', '\x2', '\x2', '\x2', '\x1A51', '\x1A52', '\x3', '\x2', 
		'\x2', '\x2', '\x1A52', '\x35F', '\x3', '\x2', '\x2', '\x2', '\x1A53', 
		'\x1A54', '\a', '\x29D', '\x2', '\x2', '\x1A54', '\x1A57', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1A55', '\x1A57', '\a', '\x18C', '\x2', '\x2', '\x1A56', 
		'\x1A53', '\x3', '\x2', '\x2', '\x2', '\x1A56', '\x1A55', '\x3', '\x2', 
		'\x2', '\x2', '\x1A57', '\x361', '\x3', '\x2', '\x2', '\x2', '\x1A58', 
		'\x1A5A', '\x5', '\x416', '\x20C', '\x2', '\x1A59', '\x1A5B', '\x5', '\x3F8', 
		'\x1FD', '\x2', '\x1A5A', '\x1A59', '\x3', '\x2', '\x2', '\x2', '\x1A5A', 
		'\x1A5B', '\x3', '\x2', '\x2', '\x2', '\x1A5B', '\x363', '\x3', '\x2', 
		'\x2', '\x2', '\x1A5C', '\x1A5D', '\a', '\x209', '\x2', '\x2', '\x1A5D', 
		'\x1A69', '\a', '\x226', '\x2', '\x2', '\x1A5E', '\x1A5F', '\a', '\x209', 
		'\x2', '\x2', '\x1A5F', '\x1A69', '\a', '\xC2', '\x2', '\x2', '\x1A60', 
		'\x1A62', '\a', '\x226', '\x2', '\x2', '\x1A61', '\x1A63', '\a', '\x287', 
		'\x2', '\x2', '\x1A62', '\x1A61', '\x3', '\x2', '\x2', '\x2', '\x1A62', 
		'\x1A63', '\x3', '\x2', '\x2', '\x2', '\x1A63', '\x1A69', '\x3', '\x2', 
		'\x2', '\x2', '\x1A64', '\x1A65', '\a', '\x226', '\x2', '\x2', '\x1A65', 
		'\x1A66', '\a', '\x209', '\x2', '\x2', '\x1A66', '\x1A69', '\a', '\xC2', 
		'\x2', '\x2', '\x1A67', '\x1A69', '\a', '\xC2', '\x2', '\x2', '\x1A68', 
		'\x1A5C', '\x3', '\x2', '\x2', '\x2', '\x1A68', '\x1A5E', '\x3', '\x2', 
		'\x2', '\x2', '\x1A68', '\x1A60', '\x3', '\x2', '\x2', '\x2', '\x1A68', 
		'\x1A64', '\x3', '\x2', '\x2', '\x2', '\x1A68', '\x1A67', '\x3', '\x2', 
		'\x2', '\x2', '\x1A69', '\x365', '\x3', '\x2', '\x2', '\x2', '\x1A6A', 
		'\x1A71', '\x5', '\x370', '\x1B9', '\x2', '\x1A6B', '\x1A6C', '\a', '\x19A', 
		'\x2', '\x2', '\x1A6C', '\x1A6D', '\a', '\x2F2', '\x2', '\x2', '\x1A6D', 
		'\x1A6E', '\x5', '\x370', '\x1B9', '\x2', '\x1A6E', '\x1A6F', '\a', '\x2F3', 
		'\x2', '\x2', '\x1A6F', '\x1A71', '\x3', '\x2', '\x2', '\x2', '\x1A70', 
		'\x1A6A', '\x3', '\x2', '\x2', '\x2', '\x1A70', '\x1A6B', '\x3', '\x2', 
		'\x2', '\x2', '\x1A71', '\x1A73', '\x3', '\x2', '\x2', '\x2', '\x1A72', 
		'\x1A74', '\x5', '\x3FC', '\x1FF', '\x2', '\x1A73', '\x1A72', '\x3', '\x2', 
		'\x2', '\x2', '\x1A73', '\x1A74', '\x3', '\x2', '\x2', '\x2', '\x1A74', 
		'\x367', '\x3', '\x2', '\x2', '\x2', '\x1A75', '\x1A76', '\t', 'J', '\x2', 
		'\x2', '\x1A76', '\x1A77', '\x5', '\x37C', '\x1BF', '\x2', '\x1A77', '\x1A78', 
		'\x5', '\x400', '\x201', '\x2', '\x1A78', '\x369', '\x3', '\x2', '\x2', 
		'\x2', '\x1A79', '\x1A7A', '\a', '\x13F', '\x2', '\x2', '\x1A7A', '\x1A7C', 
		'\a', '\xB9', '\x2', '\x2', '\x1A7B', '\x1A7D', '\x5', '\x36C', '\x1B7', 
		'\x2', '\x1A7C', '\x1A7B', '\x3', '\x2', '\x2', '\x2', '\x1A7C', '\x1A7D', 
		'\x3', '\x2', '\x2', '\x2', '\x1A7D', '\x1A7F', '\x3', '\x2', '\x2', '\x2', 
		'\x1A7E', '\x1A80', '\x5', '\x37E', '\x1C0', '\x2', '\x1A7F', '\x1A7E', 
		'\x3', '\x2', '\x2', '\x2', '\x1A7F', '\x1A80', '\x3', '\x2', '\x2', '\x2', 
		'\x1A80', '\x1A82', '\x3', '\x2', '\x2', '\x2', '\x1A81', '\x1A83', '\x5', 
		'\x36E', '\x1B8', '\x2', '\x1A82', '\x1A81', '\x3', '\x2', '\x2', '\x2', 
		'\x1A82', '\x1A83', '\x3', '\x2', '\x2', '\x2', '\x1A83', '\x36B', '\x3', 
		'\x2', '\x2', '\x2', '\x1A84', '\x1A85', '\a', '\x118', '\x2', '\x2', 
		'\x1A85', '\x1A86', '\x5', '\x416', '\x20C', '\x2', '\x1A86', '\x36D', 
		'\x3', '\x2', '\x2', '\x2', '\x1A87', '\x1A88', '\a', '\x1EB', '\x2', 
		'\x2', '\x1A88', '\x1A8B', '\a', '\x131', '\x2', '\x2', '\x1A89', '\x1A8C', 
		'\a', '\x281', '\x2', '\x2', '\x1A8A', '\x1A8C', '\x5', '\x37E', '\x1C0', 
		'\x2', '\x1A8B', '\x1A89', '\x3', '\x2', '\x2', '\x2', '\x1A8B', '\x1A8A', 
		'\x3', '\x2', '\x2', '\x2', '\x1A8C', '\x36F', '\x3', '\x2', '\x2', '\x2', 
		'\x1A8D', '\x1A9A', '\x5', '\x372', '\x1BA', '\x2', '\x1A8E', '\x1A8F', 
		'\a', '\x2F2', '\x2', '\x2', '\x1A8F', '\x1A91', '\x5', '\x2C4', '\x163', 
		'\x2', '\x1A90', '\x1A92', '\x5', '\x374', '\x1BB', '\x2', '\x1A91', '\x1A90', 
		'\x3', '\x2', '\x2', '\x2', '\x1A91', '\x1A92', '\x3', '\x2', '\x2', '\x2', 
		'\x1A92', '\x1A93', '\x3', '\x2', '\x2', '\x2', '\x1A93', '\x1A94', '\a', 
		'\x2F3', '\x2', '\x2', '\x1A94', '\x1A9A', '\x3', '\x2', '\x2', '\x2', 
		'\x1A95', '\x1A97', '\x5', '\x416', '\x20C', '\x2', '\x1A96', '\x1A98', 
		'\x5', '\x376', '\x1BC', '\x2', '\x1A97', '\x1A96', '\x3', '\x2', '\x2', 
		'\x2', '\x1A97', '\x1A98', '\x3', '\x2', '\x2', '\x2', '\x1A98', '\x1A9A', 
		'\x3', '\x2', '\x2', '\x2', '\x1A99', '\x1A8D', '\x3', '\x2', '\x2', '\x2', 
		'\x1A99', '\x1A8E', '\x3', '\x2', '\x2', '\x2', '\x1A99', '\x1A95', '\x3', 
		'\x2', '\x2', '\x2', '\x1A9A', '\x371', '\x3', '\x2', '\x2', '\x2', '\x1A9B', 
		'\x1AA8', '\t', ']', '\x2', '\x2', '\x1A9C', '\x1A9D', '\a', '\x2F2', 
		'\x2', '\x2', '\x1A9D', '\x1A9E', '\x5', '\x16E', '\xB8', '\x2', '\x1A9E', 
		'\x1A9F', '\a', '\x2F3', '\x2', '\x2', '\x1A9F', '\x1AA9', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA0', '\x1AA1', '\a', '\x2F2', '\x2', '\x2', '\x1AA1', 
		'\x1AA2', '\x5', '\x37E', '\x1C0', '\x2', '\x1AA2', '\x1AA6', '\a', '\x2F3', 
		'\x2', '\x2', '\x1AA3', '\x1AA4', '\a', '\x2F2', '\x2', '\x2', '\x1AA4', 
		'\x1AA5', '\a', '\x2F6', '\x2', '\x2', '\x1AA5', '\x1AA7', '\a', '\x2F3', 
		'\x2', '\x2', '\x1AA6', '\x1AA3', '\x3', '\x2', '\x2', '\x2', '\x1AA6', 
		'\x1AA7', '\x3', '\x2', '\x2', '\x2', '\x1AA7', '\x1AA9', '\x3', '\x2', 
		'\x2', '\x2', '\x1AA8', '\x1A9C', '\x3', '\x2', '\x2', '\x2', '\x1AA8', 
		'\x1AA0', '\x3', '\x2', '\x2', '\x2', '\x1AA9', '\x373', '\x3', '\x2', 
		'\x2', '\x2', '\x1AAA', '\x1AB3', '\a', '\x2A6', '\x2', '\x2', '\x1AAB', 
		'\x1AAC', '\a', '\x1E0', '\x2', '\x2', '\x1AAC', '\x1AB4', '\a', '\x19A', 
		'\x2', '\x2', '\x1AAD', '\x1AAE', '\a', 'M', '\x2', '\x2', '\x1AAE', '\x1AB1', 
		'\a', '\x19F', '\x2', '\x2', '\x1AAF', '\x1AB0', '\a', '\x65', '\x2', 
		'\x2', '\x1AB0', '\x1AB2', '\x5', '\x40C', '\x207', '\x2', '\x1AB1', '\x1AAF', 
		'\x3', '\x2', '\x2', '\x2', '\x1AB1', '\x1AB2', '\x3', '\x2', '\x2', '\x2', 
		'\x1AB2', '\x1AB4', '\x3', '\x2', '\x2', '\x2', '\x1AB3', '\x1AAB', '\x3', 
		'\x2', '\x2', '\x2', '\x1AB3', '\x1AAD', '\x3', '\x2', '\x2', '\x2', '\x1AB4', 
		'\x375', '\x3', '\x2', '\x2', '\x2', '\x1AB5', '\x1AB7', '\a', '\x20D', 
		'\x2', '\x2', '\x1AB6', '\x1AB8', '\a', '\x36', '\x2', '\x2', '\x1AB7', 
		'\x1AB6', '\x3', '\x2', '\x2', '\x2', '\x1AB7', '\x1AB8', '\x3', '\x2', 
		'\x2', '\x2', '\x1AB8', '\x1AB9', '\x3', '\x2', '\x2', '\x2', '\x1AB9', 
		'\x1ABA', '\a', '\x2F2', '\x2', '\x2', '\x1ABA', '\x1ABD', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1ABB', '\x1ABC', '\a', '\x2F8', '\x2', '\x2', '\x1ABC', 
		'\x1ABE', '\x5', '\x37E', '\x1C0', '\x2', '\x1ABD', '\x1ABB', '\x3', '\x2', 
		'\x2', '\x2', '\x1ABD', '\x1ABE', '\x3', '\x2', '\x2', '\x2', '\x1ABE', 
		'\x1ABF', '\x3', '\x2', '\x2', '\x2', '\x1ABF', '\x1AC1', '\a', '\x2F3', 
		'\x2', '\x2', '\x1AC0', '\x1AC2', '\x5', '\x378', '\x1BD', '\x2', '\x1AC1', 
		'\x1AC0', '\x3', '\x2', '\x2', '\x2', '\x1AC1', '\x1AC2', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC2', '\x377', '\x3', '\x2', '\x2', '\x2', '\x1AC3', 
		'\x1AC4', '\a', '\x218', '\x2', '\x2', '\x1AC4', '\x1AC5', '\a', '\x2F2', 
		'\x2', '\x2', '\x1AC5', '\x1AC6', '\x5', '\x37E', '\x1C0', '\x2', '\x1AC6', 
		'\x1AC7', '\a', '\x2F3', '\x2', '\x2', '\x1AC7', '\x379', '\x3', '\x2', 
		'\x2', '\x2', '\x1AC8', '\x1AC9', '\x5', '\x37E', '\x1C0', '\x2', '\x1AC9', 
		'\x37B', '\x3', '\x2', '\x2', '\x2', '\x1ACA', '\x1ACF', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1ACB', '\x1ACC', '\a', '\x2F8', '\x2', '\x2', '\x1ACC', 
		'\x1ACE', '\x5', '\x37E', '\x1C0', '\x2', '\x1ACD', '\x1ACB', '\x3', '\x2', 
		'\x2', '\x2', '\x1ACE', '\x1AD1', '\x3', '\x2', '\x2', '\x2', '\x1ACF', 
		'\x1ACD', '\x3', '\x2', '\x2', '\x2', '\x1ACF', '\x1AD0', '\x3', '\x2', 
		'\x2', '\x2', '\x1AD0', '\x37D', '\x3', '\x2', '\x2', '\x2', '\x1AD1', 
		'\x1ACF', '\x3', '\x2', '\x2', '\x2', '\x1AD2', '\x1AD6', '\x5', '\x380', 
		'\x1C1', '\x2', '\x1AD3', '\x1AD6', '\x5', '\x382', '\x1C2', '\x2', '\x1AD4', 
		'\x1AD6', '\a', '\x2E6', '\x2', '\x2', '\x1AD5', '\x1AD2', '\x3', '\x2', 
		'\x2', '\x2', '\x1AD5', '\x1AD3', '\x3', '\x2', '\x2', '\x2', '\x1AD5', 
		'\x1AD4', '\x3', '\x2', '\x2', '\x2', '\x1AD6', '\x37F', '\x3', '\x2', 
		'\x2', '\x2', '\x1AD7', '\x1AD8', '\a', 'z', '\x2', '\x2', '\x1AD8', '\x1AD9', 
		'\a', '\x2F2', '\x2', '\x2', '\x1AD9', '\x1ADA', '\x5', '\x16E', '\xB8', 
		'\x2', '\x1ADA', '\x1ADB', '\a', '\x2F3', '\x2', '\x2', '\x1ADB', '\x381', 
		'\x3', '\x2', '\x2', '\x2', '\x1ADC', '\x1ADD', '\b', '\x1C2', '\x1', 
		'\x2', '\x1ADD', '\x1AFF', '\x5', '\x384', '\x1C3', '\x2', '\x1ADE', '\x1AE0', 
		'\a', '\x11B', '\x2', '\x2', '\x1ADF', '\x1AE1', '\a', '\x18A', '\x2', 
		'\x2', '\x1AE0', '\x1ADF', '\x3', '\x2', '\x2', '\x2', '\x1AE0', '\x1AE1', 
		'\x3', '\x2', '\x2', '\x2', '\x1AE1', '\x1AFB', '\x3', '\x2', '\x2', '\x2', 
		'\x1AE2', '\x1AFC', '\a', '\x18D', '\x2', '\x2', '\x1AE3', '\x1AFC', '\a', 
		'\x168', '\x2', '\x2', '\x1AE4', '\x1AFC', '\a', '\x1CE', '\x2', '\x2', 
		'\x1AE5', '\x1AFC', '\a', '\x106', '\x2', '\x2', '\x1AE6', '\x1AE7', '\a', 
		'\r', '\x2', '\x2', '\x1AE7', '\x1AFC', '\a', '\x223', '\x2', '\x2', '\x1AE8', 
		'\x1AFC', '\a', '\xB0', '\x2', '\x2', '\x1AE9', '\x1AEB', '\a', '\x195', 
		'\x2', '\x2', '\x1AEA', '\x1AEC', '\a', '\x27A', '\x2', '\x2', '\x1AEB', 
		'\x1AEA', '\x3', '\x2', '\x2', '\x2', '\x1AEB', '\x1AEC', '\x3', '\x2', 
		'\x2', '\x2', '\x1AEC', '\x1AED', '\x3', '\x2', '\x2', '\x2', '\x1AED', 
		'\x1AEF', '\a', '\x2F2', '\x2', '\x2', '\x1AEE', '\x1AF0', '\a', '\x19A', 
		'\x2', '\x2', '\x1AEF', '\x1AEE', '\x3', '\x2', '\x2', '\x2', '\x1AEF', 
		'\x1AF0', '\x3', '\x2', '\x2', '\x2', '\x1AF0', '\x1AF1', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF1', '\x1AF6', '\x5', '\x454', '\x22B', '\x2', '\x1AF2', 
		'\x1AF3', '\a', '\x2F8', '\x2', '\x2', '\x1AF3', '\x1AF5', '\x5', '\x454', 
		'\x22B', '\x2', '\x1AF4', '\x1AF2', '\x3', '\x2', '\x2', '\x2', '\x1AF5', 
		'\x1AF8', '\x3', '\x2', '\x2', '\x2', '\x1AF6', '\x1AF4', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF6', '\x1AF7', '\x3', '\x2', '\x2', '\x2', '\x1AF7', 
		'\x1AF9', '\x3', '\x2', '\x2', '\x2', '\x1AF8', '\x1AF6', '\x3', '\x2', 
		'\x2', '\x2', '\x1AF9', '\x1AFA', '\a', '\x2F3', '\x2', '\x2', '\x1AFA', 
		'\x1AFC', '\x3', '\x2', '\x2', '\x2', '\x1AFB', '\x1AE2', '\x3', '\x2', 
		'\x2', '\x2', '\x1AFB', '\x1AE3', '\x3', '\x2', '\x2', '\x2', '\x1AFB', 
		'\x1AE4', '\x3', '\x2', '\x2', '\x2', '\x1AFB', '\x1AE5', '\x3', '\x2', 
		'\x2', '\x2', '\x1AFB', '\x1AE6', '\x3', '\x2', '\x2', '\x2', '\x1AFB', 
		'\x1AE8', '\x3', '\x2', '\x2', '\x2', '\x1AFB', '\x1AE9', '\x3', '\x2', 
		'\x2', '\x2', '\x1AFC', '\x1AFE', '\x3', '\x2', '\x2', '\x2', '\x1AFD', 
		'\x1ADE', '\x3', '\x2', '\x2', '\x2', '\x1AFE', '\x1B01', '\x3', '\x2', 
		'\x2', '\x2', '\x1AFF', '\x1AFD', '\x3', '\x2', '\x2', '\x2', '\x1AFF', 
		'\x1B00', '\x3', '\x2', '\x2', '\x2', '\x1B00', '\x1B05', '\x3', '\x2', 
		'\x2', '\x2', '\x1B01', '\x1AFF', '\x3', '\x2', '\x2', '\x2', '\x1B02', 
		'\x1B03', '\a', '\x18A', '\x2', '\x2', '\x1B03', '\x1B05', '\x5', '\x382', 
		'\x1C2', '\x5', '\x1B04', '\x1ADC', '\x3', '\x2', '\x2', '\x2', '\x1B04', 
		'\x1B02', '\x3', '\x2', '\x2', '\x2', '\x1B05', '\x1B0E', '\x3', '\x2', 
		'\x2', '\x2', '\x1B06', '\x1B07', '\f', '\x4', '\x2', '\x2', '\x1B07', 
		'\x1B08', '\a', '\x13', '\x2', '\x2', '\x1B08', '\x1B0D', '\x5', '\x382', 
		'\x1C2', '\x5', '\x1B09', '\x1B0A', '\f', '\x3', '\x2', '\x2', '\x1B0A', 
		'\x1B0B', '\a', '\x1A4', '\x2', '\x2', '\x1B0B', '\x1B0D', '\x5', '\x382', 
		'\x1C2', '\x4', '\x1B0C', '\x1B06', '\x3', '\x2', '\x2', '\x2', '\x1B0C', 
		'\x1B09', '\x3', '\x2', '\x2', '\x2', '\x1B0D', '\x1B10', '\x3', '\x2', 
		'\x2', '\x2', '\x1B0E', '\x1B0C', '\x3', '\x2', '\x2', '\x2', '\x1B0E', 
		'\x1B0F', '\x3', '\x2', '\x2', '\x2', '\x1B0F', '\x383', '\x3', '\x2', 
		'\x2', '\x2', '\x1B10', '\x1B0E', '\x3', '\x2', '\x2', '\x2', '\x1B11', 
		'\x1B17', '\x5', '\x386', '\x1C4', '\x2', '\x1B12', '\x1B14', '\t', '^', 
		'\x2', '\x2', '\x1B13', '\x1B15', '\a', '\x195', '\x2', '\x2', '\x1B14', 
		'\x1B13', '\x3', '\x2', '\x2', '\x2', '\x1B14', '\x1B15', '\x3', '\x2', 
		'\x2', '\x2', '\x1B15', '\x1B16', '\x3', '\x2', '\x2', '\x2', '\x1B16', 
		'\x1B18', '\x5', '\x38C', '\x1C7', '\x2', '\x1B17', '\x1B12', '\x3', '\x2', 
		'\x2', '\x2', '\x1B17', '\x1B18', '\x3', '\x2', '\x2', '\x2', '\x1B18', 
		'\x385', '\x3', '\x2', '\x2', '\x2', '\x1B19', '\x1B1A', '\b', '\x1C4', 
		'\x1', '\x2', '\x1B1A', '\x1B1B', '\x5', '\x38A', '\x1C6', '\x2', '\x1B1B', 
		'\x1B22', '\x3', '\x2', '\x2', '\x2', '\x1B1C', '\x1B1D', '\f', '\x4', 
		'\x2', '\x2', '\x1B1D', '\x1B1E', '\x5', '\x38E', '\x1C8', '\x2', '\x1B1E', 
		'\x1B1F', '\x5', '\x386', '\x1C4', '\x5', '\x1B1F', '\x1B21', '\x3', '\x2', 
		'\x2', '\x2', '\x1B20', '\x1B1C', '\x3', '\x2', '\x2', '\x2', '\x1B21', 
		'\x1B24', '\x3', '\x2', '\x2', '\x2', '\x1B22', '\x1B20', '\x3', '\x2', 
		'\x2', '\x2', '\x1B22', '\x1B23', '\x3', '\x2', '\x2', '\x2', '\x1B23', 
		'\x387', '\x3', '\x2', '\x2', '\x2', '\x1B24', '\x1B22', '\x3', '\x2', 
		'\x2', '\x2', '\x1B25', '\x1B28', '\x5', '\x486', '\x244', '\x2', '\x1B26', 
		'\x1B28', '\x5', '\x494', '\x24B', '\x2', '\x1B27', '\x1B25', '\x3', '\x2', 
		'\x2', '\x2', '\x1B27', '\x1B26', '\x3', '\x2', '\x2', '\x2', '\x1B28', 
		'\x1B29', '\x3', '\x2', '\x2', '\x2', '\x1B29', '\x1B2A', '\a', '\x2EB', 
		'\x2', '\x2', '\x1B2A', '\x1B2C', '\x3', '\x2', '\x2', '\x2', '\x1B2B', 
		'\x1B27', '\x3', '\x2', '\x2', '\x2', '\x1B2B', '\x1B2C', '\x3', '\x2', 
		'\x2', '\x2', '\x1B2C', '\x1B2F', '\x3', '\x2', '\x2', '\x2', '\x1B2D', 
		'\x1B30', '\x5', '\x490', '\x249', '\x2', '\x1B2E', '\x1B30', '\a', '\x207', 
		'\x2', '\x2', '\x1B2F', '\x1B2D', '\x3', '\x2', '\x2', '\x2', '\x1B2F', 
		'\x1B2E', '\x3', '\x2', '\x2', '\x2', '\x1B30', '\x1B3A', '\x3', '\x2', 
		'\x2', '\x2', '\x1B31', '\x1B3A', '\a', '\x208', '\x2', '\x2', '\x1B32', 
		'\x1B3A', '\x5', '\x4AA', '\x256', '\x2', '\x1B33', '\x1B3A', '\x5', '\x4A6', 
		'\x254', '\x2', '\x1B34', '\x1B35', '\x5', '\x498', '\x24D', '\x2', '\x1B35', 
		'\x1B36', '\a', '\x2EB', '\x2', '\x2', '\x1B36', '\x1B37', '\t', '_', 
		'\x2', '\x2', '\x1B37', '\x1B3A', '\x3', '\x2', '\x2', '\x2', '\x1B38', 
		'\x1B3A', '\a', '\x18D', '\x2', '\x2', '\x1B39', '\x1B2B', '\x3', '\x2', 
		'\x2', '\x2', '\x1B39', '\x1B31', '\x3', '\x2', '\x2', '\x2', '\x1B39', 
		'\x1B32', '\x3', '\x2', '\x2', '\x2', '\x1B39', '\x1B33', '\x3', '\x2', 
		'\x2', '\x2', '\x1B39', '\x1B34', '\x3', '\x2', '\x2', '\x2', '\x1B39', 
		'\x1B38', '\x3', '\x2', '\x2', '\x2', '\x1B3A', '\x389', '\x3', '\x2', 
		'\x2', '\x2', '\x1B3B', '\x1B4B', '\x5', '\x38C', '\x1C7', '\x2', '\x1B3C', 
		'\x1B3E', '\a', '\x18A', '\x2', '\x2', '\x1B3D', '\x1B3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1B3D', '\x1B3E', '\x3', '\x2', '\x2', '\x2', '\x1B3E', 
		'\x1B49', '\x3', '\x2', '\x2', '\x2', '\x1B3F', '\x1B40', '\a', '\x108', 
		'\x2', '\x2', '\x1B40', '\x1B4A', '\x5', '\x392', '\x1CA', '\x2', '\x1B41', 
		'\x1B42', '\a', '.', '\x2', '\x2', '\x1B42', '\x1B4A', '\x5', '\x394', 
		'\x1CB', '\x2', '\x1B43', '\x1B44', '\t', '`', '\x2', '\x2', '\x1B44', 
		'\x1B47', '\x5', '\x38C', '\x1C7', '\x2', '\x1B45', '\x1B46', '\a', '\xBA', 
		'\x2', '\x2', '\x1B46', '\x1B48', '\x5', '\x38C', '\x1C7', '\x2', '\x1B47', 
		'\x1B45', '\x3', '\x2', '\x2', '\x2', '\x1B47', '\x1B48', '\x3', '\x2', 
		'\x2', '\x2', '\x1B48', '\x1B4A', '\x3', '\x2', '\x2', '\x2', '\x1B49', 
		'\x1B3F', '\x3', '\x2', '\x2', '\x2', '\x1B49', '\x1B41', '\x3', '\x2', 
		'\x2', '\x2', '\x1B49', '\x1B43', '\x3', '\x2', '\x2', '\x2', '\x1B4A', 
		'\x1B4C', '\x3', '\x2', '\x2', '\x2', '\x1B4B', '\x1B3D', '\x3', '\x2', 
		'\x2', '\x2', '\x1B4B', '\x1B4C', '\x3', '\x2', '\x2', '\x2', '\x1B4C', 
		'\x38B', '\x3', '\x2', '\x2', '\x2', '\x1B4D', '\x1B4E', '\b', '\x1C7', 
		'\x1', '\x2', '\x1B4E', '\x1B57', '\x5', '\x390', '\x1C9', '\x2', '\x1B4F', 
		'\x1B54', '\a', '\x1C', '\x2', '\x2', '\x1B50', '\x1B55', '\a', '\x138', 
		'\x2', '\x2', '\x1B51', '\x1B52', '\a', '\x265', '\x2', '\x2', '\x1B52', 
		'\x1B53', '\a', '\x2BF', '\x2', '\x2', '\x1B53', '\x1B55', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x1B54', '\x1B50', '\x3', '\x2', '\x2', '\x2', '\x1B54', 
		'\x1B51', '\x3', '\x2', '\x2', '\x2', '\x1B55', '\x1B58', '\x3', '\x2', 
		'\x2', '\x2', '\x1B56', '\x1B58', '\x5', '\x396', '\x1CC', '\x2', '\x1B57', 
		'\x1B4F', '\x3', '\x2', '\x2', '\x2', '\x1B57', '\x1B56', '\x3', '\x2', 
		'\x2', '\x2', '\x1B57', '\x1B58', '\x3', '\x2', '\x2', '\x2', '\x1B58', 
		'\x1B65', '\x3', '\x2', '\x2', '\x2', '\x1B59', '\x1B5A', '\f', '\x5', 
		'\x2', '\x2', '\x1B5A', '\x1B5B', '\t', '\x61', '\x2', '\x2', '\x1B5B', 
		'\x1B64', '\x5', '\x38C', '\x1C7', '\x6', '\x1B5C', '\x1B5D', '\f', '\x4', 
		'\x2', '\x2', '\x1B5D', '\x1B5E', '\t', '\x62', '\x2', '\x2', '\x1B5E', 
		'\x1B64', '\x5', '\x38C', '\x1C7', '\x5', '\x1B5F', '\x1B60', '\f', '\x3', 
		'\x2', '\x2', '\x1B60', '\x1B61', '\a', '\x305', '\x2', '\x2', '\x1B61', 
		'\x1B62', '\a', '\x305', '\x2', '\x2', '\x1B62', '\x1B64', '\x5', '\x38C', 
		'\x1C7', '\x4', '\x1B63', '\x1B59', '\x3', '\x2', '\x2', '\x2', '\x1B63', 
		'\x1B5C', '\x3', '\x2', '\x2', '\x2', '\x1B63', '\x1B5F', '\x3', '\x2', 
		'\x2', '\x2', '\x1B64', '\x1B67', '\x3', '\x2', '\x2', '\x2', '\x1B65', 
		'\x1B63', '\x3', '\x2', '\x2', '\x2', '\x1B65', '\x1B66', '\x3', '\x2', 
		'\x2', '\x2', '\x1B66', '\x38D', '\x3', '\x2', '\x2', '\x2', '\x1B67', 
		'\x1B65', '\x3', '\x2', '\x2', '\x2', '\x1B68', '\x1B77', '\a', '\x306', 
		'\x2', '\x2', '\x1B69', '\x1B71', '\a', '\x2FD', '\x2', '\x2', '\x1B6A', 
		'\x1B6B', '\a', '\x302', '\x2', '\x2', '\x1B6B', '\x1B71', '\a', '\x301', 
		'\x2', '\x2', '\x1B6C', '\x1B6D', '\a', '\x300', '\x2', '\x2', '\x1B6D', 
		'\x1B71', '\a', '\x306', '\x2', '\x2', '\x1B6E', '\x1B6F', '\a', '\x2FE', 
		'\x2', '\x2', '\x1B6F', '\x1B71', '\a', '\x306', '\x2', '\x2', '\x1B70', 
		'\x1B69', '\x3', '\x2', '\x2', '\x2', '\x1B70', '\x1B6A', '\x3', '\x2', 
		'\x2', '\x2', '\x1B70', '\x1B6C', '\x3', '\x2', '\x2', '\x2', '\x1B70', 
		'\x1B6E', '\x3', '\x2', '\x2', '\x2', '\x1B71', '\x1B77', '\x3', '\x2', 
		'\x2', '\x2', '\x1B72', '\x1B74', '\t', '\x63', '\x2', '\x2', '\x1B73', 
		'\x1B75', '\a', '\x306', '\x2', '\x2', '\x1B74', '\x1B73', '\x3', '\x2', 
		'\x2', '\x2', '\x1B74', '\x1B75', '\x3', '\x2', '\x2', '\x2', '\x1B75', 
		'\x1B77', '\x3', '\x2', '\x2', '\x2', '\x1B76', '\x1B68', '\x3', '\x2', 
		'\x2', '\x2', '\x1B76', '\x1B70', '\x3', '\x2', '\x2', '\x2', '\x1B76', 
		'\x1B72', '\x3', '\x2', '\x2', '\x2', '\x1B77', '\x38F', '\x3', '\x2', 
		'\x2', '\x2', '\x1B78', '\x1B7D', '\x5', '\x39E', '\x1D0', '\x2', '\x1B79', 
		'\x1B7A', '\a', '\x307', '\x2', '\x2', '\x1B7A', '\x1B7B', '\x5', '\x398', 
		'\x1CD', '\x2', '\x1B7B', '\x1B7C', '\a', '\x308', '\x2', '\x2', '\x1B7C', 
		'\x1B7E', '\x3', '\x2', '\x2', '\x2', '\x1B7D', '\x1B79', '\x3', '\x2', 
		'\x2', '\x2', '\x1B7D', '\x1B7E', '\x3', '\x2', '\x2', '\x2', '\x1B7E', 
		'\x391', '\x3', '\x2', '\x2', '\x2', '\x1B7F', '\x1B80', '\a', '\x2F2', 
		'\x2', '\x2', '\x1B80', '\x1B81', '\x5', '\x16E', '\xB8', '\x2', '\x1B81', 
		'\x1B82', '\a', '\x2F3', '\x2', '\x2', '\x1B82', '\x1B92', '\x3', '\x2', 
		'\x2', '\x2', '\x1B83', '\x1B84', '\a', '\x2F2', '\x2', '\x2', '\x1B84', 
		'\x1B89', '\x5', '\x38C', '\x1C7', '\x2', '\x1B85', '\x1B86', '\a', '\x2F8', 
		'\x2', '\x2', '\x1B86', '\x1B88', '\x5', '\x38C', '\x1C7', '\x2', '\x1B87', 
		'\x1B85', '\x3', '\x2', '\x2', '\x2', '\x1B88', '\x1B8B', '\x3', '\x2', 
		'\x2', '\x2', '\x1B89', '\x1B87', '\x3', '\x2', '\x2', '\x2', '\x1B89', 
		'\x1B8A', '\x3', '\x2', '\x2', '\x2', '\x1B8A', '\x1B8C', '\x3', '\x2', 
		'\x2', '\x2', '\x1B8B', '\x1B89', '\x3', '\x2', '\x2', '\x2', '\x1B8C', 
		'\x1B8D', '\a', '\x2F3', '\x2', '\x2', '\x1B8D', '\x1B92', '\x3', '\x2', 
		'\x2', '\x2', '\x1B8E', '\x1B92', '\x5', '\x46C', '\x237', '\x2', '\x1B8F', 
		'\x1B92', '\x5', '\x45C', '\x22F', '\x2', '\x1B90', '\x1B92', '\x5', '\x45E', 
		'\x230', '\x2', '\x1B91', '\x1B7F', '\x3', '\x2', '\x2', '\x2', '\x1B91', 
		'\x1B83', '\x3', '\x2', '\x2', '\x2', '\x1B91', '\x1B8E', '\x3', '\x2', 
		'\x2', '\x2', '\x1B91', '\x1B8F', '\x3', '\x2', '\x2', '\x2', '\x1B91', 
		'\x1B90', '\x3', '\x2', '\x2', '\x2', '\x1B92', '\x393', '\x3', '\x2', 
		'\x2', '\x2', '\x1B93', '\x1B94', '\x5', '\x38C', '\x1C7', '\x2', '\x1B94', 
		'\x1B95', '\a', '\x13', '\x2', '\x2', '\x1B95', '\x1B96', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x1B96', '\x395', '\x3', '\x2', '\x2', '\x2', '\x1B97', 
		'\x1B9C', '\a', '\x81', '\x2', '\x2', '\x1B98', '\x1B99', '\a', '\x2F2', 
		'\x2', '\x2', '\x1B99', '\x1B9A', '\x5', '\x38C', '\x1C7', '\x2', '\x1B9A', 
		'\x1B9B', '\a', '\x2F3', '\x2', '\x2', '\x1B9B', '\x1B9D', '\x3', '\x2', 
		'\x2', '\x2', '\x1B9C', '\x1B98', '\x3', '\x2', '\x2', '\x2', '\x1B9C', 
		'\x1B9D', '\x3', '\x2', '\x2', '\x2', '\x1B9D', '\x1B9E', '\x3', '\x2', 
		'\x2', '\x2', '\x1B9E', '\x1B9F', '\a', '\x26E', '\x2', '\x2', '\x1B9F', 
		'\x1BA4', '\a', '\x216', '\x2', '\x2', '\x1BA0', '\x1BA1', '\a', '\x2F2', 
		'\x2', '\x2', '\x1BA1', '\x1BA2', '\x5', '\x38C', '\x1C7', '\x2', '\x1BA2', 
		'\x1BA3', '\a', '\x2F3', '\x2', '\x2', '\x1BA3', '\x1BA5', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA4', '\x1BA0', '\x3', '\x2', '\x2', '\x2', '\x1BA4', 
		'\x1BA5', '\x3', '\x2', '\x2', '\x2', '\x1BA5', '\x1BB0', '\x3', '\x2', 
		'\x2', '\x2', '\x1BA6', '\x1BAB', '\a', '\x2BB', '\x2', '\x2', '\x1BA7', 
		'\x1BA8', '\a', '\x2F2', '\x2', '\x2', '\x1BA8', '\x1BA9', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x1BA9', '\x1BAA', '\a', '\x2F3', '\x2', '\x2', '\x1BAA', 
		'\x1BAC', '\x3', '\x2', '\x2', '\x2', '\x1BAB', '\x1BA7', '\x3', '\x2', 
		'\x2', '\x2', '\x1BAB', '\x1BAC', '\x3', '\x2', '\x2', '\x2', '\x1BAC', 
		'\x1BAD', '\x3', '\x2', '\x2', '\x2', '\x1BAD', '\x1BAE', '\a', '\x26E', 
		'\x2', '\x2', '\x1BAE', '\x1BB0', '\a', '\x163', '\x2', '\x2', '\x1BAF', 
		'\x1B97', '\x3', '\x2', '\x2', '\x2', '\x1BAF', '\x1BA6', '\x3', '\x2', 
		'\x2', '\x2', '\x1BB0', '\x397', '\x3', '\x2', '\x2', '\x2', '\x1BB1', 
		'\x1BB4', '\a', '\x14', '\x2', '\x2', '\x1BB2', '\x1BB4', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1BB3', '\x1BB1', '\x3', '\x2', '\x2', '\x2', '\x1BB3', 
		'\x1BB2', '\x3', '\x2', '\x2', '\x2', '\x1BB4', '\x1BBC', '\x3', '\x2', 
		'\x2', '\x2', '\x1BB5', '\x1BB8', '\a', '\x2F8', '\x2', '\x2', '\x1BB6', 
		'\x1BB9', '\a', '\x14', '\x2', '\x2', '\x1BB7', '\x1BB9', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1BB8', '\x1BB6', '\x3', '\x2', '\x2', '\x2', '\x1BB8', 
		'\x1BB7', '\x3', '\x2', '\x2', '\x2', '\x1BB9', '\x1BBB', '\x3', '\x2', 
		'\x2', '\x2', '\x1BBA', '\x1BB5', '\x3', '\x2', '\x2', '\x2', '\x1BBB', 
		'\x1BBE', '\x3', '\x2', '\x2', '\x2', '\x1BBC', '\x1BBA', '\x3', '\x2', 
		'\x2', '\x2', '\x1BBC', '\x1BBD', '\x3', '\x2', '\x2', '\x2', '\x1BBD', 
		'\x1BC9', '\x3', '\x2', '\x2', '\x2', '\x1BBE', '\x1BBC', '\x3', '\x2', 
		'\x2', '\x2', '\x1BBF', '\x1BC4', '\x5', '\x39A', '\x1CE', '\x2', '\x1BC0', 
		'\x1BC1', '\a', '\x2F8', '\x2', '\x2', '\x1BC1', '\x1BC3', '\x5', '\x39A', 
		'\x1CE', '\x2', '\x1BC2', '\x1BC0', '\x3', '\x2', '\x2', '\x2', '\x1BC3', 
		'\x1BC6', '\x3', '\x2', '\x2', '\x2', '\x1BC4', '\x1BC2', '\x3', '\x2', 
		'\x2', '\x2', '\x1BC4', '\x1BC5', '\x3', '\x2', '\x2', '\x2', '\x1BC5', 
		'\x1BC9', '\x3', '\x2', '\x2', '\x2', '\x1BC6', '\x1BC4', '\x3', '\x2', 
		'\x2', '\x2', '\x1BC7', '\x1BC9', '\x5', '\x39C', '\x1CF', '\x2', '\x1BC8', 
		'\x1BB3', '\x3', '\x2', '\x2', '\x2', '\x1BC8', '\x1BBF', '\x3', '\x2', 
		'\x2', '\x2', '\x1BC8', '\x1BC7', '\x3', '\x2', '\x2', '\x2', '\x1BC9', 
		'\x399', '\x3', '\x2', '\x2', '\x2', '\x1BCA', '\x1BCB', '\a', '\xDD', 
		'\x2', '\x2', '\x1BCB', '\x1BDD', '\x5', '\x490', '\x249', '\x2', '\x1BCC', 
		'\x1BCD', '\a', '\x108', '\x2', '\x2', '\x1BCD', '\x1BCF', '\a', '\x2F2', 
		'\x2', '\x2', '\x1BCE', '\x1BD0', '\x5', '\x37C', '\x1BF', '\x2', '\x1BCF', 
		'\x1BCE', '\x3', '\x2', '\x2', '\x2', '\x1BCF', '\x1BD0', '\x3', '\x2', 
		'\x2', '\x2', '\x1BD0', '\x1BD1', '\x3', '\x2', '\x2', '\x2', '\x1BD1', 
		'\x1BDE', '\a', '\x2F3', '\x2', '\x2', '\x1BD2', '\x1BD3', '\a', '\x130', 
		'\x2', '\x2', '\x1BD3', '\x1BD5', '\x5', '\x37E', '\x1C0', '\x2', '\x1BD4', 
		'\x1BD2', '\x3', '\x2', '\x2', '\x2', '\x1BD4', '\x1BD5', '\x3', '\x2', 
		'\x2', '\x2', '\x1BD5', '\x1BD6', '\x3', '\x2', '\x2', '\x2', '\x1BD6', 
		'\x1BD7', '\a', '\xE1', '\x2', '\x2', '\x1BD7', '\x1BD8', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1BD8', '\x1BD9', '\a', '\x26E', '\x2', '\x2', '\x1BD9', 
		'\x1BDA', '\x5', '\x37E', '\x1C0', '\x2', '\x1BDA', '\x1BDB', '\t', '\x64', 
		'\x2', '\x2', '\x1BDB', '\x1BDC', '\x5', '\x37E', '\x1C0', '\x2', '\x1BDC', 
		'\x1BDE', '\x3', '\x2', '\x2', '\x2', '\x1BDD', '\x1BCC', '\x3', '\x2', 
		'\x2', '\x2', '\x1BDD', '\x1BD4', '\x3', '\x2', '\x2', '\x2', '\x1BDE', 
		'\x39B', '\x3', '\x2', '\x2', '\x2', '\x1BDF', '\x1BE0', '\a', '\xDD', 
		'\x2', '\x2', '\x1BE0', '\x1BE1', '\x5', '\x44A', '\x226', '\x2', '\x1BE1', 
		'\x1BE2', '\a', '\x108', '\x2', '\x2', '\x1BE2', '\x1BE9', '\a', '\x2F2', 
		'\x2', '\x2', '\x1BE3', '\x1BEA', '\x5', '\x16E', '\xB8', '\x2', '\x1BE4', 
		'\x1BE6', '\a', '\x2F2', '\x2', '\x2', '\x1BE5', '\x1BE7', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x1BE6', '\x1BE5', '\x3', '\x2', '\x2', '\x2', '\x1BE6', 
		'\x1BE7', '\x3', '\x2', '\x2', '\x2', '\x1BE7', '\x1BE8', '\x3', '\x2', 
		'\x2', '\x2', '\x1BE8', '\x1BEA', '\a', '\x2F3', '\x2', '\x2', '\x1BE9', 
		'\x1BE3', '\x3', '\x2', '\x2', '\x2', '\x1BE9', '\x1BE4', '\x3', '\x2', 
		'\x2', '\x2', '\x1BEA', '\x1BEB', '\x3', '\x2', '\x2', '\x2', '\x1BEB', 
		'\x1BEC', '\a', '\x2F3', '\x2', '\x2', '\x1BEC', '\x39D', '\x3', '\x2', 
		'\x2', '\x2', '\x1BED', '\x1BEE', '\t', '\x62', '\x2', '\x2', '\x1BEE', 
		'\x1BFE', '\x5', '\x39E', '\x1D0', '\x2', '\x1BEF', '\x1BF0', '\a', '\x1D2', 
		'\x2', '\x2', '\x1BF0', '\x1BFE', '\x5', '\x39E', '\x1D0', '\x2', '\x1BF1', 
		'\x1BF2', '\a', '\x62', '\x2', '\x2', '\x1BF2', '\x1BFE', '\x5', '\x39E', 
		'\x1D0', '\x2', '\x1BF3', '\x1BFE', '\x5', '\x3B0', '\x1D9', '\x2', '\x1BF4', 
		'\x1BF5', '\a', '\x170', '\x2', '\x2', '\x1BF5', '\x1BFE', '\x5', '\x39E', 
		'\x1D0', '\x2', '\x1BF6', '\x1BF7', '\a', '\x9F', '\x2', '\x2', '\x1BF7', 
		'\x1BFE', '\x5', '\x39E', '\x1D0', '\x2', '\x1BF8', '\x1BF9', '\a', '\xE', 
		'\x2', '\x2', '\x1BF9', '\x1BFE', '\x5', '\x39E', '\x1D0', '\x2', '\x1BFA', 
		'\x1BFE', '\x5', '\x3A0', '\x1D1', '\x2', '\x1BFB', '\x1BFE', '\x5', '\x3AE', 
		'\x1D8', '\x2', '\x1BFC', '\x1BFE', '\x5', '\x3AC', '\x1D7', '\x2', '\x1BFD', 
		'\x1BED', '\x3', '\x2', '\x2', '\x2', '\x1BFD', '\x1BEF', '\x3', '\x2', 
		'\x2', '\x2', '\x1BFD', '\x1BF1', '\x3', '\x2', '\x2', '\x2', '\x1BFD', 
		'\x1BF3', '\x3', '\x2', '\x2', '\x2', '\x1BFD', '\x1BF4', '\x3', '\x2', 
		'\x2', '\x2', '\x1BFD', '\x1BF6', '\x3', '\x2', '\x2', '\x2', '\x1BFD', 
		'\x1BF8', '\x3', '\x2', '\x2', '\x2', '\x1BFD', '\x1BFA', '\x3', '\x2', 
		'\x2', '\x2', '\x1BFD', '\x1BFB', '\x3', '\x2', '\x2', '\x2', '\x1BFD', 
		'\x1BFC', '\x3', '\x2', '\x2', '\x2', '\x1BFE', '\x39F', '\x3', '\x2', 
		'\x2', '\x2', '\x1BFF', '\x1C02', '\x5', '\x3A6', '\x1D4', '\x2', '\x1C00', 
		'\x1C02', '\x5', '\x3A2', '\x1D2', '\x2', '\x1C01', '\x1BFF', '\x3', '\x2', 
		'\x2', '\x2', '\x1C01', '\x1C00', '\x3', '\x2', '\x2', '\x2', '\x1C02', 
		'\x3A1', '\x3', '\x2', '\x2', '\x2', '\x1C03', '\x1C05', '\x5', '\x428', 
		'\x215', '\x2', '\x1C04', '\x1C03', '\x3', '\x2', '\x2', '\x2', '\x1C04', 
		'\x1C05', '\x3', '\x2', '\x2', '\x2', '\x1C05', '\x1C06', '\x3', '\x2', 
		'\x2', '\x2', '\x1C06', '\x1C07', '\a', '\x46', '\x2', '\x2', '\x1C07', 
		'\x1C09', '\x5', '\x37E', '\x1C0', '\x2', '\x1C08', '\x1C0A', '\x5', '\x3A4', 
		'\x1D3', '\x2', '\x1C09', '\x1C08', '\x3', '\x2', '\x2', '\x2', '\x1C0A', 
		'\x1C0B', '\x3', '\x2', '\x2', '\x2', '\x1C0B', '\x1C09', '\x3', '\x2', 
		'\x2', '\x2', '\x1C0B', '\x1C0C', '\x3', '\x2', '\x2', '\x2', '\x1C0C', 
		'\x1C0E', '\x3', '\x2', '\x2', '\x2', '\x1C0D', '\x1C0F', '\x5', '\x3AA', 
		'\x1D6', '\x2', '\x1C0E', '\x1C0D', '\x3', '\x2', '\x2', '\x2', '\x1C0E', 
		'\x1C0F', '\x3', '\x2', '\x2', '\x2', '\x1C0F', '\x1C10', '\x3', '\x2', 
		'\x2', '\x2', '\x1C10', '\x1C12', '\a', '\xB5', '\x2', '\x2', '\x1C11', 
		'\x1C13', '\a', '\x46', '\x2', '\x2', '\x1C12', '\x1C11', '\x3', '\x2', 
		'\x2', '\x2', '\x1C12', '\x1C13', '\x3', '\x2', '\x2', '\x2', '\x1C13', 
		'\x1C15', '\x3', '\x2', '\x2', '\x2', '\x1C14', '\x1C16', '\x5', '\x428', 
		'\x215', '\x2', '\x1C15', '\x1C14', '\x3', '\x2', '\x2', '\x2', '\x1C15', 
		'\x1C16', '\x3', '\x2', '\x2', '\x2', '\x1C16', '\x3A3', '\x3', '\x2', 
		'\x2', '\x2', '\x1C17', '\x1C18', '\a', '\x2A1', '\x2', '\x2', '\x1C18', 
		'\x1C19', '\x5', '\x37E', '\x1C0', '\x2', '\x1C19', '\x1C1C', '\a', '\x25D', 
		'\x2', '\x2', '\x1C1A', '\x1C1D', '\x5', '\x26C', '\x137', '\x2', '\x1C1B', 
		'\x1C1D', '\x5', '\x37E', '\x1C0', '\x2', '\x1C1C', '\x1C1A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C1C', '\x1C1B', '\x3', '\x2', '\x2', '\x2', '\x1C1D', 
		'\x3A5', '\x3', '\x2', '\x2', '\x2', '\x1C1E', '\x1C20', '\x5', '\x428', 
		'\x215', '\x2', '\x1C1F', '\x1C1E', '\x3', '\x2', '\x2', '\x2', '\x1C1F', 
		'\x1C20', '\x3', '\x2', '\x2', '\x2', '\x1C20', '\x1C21', '\x3', '\x2', 
		'\x2', '\x2', '\x1C21', '\x1C23', '\a', '\x46', '\x2', '\x2', '\x1C22', 
		'\x1C24', '\x5', '\x3A8', '\x1D5', '\x2', '\x1C23', '\x1C22', '\x3', '\x2', 
		'\x2', '\x2', '\x1C24', '\x1C25', '\x3', '\x2', '\x2', '\x2', '\x1C25', 
		'\x1C23', '\x3', '\x2', '\x2', '\x2', '\x1C25', '\x1C26', '\x3', '\x2', 
		'\x2', '\x2', '\x1C26', '\x1C28', '\x3', '\x2', '\x2', '\x2', '\x1C27', 
		'\x1C29', '\x5', '\x3AA', '\x1D6', '\x2', '\x1C28', '\x1C27', '\x3', '\x2', 
		'\x2', '\x2', '\x1C28', '\x1C29', '\x3', '\x2', '\x2', '\x2', '\x1C29', 
		'\x1C2A', '\x3', '\x2', '\x2', '\x2', '\x1C2A', '\x1C2C', '\a', '\xB5', 
		'\x2', '\x2', '\x1C2B', '\x1C2D', '\a', '\x46', '\x2', '\x2', '\x1C2C', 
		'\x1C2B', '\x3', '\x2', '\x2', '\x2', '\x1C2C', '\x1C2D', '\x3', '\x2', 
		'\x2', '\x2', '\x1C2D', '\x1C2F', '\x3', '\x2', '\x2', '\x2', '\x1C2E', 
		'\x1C30', '\x5', '\x428', '\x215', '\x2', '\x1C2F', '\x1C2E', '\x3', '\x2', 
		'\x2', '\x2', '\x1C2F', '\x1C30', '\x3', '\x2', '\x2', '\x2', '\x1C30', 
		'\x3A7', '\x3', '\x2', '\x2', '\x2', '\x1C31', '\x1C32', '\a', '\x2A1', 
		'\x2', '\x2', '\x1C32', '\x1C33', '\x5', '\x37E', '\x1C0', '\x2', '\x1C33', 
		'\x1C36', '\a', '\x25D', '\x2', '\x2', '\x1C34', '\x1C37', '\x5', '\x26C', 
		'\x137', '\x2', '\x1C35', '\x1C37', '\x5', '\x37E', '\x1C0', '\x2', '\x1C36', 
		'\x1C34', '\x3', '\x2', '\x2', '\x2', '\x1C36', '\x1C35', '\x3', '\x2', 
		'\x2', '\x2', '\x1C37', '\x3A9', '\x3', '\x2', '\x2', '\x2', '\x1C38', 
		'\x1C3B', '\a', '\xAE', '\x2', '\x2', '\x1C39', '\x1C3C', '\x5', '\x26C', 
		'\x137', '\x2', '\x1C3A', '\x1C3C', '\x5', '\x37E', '\x1C0', '\x2', '\x1C3B', 
		'\x1C39', '\x3', '\x2', '\x2', '\x2', '\x1C3B', '\x1C3A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C3C', '\x3AB', '\x3', '\x2', '\x2', '\x2', '\x1C3D', 
		'\x1C3E', '\x5', '\x462', '\x232', '\x2', '\x1C3E', '\x1C3F', '\x5', '\x49C', 
		'\x24F', '\x2', '\x1C3F', '\x1C51', '\x3', '\x2', '\x2', '\x2', '\x1C40', 
		'\x1C51', '\x5', '\x45C', '\x22F', '\x2', '\x1C41', '\x1C51', '\x5', '\x46C', 
		'\x237', '\x2', '\x1C42', '\x1C51', '\x5', '\x45E', '\x230', '\x2', '\x1C43', 
		'\x1C44', '\a', '\x2F2', '\x2', '\x2', '\x1C44', '\x1C45', '\x5', '\x16E', 
		'\xB8', '\x2', '\x1C45', '\x1C49', '\a', '\x2F3', '\x2', '\x2', '\x1C46', 
		'\x1C48', '\x5', '\x2D0', '\x169', '\x2', '\x1C47', '\x1C46', '\x3', '\x2', 
		'\x2', '\x2', '\x1C48', '\x1C4B', '\x3', '\x2', '\x2', '\x2', '\x1C49', 
		'\x1C47', '\x3', '\x2', '\x2', '\x2', '\x1C49', '\x1C4A', '\x3', '\x2', 
		'\x2', '\x2', '\x1C4A', '\x1C51', '\x3', '\x2', '\x2', '\x2', '\x1C4B', 
		'\x1C49', '\x3', '\x2', '\x2', '\x2', '\x1C4C', '\x1C4D', '\a', '\x2F2', 
		'\x2', '\x2', '\x1C4D', '\x1C4E', '\x5', '\x37C', '\x1BF', '\x2', '\x1C4E', 
		'\x1C4F', '\a', '\x2F3', '\x2', '\x2', '\x1C4F', '\x1C51', '\x3', '\x2', 
		'\x2', '\x2', '\x1C50', '\x1C3D', '\x3', '\x2', '\x2', '\x2', '\x1C50', 
		'\x1C40', '\x3', '\x2', '\x2', '\x2', '\x1C50', '\x1C41', '\x3', '\x2', 
		'\x2', '\x2', '\x1C50', '\x1C42', '\x3', '\x2', '\x2', '\x2', '\x1C50', 
		'\x1C43', '\x3', '\x2', '\x2', '\x2', '\x1C50', '\x1C4C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C51', '\x3AD', '\x3', '\x2', '\x2', '\x2', '\x1C52', 
		'\x1C5B', '\t', '\x65', '\x2', '\x2', '\x1C53', '\x1C54', '\a', '\x2F2', 
		'\x2', '\x2', '\x1C54', '\x1C55', '\x5', '\x16E', '\xB8', '\x2', '\x1C55', 
		'\x1C56', '\a', '\x2F3', '\x2', '\x2', '\x1C56', '\x1C5C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C57', '\x1C58', '\a', '\x2F2', '\x2', '\x2', '\x1C58', 
		'\x1C59', '\x5', '\x37E', '\x1C0', '\x2', '\x1C59', '\x1C5A', '\a', '\x2F3', 
		'\x2', '\x2', '\x1C5A', '\x1C5C', '\x3', '\x2', '\x2', '\x2', '\x1C5B', 
		'\x1C53', '\x3', '\x2', '\x2', '\x2', '\x1C5B', '\x1C57', '\x3', '\x2', 
		'\x2', '\x2', '\x1C5C', '\x3AF', '\x3', '\x2', '\x2', '\x2', '\x1C5D', 
		'\x1C6E', '\x5', '\x3B2', '\x1DA', '\x2', '\x1C5E', '\x1C6E', '\x5', '\x3B4', 
		'\x1DB', '\x2', '\x1C5F', '\x1C6E', '\x5', '\x3BA', '\x1DE', '\x2', '\x1C60', 
		'\x1C61', '\x5', '\x492', '\x24A', '\x2', '\x1C61', '\x1C62', '\a', '\x2F2', 
		'\x2', '\x2', '\x1C62', '\x1C67', '\x5', '\x37E', '\x1C0', '\x2', '\x1C63', 
		'\x1C64', '\a', '\x2F8', '\x2', '\x2', '\x1C64', '\x1C66', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1C65', '\x1C63', '\x3', '\x2', '\x2', '\x2', '\x1C66', 
		'\x1C69', '\x3', '\x2', '\x2', '\x2', '\x1C67', '\x1C65', '\x3', '\x2', 
		'\x2', '\x2', '\x1C67', '\x1C68', '\x3', '\x2', '\x2', '\x2', '\x1C68', 
		'\x1C6B', '\x3', '\x2', '\x2', '\x2', '\x1C69', '\x1C67', '\x3', '\x2', 
		'\x2', '\x2', '\x1C6A', '\x1C6C', '\a', '\x2F3', '\x2', '\x2', '\x1C6B', 
		'\x1C6A', '\x3', '\x2', '\x2', '\x2', '\x1C6B', '\x1C6C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C6C', '\x1C6E', '\x3', '\x2', '\x2', '\x2', '\x1C6D', 
		'\x1C5D', '\x3', '\x2', '\x2', '\x2', '\x1C6D', '\x1C5E', '\x3', '\x2', 
		'\x2', '\x2', '\x1C6D', '\x1C5F', '\x3', '\x2', '\x2', '\x2', '\x1C6D', 
		'\x1C60', '\x3', '\x2', '\x2', '\x2', '\x1C6E', '\x3B1', '\x3', '\x2', 
		'\x2', '\x2', '\x1C6F', '\x1C70', '\a', '\x2DC', '\x2', '\x2', '\x1C70', 
		'\x1C71', '\a', '\x2F2', '\x2', '\x2', '\x1C71', '\x1C72', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1C72', '\x1C73', '\a', '\x2F8', '\x2', '\x2', '\x1C73', 
		'\x1C76', '\x5', '\x37E', '\x1C0', '\x2', '\x1C74', '\x1C75', '\a', '\x2F8', 
		'\x2', '\x2', '\x1C75', '\x1C77', '\x5', '\x37E', '\x1C0', '\x2', '\x1C76', 
		'\x1C74', '\x3', '\x2', '\x2', '\x2', '\x1C76', '\x1C77', '\x3', '\x2', 
		'\x2', '\x2', '\x1C77', '\x1C78', '\x3', '\x2', '\x2', '\x2', '\x1C78', 
		'\x1C79', '\a', '\x2F3', '\x2', '\x2', '\x1C79', '\x1CA6', '\x3', '\x2', 
		'\x2', '\x2', '\x1C7A', '\x1C7B', '\a', '\x2DD', '\x2', '\x2', '\x1C7B', 
		'\x1C7F', '\a', '\x2F2', '\x2', '\x2', '\x1C7C', '\x1C80', '\x5', '\x462', 
		'\x232', '\x2', '\x1C7D', '\x1C80', '\x5', '\x3B0', '\x1D9', '\x2', '\x1C7E', 
		'\x1C80', '\x5', '\x37E', '\x1C0', '\x2', '\x1C7F', '\x1C7C', '\x3', '\x2', 
		'\x2', '\x2', '\x1C7F', '\x1C7D', '\x3', '\x2', '\x2', '\x2', '\x1C7F', 
		'\x1C7E', '\x3', '\x2', '\x2', '\x2', '\x1C80', '\x1C83', '\x3', '\x2', 
		'\x2', '\x2', '\x1C81', '\x1C82', '\a', '\x2F8', '\x2', '\x2', '\x1C82', 
		'\x1C84', '\x5', '\x4AA', '\x256', '\x2', '\x1C83', '\x1C81', '\x3', '\x2', 
		'\x2', '\x2', '\x1C83', '\x1C84', '\x3', '\x2', '\x2', '\x2', '\x1C84', 
		'\x1C87', '\x3', '\x2', '\x2', '\x2', '\x1C85', '\x1C86', '\a', '\x2F8', 
		'\x2', '\x2', '\x1C86', '\x1C88', '\x5', '\x4AA', '\x256', '\x2', '\x1C87', 
		'\x1C85', '\x3', '\x2', '\x2', '\x2', '\x1C87', '\x1C88', '\x3', '\x2', 
		'\x2', '\x2', '\x1C88', '\x1C89', '\x3', '\x2', '\x2', '\x2', '\x1C89', 
		'\x1C8A', '\a', '\x2F3', '\x2', '\x2', '\x1C8A', '\x1CA6', '\x3', '\x2', 
		'\x2', '\x2', '\x1C8B', '\x1C8C', '\a', '\x2D0', '\x2', '\x2', '\x1C8C', 
		'\x1C8D', '\a', '\x2F2', '\x2', '\x2', '\x1C8D', '\x1C8E', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x1C8E', '\x1C8F', '\a', '\x2F3', '\x2', '\x2', '\x1C8F', 
		'\x1CA6', '\x3', '\x2', '\x2', '\x2', '\x1C90', '\x1C91', '\a', 'N', '\x2', 
		'\x2', '\x1C91', '\x1C92', '\a', '\x2F2', '\x2', '\x2', '\x1C92', '\x1C93', 
		'\x5', '\x38C', '\x1C7', '\x2', '\x1C93', '\x1C94', '\a', '\x28E', '\x2', 
		'\x2', '\x1C94', '\x1C95', '\a', '\x16C', '\x2', '\x2', '\x1C95', '\x1C96', 
		'\a', '\x2F3', '\x2', '\x2', '\x1C96', '\x1CA6', '\x3', '\x2', '\x2', 
		'\x2', '\x1C97', '\x1C98', '\a', '\x2DE', '\x2', '\x2', '\x1C98', '\x1CA0', 
		'\a', '\x2F2', '\x2', '\x2', '\x1C99', '\x1C9B', '\t', '\x66', '\x2', 
		'\x2', '\x1C9A', '\x1C99', '\x3', '\x2', '\x2', '\x2', '\x1C9A', '\x1C9B', 
		'\x3', '\x2', '\x2', '\x2', '\x1C9B', '\x1C9D', '\x3', '\x2', '\x2', '\x2', 
		'\x1C9C', '\x1C9E', '\x5', '\x4AA', '\x256', '\x2', '\x1C9D', '\x1C9C', 
		'\x3', '\x2', '\x2', '\x2', '\x1C9D', '\x1C9E', '\x3', '\x2', '\x2', '\x2', 
		'\x1C9E', '\x1C9F', '\x3', '\x2', '\x2', '\x2', '\x1C9F', '\x1CA1', '\a', 
		'\xE1', '\x2', '\x2', '\x1CA0', '\x1C9A', '\x3', '\x2', '\x2', '\x2', 
		'\x1CA0', '\x1CA1', '\x3', '\x2', '\x2', '\x2', '\x1CA1', '\x1CA2', '\x3', 
		'\x2', '\x2', '\x2', '\x1CA2', '\x1CA3', '\x5', '\x38C', '\x1C7', '\x2', 
		'\x1CA3', '\x1CA4', '\a', '\x2F3', '\x2', '\x2', '\x1CA4', '\x1CA6', '\x3', 
		'\x2', '\x2', '\x2', '\x1CA5', '\x1C6F', '\x3', '\x2', '\x2', '\x2', '\x1CA5', 
		'\x1C7A', '\x3', '\x2', '\x2', '\x2', '\x1CA5', '\x1C8B', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA5', '\x1C90', '\x3', '\x2', '\x2', '\x2', '\x1CA5', 
		'\x1C97', '\x3', '\x2', '\x2', '\x2', '\x1CA6', '\x3B3', '\x3', '\x2', 
		'\x2', '\x2', '\x1CA7', '\x1CAA', '\x5', '\x3B6', '\x1DC', '\x2', '\x1CA8', 
		'\x1CAB', '\x5', '\x39A', '\x1CE', '\x2', '\x1CA9', '\x1CAB', '\x5', '\x39C', 
		'\x1CF', '\x2', '\x1CAA', '\x1CA8', '\x3', '\x2', '\x2', '\x2', '\x1CAA', 
		'\x1CA9', '\x3', '\x2', '\x2', '\x2', '\x1CAA', '\x1CAB', '\x3', '\x2', 
		'\x2', '\x2', '\x1CAB', '\x3B5', '\x3', '\x2', '\x2', '\x2', '\x1CAC', 
		'\x1CAD', '\a', '\x2DF', '\x2', '\x2', '\x1CAD', '\x1CAF', '\a', '\x2F2', 
		'\x2', '\x2', '\x1CAE', '\x1CB0', '\t', 'g', '\x2', '\x2', '\x1CAF', '\x1CAE', 
		'\x3', '\x2', '\x2', '\x2', '\x1CAF', '\x1CB0', '\x3', '\x2', '\x2', '\x2', 
		'\x1CB0', '\x1CB1', '\x3', '\x2', '\x2', '\x2', '\x1CB1', '\x1CB2', '\x5', 
		'\x37E', '\x1C0', '\x2', '\x1CB2', '\x1CB3', '\a', '\x2F3', '\x2', '\x2', 
		'\x1CB3', '\x1CE7', '\x3', '\x2', '\x2', '\x2', '\x1CB4', '\x1CB5', '\a', 
		'q', '\x2', '\x2', '\x1CB5', '\x1CBD', '\a', '\x2F2', '\x2', '\x2', '\x1CB6', 
		'\x1CBE', '\a', '\x2F5', '\x2', '\x2', '\x1CB7', '\x1CB9', '\t', 'P', 
		'\x2', '\x2', '\x1CB8', '\x1CB7', '\x3', '\x2', '\x2', '\x2', '\x1CB8', 
		'\x1CB9', '\x3', '\x2', '\x2', '\x2', '\x1CB9', '\x1CBA', '\x3', '\x2', 
		'\x2', '\x2', '\x1CBA', '\x1CBC', '\x5', '\x38C', '\x1C7', '\x2', '\x1CBB', 
		'\x1CB8', '\x3', '\x2', '\x2', '\x2', '\x1CBB', '\x1CBC', '\x3', '\x2', 
		'\x2', '\x2', '\x1CBC', '\x1CBE', '\x3', '\x2', '\x2', '\x2', '\x1CBD', 
		'\x1CB6', '\x3', '\x2', '\x2', '\x2', '\x1CBD', '\x1CBB', '\x3', '\x2', 
		'\x2', '\x2', '\x1CBE', '\x1CBF', '\x3', '\x2', '\x2', '\x2', '\x1CBF', 
		'\x1CC1', '\a', '\x2F3', '\x2', '\x2', '\x1CC0', '\x1CC2', '\x5', '\x3C2', 
		'\x1E2', '\x2', '\x1CC1', '\x1CC0', '\x3', '\x2', '\x2', '\x2', '\x1CC1', 
		'\x1CC2', '\x3', '\x2', '\x2', '\x2', '\x1CC2', '\x1CE7', '\x3', '\x2', 
		'\x2', '\x2', '\x1CC3', '\x1CC4', '\a', '\x2DA', '\x2', '\x2', '\x1CC4', 
		'\x1CC5', '\a', '\x2F2', '\x2', '\x2', '\x1CC5', '\x1CC8', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1CC6', '\x1CC7', '\a', '\x2F8', '\x2', '\x2', '\x1CC7', 
		'\x1CC9', '\a', '\x2EC', '\x2', '\x2', '\x1CC8', '\x1CC6', '\x3', '\x2', 
		'\x2', '\x2', '\x1CC8', '\x1CC9', '\x3', '\x2', '\x2', '\x2', '\x1CC9', 
		'\x1CCA', '\x3', '\x2', '\x2', '\x2', '\x1CCA', '\x1CCB', '\a', '\x2F3', 
		'\x2', '\x2', '\x1CCB', '\x1CE7', '\x3', '\x2', '\x2', '\x2', '\x1CCC', 
		'\x1CCD', '\a', '\x2CD', '\x2', '\x2', '\x1CCD', '\x1CCF', '\a', '\x2F2', 
		'\x2', '\x2', '\x1CCE', '\x1CD0', '\t', 'g', '\x2', '\x2', '\x1CCF', '\x1CCE', 
		'\x3', '\x2', '\x2', '\x2', '\x1CCF', '\x1CD0', '\x3', '\x2', '\x2', '\x2', 
		'\x1CD0', '\x1CD1', '\x3', '\x2', '\x2', '\x2', '\x1CD1', '\x1CD2', '\x5', 
		'\x37E', '\x1C0', '\x2', '\x1CD2', '\x1CD3', '\a', '\x2F3', '\x2', '\x2', 
		'\x1CD3', '\x1CE7', '\x3', '\x2', '\x2', '\x2', '\x1CD4', '\x1CD5', '\a', 
		'\x2D3', '\x2', '\x2', '\x1CD5', '\x1CD7', '\a', '\x2F2', '\x2', '\x2', 
		'\x1CD6', '\x1CD8', '\t', 'g', '\x2', '\x2', '\x1CD7', '\x1CD6', '\x3', 
		'\x2', '\x2', '\x2', '\x1CD7', '\x1CD8', '\x3', '\x2', '\x2', '\x2', '\x1CD8', 
		'\x1CD9', '\x3', '\x2', '\x2', '\x2', '\x1CD9', '\x1CDA', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1CDA', '\x1CDB', '\a', '\x2F3', '\x2', '\x2', '\x1CDB', 
		'\x1CE7', '\x3', '\x2', '\x2', '\x2', '\x1CDC', '\x1CDD', '\a', '\x2E3', 
		'\x2', '\x2', '\x1CDD', '\x1CDE', '\a', '\x2F2', '\x2', '\x2', '\x1CDE', 
		'\x1CDF', '\x5', '\x37C', '\x1BF', '\x2', '\x1CDF', '\x1CE0', '\a', '\x2F3', 
		'\x2', '\x2', '\x1CE0', '\x1CE7', '\x3', '\x2', '\x2', '\x2', '\x1CE1', 
		'\x1CE2', '\a', '\x2E4', '\x2', '\x2', '\x1CE2', '\x1CE3', '\a', '\x2F2', 
		'\x2', '\x2', '\x1CE3', '\x1CE4', '\x5', '\x37C', '\x1BF', '\x2', '\x1CE4', 
		'\x1CE5', '\a', '\x2F3', '\x2', '\x2', '\x1CE5', '\x1CE7', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE6', '\x1CAC', '\x3', '\x2', '\x2', '\x2', '\x1CE6', 
		'\x1CB4', '\x3', '\x2', '\x2', '\x2', '\x1CE6', '\x1CC3', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE6', '\x1CCC', '\x3', '\x2', '\x2', '\x2', '\x1CE6', 
		'\x1CD4', '\x3', '\x2', '\x2', '\x2', '\x1CE6', '\x1CDC', '\x3', '\x2', 
		'\x2', '\x2', '\x1CE6', '\x1CE1', '\x3', '\x2', '\x2', '\x2', '\x1CE7', 
		'\x3B7', '\x3', '\x2', '\x2', '\x2', '\x1CE8', '\x1CE9', '\a', '\x2E5', 
		'\x2', '\x2', '\x1CE9', '\x1CEA', '\a', '\x2F2', '\x2', '\x2', '\x1CEA', 
		'\x1CED', '\x5', '\x37E', '\x1C0', '\x2', '\x1CEB', '\x1CEC', '\a', '\x2F8', 
		'\x2', '\x2', '\x1CEC', '\x1CEE', '\x5', '\x4AA', '\x256', '\x2', '\x1CED', 
		'\x1CEB', '\x3', '\x2', '\x2', '\x2', '\x1CED', '\x1CEE', '\x3', '\x2', 
		'\x2', '\x2', '\x1CEE', '\x1CEF', '\x3', '\x2', '\x2', '\x2', '\x1CEF', 
		'\x1CF0', '\a', '\x2F3', '\x2', '\x2', '\x1CF0', '\x3B9', '\x3', '\x2', 
		'\x2', '\x2', '\x1CF1', '\x1CF2', '\x5', '\x3BC', '\x1DF', '\x2', '\x1CF2', 
		'\x1CF4', '\x5', '\x44E', '\x228', '\x2', '\x1CF3', '\x1CF5', '\x5', '\x3C2', 
		'\x1E2', '\x2', '\x1CF4', '\x1CF3', '\x3', '\x2', '\x2', '\x2', '\x1CF4', 
		'\x1CF5', '\x3', '\x2', '\x2', '\x2', '\x1CF5', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1CF6', '\x1CF7', '\x5', '\x49E', '\x250', '\x2', '\x1CF7', 
		'\x1CF9', '\x5', '\x450', '\x229', '\x2', '\x1CF8', '\x1CFA', '\x5', '\x3CA', 
		'\x1E6', '\x2', '\x1CF9', '\x1CF8', '\x3', '\x2', '\x2', '\x2', '\x1CF9', 
		'\x1CFA', '\x3', '\x2', '\x2', '\x2', '\x1CFA', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1CFB', '\x1CFC', '\a', '\x2D7', '\x2', '\x2', '\x1CFC', 
		'\x1CFD', '\a', '\x2F2', '\x2', '\x2', '\x1CFD', '\x1CFE', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1CFE', '\x1CFF', '\a', '\x2F8', '\x2', '\x2', '\x1CFF', 
		'\x1D00', '\x5', '\x37E', '\x1C0', '\x2', '\x1D00', '\x1D01', '\a', '\x2F3', 
		'\x2', '\x2', '\x1D01', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D02', 
		'\x1E3C', '\x5', '\x3B8', '\x1DD', '\x2', '\x1D03', '\x1D04', '\a', 'q', 
		'\x2', '\x2', '\x1D04', '\x1D0A', '\a', '\x2F2', '\x2', '\x2', '\x1D05', 
		'\x1D0B', '\a', '\x2F5', '\x2', '\x2', '\x1D06', '\x1D08', '\t', 'P', 
		'\x2', '\x2', '\x1D07', '\x1D06', '\x3', '\x2', '\x2', '\x2', '\x1D07', 
		'\x1D08', '\x3', '\x2', '\x2', '\x2', '\x1D08', '\x1D09', '\x3', '\x2', 
		'\x2', '\x2', '\x1D09', '\x1D0B', '\x5', '\x38C', '\x1C7', '\x2', '\x1D0A', 
		'\x1D05', '\x3', '\x2', '\x2', '\x2', '\x1D0A', '\x1D07', '\x3', '\x2', 
		'\x2', '\x2', '\x1D0B', '\x1D0C', '\x3', '\x2', '\x2', '\x2', '\x1D0C', 
		'\x1D0E', '\a', '\x2F3', '\x2', '\x2', '\x1D0D', '\x1D0F', '\x5', '\x3C2', 
		'\x1E2', '\x2', '\x1D0E', '\x1D0D', '\x3', '\x2', '\x2', '\x2', '\x1D0E', 
		'\x1D0F', '\x3', '\x2', '\x2', '\x2', '\x1D0F', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D10', '\x1D11', '\t', 'h', '\x2', '\x2', '\x1D11', '\x1D18', 
		'\a', '\x2F2', '\x2', '\x2', '\x1D12', '\x1D13', '\a', '\x166', '\x2', 
		'\x2', '\x1D13', '\x1D14', '\a', '\x2F2', '\x2', '\x2', '\x1D14', '\x1D15', 
		'\x5', '\x16E', '\xB8', '\x2', '\x1D15', '\x1D16', '\a', '\x2F3', '\x2', 
		'\x2', '\x1D16', '\x1D19', '\x3', '\x2', '\x2', '\x2', '\x1D17', '\x1D19', 
		'\x5', '\x38C', '\x1C7', '\x2', '\x1D18', '\x1D12', '\x3', '\x2', '\x2', 
		'\x2', '\x1D18', '\x1D17', '\x3', '\x2', '\x2', '\x2', '\x1D19', '\x1D1A', 
		'\x3', '\x2', '\x2', '\x2', '\x1D1A', '\x1D1B', '\a', '\x19', '\x2', '\x2', 
		'\x1D1B', '\x1D1C', '\x5', '\x454', '\x22B', '\x2', '\x1D1C', '\x1D1D', 
		'\a', '\x2F3', '\x2', '\x2', '\x1D1D', '\x1E3C', '\x3', '\x2', '\x2', 
		'\x2', '\x1D1E', '\x1D1F', '\a', 'V', '\x2', '\x2', '\x1D1F', '\x1D20', 
		'\a', '\x2F2', '\x2', '\x2', '\x1D20', '\x1D25', '\x5', '\x382', '\x1C2', 
		'\x2', '\x1D21', '\x1D22', '\a', '\x2F8', '\x2', '\x2', '\x1D22', '\x1D24', 
		'\x5', '\x382', '\x1C2', '\x2', '\x1D23', '\x1D21', '\x3', '\x2', '\x2', 
		'\x2', '\x1D24', '\x1D27', '\x3', '\x2', '\x2', '\x2', '\x1D25', '\x1D23', 
		'\x3', '\x2', '\x2', '\x2', '\x1D25', '\x1D26', '\x3', '\x2', '\x2', '\x2', 
		'\x1D26', '\x1D28', '\x3', '\x2', '\x2', '\x2', '\x1D27', '\x1D25', '\x3', 
		'\x2', '\x2', '\x2', '\x1D28', '\x1D29', '\a', '\x2F3', '\x2', '\x2', 
		'\x1D29', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D2A', '\x1D2B', '\a', 
		'W', '\x2', '\x2', '\x1D2B', '\x1D2D', '\a', '\x2F2', '\x2', '\x2', '\x1D2C', 
		'\x1D2E', '\t', 'i', '\x2', '\x2', '\x1D2D', '\x1D2C', '\x3', '\x2', '\x2', 
		'\x2', '\x1D2D', '\x1D2E', '\x3', '\x2', '\x2', '\x2', '\x1D2E', '\x1D2F', 
		'\x3', '\x2', '\x2', '\x2', '\x1D2F', '\x1D31', '\x5', '\x38C', '\x1C7', 
		'\x2', '\x1D30', '\x1D32', '\x5', '\x3CE', '\x1E8', '\x2', '\x1D31', '\x1D30', 
		'\x3', '\x2', '\x2', '\x2', '\x1D31', '\x1D32', '\x3', '\x2', '\x2', '\x2', 
		'\x1D32', '\x1D33', '\x3', '\x2', '\x2', '\x2', '\x1D33', '\x1D34', '\a', 
		'\x2F3', '\x2', '\x2', '\x1D34', '\x1E3C', '\x3', '\x2', '\x2', '\x2', 
		'\x1D35', '\x1D36', '\x5', '\x3BE', '\x1E0', '\x2', '\x1D36', '\x1D38', 
		'\x5', '\x3F0', '\x1F9', '\x2', '\x1D37', '\x1D39', '\x5', '\x44C', '\x227', 
		'\x2', '\x1D38', '\x1D37', '\x3', '\x2', '\x2', '\x2', '\x1D38', '\x1D39', 
		'\x3', '\x2', '\x2', '\x2', '\x1D39', '\x1D3B', '\x3', '\x2', '\x2', '\x2', 
		'\x1D3A', '\x1D3C', '\x5', '\x3D0', '\x1E9', '\x2', '\x1D3B', '\x1D3A', 
		'\x3', '\x2', '\x2', '\x2', '\x1D3C', '\x1D3D', '\x3', '\x2', '\x2', '\x2', 
		'\x1D3D', '\x1D3B', '\x3', '\x2', '\x2', '\x2', '\x1D3D', '\x1D3E', '\x3', 
		'\x2', '\x2', '\x2', '\x1D3E', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D3F', 
		'\x1D40', '\x5', '\x410', '\x209', '\x2', '\x1D40', '\x1D41', '\t', 'j', 
		'\x2', '\x2', '\x1D41', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D42', 
		'\x1D43', '\a', '\x8B', '\x2', '\x2', '\x1D43', '\x1D44', '\a', '\x2F2', 
		'\x2', '\x2', '\x1D44', '\x1D46', '\x5', '\x38C', '\x1C7', '\x2', '\x1D45', 
		'\x1D47', '\t', 'k', '\x2', '\x2', '\x1D46', '\x1D45', '\x3', '\x2', '\x2', 
		'\x2', '\x1D46', '\x1D47', '\x3', '\x2', '\x2', '\x2', '\x1D47', '\x1D48', 
		'\x3', '\x2', '\x2', '\x2', '\x1D48', '\x1D49', '\a', '\x2F3', '\x2', 
		'\x2', '\x1D49', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D4A', '\x1D4B', 
		'\a', '\xCC', '\x2', '\x2', '\x1D4B', '\x1D4C', '\a', '\x2F2', '\x2', 
		'\x2', '\x1D4C', '\x1D4D', '\x5', '\x49E', '\x250', '\x2', '\x1D4D', '\x1D4E', 
		'\a', '\xE1', '\x2', '\x2', '\x1D4E', '\x1D4F', '\x5', '\x38C', '\x1C7', 
		'\x2', '\x1D4F', '\x1D50', '\a', '\x2F3', '\x2', '\x2', '\x1D50', '\x1E3C', 
		'\x3', '\x2', '\x2', '\x2', '\x1D51', '\x1D52', '\t', 'l', '\x2', '\x2', 
		'\x1D52', '\x1D54', '\x5', '\x44E', '\x228', '\x2', '\x1D53', '\x1D55', 
		'\x5', '\x452', '\x22A', '\x2', '\x1D54', '\x1D53', '\x3', '\x2', '\x2', 
		'\x2', '\x1D54', '\x1D55', '\x3', '\x2', '\x2', '\x2', '\x1D55', '\x1D56', 
		'\x3', '\x2', '\x2', '\x2', '\x1D56', '\x1D57', '\x5', '\x3C2', '\x1E2', 
		'\x2', '\x1D57', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D58', '\x1D59', 
		'\x5', '\x3C0', '\x1E1', '\x2', '\x1D59', '\x1D5A', '\a', '\x2F2', '\x2', 
		'\x2', '\x1D5A', '\x1D5C', '\x5', '\x37C', '\x1BF', '\x2', '\x1D5B', '\x1D5D', 
		'\x5', '\x3D2', '\x1EA', '\x2', '\x1D5C', '\x1D5B', '\x3', '\x2', '\x2', 
		'\x2', '\x1D5C', '\x1D5D', '\x3', '\x2', '\x2', '\x2', '\x1D5D', '\x1D5F', 
		'\x3', '\x2', '\x2', '\x2', '\x1D5E', '\x1D60', '\x5', '\x3CA', '\x1E6', 
		'\x2', '\x1D5F', '\x1D5E', '\x3', '\x2', '\x2', '\x2', '\x1D5F', '\x1D60', 
		'\x3', '\x2', '\x2', '\x2', '\x1D60', '\x1D61', '\x3', '\x2', '\x2', '\x2', 
		'\x1D61', '\x1D62', '\a', '\x2F3', '\x2', '\x2', '\x1D62', '\x1E3C', '\x3', 
		'\x2', '\x2', '\x2', '\x1D63', '\x1D64', '\a', '\x272', '\x2', '\x2', 
		'\x1D64', '\x1D65', '\a', '\x2F2', '\x2', '\x2', '\x1D65', '\x1D68', '\x5', 
		'\x37E', '\x1C0', '\x2', '\x1D66', '\x1D67', '\a', '\x28E', '\x2', '\x2', 
		'\x1D67', '\x1D69', '\t', 'm', '\x2', '\x2', '\x1D68', '\x1D66', '\x3', 
		'\x2', '\x2', '\x2', '\x1D68', '\x1D69', '\x3', '\x2', '\x2', '\x2', '\x1D69', 
		'\x1D6E', '\x3', '\x2', '\x2', '\x2', '\x1D6A', '\x1D6B', '\a', '\x2F8', 
		'\x2', '\x2', '\x1D6B', '\x1D6D', '\x5', '\x37E', '\x1C0', '\x2', '\x1D6C', 
		'\x1D6A', '\x3', '\x2', '\x2', '\x2', '\x1D6D', '\x1D70', '\x3', '\x2', 
		'\x2', '\x2', '\x1D6E', '\x1D6C', '\x3', '\x2', '\x2', '\x2', '\x1D6E', 
		'\x1D6F', '\x3', '\x2', '\x2', '\x2', '\x1D6F', '\x1D71', '\x3', '\x2', 
		'\x2', '\x2', '\x1D70', '\x1D6E', '\x3', '\x2', '\x2', '\x2', '\x1D71', 
		'\x1D72', '\a', '\x2F3', '\x2', '\x2', '\x1D72', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D73', '\x1D74', '\a', '\x272', '\x2', '\x2', '\x1D74', 
		'\x1D75', '\a', '\x2F2', '\x2', '\x2', '\x1D75', '\x1D76', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1D76', '\x1D77', '\a', '\x2F8', '\x2', '\x2', '\x1D77', 
		'\x1D78', '\x5', '\x4AA', '\x256', '\x2', '\x1D78', '\x1D79', '\a', '\x2F8', 
		'\x2', '\x2', '\x1D79', '\x1D7A', '\x5', '\x4AA', '\x256', '\x2', '\x1D7A', 
		'\x1D7B', '\a', '\x2F3', '\x2', '\x2', '\x1D7B', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D7C', '\x1D7D', '\a', '\x274', '\x2', '\x2', '\x1D7D', 
		'\x1D7E', '\a', '\x2F2', '\x2', '\x2', '\x1D7E', '\x1D7F', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1D7F', '\x1D81', '\a', '\x19', '\x2', '\x2', '\x1D80', 
		'\x1D82', '\a', '\x1E9', '\x2', '\x2', '\x1D81', '\x1D80', '\x3', '\x2', 
		'\x2', '\x2', '\x1D81', '\x1D82', '\x3', '\x2', '\x2', '\x2', '\x1D82', 
		'\x1D83', '\x3', '\x2', '\x2', '\x2', '\x1D83', '\x1D84', '\x5', '\x454', 
		'\x22B', '\x2', '\x1D84', '\x1D85', '\a', '\x2F3', '\x2', '\x2', '\x1D85', 
		'\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1D86', '\x1D87', '\a', '\x2A9', 
		'\x2', '\x2', '\x1D87', '\x1D88', '\a', '\x2F2', '\x2', '\x2', '\x1D88', 
		'\x1D8A', '\x5', '\x37E', '\x1C0', '\x2', '\x1D89', '\x1D8B', '\x5', '\x32E', 
		'\x198', '\x2', '\x1D8A', '\x1D89', '\x3', '\x2', '\x2', '\x2', '\x1D8A', 
		'\x1D8B', '\x3', '\x2', '\x2', '\x2', '\x1D8B', '\x1D8C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D8C', '\x1D8F', '\a', '\x2F3', '\x2', '\x2', '\x1D8D', 
		'\x1D8E', '\a', '\x2EB', '\x2', '\x2', '\x1D8E', '\x1D90', '\x5', '\x460', 
		'\x231', '\x2', '\x1D8F', '\x1D8D', '\x3', '\x2', '\x2', '\x2', '\x1D8F', 
		'\x1D90', '\x3', '\x2', '\x2', '\x2', '\x1D90', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1D91', '\x1D92', '\t', 'n', '\x2', '\x2', '\x1D92', '\x1D97', 
		'\a', '\x2F2', '\x2', '\x2', '\x1D93', '\x1D95', '\a', '\x2F8', '\x2', 
		'\x2', '\x1D94', '\x1D93', '\x3', '\x2', '\x2', '\x2', '\x1D94', '\x1D95', 
		'\x3', '\x2', '\x2', '\x2', '\x1D95', '\x1D96', '\x3', '\x2', '\x2', '\x2', 
		'\x1D96', '\x1D98', '\x5', '\x3DE', '\x1F0', '\x2', '\x1D97', '\x1D94', 
		'\x3', '\x2', '\x2', '\x2', '\x1D98', '\x1D99', '\x3', '\x2', '\x2', '\x2', 
		'\x1D99', '\x1D97', '\x3', '\x2', '\x2', '\x2', '\x1D99', '\x1D9A', '\x3', 
		'\x2', '\x2', '\x2', '\x1D9A', '\x1D9B', '\x3', '\x2', '\x2', '\x2', '\x1D9B', 
		'\x1D9E', '\a', '\x2F3', '\x2', '\x2', '\x1D9C', '\x1D9D', '\a', '\x2EB', 
		'\x2', '\x2', '\x1D9D', '\x1D9F', '\x5', '\x460', '\x231', '\x2', '\x1D9E', 
		'\x1D9C', '\x3', '\x2', '\x2', '\x2', '\x1D9E', '\x1D9F', '\x3', '\x2', 
		'\x2', '\x2', '\x1D9F', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1DA0', 
		'\x1DA1', '\a', '\x2AD', '\x2', '\x2', '\x1DA1', '\x1DA3', '\a', '\x2F2', 
		'\x2', '\x2', '\x1DA2', '\x1DA4', '\t', 'o', '\x2', '\x2', '\x1DA3', '\x1DA2', 
		'\x3', '\x2', '\x2', '\x2', '\x1DA3', '\x1DA4', '\x3', '\x2', '\x2', '\x2', 
		'\x1DA4', '\x1DA6', '\x3', '\x2', '\x2', '\x2', '\x1DA5', '\x1DA7', '\t', 
		'p', '\x2', '\x2', '\x1DA6', '\x1DA5', '\x3', '\x2', '\x2', '\x2', '\x1DA6', 
		'\x1DA7', '\x3', '\x2', '\x2', '\x2', '\x1DA7', '\x1DA8', '\x3', '\x2', 
		'\x2', '\x2', '\x1DA8', '\x1DAB', '\x5', '\x37E', '\x1C0', '\x2', '\x1DA9', 
		'\x1DAA', '\a', '\x2F8', '\x2', '\x2', '\x1DAA', '\x1DAC', '\x5', '\x3D6', 
		'\x1EC', '\x2', '\x1DAB', '\x1DA9', '\x3', '\x2', '\x2', '\x2', '\x1DAB', 
		'\x1DAC', '\x3', '\x2', '\x2', '\x2', '\x1DAC', '\x1DB4', '\x3', '\x2', 
		'\x2', '\x2', '\x1DAD', '\x1DAE', '\a', '\x2F8', '\x2', '\x2', '\x1DAE', 
		'\x1DB0', '\x5', '\x37E', '\x1C0', '\x2', '\x1DAF', '\x1DB1', '\x5', '\x3FA', 
		'\x1FE', '\x2', '\x1DB0', '\x1DAF', '\x3', '\x2', '\x2', '\x2', '\x1DB0', 
		'\x1DB1', '\x3', '\x2', '\x2', '\x2', '\x1DB1', '\x1DB3', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB2', '\x1DAD', '\x3', '\x2', '\x2', '\x2', '\x1DB3', 
		'\x1DB6', '\x3', '\x2', '\x2', '\x2', '\x1DB4', '\x1DB2', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB4', '\x1DB5', '\x3', '\x2', '\x2', '\x2', '\x1DB5', 
		'\x1DB7', '\x3', '\x2', '\x2', '\x2', '\x1DB6', '\x1DB4', '\x3', '\x2', 
		'\x2', '\x2', '\x1DB7', '\x1DBA', '\a', '\x2F3', '\x2', '\x2', '\x1DB8', 
		'\x1DB9', '\a', '\x2EB', '\x2', '\x2', '\x1DB9', '\x1DBB', '\x5', '\x460', 
		'\x231', '\x2', '\x1DBA', '\x1DB8', '\x3', '\x2', '\x2', '\x2', '\x1DBA', 
		'\x1DBB', '\x3', '\x2', '\x2', '\x2', '\x1DBB', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1DBC', '\x1DBD', '\a', '\x2AE', '\x2', '\x2', '\x1DBD', 
		'\x1DBE', '\a', '\x2F2', '\x2', '\x2', '\x1DBE', '\x1DC0', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1DBF', '\x1DC1', '\x5', '\x3D4', '\x1EB', '\x2', '\x1DC0', 
		'\x1DBF', '\x3', '\x2', '\x2', '\x2', '\x1DC0', '\x1DC1', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC1', '\x1DC2', '\x3', '\x2', '\x2', '\x2', '\x1DC2', 
		'\x1DC3', '\a', '\x2F3', '\x2', '\x2', '\x1DC3', '\x1E3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC4', '\x1DC5', '\a', '\x2B1', '\x2', '\x2', '\x1DC5', 
		'\x1DC6', '\a', '\x2F2', '\x2', '\x2', '\x1DC6', '\x1DC7', '\t', 'q', 
		'\x2', '\x2', '\x1DC7', '\x1DC9', '\x5', '\x38C', '\x1C7', '\x2', '\x1DC8', 
		'\x1DCA', '\a', '\x29F', '\x2', '\x2', '\x1DC9', '\x1DC8', '\x3', '\x2', 
		'\x2', '\x2', '\x1DC9', '\x1DCA', '\x3', '\x2', '\x2', '\x2', '\x1DCA', 
		'\x1DCB', '\x3', '\x2', '\x2', '\x2', '\x1DCB', '\x1DCE', '\a', '\x2F3', 
		'\x2', '\x2', '\x1DCC', '\x1DCD', '\a', '\x2EB', '\x2', '\x2', '\x1DCD', 
		'\x1DCF', '\x5', '\x460', '\x231', '\x2', '\x1DCE', '\x1DCC', '\x3', '\x2', 
		'\x2', '\x2', '\x1DCE', '\x1DCF', '\x3', '\x2', '\x2', '\x2', '\x1DCF', 
		'\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1DD0', '\x1DD1', '\a', '\x2B2', 
		'\x2', '\x2', '\x1DD1', '\x1DD6', '\a', '\x2F2', '\x2', '\x2', '\x1DD2', 
		'\x1DD3', '\a', '\x167', '\x2', '\x2', '\x1DD3', '\x1DD7', '\x5', '\x46E', 
		'\x238', '\x2', '\x1DD4', '\x1DD5', '\a', '\xBB', '\x2', '\x2', '\x1DD5', 
		'\x1DD7', '\x5', '\x38C', '\x1C7', '\x2', '\x1DD6', '\x1DD2', '\x3', '\x2', 
		'\x2', '\x2', '\x1DD6', '\x1DD4', '\x3', '\x2', '\x2', '\x2', '\x1DD7', 
		'\x1DDA', '\x3', '\x2', '\x2', '\x2', '\x1DD8', '\x1DD9', '\a', '\x2F8', 
		'\x2', '\x2', '\x1DD9', '\x1DDB', '\x5', '\x38C', '\x1C7', '\x2', '\x1DDA', 
		'\x1DD8', '\x3', '\x2', '\x2', '\x2', '\x1DDA', '\x1DDB', '\x3', '\x2', 
		'\x2', '\x2', '\x1DDB', '\x1DDC', '\x3', '\x2', '\x2', '\x2', '\x1DDC', 
		'\x1DDF', '\a', '\x2F3', '\x2', '\x2', '\x1DDD', '\x1DDE', '\a', '\x2EB', 
		'\x2', '\x2', '\x1DDE', '\x1DE0', '\x5', '\x460', '\x231', '\x2', '\x1DDF', 
		'\x1DDD', '\x3', '\x2', '\x2', '\x2', '\x1DDF', '\x1DE0', '\x3', '\x2', 
		'\x2', '\x2', '\x1DE0', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1DE1', 
		'\x1DE2', '\a', '\x2B3', '\x2', '\x2', '\x1DE2', '\x1DE3', '\a', '\x2F2', 
		'\x2', '\x2', '\x1DE3', '\x1DE5', '\x5', '\x38C', '\x1C7', '\x2', '\x1DE4', 
		'\x1DE6', '\x5', '\x3D4', '\x1EB', '\x2', '\x1DE5', '\x1DE4', '\x3', '\x2', 
		'\x2', '\x2', '\x1DE5', '\x1DE6', '\x3', '\x2', '\x2', '\x2', '\x1DE6', 
		'\x1DE7', '\x3', '\x2', '\x2', '\x2', '\x1DE7', '\x1DE8', '\a', '\x1FB', 
		'\x2', '\x2', '\x1DE8', '\x1DEC', '\a', 'j', '\x2', '\x2', '\x1DE9', '\x1DEA', 
		'\a', '\x18D', '\x2', '\x2', '\x1DEA', '\x1DEB', '\a', '\x19B', '\x2', 
		'\x2', '\x1DEB', '\x1DED', '\a', '\xB0', '\x2', '\x2', '\x1DEC', '\x1DE9', 
		'\x3', '\x2', '\x2', '\x2', '\x1DEC', '\x1DED', '\x3', '\x2', '\x2', '\x2', 
		'\x1DED', '\x1DEE', '\x3', '\x2', '\x2', '\x2', '\x1DEE', '\x1DF1', '\a', 
		'\x2F3', '\x2', '\x2', '\x1DEF', '\x1DF0', '\a', '\x2EB', '\x2', '\x2', 
		'\x1DF0', '\x1DF2', '\x5', '\x460', '\x231', '\x2', '\x1DF1', '\x1DEF', 
		'\x3', '\x2', '\x2', '\x2', '\x1DF1', '\x1DF2', '\x3', '\x2', '\x2', '\x2', 
		'\x1DF2', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1DF3', '\x1DF4', '\a', 
		'\x2B4', '\x2', '\x2', '\x1DF4', '\x1DF5', '\a', '\x2F2', '\x2', '\x2', 
		'\x1DF5', '\x1DF8', '\x5', '\x38C', '\x1C7', '\x2', '\x1DF6', '\x1DF7', 
		'\a', '\x2F8', '\x2', '\x2', '\x1DF7', '\x1DF9', '\x5', '\x3E0', '\x1F1', 
		'\x2', '\x1DF8', '\x1DF6', '\x3', '\x2', '\x2', '\x2', '\x1DF8', '\x1DF9', 
		'\x3', '\x2', '\x2', '\x2', '\x1DF9', '\x1DFC', '\x3', '\x2', '\x2', '\x2', 
		'\x1DFA', '\x1DFB', '\a', '\x2F8', '\x2', '\x2', '\x1DFB', '\x1DFD', '\x5', 
		'\x3E2', '\x1F2', '\x2', '\x1DFC', '\x1DFA', '\x3', '\x2', '\x2', '\x2', 
		'\x1DFC', '\x1DFD', '\x3', '\x2', '\x2', '\x2', '\x1DFD', '\x1DFE', '\x3', 
		'\x2', '\x2', '\x2', '\x1DFE', '\x1E01', '\a', '\x2F3', '\x2', '\x2', 
		'\x1DFF', '\x1E00', '\a', '\x2EB', '\x2', '\x2', '\x1E00', '\x1E02', '\x5', 
		'\x460', '\x231', '\x2', '\x1E01', '\x1DFF', '\x3', '\x2', '\x2', '\x2', 
		'\x1E01', '\x1E02', '\x3', '\x2', '\x2', '\x2', '\x1E02', '\x1E3C', '\x3', 
		'\x2', '\x2', '\x2', '\x1E03', '\x1E04', '\a', '\x2B6', '\x2', '\x2', 
		'\x1E04', '\x1E05', '\a', '\x2F2', '\x2', '\x2', '\x1E05', '\x1E06', '\t', 
		'q', '\x2', '\x2', '\x1E06', '\x1E09', '\x5', '\x38C', '\x1C7', '\x2', 
		'\x1E07', '\x1E08', '\a', '\x19', '\x2', '\x2', '\x1E08', '\x1E0A', '\x5', 
		'\x454', '\x22B', '\x2', '\x1E09', '\x1E07', '\x3', '\x2', '\x2', '\x2', 
		'\x1E09', '\x1E0A', '\x3', '\x2', '\x2', '\x2', '\x1E0A', '\x1E0C', '\x3', 
		'\x2', '\x2', '\x2', '\x1E0B', '\x1E0D', '\x5', '\x3E4', '\x1F3', '\x2', 
		'\x1E0C', '\x1E0B', '\x3', '\x2', '\x2', '\x2', '\x1E0C', '\x1E0D', '\x3', 
		'\x2', '\x2', '\x2', '\x1E0D', '\x1E0F', '\x3', '\x2', '\x2', '\x2', '\x1E0E', 
		'\x1E10', '\x5', '\x3E6', '\x1F4', '\x2', '\x1E0F', '\x1E0E', '\x3', '\x2', 
		'\x2', '\x2', '\x1E0F', '\x1E10', '\x3', '\x2', '\x2', '\x2', '\x1E10', 
		'\x1E12', '\x3', '\x2', '\x2', '\x2', '\x1E11', '\x1E13', '\x5', '\x3E8', 
		'\x1F5', '\x2', '\x1E12', '\x1E11', '\x3', '\x2', '\x2', '\x2', '\x1E12', 
		'\x1E13', '\x3', '\x2', '\x2', '\x2', '\x1E13', '\x1E16', '\x3', '\x2', 
		'\x2', '\x2', '\x1E14', '\x1E15', '\t', 'r', '\x2', '\x2', '\x1E15', '\x1E17', 
		'\a', '\x90', '\x2', '\x2', '\x1E16', '\x1E14', '\x3', '\x2', '\x2', '\x2', 
		'\x1E16', '\x1E17', '\x3', '\x2', '\x2', '\x2', '\x1E17', '\x1E18', '\x3', 
		'\x2', '\x2', '\x2', '\x1E18', '\x1E1B', '\a', '\x2F3', '\x2', '\x2', 
		'\x1E19', '\x1E1A', '\a', '\x2EB', '\x2', '\x2', '\x1E1A', '\x1E1C', '\x5', 
		'\x460', '\x231', '\x2', '\x1E1B', '\x1E19', '\x3', '\x2', '\x2', '\x2', 
		'\x1E1B', '\x1E1C', '\x3', '\x2', '\x2', '\x2', '\x1E1C', '\x1E3C', '\x3', 
		'\x2', '\x2', '\x2', '\x1E1D', '\x1E1E', '\a', '\x2B7', '\x2', '\x2', 
		'\x1E1E', '\x1E20', '\a', '\x2F2', '\x2', '\x2', '\x1E1F', '\x1E21', '\x5', 
		'\x3D8', '\x1ED', '\x2', '\x1E20', '\x1E1F', '\x3', '\x2', '\x2', '\x2', 
		'\x1E20', '\x1E21', '\x3', '\x2', '\x2', '\x2', '\x1E21', '\x1E22', '\x3', 
		'\x2', '\x2', '\x2', '\x1E22', '\x1E24', '\x5', '\x38C', '\x1C7', '\x2', 
		'\x1E23', '\x1E25', '\x5', '\x3D4', '\x1EB', '\x2', '\x1E24', '\x1E23', 
		'\x3', '\x2', '\x2', '\x2', '\x1E24', '\x1E25', '\x3', '\x2', '\x2', '\x2', 
		'\x1E25', '\x1E2B', '\x3', '\x2', '\x2', '\x2', '\x1E26', '\x1E27', '\a', 
		'Y', '\x2', '\x2', '\x1E27', '\x1E28', '\x5', '\x3DA', '\x1EE', '\x2', 
		'\x1E28', '\x1E29', '\a', '\x2F8', '\x2', '\x2', '\x1E29', '\x1E2A', '\x5', 
		'\x3DA', '\x1EE', '\x2', '\x1E2A', '\x1E2C', '\x3', '\x2', '\x2', '\x2', 
		'\x1E2B', '\x1E26', '\x3', '\x2', '\x2', '\x2', '\x1E2B', '\x1E2C', '\x3', 
		'\x2', '\x2', '\x2', '\x1E2C', '\x1E2D', '\x3', '\x2', '\x2', '\x2', '\x1E2D', 
		'\x1E30', '\a', '\x2F3', '\x2', '\x2', '\x1E2E', '\x1E2F', '\a', '\x2EB', 
		'\x2', '\x2', '\x1E2F', '\x1E31', '\x5', '\x460', '\x231', '\x2', '\x1E30', 
		'\x1E2E', '\x3', '\x2', '\x2', '\x2', '\x1E30', '\x1E31', '\x3', '\x2', 
		'\x2', '\x2', '\x1E31', '\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1E32', 
		'\x1E33', '\a', '\x278', '\x2', '\x2', '\x1E33', '\x1E34', '\a', '\x2F2', 
		'\x2', '\x2', '\x1E34', '\x1E37', '\x5', '\x37E', '\x1C0', '\x2', '\x1E35', 
		'\x1E36', '\a', '\x2F8', '\x2', '\x2', '\x1E36', '\x1E38', '\x5', '\x4AA', 
		'\x256', '\x2', '\x1E37', '\x1E35', '\x3', '\x2', '\x2', '\x2', '\x1E37', 
		'\x1E38', '\x3', '\x2', '\x2', '\x2', '\x1E38', '\x1E39', '\x3', '\x2', 
		'\x2', '\x2', '\x1E39', '\x1E3A', '\a', '\x2F3', '\x2', '\x2', '\x1E3A', 
		'\x1E3C', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1CF1', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1CF6', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1CFB', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1D02', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1D03', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1D10', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1D1E', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1D2A', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1D35', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1D3F', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1D42', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1D4A', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1D51', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1D58', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1D63', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1D73', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1D7C', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1D86', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1D91', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1DA0', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1DBC', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1DC4', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1DD0', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1DE1', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1DF3', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3B', '\x1E03', '\x3', '\x2', '\x2', '\x2', '\x1E3B', 
		'\x1E1D', '\x3', '\x2', '\x2', '\x2', '\x1E3B', '\x1E32', '\x3', '\x2', 
		'\x2', '\x2', '\x1E3C', '\x3BB', '\x3', '\x2', '\x2', '\x2', '\x1E3D', 
		'\x1E3E', '\t', 's', '\x2', '\x2', '\x1E3E', '\x3BD', '\x3', '\x2', '\x2', 
		'\x2', '\x1E3F', '\x1E40', '\t', 't', '\x2', '\x2', '\x1E40', '\x3BF', 
		'\x3', '\x2', '\x2', '\x2', '\x1E41', '\x1E42', '\t', 'u', '\x2', '\x2', 
		'\x1E42', '\x3C1', '\x3', '\x2', '\x2', '\x2', '\x1E43', '\x1E44', '\a', 
		'\x1AA', '\x2', '\x2', '\x1E44', '\x1E46', '\a', '\x2F2', '\x2', '\x2', 
		'\x1E45', '\x1E47', '\x5', '\x2EA', '\x176', '\x2', '\x1E46', '\x1E45', 
		'\x3', '\x2', '\x2', '\x2', '\x1E46', '\x1E47', '\x3', '\x2', '\x2', '\x2', 
		'\x1E47', '\x1E4C', '\x3', '\x2', '\x2', '\x2', '\x1E48', '\x1E4A', '\x5', 
		'\x32E', '\x198', '\x2', '\x1E49', '\x1E4B', '\x5', '\x3C4', '\x1E3', 
		'\x2', '\x1E4A', '\x1E49', '\x3', '\x2', '\x2', '\x2', '\x1E4A', '\x1E4B', 
		'\x3', '\x2', '\x2', '\x2', '\x1E4B', '\x1E4D', '\x3', '\x2', '\x2', '\x2', 
		'\x1E4C', '\x1E48', '\x3', '\x2', '\x2', '\x2', '\x1E4C', '\x1E4D', '\x3', 
		'\x2', '\x2', '\x2', '\x1E4D', '\x1E4E', '\x3', '\x2', '\x2', '\x2', '\x1E4E', 
		'\x1E4F', '\a', '\x2F3', '\x2', '\x2', '\x1E4F', '\x3C3', '\x3', '\x2', 
		'\x2', '\x2', '\x1E50', '\x1E57', '\x5', '\x3C6', '\x1E4', '\x2', '\x1E51', 
		'\x1E52', '\a', '.', '\x2', '\x2', '\x1E52', '\x1E53', '\x5', '\x3C8', 
		'\x1E5', '\x2', '\x1E53', '\x1E54', '\a', '\x13', '\x2', '\x2', '\x1E54', 
		'\x1E55', '\x5', '\x3C8', '\x1E5', '\x2', '\x1E55', '\x1E58', '\x3', '\x2', 
		'\x2', '\x2', '\x1E56', '\x1E58', '\x5', '\x3C8', '\x1E5', '\x2', '\x1E57', 
		'\x1E51', '\x3', '\x2', '\x2', '\x2', '\x1E57', '\x1E56', '\x3', '\x2', 
		'\x2', '\x2', '\x1E58', '\x3C5', '\x3', '\x2', '\x2', '\x2', '\x1E59', 
		'\x1E5A', '\t', 'v', '\x2', '\x2', '\x1E5A', '\x3C7', '\x3', '\x2', '\x2', 
		'\x2', '\x1E5B', '\x1E5C', '\a', '\x27B', '\x2', '\x2', '\x1E5C', '\x1E63', 
		'\a', '\x1CC', '\x2', '\x2', '\x1E5D', '\x1E5E', '\a', 'w', '\x2', '\x2', 
		'\x1E5E', '\x1E63', '\a', '\x209', '\x2', '\x2', '\x1E5F', '\x1E60', '\x5', 
		'\x38C', '\x1C7', '\x2', '\x1E60', '\x1E61', '\t', 'w', '\x2', '\x2', 
		'\x1E61', '\x1E63', '\x3', '\x2', '\x2', '\x2', '\x1E62', '\x1E5B', '\x3', 
		'\x2', '\x2', '\x2', '\x1E62', '\x1E5D', '\x3', '\x2', '\x2', '\x2', '\x1E62', 
		'\x1E5F', '\x3', '\x2', '\x2', '\x2', '\x1E63', '\x3C9', '\x3', '\x2', 
		'\x2', '\x2', '\x1E64', '\x1E6E', '\a', '\x28E', '\x2', '\x2', '\x1E65', 
		'\x1E6F', '\a', '\x2F5', '\x2', '\x2', '\x1E66', '\x1E68', '\a', '\x2F8', 
		'\x2', '\x2', '\x1E67', '\x1E66', '\x3', '\x2', '\x2', '\x2', '\x1E67', 
		'\x1E68', '\x3', '\x2', '\x2', '\x2', '\x1E68', '\x1E69', '\x3', '\x2', 
		'\x2', '\x2', '\x1E69', '\x1E6B', '\x5', '\x3CC', '\x1E7', '\x2', '\x1E6A', 
		'\x1E67', '\x3', '\x2', '\x2', '\x2', '\x1E6B', '\x1E6C', '\x3', '\x2', 
		'\x2', '\x2', '\x1E6C', '\x1E6A', '\x3', '\x2', '\x2', '\x2', '\x1E6C', 
		'\x1E6D', '\x3', '\x2', '\x2', '\x2', '\x1E6D', '\x1E6F', '\x3', '\x2', 
		'\x2', '\x2', '\x1E6E', '\x1E65', '\x3', '\x2', '\x2', '\x2', '\x1E6E', 
		'\x1E6A', '\x3', '\x2', '\x2', '\x2', '\x1E6F', '\x3CB', '\x3', '\x2', 
		'\x2', '\x2', '\x1E70', '\x1E72', '\a', '\x108', '\x2', '\x2', '\x1E71', 
		'\x1E73', '\a', '\x1A8', '\x2', '\x2', '\x1E72', '\x1E71', '\x3', '\x2', 
		'\x2', '\x2', '\x1E72', '\x1E73', '\x3', '\x2', '\x2', '\x2', '\x1E73', 
		'\x1E76', '\x3', '\x2', '\x2', '\x2', '\x1E74', '\x1E76', '\a', '\x1A8', 
		'\x2', '\x2', '\x1E75', '\x1E70', '\x3', '\x2', '\x2', '\x2', '\x1E75', 
		'\x1E74', '\x3', '\x2', '\x2', '\x2', '\x1E75', '\x1E76', '\x3', '\x2', 
		'\x2', '\x2', '\x1E76', '\x1E77', '\x3', '\x2', '\x2', '\x2', '\x1E77', 
		'\x1E79', '\x5', '\x2D8', '\x16D', '\x2', '\x1E78', '\x1E7A', '\x5', '\x3FA', 
		'\x1FE', '\x2', '\x1E79', '\x1E78', '\x3', '\x2', '\x2', '\x2', '\x1E79', 
		'\x1E7A', '\x3', '\x2', '\x2', '\x2', '\x1E7A', '\x3CD', '\x3', '\x2', 
		'\x2', '\x2', '\x1E7B', '\x1E7C', '\a', '\x1A1', '\x2', '\x2', '\x1E7C', 
		'\x1E7D', '\a', '?', '\x2', '\x2', '\x1E7D', '\x1E7E', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x1E7E', '\x3CF', '\x3', '\x2', '\x2', '\x2', '\x1E7F', 
		'\x1E80', '\a', '\x2A4', '\x2', '\x2', '\x1E80', '\x1E81', '\a', '\xE9', 
		'\x2', '\x2', '\x1E81', '\x1E82', '\a', '\x2F2', '\x2', '\x2', '\x1E82', 
		'\x1E83', '\x5', '\x32E', '\x198', '\x2', '\x1E83', '\x1E84', '\a', '\x2F3', 
		'\x2', '\x2', '\x1E84', '\x1E87', '\x3', '\x2', '\x2', '\x2', '\x1E85', 
		'\x1E87', '\x5', '\x3C2', '\x1E2', '\x2', '\x1E86', '\x1E7F', '\x3', '\x2', 
		'\x2', '\x2', '\x1E86', '\x1E85', '\x3', '\x2', '\x2', '\x2', '\x1E87', 
		'\x3D1', '\x3', '\x2', '\x2', '\x2', '\x1E88', '\x1E9E', '\a', 'p', '\x2', 
		'\x2', '\x1E89', '\x1E8B', '\a', '\x15F', '\x2', '\x2', '\x1E8A', '\x1E8C', 
		'\a', '#', '\x2', '\x2', '\x1E8B', '\x1E8A', '\x3', '\x2', '\x2', '\x2', 
		'\x1E8B', '\x1E8C', '\x3', '\x2', '\x2', '\x2', '\x1E8C', '\x1E9F', '\x3', 
		'\x2', '\x2', '\x2', '\x1E8D', '\x1E92', '\a', '\x2F2', '\x2', '\x2', 
		'\x1E8E', '\x1E90', '\a', '\x2F8', '\x2', '\x2', '\x1E8F', '\x1E8E', '\x3', 
		'\x2', '\x2', '\x2', '\x1E8F', '\x1E90', '\x3', '\x2', '\x2', '\x2', '\x1E90', 
		'\x1E91', '\x3', '\x2', '\x2', '\x2', '\x1E91', '\x1E93', '\x5', '\x478', 
		'\x23D', '\x2', '\x1E92', '\x1E8F', '\x3', '\x2', '\x2', '\x2', '\x1E93', 
		'\x1E94', '\x3', '\x2', '\x2', '\x2', '\x1E94', '\x1E92', '\x3', '\x2', 
		'\x2', '\x2', '\x1E94', '\x1E95', '\x3', '\x2', '\x2', '\x2', '\x1E95', 
		'\x1E96', '\x3', '\x2', '\x2', '\x2', '\x1E96', '\x1E97', '\a', '\x2F3', 
		'\x2', '\x2', '\x1E97', '\x1E98', '\a', '\x290', '\x2', '\x2', '\x1E98', 
		'\x1E9A', '\a', '\x2F2', '\x2', '\x2', '\x1E99', '\x1E9B', '\x5', '\x37C', 
		'\x1BF', '\x2', '\x1E9A', '\x1E99', '\x3', '\x2', '\x2', '\x2', '\x1E9A', 
		'\x1E9B', '\x3', '\x2', '\x2', '\x2', '\x1E9B', '\x1E9C', '\x3', '\x2', 
		'\x2', '\x2', '\x1E9C', '\x1E9D', '\a', '\x2F3', '\x2', '\x2', '\x1E9D', 
		'\x1E9F', '\x3', '\x2', '\x2', '\x2', '\x1E9E', '\x1E89', '\x3', '\x2', 
		'\x2', '\x2', '\x1E9E', '\x1E8D', '\x3', '\x2', '\x2', '\x2', '\x1E9F', 
		'\x3D3', '\x3', '\x2', '\x2', '\x2', '\x1EA0', '\x1EA3', '\a', '\x1B4', 
		'\x2', '\x2', '\x1EA1', '\x1EA2', '\a', '?', '\x2', '\x2', '\x1EA2', '\x1EA4', 
		'\a', '\x291', '\x2', '\x2', '\x1EA3', '\x1EA1', '\x3', '\x2', '\x2', 
		'\x2', '\x1EA3', '\x1EA4', '\x3', '\x2', '\x2', '\x2', '\x1EA4', '\x1EA5', 
		'\x3', '\x2', '\x2', '\x2', '\x1EA5', '\x1EA7', '\x5', '\x37E', '\x1C0', 
		'\x2', '\x1EA6', '\x1EA8', '\x5', '\x3FA', '\x1FE', '\x2', '\x1EA7', '\x1EA6', 
		'\x3', '\x2', '\x2', '\x2', '\x1EA7', '\x1EA8', '\x3', '\x2', '\x2', '\x2', 
		'\x1EA8', '\x1EA9', '\x3', '\x2', '\x2', '\x2', '\x1EA9', '\x1EAA', '\a', 
		'\x2F8', '\x2', '\x2', '\x1EAA', '\x1EAC', '\x5', '\x37E', '\x1C0', '\x2', 
		'\x1EAB', '\x1EAD', '\x5', '\x3FA', '\x1FE', '\x2', '\x1EAC', '\x1EAB', 
		'\x3', '\x2', '\x2', '\x2', '\x1EAC', '\x1EAD', '\x3', '\x2', '\x2', '\x2', 
		'\x1EAD', '\x3D5', '\x3', '\x2', '\x2', '\x2', '\x1EAE', '\x1EAF', '\a', 
		'\x2AA', '\x2', '\x2', '\x1EAF', '\x1EB1', '\a', '\x2F2', '\x2', '\x2', 
		'\x1EB0', '\x1EB2', '\t', 'o', '\x2', '\x2', '\x1EB1', '\x1EB0', '\x3', 
		'\x2', '\x2', '\x2', '\x1EB1', '\x1EB2', '\x3', '\x2', '\x2', '\x2', '\x1EB2', 
		'\x1EB4', '\x3', '\x2', '\x2', '\x2', '\x1EB3', '\x1EB5', '\t', 'x', '\x2', 
		'\x2', '\x1EB4', '\x1EB3', '\x3', '\x2', '\x2', '\x2', '\x1EB4', '\x1EB5', 
		'\x3', '\x2', '\x2', '\x2', '\x1EB5', '\x1EBA', '\x3', '\x2', '\x2', '\x2', 
		'\x1EB6', '\x1EB8', '\a', '\x2F8', '\x2', '\x2', '\x1EB7', '\x1EB6', '\x3', 
		'\x2', '\x2', '\x2', '\x1EB7', '\x1EB8', '\x3', '\x2', '\x2', '\x2', '\x1EB8', 
		'\x1EB9', '\x3', '\x2', '\x2', '\x2', '\x1EB9', '\x1EBB', '\x5', '\x3DE', 
		'\x1F0', '\x2', '\x1EBA', '\x1EB7', '\x3', '\x2', '\x2', '\x2', '\x1EBB', 
		'\x1EBC', '\x3', '\x2', '\x2', '\x2', '\x1EBC', '\x1EBA', '\x3', '\x2', 
		'\x2', '\x2', '\x1EBC', '\x1EBD', '\x3', '\x2', '\x2', '\x2', '\x1EBD', 
		'\x1EBE', '\x3', '\x2', '\x2', '\x2', '\x1EBE', '\x1EBF', '\a', '\x2F3', 
		'\x2', '\x2', '\x1EBF', '\x3D7', '\x3', '\x2', '\x2', '\x2', '\x1EC0', 
		'\x1EC1', '\a', '\x2B0', '\x2', '\x2', '\x1EC1', '\x1EC5', '\a', '\x2F2', 
		'\x2', '\x2', '\x1EC2', '\x1EC3', '\x5', '\x38C', '\x1C7', '\x2', '\x1EC3', 
		'\x1EC4', '\x5', '\x3FA', '\x1FE', '\x2', '\x1EC4', '\x1EC6', '\x3', '\x2', 
		'\x2', '\x2', '\x1EC5', '\x1EC2', '\x3', '\x2', '\x2', '\x2', '\x1EC5', 
		'\x1EC6', '\x3', '\x2', '\x2', '\x2', '\x1EC6', '\x1ECD', '\x3', '\x2', 
		'\x2', '\x2', '\x1EC7', '\x1EC8', '\a', '\x2F8', '\x2', '\x2', '\x1EC8', 
		'\x1EC9', '\x5', '\x38C', '\x1C7', '\x2', '\x1EC9', '\x1ECA', '\x5', '\x3FA', 
		'\x1FE', '\x2', '\x1ECA', '\x1ECC', '\x3', '\x2', '\x2', '\x2', '\x1ECB', 
		'\x1EC7', '\x3', '\x2', '\x2', '\x2', '\x1ECC', '\x1ECF', '\x3', '\x2', 
		'\x2', '\x2', '\x1ECD', '\x1ECB', '\x3', '\x2', '\x2', '\x2', '\x1ECD', 
		'\x1ECE', '\x3', '\x2', '\x2', '\x2', '\x1ECE', '\x1ED1', '\x3', '\x2', 
		'\x2', '\x2', '\x1ECF', '\x1ECD', '\x3', '\x2', '\x2', '\x2', '\x1ED0', 
		'\x1ED2', '\x5', '\x3DC', '\x1EF', '\x2', '\x1ED1', '\x1ED0', '\x3', '\x2', 
		'\x2', '\x2', '\x1ED1', '\x1ED2', '\x3', '\x2', '\x2', '\x2', '\x1ED2', 
		'\x1ED3', '\x3', '\x2', '\x2', '\x2', '\x1ED3', '\x1ED4', '\a', '\x2F3', 
		'\x2', '\x2', '\x1ED4', '\x3D9', '\x3', '\x2', '\x2', '\x2', '\x1ED5', 
		'\x1EE0', '\x5', '\x402', '\x202', '\x2', '\x1ED6', '\x1ED7', '\a', '\xDD', 
		'\x2', '\x2', '\x1ED7', '\x1EE1', '\a', '\x1A2', '\x2', '\x2', '\x1ED8', 
		'\x1EDB', '\x5', '\x454', '\x22B', '\x2', '\x1ED9', '\x1EDA', '\a', '\x1B6', 
		'\x2', '\x2', '\x1EDA', '\x1EDC', '\x5', '\x38C', '\x1C7', '\x2', '\x1EDB', 
		'\x1ED9', '\x3', '\x2', '\x2', '\x2', '\x1EDB', '\x1EDC', '\x3', '\x2', 
		'\x2', '\x2', '\x1EDC', '\x1EDE', '\x3', '\x2', '\x2', '\x2', '\x1EDD', 
		'\x1EDF', '\x5', '\x3DC', '\x1EF', '\x2', '\x1EDE', '\x1EDD', '\x3', '\x2', 
		'\x2', '\x2', '\x1EDE', '\x1EDF', '\x3', '\x2', '\x2', '\x2', '\x1EDF', 
		'\x1EE1', '\x3', '\x2', '\x2', '\x2', '\x1EE0', '\x1ED6', '\x3', '\x2', 
		'\x2', '\x2', '\x1EE0', '\x1ED8', '\x3', '\x2', '\x2', '\x2', '\x1EE1', 
		'\x3DB', '\x3', '\x2', '\x2', '\x2', '\x1EE2', '\x1EE3', '\a', '\x8F', 
		'\x2', '\x2', '\x1EE3', '\x1EE4', '\x5', '\x38C', '\x1C7', '\x2', '\x1EE4', 
		'\x3DD', '\x3', '\x2', '\x2', '\x2', '\x1EE5', '\x1EEC', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x1EE6', '\x1EEA', '\a', '\x19', '\x2', '\x2', '\x1EE7', 
		'\x1EEB', '\x5', '\x492', '\x24A', '\x2', '\x1EE8', '\x1EE9', '\a', '\xBB', 
		'\x2', '\x2', '\x1EE9', '\x1EEB', '\x5', '\x38C', '\x1C7', '\x2', '\x1EEA', 
		'\x1EE7', '\x3', '\x2', '\x2', '\x2', '\x1EEA', '\x1EE8', '\x3', '\x2', 
		'\x2', '\x2', '\x1EEB', '\x1EED', '\x3', '\x2', '\x2', '\x2', '\x1EEC', 
		'\x1EE6', '\x3', '\x2', '\x2', '\x2', '\x1EEC', '\x1EED', '\x3', '\x2', 
		'\x2', '\x2', '\x1EED', '\x3DF', '\x3', '\x2', '\x2', '\x2', '\x1EEE', 
		'\x1EF2', '\a', '\x299', '\x2', '\x2', '\x1EEF', '\x1EF0', '\a', '\x181', 
		'\x2', '\x2', '\x1EF0', '\x1EF3', '\a', '\x291', '\x2', '\x2', '\x1EF1', 
		'\x1EF3', '\x5', '\x37E', '\x1C0', '\x2', '\x1EF2', '\x1EEF', '\x3', '\x2', 
		'\x2', '\x2', '\x1EF2', '\x1EF1', '\x3', '\x2', '\x2', '\x2', '\x1EF3', 
		'\x3E1', '\x3', '\x2', '\x2', '\x2', '\x1EF4', '\x1EFA', '\a', '\x23B', 
		'\x2', '\x2', '\x1EF5', '\x1EFB', '\a', '\x2BC', '\x2', '\x2', '\x1EF6', 
		'\x1EF8', '\a', '\x181', '\x2', '\x2', '\x1EF7', '\x1EF9', '\a', '\x291', 
		'\x2', '\x2', '\x1EF8', '\x1EF7', '\x3', '\x2', '\x2', '\x2', '\x1EF8', 
		'\x1EF9', '\x3', '\x2', '\x2', '\x2', '\x1EF9', '\x1EFB', '\x3', '\x2', 
		'\x2', '\x2', '\x1EFA', '\x1EF5', '\x3', '\x2', '\x2', '\x2', '\x1EFA', 
		'\x1EF6', '\x3', '\x2', '\x2', '\x2', '\x1EFB', '\x3E3', '\x3', '\x2', 
		'\x2', '\x2', '\x1EFC', '\x1EFD', '\a', '\xB2', '\x2', '\x2', '\x1EFD', 
		'\x1EFE', '\x5', '\x38C', '\x1C7', '\x2', '\x1EFE', '\x3E5', '\x3', '\x2', 
		'\x2', '\x2', '\x1EFF', '\x1F00', '\a', '\x299', '\x2', '\x2', '\x1F00', 
		'\x1F01', '\x5', '\x38C', '\x1C7', '\x2', '\x1F01', '\x3E7', '\x3', '\x2', 
		'\x2', '\x2', '\x1F02', '\x1F03', '\a', '\x181', '\x2', '\x2', '\x1F03', 
		'\x1F0B', '\a', '\xFF', '\x2', '\x2', '\x1F04', '\x1F08', '\a', '\xFF', 
		'\x2', '\x2', '\x1F05', '\x1F06', '\a', '\x22E', '\x2', '\x2', '\x1F06', 
		'\x1F07', '\a', '\x306', '\x2', '\x2', '\x1F07', '\x1F09', '\x5', '\x38C', 
		'\x1C7', '\x2', '\x1F08', '\x1F05', '\x3', '\x2', '\x2', '\x2', '\x1F08', 
		'\x1F09', '\x3', '\x2', '\x2', '\x2', '\x1F09', '\x1F0B', '\x3', '\x2', 
		'\x2', '\x2', '\x1F0A', '\x1F02', '\x3', '\x2', '\x2', '\x2', '\x1F0A', 
		'\x1F04', '\x3', '\x2', '\x2', '\x2', '\x1F0B', '\x3E9', '\x3', '\x2', 
		'\x2', '\x2', '\x1F0C', '\x1F16', '\a', '\x2F9', '\x2', '\x2', '\x1F0D', 
		'\x1F16', '\a', '\xC6', '\x2', '\x2', '\x1F0E', '\x1F16', '\a', '\x30E', 
		'\x2', '\x2', '\x1F0F', '\x1F10', '\a', '\x228', '\x2', '\x2', '\x1F10', 
		'\x1F16', '\t', 'y', '\x2', '\x2', '\x1F11', '\x1F16', '\a', '\x30F', 
		'\x2', '\x2', '\x1F12', '\x1F16', '\x5', '\x3EE', '\x1F8', '\x2', '\x1F13', 
		'\x1F16', '\x5', '\x3F6', '\x1FC', '\x2', '\x1F14', '\x1F16', '\x5', '\x3EC', 
		'\x1F7', '\x2', '\x1F15', '\x1F0C', '\x3', '\x2', '\x2', '\x2', '\x1F15', 
		'\x1F0D', '\x3', '\x2', '\x2', '\x2', '\x1F15', '\x1F0E', '\x3', '\x2', 
		'\x2', '\x2', '\x1F15', '\x1F0F', '\x3', '\x2', '\x2', '\x2', '\x1F15', 
		'\x1F11', '\x3', '\x2', '\x2', '\x2', '\x1F15', '\x1F12', '\x3', '\x2', 
		'\x2', '\x2', '\x1F15', '\x1F13', '\x3', '\x2', '\x2', '\x2', '\x1F15', 
		'\x1F14', '\x3', '\x2', '\x2', '\x2', '\x1F16', '\x3EB', '\x3', '\x2', 
		'\x2', '\x2', '\x1F17', '\x1F18', '\a', '\xC3', '\x2', '\x2', '\x1F18', 
		'\x1F19', '\x5', '\x296', '\x14C', '\x2', '\x1F19', '\x3ED', '\x3', '\x2', 
		'\x2', '\x2', '\x1F1A', '\x1F1B', '\a', '\x2A0', '\x2', '\x2', '\x1F1B', 
		'\x1F21', '\t', 'z', '\x2', '\x2', '\x1F1C', '\x1F1D', '\a', '\xC6', '\x2', 
		'\x2', '\x1F1D', '\x1F1E', '\t', '{', '\x2', '\x2', '\x1F1E', '\x1F22', 
		'\t', '|', '\x2', '\x2', '\x1F1F', '\x1F20', '\a', 'l', '\x2', '\x2', 
		'\x1F20', '\x1F22', '\t', '}', '\x2', '\x2', '\x1F21', '\x1F1C', '\x3', 
		'\x2', '\x2', '\x2', '\x1F21', '\x1F1F', '\x3', '\x2', '\x2', '\x2', '\x1F22', 
		'\x3EF', '\x3', '\x2', '\x2', '\x2', '\x1F23', '\x1F24', '\a', '\x2F2', 
		'\x2', '\x2', '\x1F24', '\x1F25', '\x5', '\x3F2', '\x1FA', '\x2', '\x1F25', 
		'\x1F26', '\a', '\x2F3', '\x2', '\x2', '\x1F26', '\x3F1', '\x3', '\x2', 
		'\x2', '\x2', '\x1F27', '\x1F29', '\x5', '\x3F4', '\x1FB', '\x2', '\x1F28', 
		'\x1F27', '\x3', '\x2', '\x2', '\x2', '\x1F28', '\x1F29', '\x3', '\x2', 
		'\x2', '\x2', '\x1F29', '\x1F2C', '\x3', '\x2', '\x2', '\x2', '\x1F2A', 
		'\x1F2B', '\a', '\x2F8', '\x2', '\x2', '\x1F2B', '\x1F2D', '\x5', '\x3F4', 
		'\x1FB', '\x2', '\x1F2C', '\x1F2A', '\x3', '\x2', '\x2', '\x2', '\x1F2D', 
		'\x1F2E', '\x3', '\x2', '\x2', '\x2', '\x1F2E', '\x1F2C', '\x3', '\x2', 
		'\x2', '\x2', '\x1F2E', '\x1F2F', '\x3', '\x2', '\x2', '\x2', '\x1F2F', 
		'\x3F3', '\x3', '\x2', '\x2', '\x2', '\x1F30', '\x1F31', '\x5', '\x49E', 
		'\x250', '\x2', '\x1F31', '\x1F32', '\a', '\x309', '\x2', '\x2', '\x1F32', 
		'\x1F33', '\x5', '\x37E', '\x1C0', '\x2', '\x1F33', '\x1F36', '\x3', '\x2', 
		'\x2', '\x2', '\x1F34', '\x1F36', '\x5', '\x37E', '\x1C0', '\x2', '\x1F35', 
		'\x1F30', '\x3', '\x2', '\x2', '\x2', '\x1F35', '\x1F34', '\x3', '\x2', 
		'\x2', '\x2', '\x1F36', '\x3F5', '\x3', '\x2', '\x2', '\x2', '\x1F37', 
		'\x1F38', '\a', '\x223', '\x2', '\x2', '\x1F38', '\x1F3E', '\x5', '\x49E', 
		'\x250', '\x2', '\x1F39', '\x1F3F', '\a', '\x2EE', '\x2', '\x2', '\x1F3A', 
		'\x1F3F', '\a', '\x19B', '\x2', '\x2', '\x1F3B', '\x1F3F', '\a', '\x194', 
		'\x2', '\x2', '\x1F3C', '\x1F3F', '\x5', '\x4A6', '\x254', '\x2', '\x1F3D', 
		'\x1F3F', '\x5', '\x49E', '\x250', '\x2', '\x1F3E', '\x1F39', '\x3', '\x2', 
		'\x2', '\x2', '\x1F3E', '\x1F3A', '\x3', '\x2', '\x2', '\x2', '\x1F3E', 
		'\x1F3B', '\x3', '\x2', '\x2', '\x2', '\x1F3E', '\x1F3C', '\x3', '\x2', 
		'\x2', '\x2', '\x1F3E', '\x1F3D', '\x3', '\x2', '\x2', '\x2', '\x1F3F', 
		'\x3F7', '\x3', '\x2', '\x2', '\x2', '\x1F40', '\x1F42', '\t', '~', '\x2', 
		'\x2', '\x1F41', '\x1F43', '\a', '\xDD', '\x2', '\x2', '\x1F42', '\x1F41', 
		'\x3', '\x2', '\x2', '\x2', '\x1F42', '\x1F43', '\x3', '\x2', '\x2', '\x2', 
		'\x1F43', '\x1F44', '\x3', '\x2', '\x2', '\x2', '\x1F44', '\x1F46', '\a', 
		'\x2F2', '\x2', '\x2', '\x1F45', '\x1F47', '\x5', '\x37C', '\x1BF', '\x2', 
		'\x1F46', '\x1F45', '\x3', '\x2', '\x2', '\x2', '\x1F46', '\x1F47', '\x3', 
		'\x2', '\x2', '\x2', '\x1F47', '\x1F48', '\x3', '\x2', '\x2', '\x2', '\x1F48', 
		'\x1F49', '\a', '\x2F3', '\x2', '\x2', '\x1F49', '\x3F9', '\x3', '\x2', 
		'\x2', '\x2', '\x1F4A', '\x1F4C', '\a', '\x19', '\x2', '\x2', '\x1F4B', 
		'\x1F4A', '\x3', '\x2', '\x2', '\x2', '\x1F4B', '\x1F4C', '\x3', '\x2', 
		'\x2', '\x2', '\x1F4C', '\x1F4F', '\x3', '\x2', '\x2', '\x2', '\x1F4D', 
		'\x1F50', '\x5', '\x46E', '\x238', '\x2', '\x1F4E', '\x1F50', '\x5', '\x4AA', 
		'\x256', '\x2', '\x1F4F', '\x1F4D', '\x3', '\x2', '\x2', '\x2', '\x1F4F', 
		'\x1F4E', '\x3', '\x2', '\x2', '\x2', '\x1F50', '\x1F53', '\x3', '\x2', 
		'\x2', '\x2', '\x1F51', '\x1F53', '\a', '\x19', '\x2', '\x2', '\x1F52', 
		'\x1F4B', '\x3', '\x2', '\x2', '\x2', '\x1F52', '\x1F51', '\x3', '\x2', 
		'\x2', '\x2', '\x1F53', '\x3FB', '\x3', '\x2', '\x2', '\x2', '\x1F54', 
		'\x1F57', '\x5', '\x46E', '\x238', '\x2', '\x1F55', '\x1F57', '\x5', '\x4AA', 
		'\x256', '\x2', '\x1F56', '\x1F54', '\x3', '\x2', '\x2', '\x2', '\x1F56', 
		'\x1F55', '\x3', '\x2', '\x2', '\x2', '\x1F57', '\x3FD', '\x3', '\x2', 
		'\x2', '\x2', '\x1F58', '\x1F5D', '\a', '\x2A2', '\x2', '\x2', '\x1F59', 
		'\x1F5A', '\a', 'w', '\x2', '\x2', '\x1F5A', '\x1F5B', '\a', '\x195', 
		'\x2', '\x2', '\x1F5B', '\x1F5E', '\x5', '\x410', '\x209', '\x2', '\x1F5C', 
		'\x1F5E', '\x5', '\x37E', '\x1C0', '\x2', '\x1F5D', '\x1F59', '\x3', '\x2', 
		'\x2', '\x2', '\x1F5D', '\x1F5C', '\x3', '\x2', '\x2', '\x2', '\x1F5E', 
		'\x3FF', '\x3', '\x2', '\x2', '\x2', '\x1F5F', '\x1F60', '\a', '>', '\x2', 
		'\x2', '\x1F60', '\x1F62', '\a', 'W', '\x2', '\x2', '\x1F61', '\x1F5F', 
		'\x3', '\x2', '\x2', '\x2', '\x1F61', '\x1F62', '\x3', '\x2', '\x2', '\x2', 
		'\x1F62', '\x1F63', '\x3', '\x2', '\x2', '\x2', '\x1F63', '\x1F68', '\a', 
		'\x118', '\x2', '\x2', '\x1F64', '\x1F66', '\a', '\x2F8', '\x2', '\x2', 
		'\x1F65', '\x1F64', '\x3', '\x2', '\x2', '\x2', '\x1F65', '\x1F66', '\x3', 
		'\x2', '\x2', '\x2', '\x1F66', '\x1F67', '\x3', '\x2', '\x2', '\x2', '\x1F67', 
		'\x1F69', '\x5', '\x40E', '\x208', '\x2', '\x1F68', '\x1F65', '\x3', '\x2', 
		'\x2', '\x2', '\x1F69', '\x1F6A', '\x3', '\x2', '\x2', '\x2', '\x1F6A', 
		'\x1F68', '\x3', '\x2', '\x2', '\x2', '\x1F6A', '\x1F6B', '\x3', '\x2', 
		'\x2', '\x2', '\x1F6B', '\x401', '\x3', '\x2', '\x2', '\x2', '\x1F6C', 
		'\x1F6F', '\x5', '\x46E', '\x238', '\x2', '\x1F6D', '\x1F6F', '\x5', '\x4AA', 
		'\x256', '\x2', '\x1F6E', '\x1F6C', '\x3', '\x2', '\x2', '\x2', '\x1F6E', 
		'\x1F6D', '\x3', '\x2', '\x2', '\x2', '\x1F6F', '\x403', '\x3', '\x2', 
		'\x2', '\x2', '\x1F70', '\x1F73', '\x5', '\x48A', '\x246', '\x2', '\x1F71', 
		'\x1F72', '\a', '\x2FA', '\x2', '\x2', '\x1F72', '\x1F74', '\x5', '\x414', 
		'\x20B', '\x2', '\x1F73', '\x1F71', '\x3', '\x2', '\x2', '\x2', '\x1F73', 
		'\x1F74', '\x3', '\x2', '\x2', '\x2', '\x1F74', '\x405', '\x3', '\x2', 
		'\x2', '\x2', '\x1F75', '\x1F76', '\x5', '\x46E', '\x238', '\x2', '\x1F76', 
		'\x407', '\x3', '\x2', '\x2', '\x2', '\x1F77', '\x1F79', '\x5', '\x492', 
		'\x24A', '\x2', '\x1F78', '\x1F7A', '\x5', '\xB4', '[', '\x2', '\x1F79', 
		'\x1F78', '\x3', '\x2', '\x2', '\x2', '\x1F79', '\x1F7A', '\x3', '\x2', 
		'\x2', '\x2', '\x1F7A', '\x409', '\x3', '\x2', '\x2', '\x2', '\x1F7B', 
		'\x1F7E', '\x5', '\x492', '\x24A', '\x2', '\x1F7C', '\x1F7E', '\a', '\x63', 
		'\x2', '\x2', '\x1F7D', '\x1F7B', '\x3', '\x2', '\x2', '\x2', '\x1F7D', 
		'\x1F7C', '\x3', '\x2', '\x2', '\x2', '\x1F7E', '\x40B', '\x3', '\x2', 
		'\x2', '\x2', '\x1F7F', '\x1F82', '\x5', '\x48A', '\x246', '\x2', '\x1F80', 
		'\x1F81', '\a', '\x2FA', '\x2', '\x2', '\x1F81', '\x1F83', '\x5', '\x414', 
		'\x20B', '\x2', '\x1F82', '\x1F80', '\x3', '\x2', '\x2', '\x2', '\x1F82', 
		'\x1F83', '\x3', '\x2', '\x2', '\x2', '\x1F83', '\x40D', '\x3', '\x2', 
		'\x2', '\x2', '\x1F84', '\x1F85', '\a', '\x30A', '\x2', '\x2', '\x1F85', 
		'\x1F87', '\x5', '\x49A', '\x24E', '\x2', '\x1F86', '\x1F84', '\x3', '\x2', 
		'\x2', '\x2', '\x1F86', '\x1F87', '\x3', '\x2', '\x2', '\x2', '\x1F87', 
		'\x1F88', '\x3', '\x2', '\x2', '\x2', '\x1F88', '\x1F8B', '\x5', '\x492', 
		'\x24A', '\x2', '\x1F89', '\x1F8A', '\a', '\x2EB', '\x2', '\x2', '\x1F8A', 
		'\x1F8C', '\x5', '\x492', '\x24A', '\x2', '\x1F8B', '\x1F89', '\x3', '\x2', 
		'\x2', '\x2', '\x1F8B', '\x1F8C', '\x3', '\x2', '\x2', '\x2', '\x1F8C', 
		'\x1F8F', '\x3', '\x2', '\x2', '\x2', '\x1F8D', '\x1F8F', '\x5', '\x45C', 
		'\x22F', '\x2', '\x1F8E', '\x1F86', '\x3', '\x2', '\x2', '\x2', '\x1F8E', 
		'\x1F8D', '\x3', '\x2', '\x2', '\x2', '\x1F8F', '\x40F', '\x3', '\x2', 
		'\x2', '\x2', '\x1F90', '\x1F93', '\x5', '\x45E', '\x230', '\x2', '\x1F91', 
		'\x1F93', '\x5', '\x45C', '\x22F', '\x2', '\x1F92', '\x1F90', '\x3', '\x2', 
		'\x2', '\x2', '\x1F92', '\x1F91', '\x3', '\x2', '\x2', '\x2', '\x1F93', 
		'\x411', '\x3', '\x2', '\x2', '\x2', '\x1F94', '\x1F97', '\x5', '\x46E', 
		'\x238', '\x2', '\x1F95', '\x1F97', '\x5', '\x45C', '\x22F', '\x2', '\x1F96', 
		'\x1F94', '\x3', '\x2', '\x2', '\x2', '\x1F96', '\x1F95', '\x3', '\x2', 
		'\x2', '\x2', '\x1F97', '\x413', '\x3', '\x2', '\x2', '\x2', '\x1F98', 
		'\x1F99', '\x5', '\x46E', '\x238', '\x2', '\x1F99', '\x415', '\x3', '\x2', 
		'\x2', '\x2', '\x1F9A', '\x1F9E', '\x5', '\x444', '\x223', '\x2', '\x1F9B', 
		'\x1F9C', '\a', '\x2FA', '\x2', '\x2', '\x1F9C', '\x1F9F', '\x5', '\x414', 
		'\x20B', '\x2', '\x1F9D', '\x1F9F', '\x5', '\x3F8', '\x1FD', '\x2', '\x1F9E', 
		'\x1F9B', '\x3', '\x2', '\x2', '\x2', '\x1F9E', '\x1F9D', '\x3', '\x2', 
		'\x2', '\x2', '\x1F9E', '\x1F9F', '\x3', '\x2', '\x2', '\x2', '\x1F9F', 
		'\x417', '\x3', '\x2', '\x2', '\x2', '\x1FA0', '\x1FA1', '\x5', '\x492', 
		'\x24A', '\x2', '\x1FA1', '\x419', '\x3', '\x2', '\x2', '\x2', '\x1FA2', 
		'\x1FA3', '\x5', '\x492', '\x24A', '\x2', '\x1FA3', '\x41B', '\x3', '\x2', 
		'\x2', '\x2', '\x1FA4', '\x1FA5', '\x5', '\x492', '\x24A', '\x2', '\x1FA5', 
		'\x41D', '\x3', '\x2', '\x2', '\x2', '\x1FA6', '\x1FA7', '\x5', '\x492', 
		'\x24A', '\x2', '\x1FA7', '\x41F', '\x3', '\x2', '\x2', '\x2', '\x1FA8', 
		'\x1FA9', '\x5', '\x492', '\x24A', '\x2', '\x1FA9', '\x421', '\x3', '\x2', 
		'\x2', '\x2', '\x1FAA', '\x1FAB', '\x5', '\x492', '\x24A', '\x2', '\x1FAB', 
		'\x423', '\x3', '\x2', '\x2', '\x2', '\x1FAC', '\x1FAD', '\x5', '\x492', 
		'\x24A', '\x2', '\x1FAD', '\x425', '\x3', '\x2', '\x2', '\x2', '\x1FAE', 
		'\x1FAF', '\x5', '\x492', '\x24A', '\x2', '\x1FAF', '\x427', '\x3', '\x2', 
		'\x2', '\x2', '\x1FB0', '\x1FB1', '\x5', '\x492', '\x24A', '\x2', '\x1FB1', 
		'\x429', '\x3', '\x2', '\x2', '\x2', '\x1FB2', '\x1FB3', '\x5', '\x492', 
		'\x24A', '\x2', '\x1FB3', '\x42B', '\x3', '\x2', '\x2', '\x2', '\x1FB4', 
		'\x1FB5', '\x5', '\x492', '\x24A', '\x2', '\x1FB5', '\x42D', '\x3', '\x2', 
		'\x2', '\x2', '\x1FB6', '\x1FB7', '\x5', '\x492', '\x24A', '\x2', '\x1FB7', 
		'\x42F', '\x3', '\x2', '\x2', '\x2', '\x1FB8', '\x1FB9', '\x5', '\x492', 
		'\x24A', '\x2', '\x1FB9', '\x431', '\x3', '\x2', '\x2', '\x2', '\x1FBA', 
		'\x1FBB', '\x5', '\x492', '\x24A', '\x2', '\x1FBB', '\x433', '\x3', '\x2', 
		'\x2', '\x2', '\x1FBC', '\x1FBF', '\x5', '\x46E', '\x238', '\x2', '\x1FBD', 
		'\x1FBE', '\a', '\x2EB', '\x2', '\x2', '\x1FBE', '\x1FC0', '\x5', '\x492', 
		'\x24A', '\x2', '\x1FBF', '\x1FBD', '\x3', '\x2', '\x2', '\x2', '\x1FBF', 
		'\x1FC0', '\x3', '\x2', '\x2', '\x2', '\x1FC0', '\x435', '\x3', '\x2', 
		'\x2', '\x2', '\x1FC1', '\x1FC2', '\x5', '\x434', '\x21B', '\x2', '\x1FC2', 
		'\x437', '\x3', '\x2', '\x2', '\x2', '\x1FC3', '\x1FC4', '\x5', '\x434', 
		'\x21B', '\x2', '\x1FC4', '\x439', '\x3', '\x2', '\x2', '\x2', '\x1FC5', 
		'\x1FC6', '\x5', '\x434', '\x21B', '\x2', '\x1FC6', '\x43B', '\x3', '\x2', 
		'\x2', '\x2', '\x1FC7', '\x1FC8', '\x5', '\x434', '\x21B', '\x2', '\x1FC8', 
		'\x43D', '\x3', '\x2', '\x2', '\x2', '\x1FC9', '\x1FCA', '\x5', '\x434', 
		'\x21B', '\x2', '\x1FCA', '\x43F', '\x3', '\x2', '\x2', '\x2', '\x1FCB', 
		'\x1FCC', '\x5', '\x434', '\x21B', '\x2', '\x1FCC', '\x441', '\x3', '\x2', 
		'\x2', '\x2', '\x1FCD', '\x1FCE', '\x5', '\x434', '\x21B', '\x2', '\x1FCE', 
		'\x443', '\x3', '\x2', '\x2', '\x2', '\x1FCF', '\x1FD0', '\x5', '\x434', 
		'\x21B', '\x2', '\x1FD0', '\x445', '\x3', '\x2', '\x2', '\x2', '\x1FD1', 
		'\x1FEA', '\x5', '\x416', '\x20C', '\x2', '\x1FD2', '\x1FD7', '\a', '\x28C', 
		'\x2', '\x2', '\x1FD3', '\x1FD5', '\a', '\x2F8', '\x2', '\x2', '\x1FD4', 
		'\x1FD3', '\x3', '\x2', '\x2', '\x2', '\x1FD4', '\x1FD5', '\x3', '\x2', 
		'\x2', '\x2', '\x1FD5', '\x1FD6', '\x3', '\x2', '\x2', '\x2', '\x1FD6', 
		'\x1FD8', '\x5', '\x424', '\x213', '\x2', '\x1FD7', '\x1FD4', '\x3', '\x2', 
		'\x2', '\x2', '\x1FD8', '\x1FD9', '\x3', '\x2', '\x2', '\x2', '\x1FD9', 
		'\x1FD7', '\x3', '\x2', '\x2', '\x2', '\x1FD9', '\x1FDA', '\x3', '\x2', 
		'\x2', '\x2', '\x1FDA', '\x1FEA', '\x3', '\x2', '\x2', '\x2', '\x1FDB', 
		'\x1FDC', '\a', '\x9B', '\x2', '\x2', '\x1FDC', '\x1FEA', '\x5', '\x422', 
		'\x212', '\x2', '\x1FDD', '\x1FDE', '\a', '\xAA', '\x2', '\x2', '\x1FDE', 
		'\x1FEA', '\x5', '\x42C', '\x217', '\x2', '\x1FDF', '\x1FE0', '\a', '\x15A', 
		'\x2', '\x2', '\x1FE0', '\x1FE1', '\a', '\x15F', '\x2', '\x2', '\x1FE1', 
		'\x1FEA', '\x5', '\x42C', '\x217', '\x2', '\x1FE2', '\x1FE3', '\a', '\x11E', 
		'\x2', '\x2', '\x1FE3', '\x1FE4', '\t', '\x7F', '\x2', '\x2', '\x1FE4', 
		'\x1FEA', '\x5', '\x42C', '\x217', '\x2', '\x1FE5', '\x1FE6', '\a', '\x23A', 
		'\x2', '\x2', '\x1FE6', '\x1FE7', '\a', '\x273', '\x2', '\x2', '\x1FE7', 
		'\x1FE8', '\a', '\x1D7', '\x2', '\x2', '\x1FE8', '\x1FEA', '\x5', '\x42C', 
		'\x217', '\x2', '\x1FE9', '\x1FD1', '\x3', '\x2', '\x2', '\x2', '\x1FE9', 
		'\x1FD2', '\x3', '\x2', '\x2', '\x2', '\x1FE9', '\x1FDB', '\x3', '\x2', 
		'\x2', '\x2', '\x1FE9', '\x1FDD', '\x3', '\x2', '\x2', '\x2', '\x1FE9', 
		'\x1FDF', '\x3', '\x2', '\x2', '\x2', '\x1FE9', '\x1FE2', '\x3', '\x2', 
		'\x2', '\x2', '\x1FE9', '\x1FE5', '\x3', '\x2', '\x2', '\x2', '\x1FEA', 
		'\x447', '\x3', '\x2', '\x2', '\x2', '\x1FEB', '\x1FED', '\a', '\x2F8', 
		'\x2', '\x2', '\x1FEC', '\x1FEB', '\x3', '\x2', '\x2', '\x2', '\x1FEC', 
		'\x1FED', '\x3', '\x2', '\x2', '\x2', '\x1FED', '\x1FEE', '\x3', '\x2', 
		'\x2', '\x2', '\x1FEE', '\x1FF0', '\x5', '\x490', '\x249', '\x2', '\x1FEF', 
		'\x1FEC', '\x3', '\x2', '\x2', '\x2', '\x1FF0', '\x1FF1', '\x3', '\x2', 
		'\x2', '\x2', '\x1FF1', '\x1FEF', '\x3', '\x2', '\x2', '\x2', '\x1FF1', 
		'\x1FF2', '\x3', '\x2', '\x2', '\x2', '\x1FF2', '\x449', '\x3', '\x2', 
		'\x2', '\x2', '\x1FF3', '\x1FF4', '\a', '\x2F2', '\x2', '\x2', '\x1FF4', 
		'\x1FF5', '\x5', '\x448', '\x225', '\x2', '\x1FF5', '\x1FF6', '\a', '\x2F3', 
		'\x2', '\x2', '\x1FF6', '\x44B', '\x3', '\x2', '\x2', '\x2', '\x1FF7', 
		'\x1FF8', '\a', '\x122', '\x2', '\x2', '\x1FF8', '\x1FF9', '\a', '\x2F2', 
		'\x2', '\x2', '\x1FF9', '\x1FFA', '\a', '\x2C7', '\x2', '\x2', '\x1FFA', 
		'\x1FFB', '\t', '[', '\x2', '\x2', '\x1FFB', '\x1FFC', '\x5', '\x32E', 
		'\x198', '\x2', '\x1FFC', '\x1FFE', '\a', '\x2F3', '\x2', '\x2', '\x1FFD', 
		'\x1FFF', '\x5', '\x3C2', '\x1E2', '\x2', '\x1FFE', '\x1FFD', '\x3', '\x2', 
		'\x2', '\x2', '\x1FFE', '\x1FFF', '\x3', '\x2', '\x2', '\x2', '\x1FFF', 
		'\x44D', '\x3', '\x2', '\x2', '\x2', '\x2000', '\x200A', '\a', '\x2F2', 
		'\x2', '\x2', '\x2001', '\x2003', '\a', '\x2F8', '\x2', '\x2', '\x2002', 
		'\x2001', '\x3', '\x2', '\x2', '\x2', '\x2002', '\x2003', '\x3', '\x2', 
		'\x2', '\x2', '\x2003', '\x2004', '\x3', '\x2', '\x2', '\x2', '\x2004', 
		'\x2006', '\x5', '\x3F4', '\x1FB', '\x2', '\x2005', '\x2007', '\x5', '\x452', 
		'\x22A', '\x2', '\x2006', '\x2005', '\x3', '\x2', '\x2', '\x2', '\x2006', 
		'\x2007', '\x3', '\x2', '\x2', '\x2', '\x2007', '\x2009', '\x3', '\x2', 
		'\x2', '\x2', '\x2008', '\x2002', '\x3', '\x2', '\x2', '\x2', '\x2009', 
		'\x200C', '\x3', '\x2', '\x2', '\x2', '\x200A', '\x2008', '\x3', '\x2', 
		'\x2', '\x2', '\x200A', '\x200B', '\x3', '\x2', '\x2', '\x2', '\x200B', 
		'\x200D', '\x3', '\x2', '\x2', '\x2', '\x200C', '\x200A', '\x3', '\x2', 
		'\x2', '\x2', '\x200D', '\x200F', '\a', '\x2F3', '\x2', '\x2', '\x200E', 
		'\x2010', '\x5', '\x44C', '\x227', '\x2', '\x200F', '\x200E', '\x3', '\x2', 
		'\x2', '\x2', '\x200F', '\x2010', '\x3', '\x2', '\x2', '\x2', '\x2010', 
		'\x44F', '\x3', '\x2', '\x2', '\x2', '\x2011', '\x2012', '\a', '\x2F2', 
		'\x2', '\x2', '\x2012', '\x201F', '\x5', '\x490', '\x249', '\x2', '\x2013', 
		'\x2016', '\a', '\x2F8', '\x2', '\x2', '\x2014', '\x2017', '\x5', '\x4A6', 
		'\x254', '\x2', '\x2015', '\x2017', '\a', '\x18D', '\x2', '\x2', '\x2016', 
		'\x2014', '\x3', '\x2', '\x2', '\x2', '\x2016', '\x2015', '\x3', '\x2', 
		'\x2', '\x2', '\x2017', '\x201D', '\x3', '\x2', '\x2', '\x2', '\x2018', 
		'\x201B', '\a', '\x2F8', '\x2', '\x2', '\x2019', '\x201C', '\x5', '\x4A6', 
		'\x254', '\x2', '\x201A', '\x201C', '\a', '\x18D', '\x2', '\x2', '\x201B', 
		'\x2019', '\x3', '\x2', '\x2', '\x2', '\x201B', '\x201A', '\x3', '\x2', 
		'\x2', '\x2', '\x201C', '\x201E', '\x3', '\x2', '\x2', '\x2', '\x201D', 
		'\x2018', '\x3', '\x2', '\x2', '\x2', '\x201D', '\x201E', '\x3', '\x2', 
		'\x2', '\x2', '\x201E', '\x2020', '\x3', '\x2', '\x2', '\x2', '\x201F', 
		'\x2013', '\x3', '\x2', '\x2', '\x2', '\x201F', '\x2020', '\x3', '\x2', 
		'\x2', '\x2', '\x2020', '\x2021', '\x3', '\x2', '\x2', '\x2', '\x2021', 
		'\x2032', '\a', '\x28E', '\x2', '\x2', '\x2022', '\x2023', '\x5', '\x416', 
		'\x20C', '\x2', '\x2023', '\x2024', '\a', '\x2EB', '\x2', '\x2', '\x2024', 
		'\x2025', '\a', '\x2F5', '\x2', '\x2', '\x2025', '\x2033', '\x3', '\x2', 
		'\x2', '\x2', '\x2026', '\x2033', '\a', '\x2F5', '\x2', '\x2', '\x2027', 
		'\x2029', '\a', '\x2F8', '\x2', '\x2', '\x2028', '\x2027', '\x3', '\x2', 
		'\x2', '\x2', '\x2028', '\x2029', '\x3', '\x2', '\x2', '\x2', '\x2029', 
		'\x202A', '\x3', '\x2', '\x2', '\x2', '\x202A', '\x202C', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x202B', '\x202D', '\x5', '\x3FA', '\x1FE', '\x2', '\x202C', 
		'\x202B', '\x3', '\x2', '\x2', '\x2', '\x202C', '\x202D', '\x3', '\x2', 
		'\x2', '\x2', '\x202D', '\x202F', '\x3', '\x2', '\x2', '\x2', '\x202E', 
		'\x2028', '\x3', '\x2', '\x2', '\x2', '\x202F', '\x2030', '\x3', '\x2', 
		'\x2', '\x2', '\x2030', '\x202E', '\x3', '\x2', '\x2', '\x2', '\x2030', 
		'\x2031', '\x3', '\x2', '\x2', '\x2', '\x2031', '\x2033', '\x3', '\x2', 
		'\x2', '\x2', '\x2032', '\x2022', '\x3', '\x2', '\x2', '\x2', '\x2032', 
		'\x2026', '\x3', '\x2', '\x2', '\x2', '\x2032', '\x202E', '\x3', '\x2', 
		'\x2', '\x2', '\x2033', '\x2034', '\x3', '\x2', '\x2', '\x2', '\x2034', 
		'\x2036', '\a', '\x2F3', '\x2', '\x2', '\x2035', '\x2037', '\x5', '\x44C', 
		'\x227', '\x2', '\x2036', '\x2035', '\x3', '\x2', '\x2', '\x2', '\x2036', 
		'\x2037', '\x3', '\x2', '\x2', '\x2', '\x2037', '\x451', '\x3', '\x2', 
		'\x2', '\x2', '\x2038', '\x2039', '\t', '\x80', '\x2', '\x2', '\x2039', 
		'\x203A', '\a', '\x18E', '\x2', '\x2', '\x203A', '\x453', '\x3', '\x2', 
		'\x2', '\x2', '\x203B', '\x2044', '\x5', '\x456', '\x22C', '\x2', '\x203C', 
		'\x203E', '\a', '\x1E9', '\x2', '\x2', '\x203D', '\x203C', '\x3', '\x2', 
		'\x2', '\x2', '\x203D', '\x203E', '\x3', '\x2', '\x2', '\x2', '\x203E', 
		'\x203F', '\x3', '\x2', '\x2', '\x2', '\x203F', '\x2041', '\x5', '\x496', 
		'\x24C', '\x2', '\x2040', '\x2042', '\t', '\x81', '\x2', '\x2', '\x2041', 
		'\x2040', '\x3', '\x2', '\x2', '\x2', '\x2041', '\x2042', '\x3', '\x2', 
		'\x2', '\x2', '\x2042', '\x2044', '\x3', '\x2', '\x2', '\x2', '\x2043', 
		'\x203B', '\x3', '\x2', '\x2', '\x2', '\x2043', '\x203D', '\x3', '\x2', 
		'\x2', '\x2', '\x2044', '\x455', '\x3', '\x2', '\x2', '\x2', '\x2045', 
		'\x2047', '\x5', '\x45A', '\x22E', '\x2', '\x2046', '\x2048', '\x5', '\x458', 
		'\x22D', '\x2', '\x2047', '\x2046', '\x3', '\x2', '\x2', '\x2', '\x2047', 
		'\x2048', '\x3', '\x2', '\x2', '\x2', '\x2048', '\x2052', '\x3', '\x2', 
		'\x2', '\x2', '\x2049', '\x204B', '\a', '\x2A6', '\x2', '\x2', '\x204A', 
		'\x204C', '\a', '\x138', '\x2', '\x2', '\x204B', '\x204A', '\x3', '\x2', 
		'\x2', '\x2', '\x204B', '\x204C', '\x3', '\x2', '\x2', '\x2', '\x204C', 
		'\x204D', '\x3', '\x2', '\x2', '\x2', '\x204D', '\x204E', '\a', '\x265', 
		'\x2', '\x2', '\x204E', '\x2053', '\a', '\x2BF', '\x2', '\x2', '\x204F', 
		'\x2050', '\a', 'J', '\x2', '\x2', '\x2050', '\x2051', '\a', '\x223', 
		'\x2', '\x2', '\x2051', '\x2053', '\x5', '\x49A', '\x24E', '\x2', '\x2052', 
		'\x2049', '\x3', '\x2', '\x2', '\x2', '\x2052', '\x204F', '\x3', '\x2', 
		'\x2', '\x2', '\x2052', '\x2053', '\x3', '\x2', '\x2', '\x2', '\x2053', 
		'\x2065', '\x3', '\x2', '\x2', '\x2', '\x2054', '\x2055', '\a', '\x115', 
		'\x2', '\x2', '\x2055', '\x205A', '\t', '\x82', '\x2', '\x2', '\x2056', 
		'\x2057', '\a', '\x2F2', '\x2', '\x2', '\x2057', '\x2058', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x2058', '\x2059', '\a', '\x2F3', '\x2', '\x2', '\x2059', 
		'\x205B', '\x3', '\x2', '\x2', '\x2', '\x205A', '\x2056', '\x3', '\x2', 
		'\x2', '\x2', '\x205A', '\x205B', '\x3', '\x2', '\x2', '\x2', '\x205B', 
		'\x205C', '\x3', '\x2', '\x2', '\x2', '\x205C', '\x205D', '\a', '\x26E', 
		'\x2', '\x2', '\x205D', '\x2062', '\t', '\x83', '\x2', '\x2', '\x205E', 
		'\x205F', '\a', '\x2F2', '\x2', '\x2', '\x205F', '\x2060', '\x5', '\x37E', 
		'\x1C0', '\x2', '\x2060', '\x2061', '\a', '\x2F3', '\x2', '\x2', '\x2061', 
		'\x2063', '\x3', '\x2', '\x2', '\x2', '\x2062', '\x205E', '\x3', '\x2', 
		'\x2', '\x2', '\x2062', '\x2063', '\x3', '\x2', '\x2', '\x2', '\x2063', 
		'\x2065', '\x3', '\x2', '\x2', '\x2', '\x2064', '\x2045', '\x3', '\x2', 
		'\x2', '\x2', '\x2064', '\x2054', '\x3', '\x2', '\x2', '\x2', '\x2065', 
		'\x457', '\x3', '\x2', '\x2', '\x2', '\x2066', '\x2067', '\a', '\x2F2', 
		'\x2', '\x2', '\x2067', '\x206A', '\x5', '\x4A6', '\x254', '\x2', '\x2068', 
		'\x2069', '\a', '\x2F8', '\x2', '\x2', '\x2069', '\x206B', '\x5', '\x4A6', 
		'\x254', '\x2', '\x206A', '\x2068', '\x3', '\x2', '\x2', '\x2', '\x206A', 
		'\x206B', '\x3', '\x2', '\x2', '\x2', '\x206B', '\x206D', '\x3', '\x2', 
		'\x2', '\x2', '\x206C', '\x206E', '\t', '\x84', '\x2', '\x2', '\x206D', 
		'\x206C', '\x3', '\x2', '\x2', '\x2', '\x206D', '\x206E', '\x3', '\x2', 
		'\x2', '\x2', '\x206E', '\x206F', '\x3', '\x2', '\x2', '\x2', '\x206F', 
		'\x2070', '\a', '\x2F3', '\x2', '\x2', '\x2070', '\x459', '\x3', '\x2', 
		'\x2', '\x2', '\x2071', '\x20AE', '\a', '\x34', '\x2', '\x2', '\x2072', 
		'\x20AE', '\a', '\x1C6', '\x2', '\x2', '\x2073', '\x20AE', '\a', '\x169', 
		'\x2', '\x2', '\x2074', '\x20AE', '\a', '\x33', '\x2', '\x2', '\x2075', 
		'\x20AE', '\a', '\x32', '\x2', '\x2', '\x2076', '\x20AE', '\a', '\x16A', 
		'\x2', '\x2', '\x2077', '\x20AE', '\a', '\x1CA', '\x2', '\x2', '\x2078', 
		'\x20AE', '\a', '\x1C9', '\x2', '\x2', '\x2079', '\x20AE', '\a', '\x22B', 
		'\x2', '\x2', '\x207A', '\x20AE', '\a', '\x22C', '\x2', '\x2', '\x207B', 
		'\x20AE', '\a', '\x191', '\x2', '\x2', '\x207C', '\x20AE', '\a', '\x88', 
		'\x2', '\x2', '\x207D', '\x20AE', '\a', '\x113', '\x2', '\x2', '\x207E', 
		'\x20AE', '\a', '\x117', '\x2', '\x2', '\x207F', '\x20AE', '\a', '\x190', 
		'\x2', '\x2', '\x2080', '\x20AE', '\a', '\x231', '\x2', '\x2', '\x2081', 
		'\x20AE', '\a', '\x18F', '\x2', '\x2', '\x2082', '\x20AE', '\a', '\x89', 
		'\x2', '\x2', '\x2083', '\x2085', '\a', '\xA4', '\x2', '\x2', '\x2084', 
		'\x2086', '\a', '\x1CD', '\x2', '\x2', '\x2085', '\x2084', '\x3', '\x2', 
		'\x2', '\x2', '\x2085', '\x2086', '\x3', '\x2', '\x2', '\x2', '\x2086', 
		'\x20AE', '\x3', '\x2', '\x2', '\x2', '\x2087', '\x20AE', '\a', '\xD6', 
		'\x2', '\x2', '\x2088', '\x20AE', '\a', '\x1E2', '\x2', '\x2', '\x2089', 
		'\x20AE', '\a', '\x16D', '\x2', '\x2', '\x208A', '\x208C', '\a', '\x143', 
		'\x2', '\x2', '\x208B', '\x208D', '\a', '\x1DF', '\x2', '\x2', '\x208C', 
		'\x208B', '\x3', '\x2', '\x2', '\x2', '\x208C', '\x208D', '\x3', '\x2', 
		'\x2', '\x2', '\x208D', '\x20AE', '\x3', '\x2', '\x2', '\x2', '\x208E', 
		'\x20AE', '\a', 'K', '\x2', '\x2', '\x208F', '\x20AE', '\a', 'J', '\x2', 
		'\x2', '\x2090', '\x20AE', '\a', '\x292', '\x2', '\x2', '\x2091', '\x20AE', 
		'\a', '\x293', '\x2', '\x2', '\x2092', '\x20AE', '\a', '\x244', '\x2', 
		'\x2', '\x2093', '\x20AE', '\a', '\x1DF', '\x2', '\x2', '\x2094', '\x20AE', 
		'\a', '\x39', '\x2', '\x2', '\x2095', '\x20AE', '\a', '\x80', '\x2', '\x2', 
		'\x2096', '\x20AE', '\a', '\x207', '\x2', '\x2', '\x2097', '\x20AE', '\a', 
		'\x289', '\x2', '\x2', '\x2098', '\x20AE', '\a', '\x2BB', '\x2', '\x2', 
		'\x2099', '\x20AE', '\a', '\x163', '\x2', '\x2', '\x209A', '\x20AE', '\a', 
		'\x81', '\x2', '\x2', '\x209B', '\x20AE', '\a', '\xF3', '\x2', '\x2', 
		'\x209C', '\x20AE', '\a', '\x15C', '\x2', '\x2', '\x209D', '\x20AE', '\a', 
		'\x216', '\x2', '\x2', '\x209E', '\x20AE', '\a', '\x267', '\x2', '\x2', 
		'\x209F', '\x20AE', '\a', '\x268', '\x2', '\x2', '\x20A0', '\x20AE', '\a', 
		'\x269', '\x2', '\x2', '\x20A1', '\x20AE', '\a', '\x266', '\x2', '\x2', 
		'\x20A2', '\x20AE', '\a', '\x262', '\x2', '\x2', '\x20A3', '\x20AE', '\a', 
		'\x264', '\x2', '\x2', '\x20A4', '\x20AE', '\a', '\x263', '\x2', '\x2', 
		'\x20A5', '\x20AE', '\a', '\x261', '\x2', '\x2', '\x20A6', '\x20AE', '\a', 
		'\x2BD', '\x2', '\x2', '\x20A7', '\x20AE', '\a', '\xA6', '\x2', '\x2', 
		'\x20A8', '\x20AE', '\a', '/', '\x2', '\x2', '\x20A9', '\x20AE', '\a', 
		'\x35', '\x2', '\x2', '\x20AA', '\x20AE', '\a', 'R', '\x2', '\x2', '\x20AB', 
		'\x20AE', '\a', '\x16E', '\x2', '\x2', '\x20AC', '\x20AE', '\a', '\x15E', 
		'\x2', '\x2', '\x20AD', '\x2071', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2072', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2073', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2074', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2075', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2076', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2077', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2078', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2079', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x207A', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x207B', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x207C', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x207D', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x207E', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x207F', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2080', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2081', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2082', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2083', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2087', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2088', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2089', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x208A', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x208E', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x208F', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2090', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2091', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2092', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2093', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2094', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2095', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2096', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x2097', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x2098', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x2099', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x209A', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x209B', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x209C', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x209D', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x209E', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x209F', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x20A0', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x20A1', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x20A2', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x20A3', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x20A4', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x20A5', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x20A6', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x20A7', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x20A8', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x20A9', '\x3', '\x2', 
		'\x2', '\x2', '\x20AD', '\x20AA', '\x3', '\x2', '\x2', '\x2', '\x20AD', 
		'\x20AB', '\x3', '\x2', '\x2', '\x2', '\x20AD', '\x20AC', '\x3', '\x2', 
		'\x2', '\x2', '\x20AE', '\x45B', '\x3', '\x2', '\x2', '\x2', '\x20AF', 
		'\x20B3', '\a', '\x2FC', '\x2', '\x2', '\x20B0', '\x20B1', '\a', '\x303', 
		'\x2', '\x2', '\x20B1', '\x20B3', '\a', '\x2EC', '\x2', '\x2', '\x20B2', 
		'\x20AF', '\x3', '\x2', '\x2', '\x2', '\x20B2', '\x20B0', '\x3', '\x2', 
		'\x2', '\x2', '\x20B3', '\x20BC', '\x3', '\x2', '\x2', '\x2', '\x20B4', 
		'\x20B6', '\a', '\x104', '\x2', '\x2', '\x20B5', '\x20B4', '\x3', '\x2', 
		'\x2', '\x2', '\x20B5', '\x20B6', '\x3', '\x2', '\x2', '\x2', '\x20B6', 
		'\x20BA', '\x3', '\x2', '\x2', '\x2', '\x20B7', '\x20BB', '\a', '\x2FC', 
		'\x2', '\x2', '\x20B8', '\x20B9', '\a', '\x303', '\x2', '\x2', '\x20B9', 
		'\x20BB', '\a', '\x2EC', '\x2', '\x2', '\x20BA', '\x20B7', '\x3', '\x2', 
		'\x2', '\x2', '\x20BA', '\x20B8', '\x3', '\x2', '\x2', '\x2', '\x20BB', 
		'\x20BD', '\x3', '\x2', '\x2', '\x2', '\x20BC', '\x20B5', '\x3', '\x2', 
		'\x2', '\x2', '\x20BC', '\x20BD', '\x3', '\x2', '\x2', '\x2', '\x20BD', 
		'\x20C2', '\x3', '\x2', '\x2', '\x2', '\x20BE', '\x20BF', '\a', '\x2EB', 
		'\x2', '\x2', '\x20BF', '\x20C1', '\x5', '\x460', '\x231', '\x2', '\x20C0', 
		'\x20BE', '\x3', '\x2', '\x2', '\x2', '\x20C1', '\x20C4', '\x3', '\x2', 
		'\x2', '\x2', '\x20C2', '\x20C0', '\x3', '\x2', '\x2', '\x2', '\x20C2', 
		'\x20C3', '\x3', '\x2', '\x2', '\x2', '\x20C3', '\x45D', '\x3', '\x2', 
		'\x2', '\x2', '\x20C4', '\x20C2', '\x3', '\x2', '\x2', '\x2', '\x20C5', 
		'\x20CA', '\x5', '\x460', '\x231', '\x2', '\x20C6', '\x20C7', '\a', '\x2EB', 
		'\x2', '\x2', '\x20C7', '\x20C9', '\x5', '\x460', '\x231', '\x2', '\x20C8', 
		'\x20C6', '\x3', '\x2', '\x2', '\x2', '\x20C9', '\x20CC', '\x3', '\x2', 
		'\x2', '\x2', '\x20CA', '\x20C8', '\x3', '\x2', '\x2', '\x2', '\x20CA', 
		'\x20CB', '\x3', '\x2', '\x2', '\x2', '\x20CB', '\x45F', '\x3', '\x2', 
		'\x2', '\x2', '\x20CC', '\x20CA', '\x3', '\x2', '\x2', '\x2', '\x20CD', 
		'\x20CE', '\a', '\x30A', '\x2', '\x2', '\x20CE', '\x20D0', '\x5', '\x49A', 
		'\x24E', '\x2', '\x20CF', '\x20CD', '\x3', '\x2', '\x2', '\x2', '\x20CF', 
		'\x20D0', '\x3', '\x2', '\x2', '\x2', '\x20D0', '\x20D1', '\x3', '\x2', 
		'\x2', '\x2', '\x20D1', '\x20D4', '\x5', '\x494', '\x24B', '\x2', '\x20D2', 
		'\x20D3', '\a', '\x2FA', '\x2', '\x2', '\x20D3', '\x20D5', '\x5', '\x414', 
		'\x20B', '\x2', '\x20D4', '\x20D2', '\x3', '\x2', '\x2', '\x2', '\x20D4', 
		'\x20D5', '\x3', '\x2', '\x2', '\x2', '\x20D5', '\x20D7', '\x3', '\x2', 
		'\x2', '\x2', '\x20D6', '\x20D8', '\x5', '\x3F0', '\x1F9', '\x2', '\x20D7', 
		'\x20D6', '\x3', '\x2', '\x2', '\x2', '\x20D7', '\x20D8', '\x3', '\x2', 
		'\x2', '\x2', '\x20D8', '\x20DA', '\x3', '\x2', '\x2', '\x2', '\x20D9', 
		'\x20DB', '\x5', '\x44C', '\x227', '\x2', '\x20DA', '\x20D9', '\x3', '\x2', 
		'\x2', '\x2', '\x20DA', '\x20DB', '\x3', '\x2', '\x2', '\x2', '\x20DB', 
		'\x461', '\x3', '\x2', '\x2', '\x2', '\x20DC', '\x20DD', '\a', '\x30A', 
		'\x2', '\x2', '\x20DD', '\x20DF', '\x5', '\x49A', '\x24E', '\x2', '\x20DE', 
		'\x20DC', '\x3', '\x2', '\x2', '\x2', '\x20DE', '\x20DF', '\x3', '\x2', 
		'\x2', '\x2', '\x20DF', '\x20E0', '\x3', '\x2', '\x2', '\x2', '\x20E0', 
		'\x20E1', '\x5', '\x494', '\x24B', '\x2', '\x20E1', '\x463', '\x3', '\x2', 
		'\x2', '\x2', '\x20E2', '\x20E4', '\a', '\xE', '\x2', '\x2', '\x20E3', 
		'\x20E5', '\a', '\x1D4', '\x2', '\x2', '\x20E4', '\x20E3', '\x3', '\x2', 
		'\x2', '\x2', '\x20E4', '\x20E5', '\x3', '\x2', '\x2', '\x2', '\x20E5', 
		'\x2104', '\x3', '\x2', '\x2', '\x2', '\x20E6', '\x2104', '\a', '\x10', 
		'\x2', '\x2', '\x20E7', '\x2104', '\a', '\x87', '\x2', '\x2', '\x20E8', 
		'\x2104', '\a', '\x95', '\x2', '\x2', '\x20E9', '\x2104', '\a', '\xC3', 
		'\x2', '\x2', '\x20EA', '\x2104', '\a', '\xD4', '\x2', '\x2', '\x20EB', 
		'\x20EC', '\a', '\xD4', '\x2', '\x2', '\x20EC', '\x2104', '\a', '\x17', 
		'\x2', '\x2', '\x20ED', '\x2104', '\a', '\x101', '\x2', '\x2', '\x20EE', 
		'\x20EF', '\a', '\x107', '\x2', '\x2', '\x20EF', '\x2104', '\a', '\x1D4', 
		'\x2', '\x2', '\x20F0', '\x2104', '\a', '\x110', '\x2', '\x2', '\x20F1', 
		'\x20F2', '\a', '\x122', '\x2', '\x2', '\x20F2', '\x2104', '\a', '\x21C', 
		'\x2', '\x2', '\x20F3', '\x20F4', '\a', '\x156', '\x2', '\x2', '\x20F4', 
		'\x2104', '\a', '\x29A', '\x2', '\x2', '\x20F5', '\x20F6', '\a', '\x19B', 
		'\x2', '\x2', '\x20F6', '\x20F7', '\a', '[', '\x2', '\x2', '\x20F7', '\x2104', 
		'\a', '\x1EA', '\x2', '\x2', '\x20F8', '\x20F9', '\a', '\x1DB', '\x2', 
		'\x2', '\x20F9', '\x2104', '\a', '\x200', '\x2', '\x2', '\x20FA', '\x2104', 
		'\a', '\x1E0', '\x2', '\x2', '\x20FB', '\x2104', '\a', '\x1E7', '\x2', 
		'\x2', '\x20FC', '\x2104', '\a', '\x21A', '\x2', '\x2', '\x20FD', '\x20FE', 
		'\a', '\x272', '\x2', '\x2', '\x20FE', '\x2104', '\a', '\x23A', '\x2', 
		'\x2', '\x20FF', '\x2104', '\a', '\x27C', '\x2', '\x2', '\x2100', '\x2104', 
		'\a', '\x287', '\x2', '\x2', '\x2101', '\x2104', '\a', '\x28D', '\x2', 
		'\x2', '\x2102', '\x2104', '\a', '\x2A8', '\x2', '\x2', '\x2103', '\x20E2', 
		'\x3', '\x2', '\x2', '\x2', '\x2103', '\x20E6', '\x3', '\x2', '\x2', '\x2', 
		'\x2103', '\x20E7', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x20E8', '\x3', 
		'\x2', '\x2', '\x2', '\x2103', '\x20E9', '\x3', '\x2', '\x2', '\x2', '\x2103', 
		'\x20EA', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x20EB', '\x3', '\x2', 
		'\x2', '\x2', '\x2103', '\x20ED', '\x3', '\x2', '\x2', '\x2', '\x2103', 
		'\x20EE', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x20F0', '\x3', '\x2', 
		'\x2', '\x2', '\x2103', '\x20F1', '\x3', '\x2', '\x2', '\x2', '\x2103', 
		'\x20F3', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x20F5', '\x3', '\x2', 
		'\x2', '\x2', '\x2103', '\x20F8', '\x3', '\x2', '\x2', '\x2', '\x2103', 
		'\x20FA', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x20FB', '\x3', '\x2', 
		'\x2', '\x2', '\x2103', '\x20FC', '\x3', '\x2', '\x2', '\x2', '\x2103', 
		'\x20FD', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x20FF', '\x3', '\x2', 
		'\x2', '\x2', '\x2103', '\x2100', '\x3', '\x2', '\x2', '\x2', '\x2103', 
		'\x2101', '\x3', '\x2', '\x2', '\x2', '\x2103', '\x2102', '\x3', '\x2', 
		'\x2', '\x2', '\x2104', '\x465', '\x3', '\x2', '\x2', '\x2', '\x2105', 
		'\x2106', '\a', '\xE', '\x2', '\x2', '\x2106', '\x224C', '\a', '\x1D4', 
		'\x2', '\x2', '\x2107', '\x224C', '\a', '\t', '\x2', '\x2', '\x2108', 
		'\x210A', '\a', '\a', '\x2', '\x2', '\x2109', '\x210B', '\a', '\x14', 
		'\x2', '\x2', '\x210A', '\x2109', '\x3', '\x2', '\x2', '\x2', '\x210A', 
		'\x210B', '\x3', '\x2', '\x2', '\x2', '\x210B', '\x210C', '\x3', '\x2', 
		'\x2', '\x2', '\x210C', '\x210D', '\a', '\x23A', '\x2', '\x2', '\x210D', 
		'\x210E', '\a', '\x279', '\x2', '\x2', '\x210E', '\x224C', '\a', '\x223', 
		'\x2', '\x2', '\x210F', '\x2110', '\t', '\x85', '\x2', '\x2', '\x2110', 
		'\x2111', '\a', '\x14', '\x2', '\x2', '\x2111', '\x2112', '\a', '\x23A', 
		'\x2', '\x2', '\x2112', '\x224C', '\a', '\x1D7', '\x2', '\x2', '\x2113', 
		'\x2114', '\a', '\a', '\x2', '\x2', '\x2114', '\x2115', '\a', '\x23A', 
		'\x2', '\x2', '\x2115', '\x2116', '\a', '\x148', '\x2', '\x2', '\x2116', 
		'\x224C', '\a', '\x192', '\x2', '\x2', '\x2117', '\x2119', '\a', 'r', 
		'\x2', '\x2', '\x2118', '\x211A', '\a', '\x14', '\x2', '\x2', '\x2119', 
		'\x2118', '\x3', '\x2', '\x2', '\x2', '\x2119', '\x211A', '\x3', '\x2', 
		'\x2', '\x2', '\x211A', '\x211B', '\x3', '\x2', '\x2', '\x2', '\x211B', 
		'\x224C', '\a', 'T', '\x2', '\x2', '\x211C', '\x211D', '\t', '\x86', '\x2', 
		'\x2', '\x211D', '\x211E', '\a', '\x14', '\x2', '\x2', '\x211E', '\x224C', 
		'\a', 'T', '\x2', '\x2', '\x211F', '\x2120', '\t', '\x87', '\x2', '\x2', 
		'\x2120', '\x2121', '\a', '\x14', '\x2', '\x2', '\x2121', '\x224C', '\a', 
		'k', '\x2', '\x2', '\x2122', '\x2123', '\a', '\xC4', '\x2', '\x2', '\x2123', 
		'\x2124', '\a', '\x1E5', '\x2', '\x2', '\x2124', '\x224C', '\a', '\x1C8', 
		'\x2', '\x2', '\x2125', '\x2126', '\a', '\x10', '\x2', '\x2', '\x2126', 
		'\x224C', '\a', '}', '\x2', '\x2', '\x2127', '\x2129', '\t', '\x88', '\x2', 
		'\x2', '\x2128', '\x212A', '\a', '\x1D9', '\x2', '\x2', '\x2129', '\x2128', 
		'\x3', '\x2', '\x2', '\x2', '\x2129', '\x212A', '\x3', '\x2', '\x2', '\x2', 
		'\x212A', '\x212B', '\x3', '\x2', '\x2', '\x2', '\x212B', '\x212C', '\a', 
		'}', '\x2', '\x2', '\x212C', '\x224C', '\a', '\x133', '\x2', '\x2', '\x212D', 
		'\x212E', '\a', '\xA5', '\x2', '\x2', '\x212E', '\x212F', '\a', '\x1D9', 
		'\x2', '\x2', '\x212F', '\x2130', '\a', '}', '\x2', '\x2', '\x2130', '\x224C', 
		'\a', '\x133', '\x2', '\x2', '\x2131', '\x2132', '\a', '\x87', '\x2', 
		'\x2', '\x2132', '\x2133', '\a', '\x63', '\x2', '\x2', '\x2133', '\x224C', 
		'\a', '\x221', '\x2', '\x2', '\x2134', '\x2135', '\a', '\x87', '\x2', 
		'\x2', '\x2135', '\x2136', '\a', '\x14', '\x2', '\x2', '\x2136', '\x224C', 
		'\a', '\x1D5', '\x2', '\x2', '\x2137', '\x2138', '\a', '\x12', '\x2', 
		'\x2', '\x2138', '\x2139', '\a', '\x14', '\x2', '\x2', '\x2139', '\x224C', 
		'\a', '\x99', '\x2', '\x2', '\x213A', '\x213C', '\a', 'r', '\x2', '\x2', 
		'\x213B', '\x213D', '\a', '\x14', '\x2', '\x2', '\x213C', '\x213B', '\x3', 
		'\x2', '\x2', '\x2', '\x213C', '\x213D', '\x3', '\x2', '\x2', '\x2', '\x213D', 
		'\x213E', '\x3', '\x2', '\x2', '\x2', '\x213E', '\x224C', '\a', '\x9A', 
		'\x2', '\x2', '\x213F', '\x2140', '\t', '\x86', '\x2', '\x2', '\x2140', 
		'\x2141', '\a', '\x14', '\x2', '\x2', '\x2141', '\x224C', '\a', '\x9A', 
		'\x2', '\x2', '\x2142', '\x2143', '\t', '\x87', '\x2', '\x2', '\x2143', 
		'\x2144', '\a', '\x14', '\x2', '\x2', '\x2144', '\x224C', '\a', '\x9B', 
		'\x2', '\x2', '\x2145', '\x2146', '\t', '\x87', '\x2', '\x2', '\x2146', 
		'\x2147', '\a', '\x14', '\x2', '\x2', '\x2147', '\x224C', '\a', '\xAA', 
		'\x2', '\x2', '\x2148', '\x214D', '\a', '\xD4', '\x2', '\x2', '\x2149', 
		'\x214A', '\a', '\x17', '\x2', '\x2', '\x214A', '\x214E', '\a', '\a', 
		'\x2', '\x2', '\x214B', '\x214C', '\a', '\x14', '\x2', '\x2', '\x214C', 
		'\x214E', '\a', '\x258', '\x2', '\x2', '\x214D', '\x2149', '\x3', '\x2', 
		'\x2', '\x2', '\x214D', '\x214B', '\x3', '\x2', '\x2', '\x2', '\x214E', 
		'\x224C', '\x3', '\x2', '\x2', '\x2', '\x214F', '\x2150', '\t', '\x85', 
		'\x2', '\x2', '\x2150', '\x2151', '\a', '\x14', '\x2', '\x2', '\x2151', 
		'\x224C', '\a', '\x101', '\x2', '\x2', '\x2152', '\x2154', '\a', 'r', 
		'\x2', '\x2', '\x2153', '\x2155', '\a', '\x14', '\x2', '\x2', '\x2154', 
		'\x2153', '\x3', '\x2', '\x2', '\x2', '\x2154', '\x2155', '\x3', '\x2', 
		'\x2', '\x2', '\x2155', '\x2156', '\x3', '\x2', '\x2', '\x2', '\x2156', 
		'\x224C', '\a', '\x103', '\x2', '\x2', '\x2157', '\x2158', '\t', '\x89', 
		'\x2', '\x2', '\x2158', '\x2159', '\a', '\x14', '\x2', '\x2', '\x2159', 
		'\x224C', '\a', '\x103', '\x2', '\x2', '\x215A', '\x215C', '\a', 'r', 
		'\x2', '\x2', '\x215B', '\x215D', '\t', '\x8A', '\x2', '\x2', '\x215C', 
		'\x215B', '\x3', '\x2', '\x2', '\x2', '\x215C', '\x215D', '\x3', '\x2', 
		'\x2', '\x2', '\x215D', '\x215E', '\x3', '\x2', '\x2', '\x2', '\x215E', 
		'\x224C', '\a', '\x11F', '\x2', '\x2', '\x215F', '\x2160', '\a', '\xC3', 
		'\x2', '\x2', '\x2160', '\x2161', '\a', '\x14', '\x2', '\x2', '\x2161', 
		'\x224C', '\t', '\x8B', '\x2', '\x2', '\x2162', '\x2163', '\a', '\x147', 
		'\x2', '\x2', '\x2163', '\x224C', '\a', '\x210', '\x2', '\x2', '\x2164', 
		'\x2165', '\a', '\a', '\x2', '\x2', '\x2165', '\x2166', '\a', '\x123', 
		'\x2', '\x2', '\x2166', '\x224C', '\a', '\x148', '\x2', '\x2', '\x2167', 
		'\x2169', '\a', 'r', '\x2', '\x2', '\x2168', '\x216A', '\a', '\x14', '\x2', 
		'\x2', '\x2169', '\x2168', '\x3', '\x2', '\x2', '\x2', '\x2169', '\x216A', 
		'\x3', '\x2', '\x2', '\x2', '\x216A', '\x216B', '\x3', '\x2', '\x2', '\x2', 
		'\x216B', '\x224C', '\a', '\x12C', '\x2', '\x2', '\x216C', '\x216D', '\t', 
		'\x89', '\x2', '\x2', '\x216D', '\x216E', '\a', '\x14', '\x2', '\x2', 
		'\x216E', '\x224C', '\a', '\x12C', '\x2', '\x2', '\x216F', '\x224C', '\a', 
		'\x140', '\x2', '\x2', '\x2170', '\x2172', '\a', 'r', '\x2', '\x2', '\x2171', 
		'\x2173', '\a', '\x14', '\x2', '\x2', '\x2172', '\x2171', '\x3', '\x2', 
		'\x2', '\x2', '\x2172', '\x2173', '\x3', '\x2', '\x2', '\x2', '\x2173', 
		'\x2174', '\x3', '\x2', '\x2', '\x2', '\x2174', '\x2175', '\a', '\x14D', 
		'\x2', '\x2', '\x2175', '\x224C', '\a', '\x29A', '\x2', '\x2', '\x2176', 
		'\x2177', '\t', '\x86', '\x2', '\x2', '\x2177', '\x2178', '\a', '\x14', 
		'\x2', '\x2', '\x2178', '\x2179', '\a', '\x14D', '\x2', '\x2', '\x2179', 
		'\x224C', '\a', '\x29A', '\x2', '\x2', '\x217A', '\x217C', '\a', '\xE5', 
		'\x2', '\x2', '\x217B', '\x217A', '\x3', '\x2', '\x2', '\x2', '\x217B', 
		'\x217C', '\x3', '\x2', '\x2', '\x2', '\x217C', '\x217D', '\x3', '\x2', 
		'\x2', '\x2', '\x217D', '\x217E', '\a', '\x1DB', '\x2', '\x2', '\x217E', 
		'\x224C', '\a', '\x200', '\x2', '\x2', '\x217F', '\x2180', '\a', '\x19B', 
		'\x2', '\x2', '\x2180', '\x2181', '\a', '[', '\x2', '\x2', '\x2181', '\x224C', 
		'\a', '\x1EA', '\x2', '\x2', '\x2182', '\x2184', '\a', 'r', '\x2', '\x2', 
		'\x2183', '\x2185', '\a', '\x14', '\x2', '\x2', '\x2184', '\x2183', '\x3', 
		'\x2', '\x2', '\x2', '\x2184', '\x2185', '\x3', '\x2', '\x2', '\x2', '\x2185', 
		'\x2186', '\x3', '\x2', '\x2', '\x2', '\x2186', '\x2187', '\a', '\x15A', 
		'\x2', '\x2', '\x2187', '\x224C', '\a', '\x15F', '\x2', '\x2', '\x2188', 
		'\x2189', '\t', '\x8C', '\x2', '\x2', '\x2189', '\x218A', '\a', '\x14', 
		'\x2', '\x2', '\x218A', '\x218B', '\a', '\x15A', '\x2', '\x2', '\x218B', 
		'\x224C', '\a', '\x15F', '\x2', '\x2', '\x218C', '\x218E', '\a', 'r', 
		'\x2', '\x2', '\x218D', '\x218F', '\a', '\x14', '\x2', '\x2', '\x218E', 
		'\x218D', '\x3', '\x2', '\x2', '\x2', '\x218E', '\x218F', '\x3', '\x2', 
		'\x2', '\x2', '\x218F', '\x2190', '\x3', '\x2', '\x2', '\x2', '\x2190', 
		'\x224C', '\a', 'v', '\x2', '\x2', '\x2191', '\x2192', '\t', '\x8D', '\x2', 
		'\x2', '\x2192', '\x2193', '\a', '\x14', '\x2', '\x2', '\x2193', '\x224C', 
		'\a', 'v', '\x2', '\x2', '\x2194', '\x2196', '\a', 'r', '\x2', '\x2', 
		'\x2195', '\x2197', '\a', '\x14', '\x2', '\x2', '\x2196', '\x2195', '\x3', 
		'\x2', '\x2', '\x2', '\x2196', '\x2197', '\x3', '\x2', '\x2', '\x2', '\x2197', 
		'\x2198', '\x3', '\x2', '\x2', '\x2', '\x2198', '\x2199', '\a', '\x151', 
		'\x2', '\x2', '\x2199', '\x224C', '\a', '\xD7', '\x2', '\x2', '\x219A', 
		'\x219B', '\t', '\x8E', '\x2', '\x2', '\x219B', '\x219C', '\a', '\x14', 
		'\x2', '\x2', '\x219C', '\x219D', '\a', '\x151', '\x2', '\x2', '\x219D', 
		'\x224C', '\a', '\xD7', '\x2', '\x2', '\x219E', '\x21A0', '\a', 'r', '\x2', 
		'\x2', '\x219F', '\x21A1', '\a', '\x14', '\x2', '\x2', '\x21A0', '\x219F', 
		'\x3', '\x2', '\x2', '\x2', '\x21A0', '\x21A1', '\x3', '\x2', '\x2', '\x2', 
		'\x21A1', '\x21A2', '\x3', '\x2', '\x2', '\x2', '\x21A2', '\x21A3', '\a', 
		'v', '\x2', '\x2', '\x21A3', '\x224C', '\a', '\x9A', '\x2', '\x2', '\x21A4', 
		'\x21A5', '\t', '\x8F', '\x2', '\x2', '\x21A5', '\x21A6', '\a', '\x14', 
		'\x2', '\x2', '\x21A6', '\x21A7', '\a', 'v', '\x2', '\x2', '\x21A7', '\x224C', 
		'\a', '\x9A', '\x2', '\x2', '\x21A8', '\x21AA', '\a', 'r', '\x2', '\x2', 
		'\x21A9', '\x21AB', '\a', '\x14', '\x2', '\x2', '\x21AA', '\x21A9', '\x3', 
		'\x2', '\x2', '\x2', '\x21AA', '\x21AB', '\x3', '\x2', '\x2', '\x2', '\x21AB', 
		'\x21AC', '\x3', '\x2', '\x2', '\x2', '\x21AC', '\x21AD', '\a', 'v', '\x2', 
		'\x2', '\x21AD', '\x21AE', '\a', '=', '\x2', '\x2', '\x21AE', '\x224C', 
		'\a', '\x1D6', '\x2', '\x2', '\x21AF', '\x21B0', '\t', '\x90', '\x2', 
		'\x2', '\x21B0', '\x21B1', '\a', '\x14', '\x2', '\x2', '\x21B1', '\x21B2', 
		'\a', 'v', '\x2', '\x2', '\x21B2', '\x21B3', '\a', '=', '\x2', '\x2', 
		'\x21B3', '\x224C', '\a', '\x1D6', '\x2', '\x2', '\x21B4', '\x21B6', '\a', 
		'r', '\x2', '\x2', '\x21B5', '\x21B7', '\a', '\x14', '\x2', '\x2', '\x21B6', 
		'\x21B5', '\x3', '\x2', '\x2', '\x2', '\x21B6', '\x21B7', '\x3', '\x2', 
		'\x2', '\x2', '\x21B7', '\x21B8', '\x3', '\x2', '\x2', '\x2', '\x21B8', 
		'\x224C', '\a', '\x19D', '\x2', '\x2', '\x21B9', '\x21BA', '\t', '\x89', 
		'\x2', '\x2', '\x21BA', '\x21BB', '\a', '\x14', '\x2', '\x2', '\x21BB', 
		'\x224C', '\a', '\x19D', '\x2', '\x2', '\x21BC', '\x21BD', '\t', '\x85', 
		'\x2', '\x2', '\x21BD', '\x21BE', '\a', '\x14', '\x2', '\x2', '\x21BE', 
		'\x224C', '\a', '\x1A7', '\x2', '\x2', '\x21BF', '\x21C0', '\a', 'r', 
		'\x2', '\x2', '\x21C0', '\x21C1', '\a', '\x1C7', '\x2', '\x2', '\x21C1', 
		'\x224C', '\a', '}', '\x2', '\x2', '\x21C2', '\x21C3', '\a', '\x223', 
		'\x2', '\x2', '\x21C3', '\x224C', '\a', 'h', '\x2', '\x2', '\x21C4', '\x21C6', 
		'\a', 'r', '\x2', '\x2', '\x21C5', '\x21C7', '\a', '\x14', '\x2', '\x2', 
		'\x21C6', '\x21C5', '\x3', '\x2', '\x2', '\x2', '\x21C6', '\x21C7', '\x3', 
		'\x2', '\x2', '\x2', '\x21C7', '\x21C8', '\x3', '\x2', '\x2', '\x2', '\x21C8', 
		'\x224C', '\a', '\x1D5', '\x2', '\x2', '\x21C9', '\x21CA', '\t', '\x89', 
		'\x2', '\x2', '\x21CA', '\x21CB', '\a', '\x14', '\x2', '\x2', '\x21CB', 
		'\x224C', '\a', '\x1D5', '\x2', '\x2', '\x21CC', '\x21CD', '\t', '\x85', 
		'\x2', '\x2', '\x21CD', '\x224C', '\a', '\x1D7', '\x2', '\x2', '\x21CE', 
		'\x21CF', '\a', 'r', '\x2', '\x2', '\x21CF', '\x224C', '\a', '\x202', 
		'\x2', '\x2', '\x21D0', '\x21D1', '\t', '\x91', '\x2', '\x2', '\x21D1', 
		'\x21D2', '\a', '\x14', '\x2', '\x2', '\x21D2', '\x224C', '\a', '\x202', 
		'\x2', '\x2', '\x21D3', '\x21D4', '\t', '\x85', '\x2', '\x2', '\x21D4', 
		'\x21D5', '\a', '\x204', '\x2', '\x2', '\x21D5', '\x224C', '\a', '\x219', 
		'\x2', '\x2', '\x21D6', '\x21D8', '\a', 'r', '\x2', '\x2', '\x21D7', '\x21D9', 
		'\a', '\x14', '\x2', '\x2', '\x21D8', '\x21D7', '\x3', '\x2', '\x2', '\x2', 
		'\x21D8', '\x21D9', '\x3', '\x2', '\x2', '\x2', '\x21D9', '\x21DA', '\x3', 
		'\x2', '\x2', '\x2', '\x21DA', '\x224C', '\a', '\x21C', '\x2', '\x2', 
		'\x21DB', '\x21DC', '\t', '\x92', '\x2', '\x2', '\x21DC', '\x21DD', '\a', 
		'\x14', '\x2', '\x2', '\x21DD', '\x224C', '\a', '\x21C', '\x2', '\x2', 
		'\x21DE', '\x21DF', '\t', '\x93', '\x2', '\x2', '\x21DF', '\x224C', '\a', 
		'\x221', '\x2', '\x2', '\x21E0', '\x21E1', '\a', '\x10', '\x2', '\x2', 
		'\x21E1', '\x21E2', '\a', '\x1F3', '\x2', '\x2', '\x21E2', '\x224C', '\a', 
		'p', '\x2', '\x2', '\x21E3', '\x21E5', '\a', 'r', '\x2', '\x2', '\x21E4', 
		'\x21E6', '\a', '\x14', '\x2', '\x2', '\x21E5', '\x21E4', '\x3', '\x2', 
		'\x2', '\x2', '\x21E5', '\x21E6', '\x3', '\x2', '\x2', '\x2', '\x21E6', 
		'\x21E7', '\x3', '\x2', '\x2', '\x2', '\x21E7', '\x21E8', '\a', '\x23A', 
		'\x2', '\x2', '\x21E8', '\x21E9', '\a', '\x273', '\x2', '\x2', '\x21E9', 
		'\x224C', '\a', '\x1D7', '\x2', '\x2', '\x21EA', '\x21EB', '\t', '\x94', 
		'\x2', '\x2', '\x21EB', '\x21EC', '\a', '\x14', '\x2', '\x2', '\x21EC', 
		'\x21ED', '\a', '\x23A', '\x2', '\x2', '\x21ED', '\x21EE', '\a', '\x273', 
		'\x2', '\x2', '\x21EE', '\x224C', '\a', '\x1D7', '\x2', '\x2', '\x21EF', 
		'\x21F0', '\a', '\x272', '\x2', '\x2', '\x21F0', '\x21F1', '\a', '\x14', 
		'\x2', '\x2', '\x21F1', '\x224C', '\a', '\x23A', '\x2', '\x2', '\x21F2', 
		'\x21F4', '\a', 'r', '\x2', '\x2', '\x21F3', '\x21F5', '\a', '\x14', '\x2', 
		'\x2', '\x21F4', '\x21F3', '\x3', '\x2', '\x2', '\x2', '\x21F4', '\x21F5', 
		'\x3', '\x2', '\x2', '\x2', '\x21F5', '\x21F6', '\x3', '\x2', '\x2', '\x2', 
		'\x21F6', '\x224C', '\a', '\x24D', '\x2', '\x2', '\x21F7', '\x21F8', '\a', 
		'\xA5', '\x2', '\x2', '\x21F8', '\x21F9', '\a', '\x14', '\x2', '\x2', 
		'\x21F9', '\x224C', '\a', '\x24D', '\x2', '\x2', '\x21FA', '\x21FB', '\t', 
		'\x87', '\x2', '\x2', '\x21FB', '\x21FC', '\a', '\x1D9', '\x2', '\x2', 
		'\x21FC', '\x224C', '\a', '\x24D', '\x2', '\x2', '\x21FD', '\x21FF', '\a', 
		'r', '\x2', '\x2', '\x21FE', '\x2200', '\a', '\x14', '\x2', '\x2', '\x21FF', 
		'\x21FE', '\x3', '\x2', '\x2', '\x2', '\x21FF', '\x2200', '\x3', '\x2', 
		'\x2', '\x2', '\x2200', '\x2201', '\x3', '\x2', '\x2', '\x2', '\x2201', 
		'\x224C', '\a', '\x258', '\x2', '\x2', '\x2202', '\x2203', '\t', '\x95', 
		'\x2', '\x2', '\x2203', '\x2204', '\a', '\x14', '\x2', '\x2', '\x2204', 
		'\x224C', '\a', '\x258', '\x2', '\x2', '\x2205', '\x2206', '\t', '\x96', 
		'\x2', '\x2', '\x2206', '\x224C', '\a', '\x256', '\x2', '\x2', '\x2207', 
		'\x2209', '\a', 'r', '\x2', '\x2', '\x2208', '\x220A', '\a', '\x14', '\x2', 
		'\x2', '\x2209', '\x2208', '\x3', '\x2', '\x2', '\x2', '\x2209', '\x220A', 
		'\x3', '\x2', '\x2', '\x2', '\x220A', '\x220B', '\x3', '\x2', '\x2', '\x2', 
		'\x220B', '\x224C', '\a', '\x275', '\x2', '\x2', '\x220C', '\x220D', '\t', 
		'\x86', '\x2', '\x2', '\x220D', '\x220E', '\a', '\x14', '\x2', '\x2', 
		'\x220E', '\x224C', '\a', '\x275', '\x2', '\x2', '\x220F', '\x2210', '\a', 
		'\a', '\x2', '\x2', '\x2210', '\x2211', '\a', '}', '\x2', '\x2', '\x2211', 
		'\x224C', '\a', '\x275', '\x2', '\x2', '\x2212', '\x2214', '\a', 'r', 
		'\x2', '\x2', '\x2213', '\x2215', '\a', '\x14', '\x2', '\x2', '\x2214', 
		'\x2213', '\x3', '\x2', '\x2', '\x2', '\x2214', '\x2215', '\x3', '\x2', 
		'\x2', '\x2', '\x2215', '\x2216', '\x3', '\x2', '\x2', '\x2', '\x2216', 
		'\x224C', '\a', '\x27A', '\x2', '\x2', '\x2217', '\x2218', '\t', '\x97', 
		'\x2', '\x2', '\x2218', '\x2219', '\a', '\x14', '\x2', '\x2', '\x2219', 
		'\x224C', '\a', '\x27A', '\x2', '\x2', '\x221A', '\x221B', '\t', '\x85', 
		'\x2', '\x2', '\x221B', '\x224C', '\a', '\x28C', '\x2', '\x2', '\x221C', 
		'\x221E', '\a', 'r', '\x2', '\x2', '\x221D', '\x221F', '\a', '\x14', '\x2', 
		'\x2', '\x221E', '\x221D', '\x3', '\x2', '\x2', '\x2', '\x221E', '\x221F', 
		'\x3', '\x2', '\x2', '\x2', '\x221F', '\x2220', '\x3', '\x2', '\x2', '\x2', 
		'\x2220', '\x224C', '\a', '\x29A', '\x2', '\x2', '\x2221', '\x2222', '\t', 
		'\x98', '\x2', '\x2', '\x2222', '\x2223', '\a', '\x14', '\x2', '\x2', 
		'\x2223', '\x224C', '\a', '\x29A', '\x2', '\x2', '\x2224', '\x2225', '\t', 
		'\x99', '\x2', '\x2', '\x2225', '\x224C', '\a', '\x14', '\x2', '\x2', 
		'\x2226', '\x2227', '\a', '+', '\x2', '\x2', '\x2227', '\x224C', '\a', 
		'\x28C', '\x2', '\x2', '\x2228', '\x2229', '\a', 'I', '\x2', '\x2', '\x2229', 
		'\x224C', '\a', '\x189', '\x2', '\x2', '\x222A', '\x222B', '\a', '\xC4', 
		'\x2', '\x2', '\x222B', '\x222C', '\a', '\x3', '\x2', '\x2', '\x222C', 
		'\x224C', '\a', '\x1C8', '\x2', '\x2', '\x222D', '\x222F', '\a', '\xDB', 
		'\x2', '\x2', '\x222E', '\x2230', '\a', '\x14', '\x2', '\x2', '\x222F', 
		'\x222E', '\x3', '\x2', '\x2', '\x2', '\x222F', '\x2230', '\x3', '\x2', 
		'\x2', '\x2', '\x2230', '\x2231', '\x3', '\x2', '\x2', '\x2', '\x2231', 
		'\x224C', '\a', '\x271', '\x2', '\x2', '\x2232', '\x2233', '\a', '\xE8', 
		'\x2', '\x2', '\x2233', '\x2235', '\a', '\x14', '\x2', '\x2', '\x2234', 
		'\x2236', '\a', '\x192', '\x2', '\x2', '\x2235', '\x2234', '\x3', '\x2', 
		'\x2', '\x2', '\x2235', '\x2236', '\x3', '\x2', '\x2', '\x2', '\x2236', 
		'\x2237', '\x3', '\x2', '\x2', '\x2', '\x2237', '\x224C', '\a', '\x1D3', 
		'\x2', '\x2', '\x2238', '\x2239', '\a', '\x107', '\x2', '\x2', '\x2239', 
		'\x223A', '\a', '\x14', '\x2', '\x2', '\x223A', '\x224C', '\a', '\x1D4', 
		'\x2', '\x2', '\x223B', '\x223C', '\a', '\x122', '\x2', '\x2', '\x223C', 
		'\x223D', '\a', '\x80', '\x2', '\x2', '\x223D', '\x224C', '\a', '\x265', 
		'\x2', '\x2', '\x223E', '\x223F', '\a', '\x122', '\x2', '\x2', '\x223F', 
		'\x224C', '\a', '\x252', '\x2', '\x2', '\x2240', '\x2241', '\a', '\x1DA', 
		'\x2', '\x2', '\x2241', '\x224C', '\a', '\x83', '\x2', '\x2', '\x2242', 
		'\x224C', '\a', '\x1F9', '\x2', '\x2', '\x2243', '\x2244', '\a', '\x21A', 
		'\x2', '\x2', '\x2244', '\x2245', '\a', '\x14', '\x2', '\x2', '\x2245', 
		'\x224C', '\t', '\x9A', '\x2', '\x2', '\x2246', '\x224C', '\a', '\x24E', 
		'\x2', '\x2', '\x2247', '\x224C', '\a', '\x250', '\x2', '\x2', '\x2248', 
		'\x224C', '\a', '\x251', '\x2', '\x2', '\x2249', '\x224C', '\a', '\x253', 
		'\x2', '\x2', '\x224A', '\x224C', '\a', '\x254', '\x2', '\x2', '\x224B', 
		'\x2105', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2107', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2108', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x210F', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2113', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2117', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x211C', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x211F', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2122', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2125', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2127', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x212D', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2131', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2134', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2137', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x213A', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x213F', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2142', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2145', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2148', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x214F', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2152', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2157', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x215A', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x215F', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2162', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2164', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2167', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x216C', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x216F', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2170', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2176', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x217B', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x217F', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2182', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2188', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x218C', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2191', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2194', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x219A', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x219E', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21A4', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21A8', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21AF', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21B4', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21B9', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21BC', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21BF', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21C2', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21C4', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21C9', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21CC', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21CE', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21D0', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21D3', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21D6', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21DB', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21DE', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21E0', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21E3', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21EA', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21EF', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21F2', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x21F7', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x21FA', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x21FD', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2202', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2205', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2207', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x220C', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x220F', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2212', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2217', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x221A', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x221C', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2221', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2224', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2226', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2228', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x222A', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x222D', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2232', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2238', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x223B', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x223E', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2240', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2242', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2243', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2246', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x2247', '\x3', '\x2', '\x2', '\x2', '\x224B', 
		'\x2248', '\x3', '\x2', '\x2', '\x2', '\x224B', '\x2249', '\x3', '\x2', 
		'\x2', '\x2', '\x224B', '\x224A', '\x3', '\x2', '\x2', '\x2', '\x224C', 
		'\x467', '\x3', '\x2', '\x2', '\x2', '\x224D', '\x2250', '\x5', '\x46C', 
		'\x237', '\x2', '\x224E', '\x2250', '\x5', '\x296', '\x14C', '\x2', '\x224F', 
		'\x224D', '\x3', '\x2', '\x2', '\x2', '\x224F', '\x224E', '\x3', '\x2', 
		'\x2', '\x2', '\x2250', '\x469', '\x3', '\x2', '\x2', '\x2', '\x2251', 
		'\x2252', '\a', '\x80', '\x2', '\x2', '\x2252', '\x2255', '\x5', '\x4AA', 
		'\x256', '\x2', '\x2253', '\x2255', '\x5', '\x296', '\x14C', '\x2', '\x2254', 
		'\x2251', '\x3', '\x2', '\x2', '\x2', '\x2254', '\x2253', '\x3', '\x2', 
		'\x2', '\x2', '\x2255', '\x46B', '\x3', '\x2', '\x2', '\x2', '\x2256', 
		'\x2259', '\a', '\x262', '\x2', '\x2', '\x2257', '\x225A', '\x5', '\x4AA', 
		'\x256', '\x2', '\x2258', '\x225A', '\x5', '\x45C', '\x22F', '\x2', '\x2259', 
		'\x2257', '\x3', '\x2', '\x2', '\x2', '\x2259', '\x2258', '\x3', '\x2', 
		'\x2', '\x2', '\x225A', '\x225F', '\x3', '\x2', '\x2', '\x2', '\x225B', 
		'\x225C', '\a', '\x1C', '\x2', '\x2', '\x225C', '\x225D', '\a', '\x265', 
		'\x2', '\x2', '\x225D', '\x225E', '\a', '\x2BF', '\x2', '\x2', '\x225E', 
		'\x2260', '\x5', '\x4AA', '\x256', '\x2', '\x225F', '\x225B', '\x3', '\x2', 
		'\x2', '\x2', '\x225F', '\x2260', '\x3', '\x2', '\x2', '\x2', '\x2260', 
		'\x2295', '\x3', '\x2', '\x2', '\x2', '\x2261', '\x2265', '\a', '\x115', 
		'\x2', '\x2', '\x2262', '\x2266', '\x5', '\x4AA', '\x256', '\x2', '\x2263', 
		'\x2266', '\x5', '\x45C', '\x22F', '\x2', '\x2264', '\x2266', '\x5', '\x460', 
		'\x231', '\x2', '\x2265', '\x2262', '\x3', '\x2', '\x2', '\x2', '\x2265', 
		'\x2263', '\x3', '\x2', '\x2', '\x2', '\x2265', '\x2264', '\x3', '\x2', 
		'\x2', '\x2', '\x2266', '\x2267', '\x3', '\x2', '\x2', '\x2', '\x2267', 
		'\x2275', '\t', '\x9B', '\x2', '\x2', '\x2268', '\x226B', '\a', '\x2F2', 
		'\x2', '\x2', '\x2269', '\x226C', '\a', '\x2EC', '\x2', '\x2', '\x226A', 
		'\x226C', '\x5', '\x45C', '\x22F', '\x2', '\x226B', '\x2269', '\x3', '\x2', 
		'\x2', '\x2', '\x226B', '\x226A', '\x3', '\x2', '\x2', '\x2', '\x226C', 
		'\x2272', '\x3', '\x2', '\x2', '\x2', '\x226D', '\x2270', '\a', '\x2F8', 
		'\x2', '\x2', '\x226E', '\x2271', '\a', '\x2EC', '\x2', '\x2', '\x226F', 
		'\x2271', '\x5', '\x45C', '\x22F', '\x2', '\x2270', '\x226E', '\x3', '\x2', 
		'\x2', '\x2', '\x2270', '\x226F', '\x3', '\x2', '\x2', '\x2', '\x2271', 
		'\x2273', '\x3', '\x2', '\x2', '\x2', '\x2272', '\x226D', '\x3', '\x2', 
		'\x2', '\x2', '\x2272', '\x2273', '\x3', '\x2', '\x2', '\x2', '\x2273', 
		'\x2274', '\x3', '\x2', '\x2', '\x2', '\x2274', '\x2276', '\a', '\x2F3', 
		'\x2', '\x2', '\x2275', '\x2268', '\x3', '\x2', '\x2', '\x2', '\x2275', 
		'\x2276', '\x3', '\x2', '\x2', '\x2', '\x2276', '\x2286', '\x3', '\x2', 
		'\x2', '\x2', '\x2277', '\x2284', '\a', '\x26E', '\x2', '\x2', '\x2278', 
		'\x2285', '\a', '\x81', '\x2', '\x2', '\x2279', '\x2285', '\a', '\xF3', 
		'\x2', '\x2', '\x227A', '\x2285', '\a', '\x15C', '\x2', '\x2', '\x227B', 
		'\x2282', '\a', '\x216', '\x2', '\x2', '\x227C', '\x227F', '\a', '\x2F2', 
		'\x2', '\x2', '\x227D', '\x2280', '\a', '\x2EC', '\x2', '\x2', '\x227E', 
		'\x2280', '\x5', '\x45C', '\x22F', '\x2', '\x227F', '\x227D', '\x3', '\x2', 
		'\x2', '\x2', '\x227F', '\x227E', '\x3', '\x2', '\x2', '\x2', '\x2280', 
		'\x2281', '\x3', '\x2', '\x2', '\x2', '\x2281', '\x2283', '\a', '\x2F3', 
		'\x2', '\x2', '\x2282', '\x227C', '\x3', '\x2', '\x2', '\x2', '\x2282', 
		'\x2283', '\x3', '\x2', '\x2', '\x2', '\x2283', '\x2285', '\x3', '\x2', 
		'\x2', '\x2', '\x2284', '\x2278', '\x3', '\x2', '\x2', '\x2', '\x2284', 
		'\x2279', '\x3', '\x2', '\x2', '\x2', '\x2284', '\x227A', '\x3', '\x2', 
		'\x2', '\x2', '\x2284', '\x227B', '\x3', '\x2', '\x2', '\x2', '\x2285', 
		'\x2287', '\x3', '\x2', '\x2', '\x2', '\x2286', '\x2277', '\x3', '\x2', 
		'\x2', '\x2', '\x2286', '\x2287', '\x3', '\x2', '\x2', '\x2', '\x2287', 
		'\x2295', '\x3', '\x2', '\x2', '\x2', '\x2288', '\x2295', '\x5', '\x4A6', 
		'\x254', '\x2', '\x2289', '\x228A', '\a', '\x80', '\x2', '\x2', '\x228A', 
		'\x2295', '\x5', '\x4AA', '\x256', '\x2', '\x228B', '\x2295', '\x5', '\x4AA', 
		'\x256', '\x2', '\x228C', '\x2295', '\a', '\x18D', '\x2', '\x2', '\x228D', 
		'\x2295', '\a', '\x276', '\x2', '\x2', '\x228E', '\x2295', '\a', '\xCE', 
		'\x2', '\x2', '\x228F', '\x2295', '\a', '\x85', '\x2', '\x2', '\x2290', 
		'\x2295', '\a', '\x222', '\x2', '\x2', '\x2291', '\x2295', '\a', '\x15D', 
		'\x2', '\x2', '\x2292', '\x2295', '\a', '\x150', '\x2', '\x2', '\x2293', 
		'\x2295', '\a', '\x8F', '\x2', '\x2', '\x2294', '\x2256', '\x3', '\x2', 
		'\x2', '\x2', '\x2294', '\x2261', '\x3', '\x2', '\x2', '\x2', '\x2294', 
		'\x2288', '\x3', '\x2', '\x2', '\x2', '\x2294', '\x2289', '\x3', '\x2', 
		'\x2', '\x2', '\x2294', '\x228B', '\x3', '\x2', '\x2', '\x2', '\x2294', 
		'\x228C', '\x3', '\x2', '\x2', '\x2', '\x2294', '\x228D', '\x3', '\x2', 
		'\x2', '\x2', '\x2294', '\x228E', '\x3', '\x2', '\x2', '\x2', '\x2294', 
		'\x228F', '\x3', '\x2', '\x2', '\x2', '\x2294', '\x2290', '\x3', '\x2', 
		'\x2', '\x2', '\x2294', '\x2291', '\x3', '\x2', '\x2', '\x2', '\x2294', 
		'\x2292', '\x3', '\x2', '\x2', '\x2', '\x2294', '\x2293', '\x3', '\x2', 
		'\x2', '\x2', '\x2295', '\x46D', '\x3', '\x2', '\x2', '\x2', '\x2296', 
		'\x2297', '\a', '\x30A', '\x2', '\x2', '\x2297', '\x2299', '\x5', '\x49A', 
		'\x24E', '\x2', '\x2298', '\x2296', '\x3', '\x2', '\x2', '\x2', '\x2298', 
		'\x2299', '\x3', '\x2', '\x2', '\x2', '\x2299', '\x229A', '\x3', '\x2', 
		'\x2', '\x2', '\x229A', '\x229B', '\x5', '\x492', '\x24A', '\x2', '\x229B', 
		'\x46F', '\x3', '\x2', '\x2', '\x2', '\x229C', '\x229D', '\x5', '\x46E', 
		'\x238', '\x2', '\x229D', '\x471', '\x3', '\x2', '\x2', '\x2', '\x229E', 
		'\x229F', '\x5', '\x46E', '\x238', '\x2', '\x229F', '\x473', '\x3', '\x2', 
		'\x2', '\x2', '\x22A0', '\x22A1', '\x5', '\x46E', '\x238', '\x2', '\x22A1', 
		'\x475', '\x3', '\x2', '\x2', '\x2', '\x22A2', '\x22A3', '\x5', '\x46E', 
		'\x238', '\x2', '\x22A3', '\x477', '\x3', '\x2', '\x2', '\x2', '\x22A4', 
		'\x22A5', '\x5', '\x46E', '\x238', '\x2', '\x22A5', '\x479', '\x3', '\x2', 
		'\x2', '\x2', '\x22A6', '\x22A7', '\x5', '\x46E', '\x238', '\x2', '\x22A7', 
		'\x47B', '\x3', '\x2', '\x2', '\x2', '\x22A8', '\x22A9', '\x5', '\x46E', 
		'\x238', '\x2', '\x22A9', '\x47D', '\x3', '\x2', '\x2', '\x2', '\x22AA', 
		'\x22AB', '\x5', '\x46E', '\x238', '\x2', '\x22AB', '\x47F', '\x3', '\x2', 
		'\x2', '\x2', '\x22AC', '\x22AD', '\x5', '\x46E', '\x238', '\x2', '\x22AD', 
		'\x481', '\x3', '\x2', '\x2', '\x2', '\x22AE', '\x22AF', '\x5', '\x46E', 
		'\x238', '\x2', '\x22AF', '\x483', '\x3', '\x2', '\x2', '\x2', '\x22B0', 
		'\x22B1', '\x5', '\x46E', '\x238', '\x2', '\x22B1', '\x485', '\x3', '\x2', 
		'\x2', '\x2', '\x22B2', '\x22B3', '\x5', '\x46E', '\x238', '\x2', '\x22B3', 
		'\x487', '\x3', '\x2', '\x2', '\x2', '\x22B4', '\x22B5', '\x5', '\x46E', 
		'\x238', '\x2', '\x22B5', '\x489', '\x3', '\x2', '\x2', '\x2', '\x22B6', 
		'\x22BB', '\x5', '\x46E', '\x238', '\x2', '\x22B7', '\x22B8', '\a', '\x2EB', 
		'\x2', '\x2', '\x22B8', '\x22BA', '\x5', '\x492', '\x24A', '\x2', '\x22B9', 
		'\x22B7', '\x3', '\x2', '\x2', '\x2', '\x22BA', '\x22BD', '\x3', '\x2', 
		'\x2', '\x2', '\x22BB', '\x22B9', '\x3', '\x2', '\x2', '\x2', '\x22BB', 
		'\x22BC', '\x3', '\x2', '\x2', '\x2', '\x22BC', '\x48B', '\x3', '\x2', 
		'\x2', '\x2', '\x22BD', '\x22BB', '\x3', '\x2', '\x2', '\x2', '\x22BE', 
		'\x22BF', '\x5', '\x48A', '\x246', '\x2', '\x22BF', '\x48D', '\x3', '\x2', 
		'\x2', '\x2', '\x22C0', '\x22C1', '\x5', '\x48A', '\x246', '\x2', '\x22C1', 
		'\x48F', '\x3', '\x2', '\x2', '\x2', '\x22C2', '\x22C3', '\x5', '\x48A', 
		'\x246', '\x2', '\x22C3', '\x491', '\x3', '\x2', '\x2', '\x2', '\x22C4', 
		'\x22C7', '\x5', '\x49E', '\x250', '\x2', '\x22C5', '\x22C7', '\a', '\x2EF', 
		'\x2', '\x2', '\x22C6', '\x22C4', '\x3', '\x2', '\x2', '\x2', '\x22C6', 
		'\x22C5', '\x3', '\x2', '\x2', '\x2', '\x22C7', '\x493', '\x3', '\x2', 
		'\x2', '\x2', '\x22C8', '\x22CD', '\x5', '\x492', '\x24A', '\x2', '\x22C9', 
		'\x22CA', '\a', '\x2EB', '\x2', '\x2', '\x22CA', '\x22CC', '\x5', '\x492', 
		'\x24A', '\x2', '\x22CB', '\x22C9', '\x3', '\x2', '\x2', '\x2', '\x22CC', 
		'\x22CF', '\x3', '\x2', '\x2', '\x2', '\x22CD', '\x22CB', '\x3', '\x2', 
		'\x2', '\x2', '\x22CD', '\x22CE', '\x3', '\x2', '\x2', '\x2', '\x22CE', 
		'\x495', '\x3', '\x2', '\x2', '\x2', '\x22CF', '\x22CD', '\x3', '\x2', 
		'\x2', '\x2', '\x22D0', '\x22D1', '\x5', '\x494', '\x24B', '\x2', '\x22D1', 
		'\x497', '\x3', '\x2', '\x2', '\x2', '\x22D2', '\x22D3', '\x5', '\x494', 
		'\x24B', '\x2', '\x22D3', '\x499', '\x3', '\x2', '\x2', '\x2', '\x22D4', 
		'\x22D5', '\x5', '\x494', '\x24B', '\x2', '\x22D5', '\x49B', '\x3', '\x2', 
		'\x2', '\x2', '\x22D6', '\x22D7', '\a', '\x2F2', '\x2', '\x2', '\x22D7', 
		'\x22D8', '\a', '\x2F6', '\x2', '\x2', '\x22D8', '\x22D9', '\a', '\x2F3', 
		'\x2', '\x2', '\x22D9', '\x49D', '\x3', '\x2', '\x2', '\x2', '\x22DA', 
		'\x22DB', '\t', '\x9C', '\x2', '\x2', '\x22DB', '\x49F', '\x3', '\x2', 
		'\x2', '\x2', '\x22DC', '\x22DD', '\t', '\x9D', '\x2', '\x2', '\x22DD', 
		'\x4A1', '\x3', '\x2', '\x2', '\x2', '\x22DE', '\x22DF', '\t', '\x9E', 
		'\x2', '\x2', '\x22DF', '\x4A3', '\x3', '\x2', '\x2', '\x2', '\x22E0', 
		'\x22E3', '\x5', '\x4A6', '\x254', '\x2', '\x22E1', '\x22E3', '\x5', '\x4A8', 
		'\x255', '\x2', '\x22E2', '\x22E0', '\x3', '\x2', '\x2', '\x2', '\x22E2', 
		'\x22E1', '\x3', '\x2', '\x2', '\x2', '\x22E3', '\x4A5', '\x3', '\x2', 
		'\x2', '\x2', '\x22E4', '\x22E6', '\a', '\x2F6', '\x2', '\x2', '\x22E5', 
		'\x22E4', '\x3', '\x2', '\x2', '\x2', '\x22E5', '\x22E6', '\x3', '\x2', 
		'\x2', '\x2', '\x22E6', '\x22E7', '\x3', '\x2', '\x2', '\x2', '\x22E7', 
		'\x22EA', '\a', '\x2EC', '\x2', '\x2', '\x22E8', '\x22EA', '\a', '\x2ED', 
		'\x2', '\x2', '\x22E9', '\x22E5', '\x3', '\x2', '\x2', '\x2', '\x22E9', 
		'\x22E8', '\x3', '\x2', '\x2', '\x2', '\x22EA', '\x4A7', '\x3', '\x2', 
		'\x2', '\x2', '\x22EB', '\x22EC', '\a', '\x2F7', '\x2', '\x2', '\x22EC', 
		'\x22ED', '\a', '\x2EC', '\x2', '\x2', '\x22ED', '\x4A9', '\x3', '\x2', 
		'\x2', '\x2', '\x22EE', '\x22EF', '\t', '\x9F', '\x2', '\x2', '\x22EF', 
		'\x4AB', '\x3', '\x2', '\x2', '\x2', '\x4E9', '\x4AE', '\x4B1', '\x4B5', 
		'\x4DE', '\x4EA', '\x4EF', '\x4F4', '\x4FB', '\x501', '\x506', '\x50A', 
		'\x512', '\x514', '\x518', '\x51C', '\x51F', '\x523', '\x528', '\x52E', 
		'\x537', '\x53A', '\x540', '\x549', '\x556', '\x55B', '\x565', '\x568', 
		'\x56D', '\x572', '\x579', '\x57F', '\x583', '\x589', '\x58E', '\x595', 
		'\x59C', '\x5A3', '\x5A8', '\x5AC', '\x5B8', '\x5C2', '\x5C7', '\x5D3', 
		'\x5D8', '\x5DD', '\x5E0', '\x5ED', '\x5F9', '\x5FE', '\x603', '\x60F', 
		'\x614', '\x61C', '\x61E', '\x622', '\x626', '\x629', '\x62D', '\x632', 
		'\x63E', '\x643', '\x647', '\x64A', '\x64F', '\x656', '\x660', '\x665', 
		'\x668', '\x66C', '\x66F', '\x674', '\x686', '\x68B', '\x690', '\x692', 
		'\x699', '\x6A0', '\x6A3', '\x6A6', '\x6A9', '\x6B4', '\x6C0', '\x6C4', 
		'\x6C7', '\x6D0', '\x6D8', '\x6E0', '\x6E3', '\x6EA', '\x6ED', '\x6F0', 
		'\x6F5', '\x6FA', '\x723', '\x73F', '\x746', '\x74B', '\x752', '\x75D', 
		'\x765', '\x769', '\x775', '\x778', '\x77E', '\x781', '\x786', '\x78B', 
		'\x78F', '\x799', '\x7A3', '\x7A9', '\x7B4', '\x7B9', '\x7BD', '\x7C5', 
		'\x7CD', '\x7D2', '\x7D5', '\x7D7', '\x7DA', '\x7E3', '\x7E8', '\x7EF', 
		'\x7F2', '\x7F5', '\x7F9', '\x7FC', '\x804', '\x809', '\x80E', '\x815', 
		'\x81F', '\x82F', '\x835', '\x83F', '\x849', '\x850', '\x853', '\x858', 
		'\x862', '\x867', '\x86E', '\x871', '\x876', '\x879', '\x87C', '\x88D', 
		'\x892', '\x89B', '\x89E', '\x8A3', '\x8A6', '\x8AD', '\x8B0', '\x8B7', 
		'\x8BC', '\x8C0', '\x8C5', '\x8CA', '\x8D4', '\x8DA', '\x8E4', '\x8E9', 
		'\x8F0', '\x8F6', '\x8FA', '\x8FD', '\x900', '\x911', '\x916', '\x91E', 
		'\x92C', '\x933', '\x943', '\x94D', '\x956', '\x95C', '\x961', '\x967', 
		'\x96C', '\x970', '\x979', '\x97D', '\x995', '\x997', '\x9A9', '\x9AB', 
		'\x9B0', '\x9B5', '\x9BA', '\x9BF', '\x9C9', '\x9D2', '\x9DB', '\x9E0', 
		'\x9E5', '\x9EA', '\x9EE', '\x9F1', '\x9F7', '\xA05', '\xA0A', '\xA0C', 
		'\xA0F', '\xA17', '\xA24', '\xA26', '\xA2A', '\xA32', '\xA34', '\xA36', 
		'\xA38', '\xA3C', '\xA41', '\xA4B', '\xA56', '\xA58', '\xA62', '\xA67', 
		'\xA6B', '\xA6F', '\xA73', '\xA75', '\xA78', '\xA7C', '\xA80', '\xA87', 
		'\xA8C', '\xA8E', '\xA93', '\xA97', '\xA9D', '\xA9F', '\xAA3', '\xAA7', 
		'\xAAB', '\xAAF', '\xAB1', '\xAB6', '\xABB', '\xAC0', '\xAC3', '\xACE', 
		'\xAD1', '\xAD4', '\xAD9', '\xADC', '\xAE1', '\xAE6', '\xAEA', '\xAEE', 
		'\xAF2', '\xAF7', '\xAFB', '\xAFF', '\xB0B', '\xB10', '\xB13', '\xB17', 
		'\xB1B', '\xB20', '\xB24', '\xB2A', '\xB34', '\xB37', '\xB3F', '\xB42', 
		'\xB47', '\xB4A', '\xB4E', '\xB54', '\xB57', '\xB61', '\xB63', '\xB6D', 
		'\xB6F', '\xB73', '\xB78', '\xB7A', '\xB7C', '\xB82', '\xB84', '\xB93', 
		'\xB95', '\xB99', '\xB9D', '\xBA3', '\xBB1', '\xBB6', '\xBBB', '\xBBD', 
		'\xBC5', '\xBCD', '\xBD2', '\xBDD', '\xBE9', '\xBEE', '\xBF2', '\xBFD', 
		'\xC02', '\xC09', '\xC0F', '\xC11', '\xC13', '\xC16', '\xC1B', '\xC1F', 
		'\xC21', '\xC23', '\xC26', '\xC2A', '\xC33', '\xC35', '\xC37', '\xC3A', 
		'\xC40', '\xC42', '\xC44', '\xC47', '\xC4B', '\xC58', '\xC60', '\xC63', 
		'\xC66', '\xC6B', '\xC6E', '\xC71', '\xC75', '\xC7A', '\xC7D', '\xC83', 
		'\xC85', '\xC87', '\xC8A', '\xC8D', '\xC93', '\xC95', '\xC97', '\xC9A', 
		'\xC9D', '\xCA1', '\xCAF', '\xCB7', '\xCC2', '\xCC7', '\xCC9', '\xCCF', 
		'\xCD3', '\xCD7', '\xCDC', '\xCE2', '\xCE5', '\xCE8', '\xCEB', '\xCEE', 
		'\xCF0', '\xCF7', '\xCF9', '\xCFD', '\xD09', '\xD0B', '\xD0F', '\xD13', 
		'\xD1A', '\xD22', '\xD24', '\xD27', '\xD2C', '\xD30', '\xD34', '\xD38', 
		'\xD3B', '\xD41', '\xD4A', '\xD51', '\xD57', '\xD5D', '\xD60', '\xD63', 
		'\xD68', '\xD6B', '\xD6E', '\xD72', '\xD77', '\xD85', '\xD89', '\xD8C', 
		'\xD93', '\xD97', '\xD9D', '\xDA8', '\xDB4', '\xDB9', '\xDBF', '\xDD0', 
		'\xDD2', '\xDE1', '\xDE3', '\xDF0', '\xDF3', '\xDF6', '\xDFF', '\xE02', 
		'\xE05', '\xE0C', '\xE12', '\xE17', '\xE1B', '\xE1E', '\xE21', '\xE27', 
		'\xE2C', '\xE2F', '\xE33', '\xE37', '\xE3A', '\xE41', '\xE44', '\xE46', 
		'\xE4B', '\xE51', '\xE57', '\xE61', '\xE66', '\xE69', '\xE6C', '\xE75', 
		'\xE7D', '\xE80', '\xE83', '\xE86', '\xE89', '\xE8C', '\xE8F', '\xE96', 
		'\xE99', '\xE9C', '\xEA1', '\xEA5', '\xEA8', '\xEAC', '\xEB0', '\xEB5', 
		'\xEBA', '\xEC2', '\xEC6', '\xED0', '\xEDC', '\xEE0', '\xEEB', '\xEF7', 
		'\xEFB', '\xF03', '\xF06', '\xF0A', '\xF0F', '\xF18', '\xF2A', '\xF2F', 
		'\xF34', '\xF40', '\xF46', '\xF4E', '\xF52', '\xF56', '\xF5A', '\xF63', 
		'\xF68', '\xF6C', '\xF6F', '\xF71', '\xF77', '\xF7B', '\xF82', '\xF89', 
		'\xF8D', '\xF91', '\xF9A', '\xFA1', '\xFB5', '\xFBD', '\xFCA', '\xFCE', 
		'\xFD7', '\xFDE', '\xFEB', '\xFF3', '\xFFB', '\x1001', '\x100D', '\x1015', 
		'\x101D', '\x1023', '\x1027', '\x102B', '\x102E', '\x1032', '\x1036', 
		'\x1039', '\x103D', '\x1040', '\x1043', '\x104F', '\x1054', '\x1057', 
		'\x105A', '\x105D', '\x1061', '\x1064', '\x1067', '\x106B', '\x106D', 
		'\x1072', '\x1074', '\x1080', '\x1084', '\x108F', '\x1093', '\x1097', 
		'\x10B3', '\x10C2', '\x10CA', '\x10D2', '\x10D8', '\x10E4', '\x10E8', 
		'\x10F4', '\x10F6', '\x10FD', '\x1102', '\x110A', '\x1110', '\x1117', 
		'\x111A', '\x111E', '\x112A', '\x112C', '\x1130', '\x1138', '\x113C', 
		'\x1141', '\x1144', '\x1149', '\x114B', '\x1150', '\x1154', '\x1159', 
		'\x115D', '\x1164', '\x116D', '\x1178', '\x1180', '\x118C', '\x118E', 
		'\x1194', '\x1197', '\x1199', '\x119C', '\x11B2', '\x11B8', '\x11BB', 
		'\x11C3', '\x11C9', '\x11CC', '\x11CF', '\x11D3', '\x11D6', '\x11DB', 
		'\x11E0', '\x11E3', '\x11E6', '\x11E9', '\x11ED', '\x11F2', '\x11F4', 
		'\x11F8', '\x1200', '\x1202', '\x120E', '\x1217', '\x121C', '\x121F', 
		'\x1227', '\x122E', '\x1232', '\x1236', '\x1247', '\x1259', '\x125B', 
		'\x125F', '\x126B', '\x126F', '\x127C', '\x1282', '\x128D', '\x1297', 
		'\x129B', '\x129D', '\x12A7', '\x12BB', '\x12C2', '\x12C6', '\x12C9', 
		'\x12CC', '\x12D1', '\x12DA', '\x12DC', '\x12E4', '\x12E6', '\x12EA', 
		'\x12EF', '\x12F2', '\x12F6', '\x12F9', '\x12FC', '\x1300', '\x1307', 
		'\x130A', '\x130D', '\x1312', '\x1317', '\x1320', '\x1326', '\x1330', 
		'\x1335', '\x133F', '\x1341', '\x1349', '\x1353', '\x135D', '\x1363', 
		'\x1369', '\x136E', '\x1374', '\x1377', '\x137B', '\x1380', '\x1383', 
		'\x1386', '\x1389', '\x1392', '\x1396', '\x1398', '\x13AB', '\x13B2', 
		'\x13B4', '\x13B8', '\x13CB', '\x13CE', '\x13D1', '\x13D7', '\x13DE', 
		'\x13E3', '\x13F3', '\x13F8', '\x13FE', '\x1405', '\x1420', '\x1422', 
		'\x142D', '\x1435', '\x1437', '\x1446', '\x144F', '\x1454', '\x1458', 
		'\x145B', '\x1469', '\x1471', '\x1475', '\x1478', '\x1480', '\x148C', 
		'\x1490', '\x1495', '\x1498', '\x14A5', '\x14A9', '\x14B1', '\x14B6', 
		'\x14BA', '\x14BE', '\x14C2', '\x14C8', '\x14CB', '\x14CE', '\x14E9', 
		'\x14EF', '\x14F3', '\x14FE', '\x1506', '\x150C', '\x1510', '\x1519', 
		'\x1522', '\x1527', '\x152C', '\x1532', '\x1536', '\x1539', '\x153F', 
		'\x1541', '\x155D', '\x1562', '\x1566', '\x156D', '\x1571', '\x1575', 
		'\x1579', '\x1585', '\x1589', '\x1597', '\x159D', '\x15A4', '\x15A9', 
		'\x15B4', '\x15B7', '\x15BD', '\x15BF', '\x15C8', '\x15D2', '\x15D7', 
		'\x15E6', '\x15EA', '\x15ED', '\x15F1', '\x15F4', '\x1602', '\x1604', 
		'\x1608', '\x1610', '\x1617', '\x161C', '\x161E', '\x1623', '\x1628', 
		'\x1630', '\x1637', '\x163B', '\x163E', '\x1649', '\x164F', '\x1658', 
		'\x165B', '\x1661', '\x1666', '\x166C', '\x1671', '\x1673', '\x167A', 
		'\x167D', '\x1684', '\x168F', '\x1695', '\x1699', '\x169F', '\x16A4', 
		'\x16A6', '\x16AC', '\x16B7', '\x16B9', '\x16BB', '\x16BE', '\x16C2', 
		'\x16C5', '\x16C9', '\x16CD', '\x16D2', '\x16DD', '\x16E1', '\x16E9', 
		'\x16EC', '\x16F1', '\x16F3', '\x16F8', '\x16FD', '\x1701', '\x1707', 
		'\x170B', '\x170E', '\x1716', '\x1719', '\x171D', '\x1721', '\x1726', 
		'\x1729', '\x172D', '\x1731', '\x1735', '\x1749', '\x174D', '\x1751', 
		'\x1757', '\x175B', '\x1760', '\x1762', '\x1765', '\x1769', '\x176C', 
		'\x176F', '\x1772', '\x1776', '\x1782', '\x1785', '\x1788', '\x178D', 
		'\x1793', '\x1798', '\x179E', '\x17A2', '\x17A7', '\x17AE', '\x17B4', 
		'\x17BB', '\x17BE', '\x17C1', '\x17C5', '\x17CA', '\x17CE', '\x17D0', 
		'\x17DB', '\x17E2', '\x17E6', '\x17F0', '\x17F4', '\x17F8', '\x17FD', 
		'\x1808', '\x180D', '\x1813', '\x1818', '\x181B', '\x1820', '\x1822', 
		'\x1828', '\x182D', '\x1830', '\x1835', '\x183A', '\x1843', '\x1848', 
		'\x184E', '\x1854', '\x1859', '\x185D', '\x185F', '\x1864', '\x1868', 
		'\x186E', '\x1872', '\x187B', '\x1880', '\x1883', '\x1889', '\x188E', 
		'\x1890', '\x1892', '\x1897', '\x189C', '\x18A1', '\x18A9', '\x18AE', 
		'\x18B5', '\x18B9', '\x18C2', '\x18C6', '\x18CB', '\x18D6', '\x18D8', 
		'\x18E8', '\x18ED', '\x18F3', '\x18F9', '\x1907', '\x190C', '\x1912', 
		'\x1915', '\x1918', '\x191C', '\x1921', '\x192A', '\x192C', '\x1930', 
		'\x1933', '\x1938', '\x193A', '\x193E', '\x194A', '\x1953', '\x1957', 
		'\x195C', '\x1960', '\x1964', '\x1969', '\x196C', '\x1976', '\x197C', 
		'\x197F', '\x1982', '\x1986', '\x198B', '\x1994', '\x199E', '\x19A2', 
		'\x19A6', '\x19A9', '\x19AC', '\x19B1', '\x19B6', '\x19B9', '\x19BC', 
		'\x19C2', '\x19C5', '\x19CB', '\x19CE', '\x19D1', '\x19D6', '\x19D9', 
		'\x19E1', '\x19E7', '\x19EC', '\x19F1', '\x19F9', '\x1A03', '\x1A07', 
		'\x1A09', '\x1A0C', '\x1A18', '\x1A1C', '\x1A1F', '\x1A2E', '\x1A33', 
		'\x1A37', '\x1A3E', '\x1A41', '\x1A4A', '\x1A51', '\x1A56', '\x1A5A', 
		'\x1A62', '\x1A68', '\x1A70', '\x1A73', '\x1A7C', '\x1A7F', '\x1A82', 
		'\x1A8B', '\x1A91', '\x1A97', '\x1A99', '\x1AA6', '\x1AA8', '\x1AB1', 
		'\x1AB3', '\x1AB7', '\x1ABD', '\x1AC1', '\x1ACF', '\x1AD5', '\x1AE0', 
		'\x1AEB', '\x1AEF', '\x1AF6', '\x1AFB', '\x1AFF', '\x1B04', '\x1B0C', 
		'\x1B0E', '\x1B14', '\x1B17', '\x1B22', '\x1B27', '\x1B2B', '\x1B2F', 
		'\x1B39', '\x1B3D', '\x1B47', '\x1B49', '\x1B4B', '\x1B54', '\x1B57', 
		'\x1B63', '\x1B65', '\x1B70', '\x1B74', '\x1B76', '\x1B7D', '\x1B89', 
		'\x1B91', '\x1B9C', '\x1BA4', '\x1BAB', '\x1BAF', '\x1BB3', '\x1BB8', 
		'\x1BBC', '\x1BC4', '\x1BC8', '\x1BCF', '\x1BD4', '\x1BDD', '\x1BE6', 
		'\x1BE9', '\x1BFD', '\x1C01', '\x1C04', '\x1C0B', '\x1C0E', '\x1C12', 
		'\x1C15', '\x1C1C', '\x1C1F', '\x1C25', '\x1C28', '\x1C2C', '\x1C2F', 
		'\x1C36', '\x1C3B', '\x1C49', '\x1C50', '\x1C5B', '\x1C67', '\x1C6B', 
		'\x1C6D', '\x1C76', '\x1C7F', '\x1C83', '\x1C87', '\x1C9A', '\x1C9D', 
		'\x1CA0', '\x1CA5', '\x1CAA', '\x1CAF', '\x1CB8', '\x1CBB', '\x1CBD', 
		'\x1CC1', '\x1CC8', '\x1CCF', '\x1CD7', '\x1CE6', '\x1CED', '\x1CF4', 
		'\x1CF9', '\x1D07', '\x1D0A', '\x1D0E', '\x1D18', '\x1D25', '\x1D2D', 
		'\x1D31', '\x1D38', '\x1D3D', '\x1D46', '\x1D54', '\x1D5C', '\x1D5F', 
		'\x1D68', '\x1D6E', '\x1D81', '\x1D8A', '\x1D8F', '\x1D94', '\x1D99', 
		'\x1D9E', '\x1DA3', '\x1DA6', '\x1DAB', '\x1DB0', '\x1DB4', '\x1DBA', 
		'\x1DC0', '\x1DC9', '\x1DCE', '\x1DD6', '\x1DDA', '\x1DDF', '\x1DE5', 
		'\x1DEC', '\x1DF1', '\x1DF8', '\x1DFC', '\x1E01', '\x1E09', '\x1E0C', 
		'\x1E0F', '\x1E12', '\x1E16', '\x1E1B', '\x1E20', '\x1E24', '\x1E2B', 
		'\x1E30', '\x1E37', '\x1E3B', '\x1E46', '\x1E4A', '\x1E4C', '\x1E57', 
		'\x1E62', '\x1E67', '\x1E6C', '\x1E6E', '\x1E72', '\x1E75', '\x1E79', 
		'\x1E86', '\x1E8B', '\x1E8F', '\x1E94', '\x1E9A', '\x1E9E', '\x1EA3', 
		'\x1EA7', '\x1EAC', '\x1EB1', '\x1EB4', '\x1EB7', '\x1EBC', '\x1EC5', 
		'\x1ECD', '\x1ED1', '\x1EDB', '\x1EDE', '\x1EE0', '\x1EEA', '\x1EEC', 
		'\x1EF2', '\x1EF8', '\x1EFA', '\x1F08', '\x1F0A', '\x1F15', '\x1F21', 
		'\x1F28', '\x1F2E', '\x1F35', '\x1F3E', '\x1F42', '\x1F46', '\x1F4B', 
		'\x1F4F', '\x1F52', '\x1F56', '\x1F5D', '\x1F61', '\x1F65', '\x1F6A', 
		'\x1F6E', '\x1F73', '\x1F79', '\x1F7D', '\x1F82', '\x1F86', '\x1F8B', 
		'\x1F8E', '\x1F92', '\x1F96', '\x1F9E', '\x1FBF', '\x1FD4', '\x1FD9', 
		'\x1FE9', '\x1FEC', '\x1FF1', '\x1FFE', '\x2002', '\x2006', '\x200A', 
		'\x200F', '\x2016', '\x201B', '\x201D', '\x201F', '\x2028', '\x202C', 
		'\x2030', '\x2032', '\x2036', '\x203D', '\x2041', '\x2043', '\x2047', 
		'\x204B', '\x2052', '\x205A', '\x2062', '\x2064', '\x206A', '\x206D', 
		'\x2085', '\x208C', '\x20AD', '\x20B2', '\x20B5', '\x20BA', '\x20BC', 
		'\x20C2', '\x20CA', '\x20CF', '\x20D4', '\x20D7', '\x20DA', '\x20DE', 
		'\x20E4', '\x2103', '\x210A', '\x2119', '\x2129', '\x213C', '\x214D', 
		'\x2154', '\x215C', '\x2169', '\x2172', '\x217B', '\x2184', '\x218E', 
		'\x2196', '\x21A0', '\x21AA', '\x21B6', '\x21C6', '\x21D8', '\x21E5', 
		'\x21F4', '\x21FF', '\x2209', '\x2214', '\x221E', '\x222F', '\x2235', 
		'\x224B', '\x224F', '\x2254', '\x2259', '\x225F', '\x2265', '\x226B', 
		'\x2270', '\x2272', '\x2275', '\x227F', '\x2282', '\x2284', '\x2286', 
		'\x2294', '\x2298', '\x22BB', '\x22C6', '\x22CD', '\x22E2', '\x22E5', 
		'\x22E9',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace Bb.Oracle.Parser
